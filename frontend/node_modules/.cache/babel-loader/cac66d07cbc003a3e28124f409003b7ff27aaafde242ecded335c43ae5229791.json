{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { mixin, createObjectPropListener } from \"../helpers/object.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable. The class performs the calculations based on the renderable indexes.\n *\n * Transformation is always applied relative to the current selection.\n *\n * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`\n * option is enabled, the table size is increased by the number of row and/or column headers.\n * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),\n * the algorithm can be written as simply as possible (without new if's that distinguish the headers\n * logic).\n *\n * @class Transformation\n * @util\n */\nvar _range = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _Transformation_brand = /*#__PURE__*/new WeakSet();\nclass Transformation {\n  constructor(range, options) {\n    /**\n     * Clamps the coords to make sure they points to the cell (or header) in the table range.\n     *\n     * @param {CellCoords} zeroBasedCoords The coords object to clamp.\n     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}\n     */\n    _classPrivateMethodInitSpec(this, _Transformation_brand);\n    /**\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n    _classPrivateFieldInitSpec(this, _range, void 0);\n    /**\n     * Additional options which define the state of the settings which can infer transformation and\n     * give the possibility to translate indexes.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _options, void 0);\n    /**\n     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`\n     * option.\n     *\n     * @type {{ x: number, y: number }}\n     */\n    _classPrivateFieldInitSpec(this, _offset, {\n      x: 0,\n      y: 0\n    });\n    _classPrivateFieldSet(_range, this, range);\n    _classPrivateFieldSet(_options, this, options);\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const delta = _classPrivateFieldGet(_options, this).createCellCoords(rowDelta, colDelta);\n    let visualCoords = _classPrivateFieldGet(_range, this).current().highlight;\n    const highlightRenderableCoords = _classPrivateFieldGet(_options, this).visualToRenderableCoords(visualCoords);\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformStart', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        width,\n        height\n      } = _assertClassBrand(_Transformation_brand, this, _getTableSize).call(this);\n      const {\n        row,\n        col\n      } = _assertClassBrand(_Transformation_brand, this, _visualToZeroBasedCoords).call(this, visualCoords);\n      const fixedRowsBottom = _classPrivateFieldGet(_options, this).fixedRowsBottom();\n      const minSpareRows = _classPrivateFieldGet(_options, this).minSpareRows();\n      const minSpareCols = _classPrivateFieldGet(_options, this).minSpareCols();\n      const autoWrapRow = _classPrivateFieldGet(_options, this).autoWrapRow();\n      const autoWrapCol = _classPrivateFieldGet(_options, this).autoWrapCol();\n      const zeroBasedCoords = _classPrivateFieldGet(_options, this).createCellCoords(row + delta.row, col + delta.col);\n      if (zeroBasedCoords.row >= height) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);\n        const nextColumn = zeroBasedCoords.col + 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), nextColumn >= width);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(_options, this).countRenderableRows());\n        } else if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.row < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapCol);\n        const previousColumn = zeroBasedCoords.col - 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), previousColumn < 0);\n        if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      if (zeroBasedCoords.col >= width) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareCols > 0);\n        const nextRow = zeroBasedCoords.row + 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), nextRow >= height);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(_options, this).countRenderableColumns());\n        } else if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.col < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapRow);\n        const previousRow = zeroBasedCoords.row - 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), previousRow < 0);\n        if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      const {\n        rowDir,\n        colDir\n      } = _assertClassBrand(_Transformation_brand, this, _clampCoords).call(this, zeroBasedCoords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      visualCoords = _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, zeroBasedCoords);\n    }\n    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformEnd(rowDelta, colDelta) {\n    const delta = _classPrivateFieldGet(_options, this).createCellCoords(rowDelta, colDelta);\n    const cellRange = _classPrivateFieldGet(_range, this).current();\n    const highlightRenderableCoords = _classPrivateFieldGet(_options, this).visualToRenderableCoords(cellRange.highlight);\n    const toRow = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, cellRange.to.row, cellRange.from.row);\n    const toColumn = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, cellRange.to.col, cellRange.from.col);\n    const visualCoords = cellRange.to.clone();\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformEnd', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null && toRow !== null && toColumn !== null) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = _assertClassBrand(_Transformation_brand, this, _visualToZeroBasedCoords).call(this, cellRange.highlight);\n      const coords = _classPrivateFieldGet(_options, this).createCellCoords(toRow + delta.row, toColumn + delta.col);\n      const topStartCorner = cellRange.getTopStartCorner();\n      const topEndCorner = cellRange.getTopEndCorner();\n      const bottomEndCorner = cellRange.getBottomEndCorner();\n      if (delta.col < 0 && toColumn >= highlightColumn && coords.col < highlightColumn) {\n        const columnRestDelta = coords.col - highlightColumn;\n        coords.col = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, topStartCorner.col, topEndCorner.col) + columnRestDelta;\n      } else if (delta.col > 0 && toColumn <= highlightColumn && coords.col > highlightColumn) {\n        const endColumnIndex = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, topEndCorner.col, topStartCorner.col);\n        const columnRestDelta = Math.max(coords.col - endColumnIndex, 1);\n        coords.col = endColumnIndex + columnRestDelta;\n      }\n      if (delta.row < 0 && toRow >= highlightRow && coords.row < highlightRow) {\n        const rowRestDelta = coords.row - highlightRow;\n        coords.row = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, topStartCorner.row, bottomEndCorner.row) + rowRestDelta;\n      } else if (delta.row > 0 && toRow <= highlightRow && coords.row > highlightRow) {\n        const bottomRowIndex = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, bottomEndCorner.row, topStartCorner.row);\n        const rowRestDelta = Math.max(coords.row - bottomRowIndex, 1);\n        coords.row = bottomRowIndex + rowRestDelta;\n      }\n      const {\n        rowDir,\n        colDir\n      } = _assertClassBrand(_Transformation_brand, this, _clampCoords).call(this, coords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      const newVisualCoords = _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, coords);\n      if (delta.row === 0 && delta.col !== 0) {\n        visualCoords.col = newVisualCoords.col;\n      } else if (delta.row !== 0 && delta.col === 0) {\n        visualCoords.row = newVisualCoords.row;\n      } else {\n        visualCoords.row = newVisualCoords.row;\n        visualCoords.col = newVisualCoords.col;\n      }\n    }\n    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets the additional offset in table size that may occur when the `navigableHeaders` option\n   * is enabled.\n   *\n   * @param {{x: number, y: number}} offset Offset as x and y properties.\n   */\n  setOffsetSize(_ref) {\n    let {\n      x,\n      y\n    } = _ref;\n    _classPrivateFieldSet(_offset, this, {\n      x,\n      y\n    });\n  }\n\n  /**\n   * Resets the offset size to the default values.\n   */\n  resetOffsetSize() {\n    _classPrivateFieldSet(_offset, this, {\n      x: 0,\n      y: 0\n    });\n  }\n}\nfunction _clampCoords(zeroBasedCoords) {\n  const {\n    width,\n    height\n  } = _assertClassBrand(_Transformation_brand, this, _getTableSize).call(this);\n  let rowDir = 0;\n  let colDir = 0;\n  if (zeroBasedCoords.row < 0) {\n    rowDir = -1;\n    zeroBasedCoords.row = 0;\n  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {\n    rowDir = 1;\n    zeroBasedCoords.row = height - 1;\n  }\n  if (zeroBasedCoords.col < 0) {\n    colDir = -1;\n    zeroBasedCoords.col = 0;\n  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {\n    colDir = 1;\n    zeroBasedCoords.col = width - 1;\n  }\n  return {\n    rowDir,\n    colDir\n  };\n}\n/**\n * Gets the table size in number of rows with headers as \"height\" and number of columns with\n * headers as \"width\".\n *\n * @returns {{width: number, height: number}}\n */\nfunction _getTableSize() {\n  return {\n    width: _classPrivateFieldGet(_offset, this).x + _classPrivateFieldGet(_options, this).countRenderableColumns(),\n    height: _classPrivateFieldGet(_offset, this).y + _classPrivateFieldGet(_options, this).countRenderableRows()\n  };\n}\n/**\n * Finds the first non-hidden zero-based row in the table range.\n *\n * @param {number} visualRowFrom The visual row from which the search should start.\n * @param {number} visualRowTo The visual row to which the search should end.\n * @returns {number | null}\n */\nfunction _findFirstNonHiddenZeroBasedRow(visualRowFrom, visualRowTo) {\n  const row = _classPrivateFieldGet(_options, this).findFirstNonHiddenRenderableRow(visualRowFrom, visualRowTo);\n  if (row === null) {\n    return null;\n  }\n  return _classPrivateFieldGet(_offset, this).y + row;\n}\n/**\n * Finds the first non-hidden zero-based column in the table range.\n *\n * @param {number} visualColumnFrom The visual column from which the search should start.\n * @param {number} visualColumnTo The visual column to which the search should end.\n * @returns {number | null}\n */\nfunction _findFirstNonHiddenZeroBasedColumn(visualColumnFrom, visualColumnTo) {\n  const column = _classPrivateFieldGet(_options, this).findFirstNonHiddenRenderableColumn(visualColumnFrom, visualColumnTo);\n  if (column === null) {\n    return null;\n  }\n  return _classPrivateFieldGet(_offset, this).x + column;\n}\n/**\n * Translates the visual coordinates to zero-based ones.\n *\n * @param {CellCoords} visualCoords The visual coords to process.\n * @returns {CellCoords}\n */\nfunction _visualToZeroBasedCoords(visualCoords) {\n  const {\n    row,\n    col\n  } = _classPrivateFieldGet(_options, this).visualToRenderableCoords(visualCoords);\n  if (row === null || col === null) {\n    throw new Error('Renderable coords are not visible.');\n  }\n  return _classPrivateFieldGet(_options, this).createCellCoords(_classPrivateFieldGet(_offset, this).y + row, _classPrivateFieldGet(_offset, this).x + col);\n}\n/**\n * Translates the zero-based coordinates to visual ones.\n *\n * @param {CellCoords} zeroBasedCoords The coordinates to process.\n * @returns {CellCoords}\n */\nfunction _zeroBasedToVisualCoords(zeroBasedCoords) {\n  const coords = zeroBasedCoords.clone();\n  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(_offset, this).x;\n  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(_offset, this).y;\n  return _classPrivateFieldGet(_options, this).renderableToVisualCoords(coords);\n}\nmixin(Transformation, localHooks);\nexport default Transformation;","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","mixin","createObjectPropListener","localHooks","_range","WeakMap","_options","_offset","_Transformation_brand","WeakSet","Transformation","constructor","range","options","x","y","transformStart","rowDelta","colDelta","createMissingRecords","undefined","delta","createCellCoords","visualCoords","current","highlight","highlightRenderableCoords","visualToRenderableCoords","rowTransformDir","colTransformDir","runLocalHooks","row","col","width","height","_getTableSize","call","_visualToZeroBasedCoords","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","zeroBasedCoords","isActionInterrupted","nextColumn","newCoords","_zeroBasedToVisualCoords","value","countRenderableRows","assign","previousColumn","nextRow","countRenderableColumns","previousRow","rowDir","colDir","_clampCoords","transformEnd","cellRange","toRow","_findFirstNonHiddenZeroBasedRow","to","from","toColumn","_findFirstNonHiddenZeroBasedColumn","clone","highlightRow","highlightColumn","coords","topStartCorner","getTopStartCorner","topEndCorner","getTopEndCorner","bottomEndCorner","getBottomEndCorner","columnRestDelta","endColumnIndex","Math","max","rowRestDelta","bottomRowIndex","newVisualCoords","setOffsetSize","_ref","resetOffsetSize","visualRowFrom","visualRowTo","findFirstNonHiddenRenderableRow","visualColumnFrom","visualColumnTo","column","findFirstNonHiddenRenderableColumn","Error","renderableToVisualCoords"],"sources":["D:/gym-project/frontend/node_modules/handsontable/selection/transformation.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { mixin, createObjectPropListener } from \"../helpers/object.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable. The class performs the calculations based on the renderable indexes.\n *\n * Transformation is always applied relative to the current selection.\n *\n * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`\n * option is enabled, the table size is increased by the number of row and/or column headers.\n * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),\n * the algorithm can be written as simply as possible (without new if's that distinguish the headers\n * logic).\n *\n * @class Transformation\n * @util\n */\nvar _range = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _Transformation_brand = /*#__PURE__*/new WeakSet();\nclass Transformation {\n  constructor(range, options) {\n    /**\n     * Clamps the coords to make sure they points to the cell (or header) in the table range.\n     *\n     * @param {CellCoords} zeroBasedCoords The coords object to clamp.\n     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}\n     */\n    _classPrivateMethodInitSpec(this, _Transformation_brand);\n    /**\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n    _classPrivateFieldInitSpec(this, _range, void 0);\n    /**\n     * Additional options which define the state of the settings which can infer transformation and\n     * give the possibility to translate indexes.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _options, void 0);\n    /**\n     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`\n     * option.\n     *\n     * @type {{ x: number, y: number }}\n     */\n    _classPrivateFieldInitSpec(this, _offset, {\n      x: 0,\n      y: 0\n    });\n    _classPrivateFieldSet(_range, this, range);\n    _classPrivateFieldSet(_options, this, options);\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const delta = _classPrivateFieldGet(_options, this).createCellCoords(rowDelta, colDelta);\n    let visualCoords = _classPrivateFieldGet(_range, this).current().highlight;\n    const highlightRenderableCoords = _classPrivateFieldGet(_options, this).visualToRenderableCoords(visualCoords);\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformStart', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        width,\n        height\n      } = _assertClassBrand(_Transformation_brand, this, _getTableSize).call(this);\n      const {\n        row,\n        col\n      } = _assertClassBrand(_Transformation_brand, this, _visualToZeroBasedCoords).call(this, visualCoords);\n      const fixedRowsBottom = _classPrivateFieldGet(_options, this).fixedRowsBottom();\n      const minSpareRows = _classPrivateFieldGet(_options, this).minSpareRows();\n      const minSpareCols = _classPrivateFieldGet(_options, this).minSpareCols();\n      const autoWrapRow = _classPrivateFieldGet(_options, this).autoWrapRow();\n      const autoWrapCol = _classPrivateFieldGet(_options, this).autoWrapCol();\n      const zeroBasedCoords = _classPrivateFieldGet(_options, this).createCellCoords(row + delta.row, col + delta.col);\n      if (zeroBasedCoords.row >= height) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);\n        const nextColumn = zeroBasedCoords.col + 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), nextColumn >= width);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(_options, this).countRenderableRows());\n        } else if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.row < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapCol);\n        const previousColumn = zeroBasedCoords.col - 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), previousColumn < 0);\n        if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      if (zeroBasedCoords.col >= width) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareCols > 0);\n        const nextRow = zeroBasedCoords.row + 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), nextRow >= height);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(_options, this).countRenderableColumns());\n        } else if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.col < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapRow);\n        const previousRow = zeroBasedCoords.row - 1;\n        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), previousRow < 0);\n        if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      const {\n        rowDir,\n        colDir\n      } = _assertClassBrand(_Transformation_brand, this, _clampCoords).call(this, zeroBasedCoords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      visualCoords = _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, zeroBasedCoords);\n    }\n    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformEnd(rowDelta, colDelta) {\n    const delta = _classPrivateFieldGet(_options, this).createCellCoords(rowDelta, colDelta);\n    const cellRange = _classPrivateFieldGet(_range, this).current();\n    const highlightRenderableCoords = _classPrivateFieldGet(_options, this).visualToRenderableCoords(cellRange.highlight);\n    const toRow = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, cellRange.to.row, cellRange.from.row);\n    const toColumn = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, cellRange.to.col, cellRange.from.col);\n    const visualCoords = cellRange.to.clone();\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformEnd', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null && toRow !== null && toColumn !== null) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = _assertClassBrand(_Transformation_brand, this, _visualToZeroBasedCoords).call(this, cellRange.highlight);\n      const coords = _classPrivateFieldGet(_options, this).createCellCoords(toRow + delta.row, toColumn + delta.col);\n      const topStartCorner = cellRange.getTopStartCorner();\n      const topEndCorner = cellRange.getTopEndCorner();\n      const bottomEndCorner = cellRange.getBottomEndCorner();\n      if (delta.col < 0 && toColumn >= highlightColumn && coords.col < highlightColumn) {\n        const columnRestDelta = coords.col - highlightColumn;\n        coords.col = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, topStartCorner.col, topEndCorner.col) + columnRestDelta;\n      } else if (delta.col > 0 && toColumn <= highlightColumn && coords.col > highlightColumn) {\n        const endColumnIndex = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, topEndCorner.col, topStartCorner.col);\n        const columnRestDelta = Math.max(coords.col - endColumnIndex, 1);\n        coords.col = endColumnIndex + columnRestDelta;\n      }\n      if (delta.row < 0 && toRow >= highlightRow && coords.row < highlightRow) {\n        const rowRestDelta = coords.row - highlightRow;\n        coords.row = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, topStartCorner.row, bottomEndCorner.row) + rowRestDelta;\n      } else if (delta.row > 0 && toRow <= highlightRow && coords.row > highlightRow) {\n        const bottomRowIndex = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, bottomEndCorner.row, topStartCorner.row);\n        const rowRestDelta = Math.max(coords.row - bottomRowIndex, 1);\n        coords.row = bottomRowIndex + rowRestDelta;\n      }\n      const {\n        rowDir,\n        colDir\n      } = _assertClassBrand(_Transformation_brand, this, _clampCoords).call(this, coords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      const newVisualCoords = _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, coords);\n      if (delta.row === 0 && delta.col !== 0) {\n        visualCoords.col = newVisualCoords.col;\n      } else if (delta.row !== 0 && delta.col === 0) {\n        visualCoords.row = newVisualCoords.row;\n      } else {\n        visualCoords.row = newVisualCoords.row;\n        visualCoords.col = newVisualCoords.col;\n      }\n    }\n    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets the additional offset in table size that may occur when the `navigableHeaders` option\n   * is enabled.\n   *\n   * @param {{x: number, y: number}} offset Offset as x and y properties.\n   */\n  setOffsetSize(_ref) {\n    let {\n      x,\n      y\n    } = _ref;\n    _classPrivateFieldSet(_offset, this, {\n      x,\n      y\n    });\n  }\n\n  /**\n   * Resets the offset size to the default values.\n   */\n  resetOffsetSize() {\n    _classPrivateFieldSet(_offset, this, {\n      x: 0,\n      y: 0\n    });\n  }\n}\nfunction _clampCoords(zeroBasedCoords) {\n  const {\n    width,\n    height\n  } = _assertClassBrand(_Transformation_brand, this, _getTableSize).call(this);\n  let rowDir = 0;\n  let colDir = 0;\n  if (zeroBasedCoords.row < 0) {\n    rowDir = -1;\n    zeroBasedCoords.row = 0;\n  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {\n    rowDir = 1;\n    zeroBasedCoords.row = height - 1;\n  }\n  if (zeroBasedCoords.col < 0) {\n    colDir = -1;\n    zeroBasedCoords.col = 0;\n  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {\n    colDir = 1;\n    zeroBasedCoords.col = width - 1;\n  }\n  return {\n    rowDir,\n    colDir\n  };\n}\n/**\n * Gets the table size in number of rows with headers as \"height\" and number of columns with\n * headers as \"width\".\n *\n * @returns {{width: number, height: number}}\n */\nfunction _getTableSize() {\n  return {\n    width: _classPrivateFieldGet(_offset, this).x + _classPrivateFieldGet(_options, this).countRenderableColumns(),\n    height: _classPrivateFieldGet(_offset, this).y + _classPrivateFieldGet(_options, this).countRenderableRows()\n  };\n}\n/**\n * Finds the first non-hidden zero-based row in the table range.\n *\n * @param {number} visualRowFrom The visual row from which the search should start.\n * @param {number} visualRowTo The visual row to which the search should end.\n * @returns {number | null}\n */\nfunction _findFirstNonHiddenZeroBasedRow(visualRowFrom, visualRowTo) {\n  const row = _classPrivateFieldGet(_options, this).findFirstNonHiddenRenderableRow(visualRowFrom, visualRowTo);\n  if (row === null) {\n    return null;\n  }\n  return _classPrivateFieldGet(_offset, this).y + row;\n}\n/**\n * Finds the first non-hidden zero-based column in the table range.\n *\n * @param {number} visualColumnFrom The visual column from which the search should start.\n * @param {number} visualColumnTo The visual column to which the search should end.\n * @returns {number | null}\n */\nfunction _findFirstNonHiddenZeroBasedColumn(visualColumnFrom, visualColumnTo) {\n  const column = _classPrivateFieldGet(_options, this).findFirstNonHiddenRenderableColumn(visualColumnFrom, visualColumnTo);\n  if (column === null) {\n    return null;\n  }\n  return _classPrivateFieldGet(_offset, this).x + column;\n}\n/**\n * Translates the visual coordinates to zero-based ones.\n *\n * @param {CellCoords} visualCoords The visual coords to process.\n * @returns {CellCoords}\n */\nfunction _visualToZeroBasedCoords(visualCoords) {\n  const {\n    row,\n    col\n  } = _classPrivateFieldGet(_options, this).visualToRenderableCoords(visualCoords);\n  if (row === null || col === null) {\n    throw new Error('Renderable coords are not visible.');\n  }\n  return _classPrivateFieldGet(_options, this).createCellCoords(_classPrivateFieldGet(_offset, this).y + row, _classPrivateFieldGet(_offset, this).x + col);\n}\n/**\n * Translates the zero-based coordinates to visual ones.\n *\n * @param {CellCoords} zeroBasedCoords The coordinates to process.\n * @returns {CellCoords}\n */\nfunction _zeroBasedToVisualCoords(zeroBasedCoords) {\n  const coords = zeroBasedCoords.clone();\n  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(_offset, this).x;\n  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(_offset, this).y;\n  return _classPrivateFieldGet(_options, this).renderableToVisualCoords(coords);\n}\nmixin(Transformation, localHooks);\nexport default Transformation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}