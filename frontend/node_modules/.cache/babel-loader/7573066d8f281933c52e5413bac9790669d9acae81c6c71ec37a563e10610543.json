{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { TrimmingMap } from \"../../translations/index.mjs\";\nimport { arrayEach, arrayReduce } from \"../../helpers/array.mjs\";\nexport const PLUGIN_KEY = 'trimRows';\nexport const PLUGIN_PRIORITY = 330;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin TrimRows\n * @class TrimRows\n *\n * @description\n * The plugin allows to trim certain rows. The trimming is achieved by applying the transformation algorithm to the data\n * transformation. In this case, when the row is trimmed it is not accessible using `getData*` methods thus the trimmed\n * data is not visible to other plugins.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   // hide selected rows on table initialization\n *   trimRows: [1, 2, 5]\n * });\n *\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   // hide selected rows on table initialization\n *   trimRows={[1, 2, 5]}\n * />\n *\n * const hot = hotRef.current.hotInstance;\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n */\nvar _TrimRows_brand = /*#__PURE__*/new WeakSet();\nexport class TrimRows extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On map initialized hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _TrimRows_brand);\n    /**\n     * Map of skipped rows by the plugin.\n     *\n     * @private\n     * @type {null|TrimmingMap}\n     */\n    _defineProperty(this, \"trimmedRowsMap\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap('trimRows', new TrimmingMap());\n    this.trimmedRowsMap.addLocalHook('init', () => _assertClassBrand(_TrimRows_brand, this, _onMapInit).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`trimRows`](@/api/options.md#trimrows)\n   */\n  updatePlugin() {\n    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(trimmedRows)) {\n      this.hot.batchExecution(() => {\n        this.trimmedRowsMap.clear();\n        arrayEach(trimmedRows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hot.rowIndexMapper.unregisterMap('trimRows');\n    super.disablePlugin();\n  }\n\n  /**\n   * Get list of trimmed rows.\n   *\n   * @returns {Array} Physical rows.\n   */\n  getTrimmedRows() {\n    return this.trimmedRowsMap.getTrimmedIndexes();\n  }\n\n  /**\n   * Trims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeTrimRow\n   * @fires Hooks#afterTrimRow\n   */\n  trimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    if (isValidConfig) {\n      destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));\n    }\n    const allowTrimRow = this.hot.runHooks('beforeTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig);\n    if (allowTrimRow === false) {\n      return;\n    }\n    if (isValidConfig) {\n      this.hot.batchExecution(() => {\n        arrayEach(rows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    this.hot.runHooks('afterTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);\n  }\n\n  /**\n   * Trims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  trimRow() {\n    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {\n      row[_key] = arguments[_key];\n    }\n    this.trimRows(row);\n  }\n\n  /**\n   * Untrims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeUntrimRow\n   * @fires Hooks#afterUntrimRow\n   */\n  untrimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    const trimmingMapValues = this.trimmedRowsMap.getValues().slice();\n    const isAnyRowUntrimmed = rows.length > 0;\n    if (isValidConfig && isAnyRowUntrimmed) {\n      // Preparing new values for trimming map.\n      arrayEach(rows, physicalRow => {\n        trimmingMapValues[physicalRow] = false;\n      });\n\n      // Preparing new trimming config.\n      destinationTrimConfig = arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => {\n        if (isTrimmed) {\n          trimmedIndexes.push(physicalIndex);\n        }\n        return trimmedIndexes;\n      }, []);\n    }\n    const allowUntrimRow = this.hot.runHooks('beforeUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);\n    if (allowUntrimRow === false) {\n      return;\n    }\n    if (isValidConfig && isAnyRowUntrimmed) {\n      this.trimmedRowsMap.setValues(trimmingMapValues);\n    }\n    this.hot.runHooks('afterUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);\n  }\n\n  /**\n   * Untrims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  untrimRow() {\n    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      row[_key2] = arguments[_key2];\n    }\n    this.untrimRows(row);\n  }\n\n  /**\n   * Checks if given row is hidden.\n   *\n   * @param {number} physicalRow Physical row index.\n   * @returns {boolean}\n   */\n  isTrimmed(physicalRow) {\n    return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;\n  }\n\n  /**\n   * Untrims all trimmed rows.\n   */\n  untrimAll() {\n    this.untrimRows(this.getTrimmedRows());\n  }\n\n  /**\n   * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.\n   *\n   * @param {Array} trimmedRows List of physical row indexes.\n   * @returns {boolean}\n   */\n  isValidConfig(trimmedRows) {\n    const sourceRows = this.hot.countSourceRows();\n    return trimmedRows.every(trimmedRow => Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onMapInit() {\n  const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n  if (Array.isArray(trimmedRows)) {\n    this.hot.batchExecution(() => {\n      arrayEach(trimmedRows, physicalRow => {\n        this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n      });\n    }, true);\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","t","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_assertClassBrand","n","arguments","length","BasePlugin","TrimmingMap","arrayEach","arrayReduce","PLUGIN_KEY","PLUGIN_PRIORITY","_TrimRows_brand","WeakSet","TrimRows","constructor","isEnabled","hot","getSettings","enablePlugin","enabled","trimmedRowsMap","rowIndexMapper","registerMap","addLocalHook","_onMapInit","updatePlugin","trimmedRows","Array","isArray","batchExecution","clear","physicalRow","setValueAtIndex","disablePlugin","unregisterMap","getTrimmedRows","getTrimmedIndexes","trimRows","rows","currentTrimConfig","isValidConfig","destinationTrimConfig","from","Set","concat","allowTrimRow","runHooks","trimRow","_len","row","_key","untrimRows","trimmingMapValues","getValues","slice","isAnyRowUntrimmed","trimmedIndexes","isTrimmed","physicalIndex","push","allowUntrimRow","setValues","untrimRow","_len2","_key2","getValueAtIndex","untrimAll","sourceRows","countSourceRows","every","trimmedRow","isInteger","destroy"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/trimRows/trimRows.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { TrimmingMap } from \"../../translations/index.mjs\";\nimport { arrayEach, arrayReduce } from \"../../helpers/array.mjs\";\nexport const PLUGIN_KEY = 'trimRows';\nexport const PLUGIN_PRIORITY = 330;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin TrimRows\n * @class TrimRows\n *\n * @description\n * The plugin allows to trim certain rows. The trimming is achieved by applying the transformation algorithm to the data\n * transformation. In this case, when the row is trimmed it is not accessible using `getData*` methods thus the trimmed\n * data is not visible to other plugins.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   // hide selected rows on table initialization\n *   trimRows: [1, 2, 5]\n * });\n *\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   // hide selected rows on table initialization\n *   trimRows={[1, 2, 5]}\n * />\n *\n * const hot = hotRef.current.hotInstance;\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n */\nvar _TrimRows_brand = /*#__PURE__*/new WeakSet();\nexport class TrimRows extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On map initialized hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _TrimRows_brand);\n    /**\n     * Map of skipped rows by the plugin.\n     *\n     * @private\n     * @type {null|TrimmingMap}\n     */\n    _defineProperty(this, \"trimmedRowsMap\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap('trimRows', new TrimmingMap());\n    this.trimmedRowsMap.addLocalHook('init', () => _assertClassBrand(_TrimRows_brand, this, _onMapInit).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`trimRows`](@/api/options.md#trimrows)\n   */\n  updatePlugin() {\n    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(trimmedRows)) {\n      this.hot.batchExecution(() => {\n        this.trimmedRowsMap.clear();\n        arrayEach(trimmedRows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hot.rowIndexMapper.unregisterMap('trimRows');\n    super.disablePlugin();\n  }\n\n  /**\n   * Get list of trimmed rows.\n   *\n   * @returns {Array} Physical rows.\n   */\n  getTrimmedRows() {\n    return this.trimmedRowsMap.getTrimmedIndexes();\n  }\n\n  /**\n   * Trims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeTrimRow\n   * @fires Hooks#afterTrimRow\n   */\n  trimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    if (isValidConfig) {\n      destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));\n    }\n    const allowTrimRow = this.hot.runHooks('beforeTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig);\n    if (allowTrimRow === false) {\n      return;\n    }\n    if (isValidConfig) {\n      this.hot.batchExecution(() => {\n        arrayEach(rows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    this.hot.runHooks('afterTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);\n  }\n\n  /**\n   * Trims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  trimRow() {\n    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {\n      row[_key] = arguments[_key];\n    }\n    this.trimRows(row);\n  }\n\n  /**\n   * Untrims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeUntrimRow\n   * @fires Hooks#afterUntrimRow\n   */\n  untrimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    const trimmingMapValues = this.trimmedRowsMap.getValues().slice();\n    const isAnyRowUntrimmed = rows.length > 0;\n    if (isValidConfig && isAnyRowUntrimmed) {\n      // Preparing new values for trimming map.\n      arrayEach(rows, physicalRow => {\n        trimmingMapValues[physicalRow] = false;\n      });\n\n      // Preparing new trimming config.\n      destinationTrimConfig = arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => {\n        if (isTrimmed) {\n          trimmedIndexes.push(physicalIndex);\n        }\n        return trimmedIndexes;\n      }, []);\n    }\n    const allowUntrimRow = this.hot.runHooks('beforeUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);\n    if (allowUntrimRow === false) {\n      return;\n    }\n    if (isValidConfig && isAnyRowUntrimmed) {\n      this.trimmedRowsMap.setValues(trimmingMapValues);\n    }\n    this.hot.runHooks('afterUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);\n  }\n\n  /**\n   * Untrims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  untrimRow() {\n    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      row[_key2] = arguments[_key2];\n    }\n    this.untrimRows(row);\n  }\n\n  /**\n   * Checks if given row is hidden.\n   *\n   * @param {number} physicalRow Physical row index.\n   * @returns {boolean}\n   */\n  isTrimmed(physicalRow) {\n    return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;\n  }\n\n  /**\n   * Untrims all trimmed rows.\n   */\n  untrimAll() {\n    this.untrimRows(this.getTrimmedRows());\n  }\n\n  /**\n   * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.\n   *\n   * @param {Array} trimmedRows List of physical row indexes.\n   * @returns {boolean}\n   */\n  isValidConfig(trimmedRows) {\n    const sourceRows = this.hot.countSourceRows();\n    return trimmedRows.every(trimmedRow => Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onMapInit() {\n  const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n  if (Array.isArray(trimmedRows)) {\n    this.hot.batchExecution(() => {\n      arrayEach(trimmedRows, physicalRow => {\n        this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n      });\n    }, true);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}