{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { ChangesObserver } from \"./observer.mjs\";\nimport { arrayDiff } from \"./utils.mjs\";\n/**\n * The ChangesObservable module is an object that represents a resource that provides\n * the ability to observe the changes that happened in the index map indexes during\n * the code running.\n *\n * @private\n * @class ChangesObservable\n */\nvar _observers = /*#__PURE__*/new WeakMap();\nvar _indexMatrix = /*#__PURE__*/new WeakMap();\nvar _currentIndexState = /*#__PURE__*/new WeakMap();\nvar _isMatrixIndexesInitialized = /*#__PURE__*/new WeakMap();\nvar _initialIndexValue = /*#__PURE__*/new WeakMap();\nexport class ChangesObservable {\n  constructor() {\n    let {\n      initialIndexValue\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * The list of registered ChangesObserver instances.\n     *\n     * @type {ChangesObserver[]}\n     */\n    _classPrivateFieldInitSpec(this, _observers, new Set());\n    /**\n     * An array with default values that act as a base array that will be compared with\n     * the last saved index state. The changes are generated and immediately send through\n     * the newly created ChangesObserver object. Thanks to that, the observer initially has\n     * all information about what indexes are currently changed.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _indexMatrix, []);\n    /**\n     * An array that holds the indexes state that is currently valid. The value is changed on every\n     * index mapper cache update.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _currentIndexState, []);\n    /**\n     * The flag determines if the observable is initialized or not. Not initialized object creates\n     * index matrix once while emitting new changes.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isMatrixIndexesInitialized, false);\n    /**\n     * The initial index value allows control from what value the index matrix array will be created.\n     * Changing that value changes how the array diff generates the changes for the initial data\n     * sent to the subscribers. For example, the changes can be triggered by detecting the changes\n     * from `false` to `true` value or vice versa. Generally, it depends on which index map type\n     * the Observable will work with. For \"hiding\" or \"trimming\" index types, it will be boolean\n     * values. For various index maps, it can be anything, but I suspect that the most appropriate\n     * initial value will be \"undefined\" in that case.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _initialIndexValue, false);\n    _classPrivateFieldSet(_initialIndexValue, this, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Creates and returns a new instance of the ChangesObserver object. The resource\n   * allows subscribing to the index changes that during the code running may change.\n   * Changes are emitted as an array of the index change. Each change is represented\n   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.\n   *\n   * For example:\n   * ```\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'replace', index: 3, oldValue: false, newValue: true },\n   *   { op: 'insert', index: 4, oldValue: false, newValue: true },\n   * ]\n   * // or when the new index map changes have less indexes\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'remove', index: 4, oldValue: false, newValue: true },\n   * ]\n   * ```\n   *\n   * @returns {ChangesObserver}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  createObserver() {\n    const observer = new ChangesObserver();\n    _classPrivateFieldGet(_observers, this).add(observer);\n    observer.addLocalHook('unsubscribe', () => {\n      _classPrivateFieldGet(_observers, this).delete(observer);\n    });\n    observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet(_indexMatrix, this), _classPrivateFieldGet(_currentIndexState, this)));\n    return observer;\n  }\n\n  /**\n   * The method is an entry point for triggering new index map changes. Emitting the\n   * changes triggers comparing algorithm which compares last saved state with a new\n   * state. When there are some differences, the changes are sent to all subscribers.\n   *\n   * @param {Array} indexesState An array with index map state.\n   */\n  emit(indexesState) {\n    let currentIndexState = _classPrivateFieldGet(_currentIndexState, this);\n    if (!_classPrivateFieldGet(_isMatrixIndexesInitialized, this) || _classPrivateFieldGet(_indexMatrix, this).length !== indexesState.length) {\n      if (indexesState.length === 0) {\n        indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet(_initialIndexValue, this));\n      } else {\n        _classPrivateFieldSet(_indexMatrix, this, new Array(indexesState.length).fill(_classPrivateFieldGet(_initialIndexValue, this)));\n      }\n      if (!_classPrivateFieldGet(_isMatrixIndexesInitialized, this)) {\n        _classPrivateFieldSet(_isMatrixIndexesInitialized, this, true);\n        currentIndexState = _classPrivateFieldGet(_indexMatrix, this);\n      }\n    }\n    const changes = arrayDiff(currentIndexState, indexesState);\n    _classPrivateFieldGet(_observers, this).forEach(observer => observer._write(changes));\n    _classPrivateFieldSet(_currentIndexState, this, indexesState);\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","ChangesObserver","arrayDiff","_observers","WeakMap","_indexMatrix","_currentIndexState","_isMatrixIndexesInitialized","_initialIndexValue","ChangesObservable","constructor","initialIndexValue","undefined","Set","createObserver","observer","add","addLocalHook","delete","_writeInitialChanges","emit","indexesState","currentIndexState","Array","fill","changes","forEach","_write"],"sources":["D:/gym-project/frontend/node_modules/handsontable/translations/changesObservable/observable.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { ChangesObserver } from \"./observer.mjs\";\nimport { arrayDiff } from \"./utils.mjs\";\n/**\n * The ChangesObservable module is an object that represents a resource that provides\n * the ability to observe the changes that happened in the index map indexes during\n * the code running.\n *\n * @private\n * @class ChangesObservable\n */\nvar _observers = /*#__PURE__*/new WeakMap();\nvar _indexMatrix = /*#__PURE__*/new WeakMap();\nvar _currentIndexState = /*#__PURE__*/new WeakMap();\nvar _isMatrixIndexesInitialized = /*#__PURE__*/new WeakMap();\nvar _initialIndexValue = /*#__PURE__*/new WeakMap();\nexport class ChangesObservable {\n  constructor() {\n    let {\n      initialIndexValue\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * The list of registered ChangesObserver instances.\n     *\n     * @type {ChangesObserver[]}\n     */\n    _classPrivateFieldInitSpec(this, _observers, new Set());\n    /**\n     * An array with default values that act as a base array that will be compared with\n     * the last saved index state. The changes are generated and immediately send through\n     * the newly created ChangesObserver object. Thanks to that, the observer initially has\n     * all information about what indexes are currently changed.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _indexMatrix, []);\n    /**\n     * An array that holds the indexes state that is currently valid. The value is changed on every\n     * index mapper cache update.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _currentIndexState, []);\n    /**\n     * The flag determines if the observable is initialized or not. Not initialized object creates\n     * index matrix once while emitting new changes.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isMatrixIndexesInitialized, false);\n    /**\n     * The initial index value allows control from what value the index matrix array will be created.\n     * Changing that value changes how the array diff generates the changes for the initial data\n     * sent to the subscribers. For example, the changes can be triggered by detecting the changes\n     * from `false` to `true` value or vice versa. Generally, it depends on which index map type\n     * the Observable will work with. For \"hiding\" or \"trimming\" index types, it will be boolean\n     * values. For various index maps, it can be anything, but I suspect that the most appropriate\n     * initial value will be \"undefined\" in that case.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _initialIndexValue, false);\n    _classPrivateFieldSet(_initialIndexValue, this, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Creates and returns a new instance of the ChangesObserver object. The resource\n   * allows subscribing to the index changes that during the code running may change.\n   * Changes are emitted as an array of the index change. Each change is represented\n   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.\n   *\n   * For example:\n   * ```\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'replace', index: 3, oldValue: false, newValue: true },\n   *   { op: 'insert', index: 4, oldValue: false, newValue: true },\n   * ]\n   * // or when the new index map changes have less indexes\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'remove', index: 4, oldValue: false, newValue: true },\n   * ]\n   * ```\n   *\n   * @returns {ChangesObserver}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  createObserver() {\n    const observer = new ChangesObserver();\n    _classPrivateFieldGet(_observers, this).add(observer);\n    observer.addLocalHook('unsubscribe', () => {\n      _classPrivateFieldGet(_observers, this).delete(observer);\n    });\n    observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet(_indexMatrix, this), _classPrivateFieldGet(_currentIndexState, this)));\n    return observer;\n  }\n\n  /**\n   * The method is an entry point for triggering new index map changes. Emitting the\n   * changes triggers comparing algorithm which compares last saved state with a new\n   * state. When there are some differences, the changes are sent to all subscribers.\n   *\n   * @param {Array} indexesState An array with index map state.\n   */\n  emit(indexesState) {\n    let currentIndexState = _classPrivateFieldGet(_currentIndexState, this);\n    if (!_classPrivateFieldGet(_isMatrixIndexesInitialized, this) || _classPrivateFieldGet(_indexMatrix, this).length !== indexesState.length) {\n      if (indexesState.length === 0) {\n        indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet(_initialIndexValue, this));\n      } else {\n        _classPrivateFieldSet(_indexMatrix, this, new Array(indexesState.length).fill(_classPrivateFieldGet(_initialIndexValue, this)));\n      }\n      if (!_classPrivateFieldGet(_isMatrixIndexesInitialized, this)) {\n        _classPrivateFieldSet(_isMatrixIndexesInitialized, this, true);\n        currentIndexState = _classPrivateFieldGet(_indexMatrix, this);\n      }\n    }\n    const changes = arrayDiff(currentIndexState, indexesState);\n    _classPrivateFieldGet(_observers, this).forEach(observer => observer._write(changes));\n    _classPrivateFieldSet(_currentIndexState, this, indexesState);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}