{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression, isDate, isDateValid, getDateInHfFormat, getDateFromExcelDate, getDateInHotFormat, isFormula } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides, haveEngineSettingsChanged } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport IndexSyncer from \"./indexSyncer/index.mjs\";\nexport const PLUGIN_KEY = 'formulas';\nexport const SETTING_KEYS = ['maxRows', 'maxColumns', 'language'];\nexport const PLUGIN_PRIORITY = 260;\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nconst isBlockedSource = source => source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nvar _Formulas_brand = /*#__PURE__*/new WeakSet();\nexport class Formulas extends BasePlugin {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n    _classPrivateMethodInitSpec(this, _Formulas_brand);\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _internalOperationPending, false);\n    /**\n     * Flag needed to mark if Handsontable was initialized with no data.\n     * (Required to work around the fact, that Handsontable auto-generates sample data, when no data is provided).\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hotWasInitializedWithEmptyData, false);\n    /**\n     * The list of the HyperFormula listeners.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _engineListeners, [['valuesUpdated', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineValuesUpdated).call(_this, ...args);\n    }], ['namedExpressionAdded', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineNamedExpressionsAdded).call(_this, ...args);\n    }], ['namedExpressionRemoved', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineNamedExpressionsRemoved).call(_this, ...args);\n    }], ['sheetAdded', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineSheetAdded).call(_this, ...args);\n    }], ['sheetRenamed', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineSheetRenamed).call(_this, ...args);\n    }], ['sheetRemoved', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineSheetRemoved).call(_this, ...args);\n    }]]);\n    /**\n     * Static register used to set up one global HyperFormula instance.\n     * TODO: currently used in tests, might be removed later.\n     *\n     * @private\n     * @type {object}\n     */\n    _defineProperty(this, \"staticRegister\", staticRegister('formulas'));\n    /**\n     * The engine instance that will be used for this instance of Handsontable.\n     *\n     * @type {HyperFormula|null}\n     */\n    _defineProperty(this, \"engine\", null);\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @type {string|null}\n     */\n    _defineProperty(this, \"sheetName\", null);\n    /**\n     * Index synchronizer responsible for manipulating with some general options related to indexes synchronization.\n     *\n     * @type {IndexSyncer|null}\n     */\n    _defineProperty(this, \"indexSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the rows.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"rowAxisSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the columns.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"columnAxisSyncer\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * HyperFormula's sheet id.\n   *\n   * @type {number|null}\n   */\n  get sheetId() {\n    return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    /* eslint-disable no-unneeded-ternary */\n    return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _setupEngine,\n      _this2 = this;\n    if (this.enabled) {\n      return;\n    }\n    this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n    if (!this.engine) {\n      warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n      return;\n    }\n\n    // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n    if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n      const newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      if (newSheetName !== false) {\n        this.sheetName = newSheetName;\n      }\n    }\n    this.addHook('beforeLoadData', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeLoadData).call(_this2, ...args);\n    });\n    this.addHook('afterLoadData', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterLoadData).call(_this2, ...args);\n    });\n\n    // The `updateData` hooks utilize the same logic as the `loadData` hooks.\n    this.addHook('beforeUpdateData', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeLoadData).call(_this2, ...args);\n    });\n    this.addHook('afterUpdateData', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterLoadData).call(_this2, ...args);\n    });\n    this.addHook('modifyData', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onModifyData).call(_this2, ...args);\n    });\n    this.addHook('modifySourceData', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onModifySourceData).call(_this2, ...args);\n    });\n    this.addHook('beforeValidate', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeValidate).call(_this2, ...args);\n    });\n    this.addHook('afterSetSourceDataAtCell', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterSetSourceDataAtCell).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtCell', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterSetDataAtCell).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtRowProp', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterSetDataAtCell).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateRow', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeCreateRow).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateCol', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeCreateCol).call(_this2, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterCreateRow).call(_this2, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterCreateCol).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveRow', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeRemoveRow).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveCol', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeRemoveCol).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterRemoveRow).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterRemoveCol).call(_this2, ...args);\n    });\n    this.indexSyncer = new IndexSyncer(this.hot.rowIndexMapper, this.hot.columnIndexMapper, postponedAction => {\n      this.hot.addHookOnce('init', () => {\n        // Engine is initialized after executing callback to `afterLoadData` hook. Thus, some actions on indexes should\n        // be postponed.\n        postponedAction();\n      });\n    });\n    this.rowAxisSyncer = this.indexSyncer.getForAxis('row');\n    this.columnAxisSyncer = this.indexSyncer.getForAxis('column');\n    this.hot.addHook('afterRowSequenceChange', this.rowAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('afterColumnSequenceChange', this.columnAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('beforeRowMove', (movedRows, finalIndex, _, movePossible) => {\n      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, movePossible);\n    });\n    this.hot.addHook('beforeColumnMove', (movedColumns, finalIndex, _, movePossible) => {\n      this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, movePossible);\n    });\n    this.hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('afterColumnMove', (movedColumns, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('beforeColumnFreeze', (column, freezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart, freezePerformed);\n    });\n    this.hot.addHook('afterColumnFreeze', (_, freezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, freezePerformed);\n    });\n    this.hot.addHook('beforeColumnUnfreeze', (column, unfreezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);\n    });\n    this.hot.addHook('afterColumnUnfreeze', (_, unfreezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, unfreezePerformed);\n    });\n\n    // TODO: Actions related to overwriting dates from HOT format to HF default format are done as callback to this\n    // hook, because some hooks, such as `afterLoadData` doesn't have information about composed cell properties.\n    // Another hooks are triggered to late for setting HF's engine data needed for some actions.\n    this.addHook('afterCellMetaReset', function () {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterCellMetaReset).call(_this2, ...args);\n    });\n\n    // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeUndo', () => {\n      this.indexSyncer.setPerformUndo(true);\n      this.engine.undo();\n    });\n\n    // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeRedo', () => {\n      this.indexSyncer.setPerformRedo(true);\n      this.engine.redo();\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformUndo(false);\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformRedo(false);\n    });\n    this.addHook('afterDetachChild', function () {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterDetachChild).call(_this2, ...args);\n    });\n    this.addHook('beforeAutofill', function () {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeAutofill).call(_this2, ...args);\n    });\n    _classPrivateFieldGet(_engineListeners, this).forEach(_ref => {\n      let [eventName, listener] = _ref;\n      return this.engine.on(eventName, listener);\n    });\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    _classPrivateFieldGet(_engineListeners, this).forEach(_ref2 => {\n      let [eventName, listener] = _ref2;\n      return this.engine.off(eventName, listener);\n    });\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.disablePlugin();\n  }\n\n  /**\n   * Triggered on `updateSettings`.\n   *\n   * @private\n   * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n   */\n  updatePlugin(newSettings) {\n    const newEngineSettings = getEngineSettingsWithOverrides(this.hot.getSettings());\n    if (haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {\n      this.engine.updateConfig(newEngineSettings);\n    }\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n      this.switchSheet(pluginSettings.sheetName);\n    }\n\n    // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n    // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n    if (!newSettings.data && this.sheetName === null) {\n      const sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n      if (sheetName && this.engine.doesSheetExist(sheetName)) {\n        this.switchSheet(this.sheetName);\n      } else {\n        this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined, this.hot.getSourceDataArray());\n      }\n    }\n    super.updatePlugin(newSettings);\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(_engineListeners, this).forEach(_ref3 => {\n      var _this$engine;\n      let [eventName, listener] = _ref3;\n      return (_this$engine = this.engine) === null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, listener);\n    });\n    _classPrivateFieldSet(_engineListeners, this, null);\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.destroy();\n  }\n\n  /**\n   * Add a sheet to the shared HyperFormula instance.\n   *\n   * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n   * auto-generated by HyperFormula.\n   * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n   * arrays - array of objects is not supported in this scenario.\n   * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n   * engine, the created sheet name otherwise.\n   */\n  addSheet(sheetName, sheetData) {\n    if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n      warn('The provided data should be an array of arrays.');\n      return false;\n    }\n    if (sheetName !== undefined && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n      warn('Sheet with the provided name already exists.');\n      return false;\n    }\n    try {\n      const actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined);\n      if (sheetData) {\n        this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n      }\n      return actualSheetName;\n    } catch (e) {\n      warn(e.message);\n      return false;\n    }\n  }\n\n  /**\n   * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n   * instance).\n   *\n   * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n   */\n  switchSheet(sheetName) {\n    if (!this.engine.doesSheetExist(sheetName)) {\n      error(`The sheet named \\`${sheetName}\\` does not exist, switch aborted.`);\n      return;\n    }\n    this.sheetName = sheetName;\n    const serialized = this.engine.getSheetSerialized(this.sheetId);\n    if (serialized.length > 0) {\n      this.hot.loadData(serialized, `${toUpperCaseFirst(PLUGIN_KEY)}.switchSheet`);\n    }\n  }\n\n  /**\n   * Get the cell type under specified visual coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n   */\n  getCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    const physicalRow = this.hot.toPhysicalRow(row);\n    const physicalColumn = this.hot.toPhysicalColumn(column);\n    if (physicalRow !== null && physicalColumn !== null) {\n      return this.engine.getCellType({\n        sheet,\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n      });\n    } else {\n      // Should return `EMPTY` when out of bounds (according to the test cases).\n      return 'EMPTY';\n    }\n  }\n\n  /**\n   * Returns `true` if under specified visual coordinates is formula.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {boolean}\n   */\n  isFormulaCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    return this.engine.doesCellHaveFormula({\n      sheet,\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n    });\n  }\n\n  /**\n   * Renders dependent sheets (handsontable instances) based on the changes - list of the\n   * recalculated dependent cells.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n   */\n  renderDependentSheets(dependentCells) {\n    let renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const affectedSheetIds = new Set();\n    dependentCells.forEach(change => {\n      var _change$address;\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n      if (sheetId !== undefined) {\n        if (!affectedSheetIds.has(sheetId)) {\n          affectedSheetIds.add(sheetId);\n        }\n      }\n    });\n    getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {\n      if ((renderSelf || sheetId !== this.sheetId) && affectedSheetIds.has(sheetId)) {\n        var _relatedHot$view;\n        relatedHot.render();\n        (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();\n      }\n    });\n  }\n\n  /**\n   * Validates dependent cells based on the cells that are modified by the change.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n   */\n  validateDependentCells(dependentCells) {\n    let changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const stringifyAddress = change => {\n      var _change$address2;\n      const {\n        row,\n        col,\n        sheet\n      } = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {};\n      return isDefined(sheet) ? `${sheet}:${row}x${col}` : '';\n    };\n    const changedCellsSet = new Set(changedCells.map(change => stringifyAddress(change)));\n    dependentCells.forEach(change => {\n      var _change$address3, _change$address4;\n      const {\n        row,\n        col\n      } = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {};\n\n      // Don't try to validate cells outside of the visual part of the table.\n      if (isDefined(row) === false || isDefined(col) === false || row >= this.hot.countRows() || col >= this.hot.countCols()) {\n        return;\n      }\n\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n      const addressId = stringifyAddress(change);\n\n      // Validate the cells that depend on the calculated formulas. Skip that cells\n      // where the user directly changes the values - the Core triggers those validators.\n      if (sheetId !== undefined && !changedCellsSet.has(addressId)) {\n        const boundHot = getRegisteredHotInstances(this.engine).get(sheetId);\n\n        // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n        if (!boundHot) {\n          return;\n        }\n\n        // It will just re-render certain cell when necessary.\n        boundHot.validateCell(boundHot.getDataAtCell(row, col), boundHot.getCellMeta(row, col), () => {});\n      }\n    });\n  }\n\n  /**\n   * Sync a change from the change-related hooks with the engine.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {Handsontable.CellValue} newValue New value.\n   * @returns {Array} Array of changes exported from the engine.\n   */\n  syncChangeWithEngine(row, column, newValue) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if (isDate(newValue, cellMeta.type)) {\n      if (isDateValid(newValue, cellMeta.dateFormat)) {\n        // Rewriting date in HOT format to HF format.\n        newValue = getDateInHfFormat(newValue, cellMeta.dateFormat);\n      } else if (isFormula(newValue) === false) {\n        // Escaping value from date parsing using \"'\" sign (HF feature).\n        newValue = `'${newValue}`;\n      }\n    }\n    return this.engine.setCellContents(address, newValue);\n  }\n}\nfunction _onBeforeValidate(value, visualRow, prop) {\n  const visualColumn = this.hot.propToCol(prop);\n  if (this.isFormulaCellType(visualRow, visualColumn)) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);\n    let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel-like date).\n\n    if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n      cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n    }\n\n    // If `cellValue` is an object it is expected to be an error\n    return typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  }\n  return value;\n}\n/**\n * `onBeforeAutofill` hook callback.\n *\n * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n * @param {CellRange} sourceRange The range values will be filled from.\n * @param {CellRange} targetRange The range new values will be filled into.\n * @returns {boolean|*}\n */\nfunction _onBeforeAutofill(fillData, sourceRange, targetRange) {\n  const {\n    row: sourceTopStartRow,\n    col: sourceTopStartColumn\n  } = sourceRange.getTopStartCorner();\n  const {\n    row: sourceBottomEndRow,\n    col: sourceBottomEndColumn\n  } = sourceRange.getBottomEndCorner();\n  const {\n    row: targetTopStartRow,\n    col: targetTopStartColumn\n  } = targetRange.getTopStartCorner();\n  const {\n    row: targetBottomEndRow,\n    col: targetBottomEndColumn\n  } = targetRange.getBottomEndCorner();\n  const engineSourceRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n  const engineTargetRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n\n  // Blocks the autofill operation if HyperFormula says that at least one of\n  // the underlying cell's contents cannot be set.\n  if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n    return false;\n  }\n  const fillRangeData = this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n  const {\n    row: sourceStartRow,\n    col: sourceStartColumn\n  } = engineSourceRange.start;\n  const {\n    row: sourceEndRow,\n    col: sourceEndColumn\n  } = engineSourceRange.end;\n  const populationRowLength = sourceEndRow - sourceStartRow + 1;\n  const populationColumnLength = sourceEndColumn - sourceStartColumn + 1;\n  for (let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; populatedRowIndex += 1) {\n    for (let populatedColumnIndex = 0; populatedColumnIndex < fillRangeData[populatedRowIndex].length; populatedColumnIndex += 1) {\n      const populatedValue = fillRangeData[populatedRowIndex][populatedColumnIndex];\n      const sourceRow = sourceStartRow + populatedRowIndex % populationRowLength;\n      const sourceColumn = sourceStartColumn + populatedColumnIndex % populationColumnLength;\n      const sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);\n      if (isDate(populatedValue, sourceCellMeta.type)) {\n        if (populatedValue.startsWith('\\'')) {\n          // Populating values on HOT side without apostrophe.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = populatedValue.slice(1);\n        } else if (this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {\n          // Populating date in proper format, coming from the source cell.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);\n        }\n      }\n    }\n  }\n  return fillRangeData;\n}\n/**\n * `beforeLoadData` hook callback.\n *\n * @param {Array} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n * @param {string} [source] Source of the call.\n */\nfunction _onBeforeLoadData(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n\n  // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n  // initial dataset.\n  _classPrivateFieldSet(_hotWasInitializedWithEmptyData, this, isUndefined(this.hot.getSettings().data));\n}\n/**\n * Callback to `afterCellMetaReset` hook which is triggered after setting cell meta.\n */\nfunction _onAfterCellMetaReset() {\n  const sourceDataArray = this.hot.getSourceDataArray();\n  let valueChanged = false;\n  sourceDataArray.forEach((rowData, rowIndex) => {\n    rowData.forEach((cellValue, columnIndex) => {\n      const cellMeta = this.hot.getCellMeta(rowIndex, columnIndex);\n      const dateFormat = cellMeta.dateFormat;\n      if (isDate(cellValue, cellMeta.type)) {\n        valueChanged = true;\n        if (isDateValid(cellValue, dateFormat)) {\n          // Rewriting date in HOT format to HF format.\n          sourceDataArray[rowIndex][columnIndex] = getDateInHfFormat(cellValue, dateFormat);\n        } else if (this.isFormulaCellType(rowIndex, columnIndex) === false) {\n          // Escaping value from date parsing using \"'\" sign (HF feature).\n          sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;\n        }\n      }\n    });\n  });\n  if (valueChanged === true) {\n    _classPrivateFieldSet(_internalOperationPending, this, true);\n    this.engine.setSheetContent(this.sheetId, sourceDataArray);\n    _classPrivateFieldSet(_internalOperationPending, this, false);\n  }\n}\n/**\n * `afterLoadData` hook callback.\n *\n * @param {Array} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n * @param {string} [source] Source of the call.\n */\nfunction _onAfterLoadData(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n  this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n  if (!_classPrivateFieldGet(_hotWasInitializedWithEmptyData, this)) {\n    const sourceDataArray = this.hot.getSourceDataArray();\n    if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n      _classPrivateFieldSet(_internalOperationPending, this, true);\n      const dependentCells = this.engine.setSheetContent(this.sheetId, sourceDataArray);\n      this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);\n      this.renderDependentSheets(dependentCells);\n      _classPrivateFieldSet(_internalOperationPending, this, false);\n    }\n  } else {\n    this.switchSheet(this.sheetName);\n  }\n}\n/**\n * `modifyData` hook callback.\n *\n * @param {number} physicalRow Physical row index.\n * @param {number} visualColumn Visual column index.\n * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n *   property.\n * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n */\nfunction _onModifyData(physicalRow, visualColumn, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(_internalOperationPending, this) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(physicalRow);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      if (isEscapedFormulaExpression(valueHolder.value)) {\n        valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n      }\n      return;\n    }\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel like date).\n\n  // TODO: Workaround. We use HOT's `getCellsMeta` method instead of HOT's `getCellMeta` method. Getting cell meta\n  // using the second method lead to execution of the `cells` method. Using the `getDataAtCell` (which may be useful)\n  // in a callback to the `cells` method leads to triggering the `modifyData` hook. Thus, the `onModifyData` callback\n  // is executed once again and it cause creation of an infinite loop.\n  let cellMeta = this.hot.getCellsMeta().find(singleCellMeta => singleCellMeta.visualRow === visualRow && singleCellMeta.visualCol === visualColumn);\n  if (cellMeta === undefined) {\n    cellMeta = {};\n  }\n  if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n    cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n  }\n\n  // If `cellValue` is an object it is expected to be an error\n  const value = typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  valueHolder.value = value;\n}\n/**\n * `modifySourceData` hook callback.\n *\n * @param {number} row Physical row index.\n * @param {number|string} columnOrProp Physical column index or prop.\n * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n *   property.\n * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n */\nfunction _onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(_internalOperationPending, this) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(row);\n  const visualColumn = this.hot.propToCol(columnOrProp);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      return;\n    }\n  }\n  const dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n  // Don't actually change the source data if HyperFormula is not\n  // initialized yet. This is done to allow the `afterLoadData` hook to\n  // load the existing source data with `Handsontable#getSourceDataArray`\n  // properly.\n  if (dimensions.width === 0 && dimensions.height === 0) {\n    return;\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  valueHolder.value = this.engine.getCellSerialized(address);\n}\n/**\n * `onAfterSetDataAtCell` hook callback.\n *\n * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterSetDataAtCell(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const outOfBoundsChanges = [];\n  const changedCells = [];\n  const dependentCells = this.engine.batch(() => {\n    changes.forEach(_ref4 => {\n      let [visualRow, prop,, newValue] = _ref4;\n      const visualColumn = this.hot.propToCol(prop);\n      const physicalRow = this.hot.toPhysicalRow(visualRow);\n      const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      const address = {\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n        sheet: this.sheetId\n      };\n      if (physicalRow !== null && physicalColumn !== null) {\n        this.syncChangeWithEngine(visualRow, visualColumn, newValue);\n      } else {\n        outOfBoundsChanges.push([visualRow, visualColumn, newValue]);\n      }\n      changedCells.push({\n        address\n      });\n    });\n  });\n  if (outOfBoundsChanges.length) {\n    // Workaround for rows/columns being created two times (by HOT and the engine).\n    // (unfortunately, this requires an extra re-render)\n    this.hot.addHookOnce('afterChange', () => {\n      const outOfBoundsDependentCells = this.engine.batch(() => {\n        outOfBoundsChanges.forEach(_ref5 => {\n          let [row, column, newValue] = _ref5;\n          this.syncChangeWithEngine(row, column, newValue);\n        });\n      });\n      this.renderDependentSheets(outOfBoundsDependentCells, true);\n    });\n  }\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\n/**\n * `onAfterSetSourceDataAtCell` hook callback.\n *\n * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterSetSourceDataAtCell(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const dependentCells = [];\n  const changedCells = [];\n  changes.forEach(_ref6 => {\n    let [visualRow, prop,, newValue] = _ref6;\n    const visualColumn = this.hot.propToCol(prop);\n    if (!isNumeric(visualColumn)) {\n      return;\n    }\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set source cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    changedCells.push({\n      address\n    });\n    dependentCells.push(...this.engine.setCellContents(address, newValue));\n  });\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\n/**\n * `beforeCreateRow` hook callback.\n *\n * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n * @param {number} amount Number of newly created rows in the data source array.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeCreateRow(visualRow, amount) {\n  let hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);\n  if (visualRow >= this.hot.countRows()) {\n    hfRowIndex = visualRow; // Row beyond the table boundaries.\n  }\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) {\n    return false;\n  }\n}\n/**\n * `beforeCreateCol` hook callback.\n *\n * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n * @param {number} amount Number of newly created columns in the data source.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeCreateCol(visualColumn, amount) {\n  let hfColumnIndex = this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);\n  if (visualColumn >= this.hot.countCols()) {\n    hfColumnIndex = visualColumn; // Column beyond the table boundaries.\n  }\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) {\n    return false;\n  }\n}\n/**\n * `beforeRemoveRow` hook callback.\n *\n * @param {number} row Visual index of starter row.\n * @param {number} amount Amount of rows to be removed.\n * @param {number[]} physicalRows An array of physical rows removed from the data source.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeRemoveRow(row, amount, physicalRows) {\n  const hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);\n  const possible = hfRows.every(hfRow => {\n    return this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);\n  });\n  return possible === false ? false : undefined;\n}\n/**\n * `beforeRemoveCol` hook callback.\n *\n * @param {number} col Visual index of starter column.\n * @param {number} amount Amount of columns to be removed.\n * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeRemoveCol(col, amount, physicalColumns) {\n  const hfColumns = this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);\n  const possible = hfColumns.every(hfColumn => {\n    return this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);\n  });\n  return possible === false ? false : undefined;\n}\n/**\n * `afterCreateRow` hook callback.\n *\n * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n * @param {number} amount Number of newly created rows in the data source array.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterCreateRow(visualRow, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addRows(this.sheetId, [this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterCreateCol` hook callback.\n *\n * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n * @param {number} amount Number of newly created columns in the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterCreateCol(visualColumn, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addColumns(this.sheetId, [this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterRemoveRow` hook callback.\n *\n * @param {number} row Visual index of starter row.\n * @param {number} amount An amount of removed rows.\n * @param {number[]} physicalRows An array of physical rows removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterRemoveRow(row, amount, physicalRows, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfRows = this.rowAxisSyncer.getRemovedHfIndexes().sort((a, b) => b - a); // sort numeric values descending\n\n  const changes = this.engine.batch(() => {\n    descendingHfRows.forEach(hfRow => {\n      this.engine.removeRows(this.sheetId, [hfRow, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterRemoveCol` hook callback.\n *\n * @param {number} col Visual index of starter column.\n * @param {number} amount An amount of removed columns.\n * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterRemoveCol(col, amount, physicalColumns, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfColumns = this.columnAxisSyncer.getRemovedHfIndexes().sort((a, b) => b - a); // sort numeric values descending\n\n  const changes = this.engine.batch(() => {\n    descendingHfColumns.forEach(hfColumn => {\n      this.engine.removeColumns(this.sheetId, [hfColumn, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterDetachChild` hook callback.\n * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n *\n * @param {object} parent An object representing the parent from which the element was detached.\n * @param {object} element The detached element.\n * @param {number} finalElementRowIndex The final row index of the detached element.\n */\nfunction _onAfterDetachChild(parent, element, finalElementRowIndex) {\n  var _element$__children;\n  _classPrivateFieldSet(_internalOperationPending, this, true);\n  const rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n  _classPrivateFieldSet(_internalOperationPending, this, false);\n  rowsData.forEach((row, relativeRowIndex) => {\n    row.forEach((value, colIndex) => {\n      this.engine.setCellContents({\n        col: colIndex,\n        row: finalElementRowIndex + relativeRowIndex,\n        sheet: this.sheetId\n      }, [[value]]);\n    });\n  });\n}\n/**\n * Called when a value is updated in the engine.\n *\n * @fires Hooks#afterFormulasValuesUpdate\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineValuesUpdated(changes) {\n  this.hot.runHooks('afterFormulasValuesUpdate', changes);\n}\n/**\n * Called when a named expression is added to the engine instance.\n *\n * @fires Hooks#afterNamedExpressionAdded\n * @param {string} namedExpressionName The name of the added expression.\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n}\n/**\n * Called when a named expression is removed from the engine instance.\n *\n * @fires Hooks#afterNamedExpressionRemoved\n * @param {string} namedExpressionName The name of the removed expression.\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n}\n/**\n * Called when a new sheet is added to the engine instance.\n *\n * @fires Hooks#afterSheetAdded\n * @param {string} addedSheetDisplayName The name of the added sheet.\n */\nfunction _onEngineSheetAdded(addedSheetDisplayName) {\n  this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n}\n/**\n * Called when a sheet in the engine instance is renamed.\n *\n * @fires Hooks#afterSheetRenamed\n * @param {string} oldDisplayName The old name of the sheet.\n * @param {string} newDisplayName The new name of the sheet.\n */\nfunction _onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n  this.sheetName = newDisplayName;\n  this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n}\n/**\n * Called when a sheet is removed from the engine instance.\n *\n * @fires Hooks#afterSheetRemoved\n * @param {string} removedSheetDisplayName The removed sheet name.\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineSheetRemoved(removedSheetDisplayName, changes) {\n  this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_defineProperty","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","_classPrivateFieldInitSpec","set","has","_classPrivateFieldSet","s","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","BasePlugin","staticRegister","error","warn","isNumeric","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","isDate","isDateValid","getDateInHfFormat","getDateFromExcelDate","getDateInHotFormat","isFormula","getEngineSettingsWithOverrides","haveEngineSettingsChanged","isArrayOfArrays","toUpperCaseFirst","Hooks","IndexSyncer","PLUGIN_KEY","SETTING_KEYS","PLUGIN_PRIORITY","getSingleton","register","isBlockedSource","source","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","_Formulas_brand","WeakSet","Formulas","constructor","_this","_len","args","Array","_key","_onEngineValuesUpdated","_len2","_key2","_onEngineNamedExpressionsAdded","_len3","_key3","_onEngineNamedExpressionsRemoved","_len4","_key4","_onEngineSheetAdded","_len5","_key5","_onEngineSheetRenamed","_len6","_key6","_onEngineSheetRemoved","sheetId","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this2","enabled","doesSheetExist","newSheetName","addSheet","getSourceDataArray","addHook","_len7","_key7","_onBeforeLoadData","_len8","_key8","_onAfterLoadData","_len9","_key9","_len10","_key10","_len11","_key11","_onModifyData","_len12","_key12","_onModifySourceData","_len13","_key13","_onBeforeValidate","_len14","_key14","_onAfterSetSourceDataAtCell","_len15","_key15","_onAfterSetDataAtCell","_len16","_key16","_len17","_key17","_onBeforeCreateRow","_len18","_key18","_onBeforeCreateCol","_len19","_key19","_onAfterCreateRow","_len20","_key20","_onAfterCreateCol","_len21","_key21","_onBeforeRemoveRow","_len22","_key22","_onBeforeRemoveCol","_len23","_key23","_onAfterRemoveRow","_len24","_key24","_onAfterRemoveCol","indexSyncer","rowIndexMapper","columnIndexMapper","postponedAction","addHookOnce","rowAxisSyncer","getForAxis","columnAxisSyncer","getIndexesChangeSyncMethod","movedRows","finalIndex","_","movePossible","storeMovesInformation","movedColumns","dropIndex","orderChanged","calculateAndSyncMoves","column","freezePerformed","fixedColumnsStart","unfreezePerformed","_len25","_key25","_onAfterCellMetaReset","setPerformUndo","undo","setPerformRedo","redo","_len26","_key26","_onAfterDetachChild","_len27","_key27","_onBeforeAutofill","forEach","_ref","eventName","listener","on","disablePlugin","_ref2","off","updatePlugin","newSettings","newEngineSettings","getConfig","updateConfig","pluginSettings","switchSheet","data","undefined","destroy","_ref3","_this$engine","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","loadData","getCellType","row","sheet","physicalRow","toPhysicalRow","physicalColumn","toPhysicalColumn","getHfIndexFromVisualIndex","col","isFormulaCellType","doesCellHaveFormula","renderDependentSheets","dependentCells","renderSelf","affectedSheetIds","Set","change","_change$address","address","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","changedCells","stringifyAddress","_change$address2","changedCellsSet","map","_change$address3","_change$address4","countRows","countCols","addressId","boundHot","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","cellMeta","type","dateFormat","setCellContents","visualRow","prop","visualColumn","propToCol","cellValue","getCellValue","fillData","sourceRange","targetRange","sourceTopStartRow","sourceTopStartColumn","getTopStartCorner","sourceBottomEndRow","sourceBottomEndColumn","getBottomEndCorner","targetTopStartRow","targetTopStartColumn","targetBottomEndRow","targetBottomEndColumn","engineSourceRange","start","end","engineTargetRange","fillRangeData","getFillRangeData","sourceStartRow","sourceStartColumn","sourceEndRow","sourceEndColumn","populationRowLength","populationColumnLength","populatedRowIndex","populatedColumnIndex","populatedValue","sourceRow","sourceColumn","sourceCellMeta","startsWith","slice","sourceData","initialLoad","includes","sourceDataArray","valueChanged","rowData","rowIndex","columnIndex","isItPossibleToReplaceSheetContent","setupSyncEndpoint","valueHolder","ioMode","toVisualRow","cellType","getCellsMeta","find","singleCellMeta","visualCol","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","outOfBoundsChanges","batch","_ref4","push","outOfBoundsDependentCells","_ref5","_ref6","amount","hfRowIndex","isItPossibleToAddRows","hfColumnIndex","isItPossibleToAddColumns","physicalRows","hfRows","setRemovedHfIndexes","possible","every","hfRow","isItPossibleToRemoveRows","physicalColumns","hfColumns","hfColumn","isItPossibleToRemoveColumns","addRows","addColumns","descendingHfRows","getRemovedHfIndexes","sort","b","removeRows","descendingHfColumns","removeColumns","parent","element","finalElementRowIndex","_element$__children","rowsData","__children","countSourceCols","relativeRowIndex","colIndex","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/formulas/formulas.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression, isDate, isDateValid, getDateInHfFormat, getDateFromExcelDate, getDateInHotFormat, isFormula } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides, haveEngineSettingsChanged } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport IndexSyncer from \"./indexSyncer/index.mjs\";\nexport const PLUGIN_KEY = 'formulas';\nexport const SETTING_KEYS = ['maxRows', 'maxColumns', 'language'];\nexport const PLUGIN_PRIORITY = 260;\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nconst isBlockedSource = source => source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nvar _Formulas_brand = /*#__PURE__*/new WeakSet();\nexport class Formulas extends BasePlugin {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n    _classPrivateMethodInitSpec(this, _Formulas_brand);\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _internalOperationPending, false);\n    /**\n     * Flag needed to mark if Handsontable was initialized with no data.\n     * (Required to work around the fact, that Handsontable auto-generates sample data, when no data is provided).\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hotWasInitializedWithEmptyData, false);\n    /**\n     * The list of the HyperFormula listeners.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _engineListeners, [['valuesUpdated', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineValuesUpdated).call(_this, ...args);\n    }], ['namedExpressionAdded', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineNamedExpressionsAdded).call(_this, ...args);\n    }], ['namedExpressionRemoved', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineNamedExpressionsRemoved).call(_this, ...args);\n    }], ['sheetAdded', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineSheetAdded).call(_this, ...args);\n    }], ['sheetRenamed', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineSheetRenamed).call(_this, ...args);\n    }], ['sheetRemoved', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_Formulas_brand, _this, _onEngineSheetRemoved).call(_this, ...args);\n    }]]);\n    /**\n     * Static register used to set up one global HyperFormula instance.\n     * TODO: currently used in tests, might be removed later.\n     *\n     * @private\n     * @type {object}\n     */\n    _defineProperty(this, \"staticRegister\", staticRegister('formulas'));\n    /**\n     * The engine instance that will be used for this instance of Handsontable.\n     *\n     * @type {HyperFormula|null}\n     */\n    _defineProperty(this, \"engine\", null);\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @type {string|null}\n     */\n    _defineProperty(this, \"sheetName\", null);\n    /**\n     * Index synchronizer responsible for manipulating with some general options related to indexes synchronization.\n     *\n     * @type {IndexSyncer|null}\n     */\n    _defineProperty(this, \"indexSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the rows.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"rowAxisSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the columns.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"columnAxisSyncer\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * HyperFormula's sheet id.\n   *\n   * @type {number|null}\n   */\n  get sheetId() {\n    return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    /* eslint-disable no-unneeded-ternary */\n    return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _setupEngine,\n      _this2 = this;\n    if (this.enabled) {\n      return;\n    }\n    this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n    if (!this.engine) {\n      warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n      return;\n    }\n\n    // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n    if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n      const newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      if (newSheetName !== false) {\n        this.sheetName = newSheetName;\n      }\n    }\n    this.addHook('beforeLoadData', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeLoadData).call(_this2, ...args);\n    });\n    this.addHook('afterLoadData', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterLoadData).call(_this2, ...args);\n    });\n\n    // The `updateData` hooks utilize the same logic as the `loadData` hooks.\n    this.addHook('beforeUpdateData', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeLoadData).call(_this2, ...args);\n    });\n    this.addHook('afterUpdateData', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterLoadData).call(_this2, ...args);\n    });\n    this.addHook('modifyData', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onModifyData).call(_this2, ...args);\n    });\n    this.addHook('modifySourceData', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onModifySourceData).call(_this2, ...args);\n    });\n    this.addHook('beforeValidate', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeValidate).call(_this2, ...args);\n    });\n    this.addHook('afterSetSourceDataAtCell', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterSetSourceDataAtCell).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtCell', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterSetDataAtCell).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtRowProp', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterSetDataAtCell).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateRow', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeCreateRow).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateCol', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeCreateCol).call(_this2, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterCreateRow).call(_this2, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterCreateCol).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveRow', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeRemoveRow).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveCol', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeRemoveCol).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterRemoveRow).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterRemoveCol).call(_this2, ...args);\n    });\n    this.indexSyncer = new IndexSyncer(this.hot.rowIndexMapper, this.hot.columnIndexMapper, postponedAction => {\n      this.hot.addHookOnce('init', () => {\n        // Engine is initialized after executing callback to `afterLoadData` hook. Thus, some actions on indexes should\n        // be postponed.\n        postponedAction();\n      });\n    });\n    this.rowAxisSyncer = this.indexSyncer.getForAxis('row');\n    this.columnAxisSyncer = this.indexSyncer.getForAxis('column');\n    this.hot.addHook('afterRowSequenceChange', this.rowAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('afterColumnSequenceChange', this.columnAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('beforeRowMove', (movedRows, finalIndex, _, movePossible) => {\n      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, movePossible);\n    });\n    this.hot.addHook('beforeColumnMove', (movedColumns, finalIndex, _, movePossible) => {\n      this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, movePossible);\n    });\n    this.hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('afterColumnMove', (movedColumns, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('beforeColumnFreeze', (column, freezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart, freezePerformed);\n    });\n    this.hot.addHook('afterColumnFreeze', (_, freezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, freezePerformed);\n    });\n    this.hot.addHook('beforeColumnUnfreeze', (column, unfreezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);\n    });\n    this.hot.addHook('afterColumnUnfreeze', (_, unfreezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, unfreezePerformed);\n    });\n\n    // TODO: Actions related to overwriting dates from HOT format to HF default format are done as callback to this\n    // hook, because some hooks, such as `afterLoadData` doesn't have information about composed cell properties.\n    // Another hooks are triggered to late for setting HF's engine data needed for some actions.\n    this.addHook('afterCellMetaReset', function () {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterCellMetaReset).call(_this2, ...args);\n    });\n\n    // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeUndo', () => {\n      this.indexSyncer.setPerformUndo(true);\n      this.engine.undo();\n    });\n\n    // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeRedo', () => {\n      this.indexSyncer.setPerformRedo(true);\n      this.engine.redo();\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformUndo(false);\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformRedo(false);\n    });\n    this.addHook('afterDetachChild', function () {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onAfterDetachChild).call(_this2, ...args);\n    });\n    this.addHook('beforeAutofill', function () {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return _assertClassBrand(_Formulas_brand, _this2, _onBeforeAutofill).call(_this2, ...args);\n    });\n    _classPrivateFieldGet(_engineListeners, this).forEach(_ref => {\n      let [eventName, listener] = _ref;\n      return this.engine.on(eventName, listener);\n    });\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    _classPrivateFieldGet(_engineListeners, this).forEach(_ref2 => {\n      let [eventName, listener] = _ref2;\n      return this.engine.off(eventName, listener);\n    });\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.disablePlugin();\n  }\n\n  /**\n   * Triggered on `updateSettings`.\n   *\n   * @private\n   * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n   */\n  updatePlugin(newSettings) {\n    const newEngineSettings = getEngineSettingsWithOverrides(this.hot.getSettings());\n    if (haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {\n      this.engine.updateConfig(newEngineSettings);\n    }\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n      this.switchSheet(pluginSettings.sheetName);\n    }\n\n    // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n    // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n    if (!newSettings.data && this.sheetName === null) {\n      const sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n      if (sheetName && this.engine.doesSheetExist(sheetName)) {\n        this.switchSheet(this.sheetName);\n      } else {\n        this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined, this.hot.getSourceDataArray());\n      }\n    }\n    super.updatePlugin(newSettings);\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(_engineListeners, this).forEach(_ref3 => {\n      var _this$engine;\n      let [eventName, listener] = _ref3;\n      return (_this$engine = this.engine) === null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, listener);\n    });\n    _classPrivateFieldSet(_engineListeners, this, null);\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.destroy();\n  }\n\n  /**\n   * Add a sheet to the shared HyperFormula instance.\n   *\n   * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n   * auto-generated by HyperFormula.\n   * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n   * arrays - array of objects is not supported in this scenario.\n   * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n   * engine, the created sheet name otherwise.\n   */\n  addSheet(sheetName, sheetData) {\n    if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n      warn('The provided data should be an array of arrays.');\n      return false;\n    }\n    if (sheetName !== undefined && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n      warn('Sheet with the provided name already exists.');\n      return false;\n    }\n    try {\n      const actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined);\n      if (sheetData) {\n        this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n      }\n      return actualSheetName;\n    } catch (e) {\n      warn(e.message);\n      return false;\n    }\n  }\n\n  /**\n   * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n   * instance).\n   *\n   * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n   */\n  switchSheet(sheetName) {\n    if (!this.engine.doesSheetExist(sheetName)) {\n      error(`The sheet named \\`${sheetName}\\` does not exist, switch aborted.`);\n      return;\n    }\n    this.sheetName = sheetName;\n    const serialized = this.engine.getSheetSerialized(this.sheetId);\n    if (serialized.length > 0) {\n      this.hot.loadData(serialized, `${toUpperCaseFirst(PLUGIN_KEY)}.switchSheet`);\n    }\n  }\n\n  /**\n   * Get the cell type under specified visual coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n   */\n  getCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    const physicalRow = this.hot.toPhysicalRow(row);\n    const physicalColumn = this.hot.toPhysicalColumn(column);\n    if (physicalRow !== null && physicalColumn !== null) {\n      return this.engine.getCellType({\n        sheet,\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n      });\n    } else {\n      // Should return `EMPTY` when out of bounds (according to the test cases).\n      return 'EMPTY';\n    }\n  }\n\n  /**\n   * Returns `true` if under specified visual coordinates is formula.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {boolean}\n   */\n  isFormulaCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    return this.engine.doesCellHaveFormula({\n      sheet,\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n    });\n  }\n\n  /**\n   * Renders dependent sheets (handsontable instances) based on the changes - list of the\n   * recalculated dependent cells.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n   */\n  renderDependentSheets(dependentCells) {\n    let renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const affectedSheetIds = new Set();\n    dependentCells.forEach(change => {\n      var _change$address;\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n      if (sheetId !== undefined) {\n        if (!affectedSheetIds.has(sheetId)) {\n          affectedSheetIds.add(sheetId);\n        }\n      }\n    });\n    getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {\n      if ((renderSelf || sheetId !== this.sheetId) && affectedSheetIds.has(sheetId)) {\n        var _relatedHot$view;\n        relatedHot.render();\n        (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();\n      }\n    });\n  }\n\n  /**\n   * Validates dependent cells based on the cells that are modified by the change.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n   */\n  validateDependentCells(dependentCells) {\n    let changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const stringifyAddress = change => {\n      var _change$address2;\n      const {\n        row,\n        col,\n        sheet\n      } = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {};\n      return isDefined(sheet) ? `${sheet}:${row}x${col}` : '';\n    };\n    const changedCellsSet = new Set(changedCells.map(change => stringifyAddress(change)));\n    dependentCells.forEach(change => {\n      var _change$address3, _change$address4;\n      const {\n        row,\n        col\n      } = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {};\n\n      // Don't try to validate cells outside of the visual part of the table.\n      if (isDefined(row) === false || isDefined(col) === false || row >= this.hot.countRows() || col >= this.hot.countCols()) {\n        return;\n      }\n\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n      const addressId = stringifyAddress(change);\n\n      // Validate the cells that depend on the calculated formulas. Skip that cells\n      // where the user directly changes the values - the Core triggers those validators.\n      if (sheetId !== undefined && !changedCellsSet.has(addressId)) {\n        const boundHot = getRegisteredHotInstances(this.engine).get(sheetId);\n\n        // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n        if (!boundHot) {\n          return;\n        }\n\n        // It will just re-render certain cell when necessary.\n        boundHot.validateCell(boundHot.getDataAtCell(row, col), boundHot.getCellMeta(row, col), () => {});\n      }\n    });\n  }\n\n  /**\n   * Sync a change from the change-related hooks with the engine.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {Handsontable.CellValue} newValue New value.\n   * @returns {Array} Array of changes exported from the engine.\n   */\n  syncChangeWithEngine(row, column, newValue) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if (isDate(newValue, cellMeta.type)) {\n      if (isDateValid(newValue, cellMeta.dateFormat)) {\n        // Rewriting date in HOT format to HF format.\n        newValue = getDateInHfFormat(newValue, cellMeta.dateFormat);\n      } else if (isFormula(newValue) === false) {\n        // Escaping value from date parsing using \"'\" sign (HF feature).\n        newValue = `'${newValue}`;\n      }\n    }\n    return this.engine.setCellContents(address, newValue);\n  }\n}\nfunction _onBeforeValidate(value, visualRow, prop) {\n  const visualColumn = this.hot.propToCol(prop);\n  if (this.isFormulaCellType(visualRow, visualColumn)) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);\n    let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel-like date).\n\n    if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n      cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n    }\n\n    // If `cellValue` is an object it is expected to be an error\n    return typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  }\n  return value;\n}\n/**\n * `onBeforeAutofill` hook callback.\n *\n * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n * @param {CellRange} sourceRange The range values will be filled from.\n * @param {CellRange} targetRange The range new values will be filled into.\n * @returns {boolean|*}\n */\nfunction _onBeforeAutofill(fillData, sourceRange, targetRange) {\n  const {\n    row: sourceTopStartRow,\n    col: sourceTopStartColumn\n  } = sourceRange.getTopStartCorner();\n  const {\n    row: sourceBottomEndRow,\n    col: sourceBottomEndColumn\n  } = sourceRange.getBottomEndCorner();\n  const {\n    row: targetTopStartRow,\n    col: targetTopStartColumn\n  } = targetRange.getTopStartCorner();\n  const {\n    row: targetBottomEndRow,\n    col: targetBottomEndColumn\n  } = targetRange.getBottomEndCorner();\n  const engineSourceRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n  const engineTargetRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n\n  // Blocks the autofill operation if HyperFormula says that at least one of\n  // the underlying cell's contents cannot be set.\n  if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n    return false;\n  }\n  const fillRangeData = this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n  const {\n    row: sourceStartRow,\n    col: sourceStartColumn\n  } = engineSourceRange.start;\n  const {\n    row: sourceEndRow,\n    col: sourceEndColumn\n  } = engineSourceRange.end;\n  const populationRowLength = sourceEndRow - sourceStartRow + 1;\n  const populationColumnLength = sourceEndColumn - sourceStartColumn + 1;\n  for (let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; populatedRowIndex += 1) {\n    for (let populatedColumnIndex = 0; populatedColumnIndex < fillRangeData[populatedRowIndex].length; populatedColumnIndex += 1) {\n      const populatedValue = fillRangeData[populatedRowIndex][populatedColumnIndex];\n      const sourceRow = sourceStartRow + populatedRowIndex % populationRowLength;\n      const sourceColumn = sourceStartColumn + populatedColumnIndex % populationColumnLength;\n      const sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);\n      if (isDate(populatedValue, sourceCellMeta.type)) {\n        if (populatedValue.startsWith('\\'')) {\n          // Populating values on HOT side without apostrophe.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = populatedValue.slice(1);\n        } else if (this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {\n          // Populating date in proper format, coming from the source cell.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);\n        }\n      }\n    }\n  }\n  return fillRangeData;\n}\n/**\n * `beforeLoadData` hook callback.\n *\n * @param {Array} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n * @param {string} [source] Source of the call.\n */\nfunction _onBeforeLoadData(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n\n  // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n  // initial dataset.\n  _classPrivateFieldSet(_hotWasInitializedWithEmptyData, this, isUndefined(this.hot.getSettings().data));\n}\n/**\n * Callback to `afterCellMetaReset` hook which is triggered after setting cell meta.\n */\nfunction _onAfterCellMetaReset() {\n  const sourceDataArray = this.hot.getSourceDataArray();\n  let valueChanged = false;\n  sourceDataArray.forEach((rowData, rowIndex) => {\n    rowData.forEach((cellValue, columnIndex) => {\n      const cellMeta = this.hot.getCellMeta(rowIndex, columnIndex);\n      const dateFormat = cellMeta.dateFormat;\n      if (isDate(cellValue, cellMeta.type)) {\n        valueChanged = true;\n        if (isDateValid(cellValue, dateFormat)) {\n          // Rewriting date in HOT format to HF format.\n          sourceDataArray[rowIndex][columnIndex] = getDateInHfFormat(cellValue, dateFormat);\n        } else if (this.isFormulaCellType(rowIndex, columnIndex) === false) {\n          // Escaping value from date parsing using \"'\" sign (HF feature).\n          sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;\n        }\n      }\n    });\n  });\n  if (valueChanged === true) {\n    _classPrivateFieldSet(_internalOperationPending, this, true);\n    this.engine.setSheetContent(this.sheetId, sourceDataArray);\n    _classPrivateFieldSet(_internalOperationPending, this, false);\n  }\n}\n/**\n * `afterLoadData` hook callback.\n *\n * @param {Array} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n * @param {string} [source] Source of the call.\n */\nfunction _onAfterLoadData(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n  this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n  if (!_classPrivateFieldGet(_hotWasInitializedWithEmptyData, this)) {\n    const sourceDataArray = this.hot.getSourceDataArray();\n    if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n      _classPrivateFieldSet(_internalOperationPending, this, true);\n      const dependentCells = this.engine.setSheetContent(this.sheetId, sourceDataArray);\n      this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);\n      this.renderDependentSheets(dependentCells);\n      _classPrivateFieldSet(_internalOperationPending, this, false);\n    }\n  } else {\n    this.switchSheet(this.sheetName);\n  }\n}\n/**\n * `modifyData` hook callback.\n *\n * @param {number} physicalRow Physical row index.\n * @param {number} visualColumn Visual column index.\n * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n *   property.\n * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n */\nfunction _onModifyData(physicalRow, visualColumn, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(_internalOperationPending, this) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(physicalRow);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      if (isEscapedFormulaExpression(valueHolder.value)) {\n        valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n      }\n      return;\n    }\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel like date).\n\n  // TODO: Workaround. We use HOT's `getCellsMeta` method instead of HOT's `getCellMeta` method. Getting cell meta\n  // using the second method lead to execution of the `cells` method. Using the `getDataAtCell` (which may be useful)\n  // in a callback to the `cells` method leads to triggering the `modifyData` hook. Thus, the `onModifyData` callback\n  // is executed once again and it cause creation of an infinite loop.\n  let cellMeta = this.hot.getCellsMeta().find(singleCellMeta => singleCellMeta.visualRow === visualRow && singleCellMeta.visualCol === visualColumn);\n  if (cellMeta === undefined) {\n    cellMeta = {};\n  }\n  if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n    cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n  }\n\n  // If `cellValue` is an object it is expected to be an error\n  const value = typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  valueHolder.value = value;\n}\n/**\n * `modifySourceData` hook callback.\n *\n * @param {number} row Physical row index.\n * @param {number|string} columnOrProp Physical column index or prop.\n * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n *   property.\n * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n */\nfunction _onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(_internalOperationPending, this) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(row);\n  const visualColumn = this.hot.propToCol(columnOrProp);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      return;\n    }\n  }\n  const dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n  // Don't actually change the source data if HyperFormula is not\n  // initialized yet. This is done to allow the `afterLoadData` hook to\n  // load the existing source data with `Handsontable#getSourceDataArray`\n  // properly.\n  if (dimensions.width === 0 && dimensions.height === 0) {\n    return;\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  valueHolder.value = this.engine.getCellSerialized(address);\n}\n/**\n * `onAfterSetDataAtCell` hook callback.\n *\n * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterSetDataAtCell(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const outOfBoundsChanges = [];\n  const changedCells = [];\n  const dependentCells = this.engine.batch(() => {\n    changes.forEach(_ref4 => {\n      let [visualRow, prop,, newValue] = _ref4;\n      const visualColumn = this.hot.propToCol(prop);\n      const physicalRow = this.hot.toPhysicalRow(visualRow);\n      const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      const address = {\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n        sheet: this.sheetId\n      };\n      if (physicalRow !== null && physicalColumn !== null) {\n        this.syncChangeWithEngine(visualRow, visualColumn, newValue);\n      } else {\n        outOfBoundsChanges.push([visualRow, visualColumn, newValue]);\n      }\n      changedCells.push({\n        address\n      });\n    });\n  });\n  if (outOfBoundsChanges.length) {\n    // Workaround for rows/columns being created two times (by HOT and the engine).\n    // (unfortunately, this requires an extra re-render)\n    this.hot.addHookOnce('afterChange', () => {\n      const outOfBoundsDependentCells = this.engine.batch(() => {\n        outOfBoundsChanges.forEach(_ref5 => {\n          let [row, column, newValue] = _ref5;\n          this.syncChangeWithEngine(row, column, newValue);\n        });\n      });\n      this.renderDependentSheets(outOfBoundsDependentCells, true);\n    });\n  }\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\n/**\n * `onAfterSetSourceDataAtCell` hook callback.\n *\n * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterSetSourceDataAtCell(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const dependentCells = [];\n  const changedCells = [];\n  changes.forEach(_ref6 => {\n    let [visualRow, prop,, newValue] = _ref6;\n    const visualColumn = this.hot.propToCol(prop);\n    if (!isNumeric(visualColumn)) {\n      return;\n    }\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set source cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    changedCells.push({\n      address\n    });\n    dependentCells.push(...this.engine.setCellContents(address, newValue));\n  });\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\n/**\n * `beforeCreateRow` hook callback.\n *\n * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n * @param {number} amount Number of newly created rows in the data source array.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeCreateRow(visualRow, amount) {\n  let hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);\n  if (visualRow >= this.hot.countRows()) {\n    hfRowIndex = visualRow; // Row beyond the table boundaries.\n  }\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) {\n    return false;\n  }\n}\n/**\n * `beforeCreateCol` hook callback.\n *\n * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n * @param {number} amount Number of newly created columns in the data source.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeCreateCol(visualColumn, amount) {\n  let hfColumnIndex = this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);\n  if (visualColumn >= this.hot.countCols()) {\n    hfColumnIndex = visualColumn; // Column beyond the table boundaries.\n  }\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) {\n    return false;\n  }\n}\n/**\n * `beforeRemoveRow` hook callback.\n *\n * @param {number} row Visual index of starter row.\n * @param {number} amount Amount of rows to be removed.\n * @param {number[]} physicalRows An array of physical rows removed from the data source.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeRemoveRow(row, amount, physicalRows) {\n  const hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);\n  const possible = hfRows.every(hfRow => {\n    return this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);\n  });\n  return possible === false ? false : undefined;\n}\n/**\n * `beforeRemoveCol` hook callback.\n *\n * @param {number} col Visual index of starter column.\n * @param {number} amount Amount of columns to be removed.\n * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\nfunction _onBeforeRemoveCol(col, amount, physicalColumns) {\n  const hfColumns = this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);\n  const possible = hfColumns.every(hfColumn => {\n    return this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);\n  });\n  return possible === false ? false : undefined;\n}\n/**\n * `afterCreateRow` hook callback.\n *\n * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n * @param {number} amount Number of newly created rows in the data source array.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterCreateRow(visualRow, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addRows(this.sheetId, [this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterCreateCol` hook callback.\n *\n * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n * @param {number} amount Number of newly created columns in the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterCreateCol(visualColumn, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addColumns(this.sheetId, [this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterRemoveRow` hook callback.\n *\n * @param {number} row Visual index of starter row.\n * @param {number} amount An amount of removed rows.\n * @param {number[]} physicalRows An array of physical rows removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterRemoveRow(row, amount, physicalRows, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfRows = this.rowAxisSyncer.getRemovedHfIndexes().sort((a, b) => b - a); // sort numeric values descending\n\n  const changes = this.engine.batch(() => {\n    descendingHfRows.forEach(hfRow => {\n      this.engine.removeRows(this.sheetId, [hfRow, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterRemoveCol` hook callback.\n *\n * @param {number} col Visual index of starter column.\n * @param {number} amount An amount of removed columns.\n * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n */\nfunction _onAfterRemoveCol(col, amount, physicalColumns, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfColumns = this.columnAxisSyncer.getRemovedHfIndexes().sort((a, b) => b - a); // sort numeric values descending\n\n  const changes = this.engine.batch(() => {\n    descendingHfColumns.forEach(hfColumn => {\n      this.engine.removeColumns(this.sheetId, [hfColumn, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\n/**\n * `afterDetachChild` hook callback.\n * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n *\n * @param {object} parent An object representing the parent from which the element was detached.\n * @param {object} element The detached element.\n * @param {number} finalElementRowIndex The final row index of the detached element.\n */\nfunction _onAfterDetachChild(parent, element, finalElementRowIndex) {\n  var _element$__children;\n  _classPrivateFieldSet(_internalOperationPending, this, true);\n  const rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n  _classPrivateFieldSet(_internalOperationPending, this, false);\n  rowsData.forEach((row, relativeRowIndex) => {\n    row.forEach((value, colIndex) => {\n      this.engine.setCellContents({\n        col: colIndex,\n        row: finalElementRowIndex + relativeRowIndex,\n        sheet: this.sheetId\n      }, [[value]]);\n    });\n  });\n}\n/**\n * Called when a value is updated in the engine.\n *\n * @fires Hooks#afterFormulasValuesUpdate\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineValuesUpdated(changes) {\n  this.hot.runHooks('afterFormulasValuesUpdate', changes);\n}\n/**\n * Called when a named expression is added to the engine instance.\n *\n * @fires Hooks#afterNamedExpressionAdded\n * @param {string} namedExpressionName The name of the added expression.\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n}\n/**\n * Called when a named expression is removed from the engine instance.\n *\n * @fires Hooks#afterNamedExpressionRemoved\n * @param {string} namedExpressionName The name of the removed expression.\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n}\n/**\n * Called when a new sheet is added to the engine instance.\n *\n * @fires Hooks#afterSheetAdded\n * @param {string} addedSheetDisplayName The name of the added sheet.\n */\nfunction _onEngineSheetAdded(addedSheetDisplayName) {\n  this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n}\n/**\n * Called when a sheet in the engine instance is renamed.\n *\n * @fires Hooks#afterSheetRenamed\n * @param {string} oldDisplayName The old name of the sheet.\n * @param {string} newDisplayName The new name of the sheet.\n */\nfunction _onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n  this.sheetName = newDisplayName;\n  this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n}\n/**\n * Called when a sheet is removed from the engine instance.\n *\n * @fires Hooks#afterSheetRemoved\n * @param {string} removedSheetDisplayName The removed sheet name.\n * @param {Array} changes The values and location of applied changes.\n */\nfunction _onEngineSheetRemoved(removedSheetDisplayName, changes) {\n  this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n}"],"mappings":"AAUA,SAASA,2BAA2BA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAAEC,0BAA0B,CAACF,CAAC,EAAEC,CAAC,CAAC,EAAEA,CAAC,CAACE,GAAG,CAACH,CAAC,CAAC;AAAE;AACzF,SAASI,eAAeA,CAACJ,CAAC,EAAEK,CAAC,EAAEC,CAAC,EAAE;EAAE,OAAO,CAACD,CAAC,GAAGE,cAAc,CAACF,CAAC,CAAC,KAAKL,CAAC,GAAGQ,MAAM,CAACC,cAAc,CAACT,CAAC,EAAEK,CAAC,EAAE;IAAEK,KAAK,EAAEJ,CAAC;IAAEK,UAAU,EAAE,CAAC,CAAC;IAAEC,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGb,CAAC,CAACK,CAAC,CAAC,GAAGC,CAAC,EAAEN,CAAC;AAAE;AACnL,SAASO,cAAcA,CAACD,CAAC,EAAE;EAAE,IAAIQ,CAAC,GAAGC,YAAY,CAACT,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOQ,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAACT,CAAC,EAAED,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOC,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIN,CAAC,GAAGM,CAAC,CAACU,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKjB,CAAC,EAAE;IAAE,IAAIc,CAAC,GAAGd,CAAC,CAACkB,IAAI,CAACZ,CAAC,EAAED,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOS,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIK,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKd,CAAC,GAAGe,MAAM,GAAGC,MAAM,EAAEf,CAAC,CAAC;AAAE;AACvT,SAASgB,0BAA0BA,CAACtB,CAAC,EAAEM,CAAC,EAAEL,CAAC,EAAE;EAAEC,0BAA0B,CAACF,CAAC,EAAEM,CAAC,CAAC,EAAEA,CAAC,CAACiB,GAAG,CAACvB,CAAC,EAAEC,CAAC,CAAC;AAAE;AAC9F,SAASC,0BAA0BA,CAACF,CAAC,EAAEM,CAAC,EAAE;EAAE,IAAIA,CAAC,CAACkB,GAAG,CAACxB,CAAC,CAAC,EAAE,MAAM,IAAImB,SAAS,CAAC,gEAAgE,CAAC;AAAE;AACjJ,SAASM,qBAAqBA,CAACC,CAAC,EAAEzB,CAAC,EAAEI,CAAC,EAAE;EAAE,OAAOqB,CAAC,CAACH,GAAG,CAACI,iBAAiB,CAACD,CAAC,EAAEzB,CAAC,CAAC,EAAEI,CAAC,CAAC,EAAEA,CAAC;AAAE;AACvF,SAASuB,qBAAqBA,CAACF,CAAC,EAAEzB,CAAC,EAAE;EAAE,OAAOyB,CAAC,CAACG,GAAG,CAACF,iBAAiB,CAACD,CAAC,EAAEzB,CAAC,CAAC,CAAC;AAAE;AAC9E,SAAS0B,iBAAiBA,CAAC3B,CAAC,EAAEM,CAAC,EAAEwB,CAAC,EAAE;EAAE,IAAI,UAAU,IAAI,OAAO9B,CAAC,GAAGA,CAAC,KAAKM,CAAC,GAAGN,CAAC,CAACwB,GAAG,CAAClB,CAAC,CAAC,EAAE,OAAOyB,SAAS,CAACC,MAAM,GAAG,CAAC,GAAG1B,CAAC,GAAGwB,CAAC;EAAE,MAAM,IAAIX,SAAS,CAAC,+CAA+C,CAAC;AAAE;AAClM,SAASc,UAAU,QAAQ,mBAAmB;AAC9C,OAAOC,cAAc,MAAM,gCAAgC;AAC3D,SAASC,KAAK,EAAEC,IAAI,QAAQ,2BAA2B;AACvD,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAASC,SAAS,EAAEC,WAAW,QAAQ,yBAAyB;AAChE,SAASC,WAAW,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,yBAAyB,QAAQ,uBAAuB;AAC5G,SAASC,0BAA0B,EAAEC,yBAAyB,EAAEC,MAAM,EAAEC,WAAW,EAAEC,iBAAiB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,SAAS,QAAQ,aAAa;AAChL,SAASC,8BAA8B,EAAEC,yBAAyB,QAAQ,uBAAuB;AACjG,SAASC,eAAe,QAAQ,wBAAwB;AACxD,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,OAAOC,KAAK,MAAM,uBAAuB;AACzC,OAAOC,WAAW,MAAM,yBAAyB;AACjD,OAAO,MAAMC,UAAU,GAAG,UAAU;AACpC,OAAO,MAAMC,YAAY,GAAG,CAAC,SAAS,EAAE,YAAY,EAAE,UAAU,CAAC;AACjE,OAAO,MAAMC,eAAe,GAAG,GAAG;AAClCJ,KAAK,CAACK,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,2BAA2B,CAAC;AAC1DN,KAAK,CAACK,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,6BAA6B,CAAC;AAC5DN,KAAK,CAACK,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,iBAAiB,CAAC;AAChDN,KAAK,CAACK,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,mBAAmB,CAAC;AAClDN,KAAK,CAACK,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,mBAAmB,CAAC;AAClDN,KAAK,CAACK,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,2BAA2B,CAAC;;AAE1D;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAGC,MAAM,IAAIA,MAAM,KAAK,eAAe,IAAIA,MAAM,KAAK,eAAe,IAAIA,MAAM,KAAK,MAAM;;AAE/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,yBAAyB,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AAC1D,IAAIC,+BAA+B,GAAG,aAAa,IAAID,OAAO,CAAC,CAAC;AAChE,IAAIE,gBAAgB,GAAG,aAAa,IAAIF,OAAO,CAAC,CAAC;AACjD,IAAIG,eAAe,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AAChD,OAAO,MAAMC,QAAQ,SAAStC,UAAU,CAAC;EACvCuC,WAAWA,CAAA,EAAG;IACZ,IAAIC,KAAK;IACT,KAAK,CAAC,GAAG1C,SAAS,CAAC;IACnB0C,KAAK,GAAG,IAAI;IACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI1E,2BAA2B,CAAC,IAAI,EAAEsE,eAAe,CAAC;IAClD;AACJ;AACA;AACA;AACA;AACA;IACI/C,0BAA0B,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,KAAK,CAAC;IAClE;AACJ;AACA;AACA;AACA;AACA;IACI3C,0BAA0B,CAAC,IAAI,EAAE6C,+BAA+B,EAAE,KAAK,CAAC;IACxE;AACJ;AACA;AACA;AACA;IACI7C,0BAA0B,CAAC,IAAI,EAAE8C,gBAAgB,EAAE,CAAC,CAAC,eAAe,EAAE,YAAY;MAChF,KAAK,IAAIM,IAAI,GAAG3C,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACF,IAAI,CAAC,EAAEG,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGH,IAAI,EAAEG,IAAI,EAAE,EAAE;QACvFF,IAAI,CAACE,IAAI,CAAC,GAAG9C,SAAS,CAAC8C,IAAI,CAAC;MAC9B;MACA,OAAOlD,iBAAiB,CAAC0C,eAAe,EAAEI,KAAK,EAAEK,sBAAsB,CAAC,CAAC5D,IAAI,CAACuD,KAAK,EAAE,GAAGE,IAAI,CAAC;IAC/F,CAAC,CAAC,EAAE,CAAC,sBAAsB,EAAE,YAAY;MACvC,KAAK,IAAII,KAAK,GAAGhD,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACG,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FL,IAAI,CAACK,KAAK,CAAC,GAAGjD,SAAS,CAACiD,KAAK,CAAC;MAChC;MACA,OAAOrD,iBAAiB,CAAC0C,eAAe,EAAEI,KAAK,EAAEQ,8BAA8B,CAAC,CAAC/D,IAAI,CAACuD,KAAK,EAAE,GAAGE,IAAI,CAAC;IACvG,CAAC,CAAC,EAAE,CAAC,wBAAwB,EAAE,YAAY;MACzC,KAAK,IAAIO,KAAK,GAAGnD,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACM,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FR,IAAI,CAACQ,KAAK,CAAC,GAAGpD,SAAS,CAACoD,KAAK,CAAC;MAChC;MACA,OAAOxD,iBAAiB,CAAC0C,eAAe,EAAEI,KAAK,EAAEW,gCAAgC,CAAC,CAAClE,IAAI,CAACuD,KAAK,EAAE,GAAGE,IAAI,CAAC;IACzG,CAAC,CAAC,EAAE,CAAC,YAAY,EAAE,YAAY;MAC7B,KAAK,IAAIU,KAAK,GAAGtD,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACS,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FX,IAAI,CAACW,KAAK,CAAC,GAAGvD,SAAS,CAACuD,KAAK,CAAC;MAChC;MACA,OAAO3D,iBAAiB,CAAC0C,eAAe,EAAEI,KAAK,EAAEc,mBAAmB,CAAC,CAACrE,IAAI,CAACuD,KAAK,EAAE,GAAGE,IAAI,CAAC;IAC5F,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,YAAY;MAC/B,KAAK,IAAIa,KAAK,GAAGzD,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACY,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7Fd,IAAI,CAACc,KAAK,CAAC,GAAG1D,SAAS,CAAC0D,KAAK,CAAC;MAChC;MACA,OAAO9D,iBAAiB,CAAC0C,eAAe,EAAEI,KAAK,EAAEiB,qBAAqB,CAAC,CAACxE,IAAI,CAACuD,KAAK,EAAE,GAAGE,IAAI,CAAC;IAC9F,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,YAAY;MAC/B,KAAK,IAAIgB,KAAK,GAAG5D,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACe,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FjB,IAAI,CAACiB,KAAK,CAAC,GAAG7D,SAAS,CAAC6D,KAAK,CAAC;MAChC;MACA,OAAOjE,iBAAiB,CAAC0C,eAAe,EAAEI,KAAK,EAAEoB,qBAAqB,CAAC,CAAC3E,IAAI,CAACuD,KAAK,EAAE,GAAGE,IAAI,CAAC;IAC9F,CAAC,CAAC,CAAC,CAAC;IACJ;AACJ;AACA;AACA;AACA;AACA;AACA;IACIvE,eAAe,CAAC,IAAI,EAAE,gBAAgB,EAAE8B,cAAc,CAAC,UAAU,CAAC,CAAC;IACnE;AACJ;AACA;AACA;AACA;IACI9B,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC;IACrC;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC;IACxC;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,aAAa,EAAE,IAAI,CAAC;IAC1C;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,eAAe,EAAE,IAAI,CAAC;IAC5C;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,kBAAkB,EAAE,IAAI,CAAC;EACjD;EACA,WAAWsD,UAAUA,CAAA,EAAG;IACtB,OAAOA,UAAU;EACnB;EACA,WAAWE,eAAeA,CAAA,EAAG;IAC3B,OAAOA,eAAe;EACxB;EACA,WAAWD,YAAYA,CAAA,EAAG;IACxB,OAAO,CAACD,UAAU,EAAE,GAAGC,YAAY,CAAC;EACtC;EACA;AACF;AACA;AACA;AACA;EACE,IAAImC,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,SAAS,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI,CAACC,MAAM,CAACC,UAAU,CAAC,IAAI,CAACF,SAAS,CAAC;EAChF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,SAASA,CAAA,EAAG;IACV;IACA,OAAO,IAAI,CAACC,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC1C,UAAU,CAAC,GAAG,IAAI,GAAG,KAAK;EAC1D;;EAEA;AACF;AACA;EACE2C,YAAYA,CAAA,EAAG;IACb,IAAIC,YAAY;MACdC,MAAM,GAAG,IAAI;IACf,IAAI,IAAI,CAACC,OAAO,EAAE;MAChB;IACF;IACA,IAAI,CAACR,MAAM,GAAG,CAACM,YAAY,GAAG9D,WAAW,CAAC,IAAI,CAAC2D,GAAG,CAAC,MAAM,IAAI,IAAIG,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG,IAAI,CAACN,MAAM;IACrH,IAAI,CAAC,IAAI,CAACA,MAAM,EAAE;MAChB5D,IAAI,CAAC,2FAA2F,GAAG,sCAAsC,CAAC;MAC1I;IACF;;IAEA;IACA,IAAI,IAAI,CAAC2D,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,EAAE;MAC1E,MAAMW,YAAY,GAAG,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACZ,SAAS,EAAE,IAAI,CAACI,GAAG,CAACS,kBAAkB,CAAC,CAAC,CAAC;MACjF,IAAIF,YAAY,KAAK,KAAK,EAAE;QAC1B,IAAI,CAACX,SAAS,GAAGW,YAAY;MAC/B;IACF;IACA,IAAI,CAACG,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIC,KAAK,GAAG/E,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACkC,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FpC,IAAI,CAACoC,KAAK,CAAC,GAAGhF,SAAS,CAACgF,KAAK,CAAC;MAChC;MACA,OAAOpF,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAES,iBAAiB,CAAC,CAAC9F,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,eAAe,EAAE,YAAY;MACxC,KAAK,IAAII,KAAK,GAAGlF,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACqC,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FvC,IAAI,CAACuC,KAAK,CAAC,GAAGnF,SAAS,CAACmF,KAAK,CAAC;MAChC;MACA,OAAOvF,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEY,gBAAgB,CAAC,CAACjG,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC3F,CAAC,CAAC;;IAEF;IACA,IAAI,CAACkC,OAAO,CAAC,kBAAkB,EAAE,YAAY;MAC3C,KAAK,IAAIO,KAAK,GAAGrF,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACwC,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7F1C,IAAI,CAAC0C,KAAK,CAAC,GAAGtF,SAAS,CAACsF,KAAK,CAAC;MAChC;MACA,OAAO1F,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAES,iBAAiB,CAAC,CAAC9F,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAIS,MAAM,GAAGvF,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC0C,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG5C,IAAI,CAAC4C,MAAM,CAAC,GAAGxF,SAAS,CAACwF,MAAM,CAAC;MAClC;MACA,OAAO5F,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEY,gBAAgB,CAAC,CAACjG,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC3F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,YAAY,EAAE,YAAY;MACrC,KAAK,IAAIW,MAAM,GAAGzF,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC4C,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG9C,IAAI,CAAC8C,MAAM,CAAC,GAAG1F,SAAS,CAAC0F,MAAM,CAAC;MAClC;MACA,OAAO9F,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEmB,aAAa,CAAC,CAACxG,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACxF,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,kBAAkB,EAAE,YAAY;MAC3C,KAAK,IAAIc,MAAM,GAAG5F,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC+C,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGjD,IAAI,CAACiD,MAAM,CAAC,GAAG7F,SAAS,CAAC6F,MAAM,CAAC;MAClC;MACA,OAAOjG,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEsB,mBAAmB,CAAC,CAAC3G,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC9F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIiB,MAAM,GAAG/F,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACkD,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGpD,IAAI,CAACoD,MAAM,CAAC,GAAGhG,SAAS,CAACgG,MAAM,CAAC;MAClC;MACA,OAAOpG,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEyB,iBAAiB,CAAC,CAAC9G,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,0BAA0B,EAAE,YAAY;MACnD,KAAK,IAAIoB,MAAM,GAAGlG,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACqD,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGvD,IAAI,CAACuD,MAAM,CAAC,GAAGnG,SAAS,CAACmG,MAAM,CAAC;MAClC;MACA,OAAOvG,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAE4B,2BAA2B,CAAC,CAACjH,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACtG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,oBAAoB,EAAE,YAAY;MAC7C,KAAK,IAAIuB,MAAM,GAAGrG,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACwD,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG1D,IAAI,CAAC0D,MAAM,CAAC,GAAGtG,SAAS,CAACsG,MAAM,CAAC;MAClC;MACA,OAAO1G,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAE+B,qBAAqB,CAAC,CAACpH,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAChG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,uBAAuB,EAAE,YAAY;MAChD,KAAK,IAAI0B,MAAM,GAAGxG,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC2D,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG7D,IAAI,CAAC6D,MAAM,CAAC,GAAGzG,SAAS,CAACyG,MAAM,CAAC;MAClC;MACA,OAAO7G,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAE+B,qBAAqB,CAAC,CAACpH,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAChG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAI4B,MAAM,GAAG1G,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC6D,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG/D,IAAI,CAAC+D,MAAM,CAAC,GAAG3G,SAAS,CAAC2G,MAAM,CAAC;MAClC;MACA,OAAO/G,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEoC,kBAAkB,CAAC,CAACzH,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC7F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAI+B,MAAM,GAAG7G,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACgE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGlE,IAAI,CAACkE,MAAM,CAAC,GAAG9G,SAAS,CAAC8G,MAAM,CAAC;MAClC;MACA,OAAOlH,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEuC,kBAAkB,CAAC,CAAC5H,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC7F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIkC,MAAM,GAAGhH,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACmE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGrE,IAAI,CAACqE,MAAM,CAAC,GAAGjH,SAAS,CAACiH,MAAM,CAAC;MAClC;MACA,OAAOrH,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAE0C,iBAAiB,CAAC,CAAC/H,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIqC,MAAM,GAAGnH,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACsE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGxE,IAAI,CAACwE,MAAM,CAAC,GAAGpH,SAAS,CAACoH,MAAM,CAAC;MAClC;MACA,OAAOxH,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAE6C,iBAAiB,CAAC,CAAClI,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAIwC,MAAM,GAAGtH,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACyE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG3E,IAAI,CAAC2E,MAAM,CAAC,GAAGvH,SAAS,CAACuH,MAAM,CAAC;MAClC;MACA,OAAO3H,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEgD,kBAAkB,CAAC,CAACrI,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC7F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAI2C,MAAM,GAAGzH,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC4E,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG9E,IAAI,CAAC8E,MAAM,CAAC,GAAG1H,SAAS,CAAC0H,MAAM,CAAC;MAClC;MACA,OAAO9H,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEmD,kBAAkB,CAAC,CAACxI,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC7F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAI8C,MAAM,GAAG5H,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC+E,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGjF,IAAI,CAACiF,MAAM,CAAC,GAAG7H,SAAS,CAAC6H,MAAM,CAAC;MAClC;MACA,OAAOjI,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEsD,iBAAiB,CAAC,CAAC3I,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIiD,MAAM,GAAG/H,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACkF,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGpF,IAAI,CAACoF,MAAM,CAAC,GAAGhI,SAAS,CAACgI,MAAM,CAAC;MAClC;MACA,OAAOpI,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEyD,iBAAiB,CAAC,CAAC9I,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACsF,WAAW,GAAG,IAAIxG,WAAW,CAAC,IAAI,CAAC0C,GAAG,CAAC+D,cAAc,EAAE,IAAI,CAAC/D,GAAG,CAACgE,iBAAiB,EAAEC,eAAe,IAAI;MACzG,IAAI,CAACjE,GAAG,CAACkE,WAAW,CAAC,MAAM,EAAE,MAAM;QACjC;QACA;QACAD,eAAe,CAAC,CAAC;MACnB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,IAAI,CAACE,aAAa,GAAG,IAAI,CAACL,WAAW,CAACM,UAAU,CAAC,KAAK,CAAC;IACvD,IAAI,CAACC,gBAAgB,GAAG,IAAI,CAACP,WAAW,CAACM,UAAU,CAAC,QAAQ,CAAC;IAC7D,IAAI,CAACpE,GAAG,CAACU,OAAO,CAAC,wBAAwB,EAAE,IAAI,CAACyD,aAAa,CAACG,0BAA0B,CAAC,CAAC,CAAC;IAC3F,IAAI,CAACtE,GAAG,CAACU,OAAO,CAAC,2BAA2B,EAAE,IAAI,CAAC2D,gBAAgB,CAACC,0BAA0B,CAAC,CAAC,CAAC;IACjG,IAAI,CAACtE,GAAG,CAACU,OAAO,CAAC,eAAe,EAAE,CAAC6D,SAAS,EAAEC,UAAU,EAAEC,CAAC,EAAEC,YAAY,KAAK;MAC5E,IAAI,CAACP,aAAa,CAACQ,qBAAqB,CAACJ,SAAS,EAAEC,UAAU,EAAEE,YAAY,CAAC;IAC/E,CAAC,CAAC;IACF,IAAI,CAAC1E,GAAG,CAACU,OAAO,CAAC,kBAAkB,EAAE,CAACkE,YAAY,EAAEJ,UAAU,EAAEC,CAAC,EAAEC,YAAY,KAAK;MAClF,IAAI,CAACL,gBAAgB,CAACM,qBAAqB,CAACC,YAAY,EAAEJ,UAAU,EAAEE,YAAY,CAAC;IACrF,CAAC,CAAC;IACF,IAAI,CAAC1E,GAAG,CAACU,OAAO,CAAC,cAAc,EAAE,CAAC6D,SAAS,EAAEC,UAAU,EAAEK,SAAS,EAAEH,YAAY,EAAEI,YAAY,KAAK;MACjG,IAAI,CAACX,aAAa,CAACY,qBAAqB,CAACL,YAAY,EAAEI,YAAY,CAAC;IACtE,CAAC,CAAC;IACF,IAAI,CAAC9E,GAAG,CAACU,OAAO,CAAC,iBAAiB,EAAE,CAACkE,YAAY,EAAEJ,UAAU,EAAEK,SAAS,EAAEH,YAAY,EAAEI,YAAY,KAAK;MACvG,IAAI,CAACT,gBAAgB,CAACU,qBAAqB,CAACL,YAAY,EAAEI,YAAY,CAAC;IACzE,CAAC,CAAC;IACF,IAAI,CAAC9E,GAAG,CAACU,OAAO,CAAC,oBAAoB,EAAE,CAACsE,MAAM,EAAEC,eAAe,KAAK;MAClE,IAAI,CAACZ,gBAAgB,CAACM,qBAAqB,CAAC,CAACK,MAAM,CAAC,EAAE,IAAI,CAAChF,GAAG,CAACC,WAAW,CAAC,CAAC,CAACiF,iBAAiB,EAAED,eAAe,CAAC;IAClH,CAAC,CAAC;IACF,IAAI,CAACjF,GAAG,CAACU,OAAO,CAAC,mBAAmB,EAAE,CAAC+D,CAAC,EAAEQ,eAAe,KAAK;MAC5D,IAAI,CAACZ,gBAAgB,CAACU,qBAAqB,CAACE,eAAe,EAAEA,eAAe,CAAC;IAC/E,CAAC,CAAC;IACF,IAAI,CAACjF,GAAG,CAACU,OAAO,CAAC,sBAAsB,EAAE,CAACsE,MAAM,EAAEG,iBAAiB,KAAK;MACtE,IAAI,CAACd,gBAAgB,CAACM,qBAAqB,CAAC,CAACK,MAAM,CAAC,EAAE,IAAI,CAAChF,GAAG,CAACC,WAAW,CAAC,CAAC,CAACiF,iBAAiB,GAAG,CAAC,EAAEC,iBAAiB,CAAC;IACxH,CAAC,CAAC;IACF,IAAI,CAACnF,GAAG,CAACU,OAAO,CAAC,qBAAqB,EAAE,CAAC+D,CAAC,EAAEU,iBAAiB,KAAK;MAChE,IAAI,CAACd,gBAAgB,CAACU,qBAAqB,CAACI,iBAAiB,EAAEA,iBAAiB,CAAC;IACnF,CAAC,CAAC;;IAEF;IACA;IACA;IACA,IAAI,CAACzE,OAAO,CAAC,oBAAoB,EAAE,YAAY;MAC7C,KAAK,IAAI0E,MAAM,GAAGxJ,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAAC2G,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG7G,IAAI,CAAC6G,MAAM,CAAC,GAAGzJ,SAAS,CAACyJ,MAAM,CAAC;MAClC;MACA,OAAO7J,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEkF,qBAAqB,CAAC,CAACvK,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAChG,CAAC,CAAC;;IAEF;IACA,IAAI,CAACkC,OAAO,CAAC,YAAY,EAAE,MAAM;MAC/B,IAAI,CAACoD,WAAW,CAACyB,cAAc,CAAC,IAAI,CAAC;MACrC,IAAI,CAAC1F,MAAM,CAAC2F,IAAI,CAAC,CAAC;IACpB,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC9E,OAAO,CAAC,YAAY,EAAE,MAAM;MAC/B,IAAI,CAACoD,WAAW,CAAC2B,cAAc,CAAC,IAAI,CAAC;MACrC,IAAI,CAAC5F,MAAM,CAAC6F,IAAI,CAAC,CAAC;IACpB,CAAC,CAAC;IACF,IAAI,CAAChF,OAAO,CAAC,WAAW,EAAE,MAAM;MAC9B,IAAI,CAACoD,WAAW,CAACyB,cAAc,CAAC,KAAK,CAAC;IACxC,CAAC,CAAC;IACF,IAAI,CAAC7E,OAAO,CAAC,WAAW,EAAE,MAAM;MAC9B,IAAI,CAACoD,WAAW,CAAC2B,cAAc,CAAC,KAAK,CAAC;IACxC,CAAC,CAAC;IACF,IAAI,CAAC/E,OAAO,CAAC,kBAAkB,EAAE,YAAY;MAC3C,KAAK,IAAIiF,MAAM,GAAG/J,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACkH,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGpH,IAAI,CAACoH,MAAM,CAAC,GAAGhK,SAAS,CAACgK,MAAM,CAAC;MAClC;MACA,OAAOpK,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAEyF,mBAAmB,CAAC,CAAC9K,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC9F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIoF,MAAM,GAAGlK,SAAS,CAACC,MAAM,EAAE2C,IAAI,GAAG,IAAIC,KAAK,CAACqH,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGvH,IAAI,CAACuH,MAAM,CAAC,GAAGnK,SAAS,CAACmK,MAAM,CAAC;MAClC;MACA,OAAOvK,iBAAiB,CAAC0C,eAAe,EAAEkC,MAAM,EAAE4F,iBAAiB,CAAC,CAACjL,IAAI,CAACqF,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF/C,qBAAqB,CAACwC,gBAAgB,EAAE,IAAI,CAAC,CAACgI,OAAO,CAACC,IAAI,IAAI;MAC5D,IAAI,CAACC,SAAS,EAAEC,QAAQ,CAAC,GAAGF,IAAI;MAChC,OAAO,IAAI,CAACrG,MAAM,CAACwG,EAAE,CAACF,SAAS,EAAEC,QAAQ,CAAC;IAC5C,CAAC,CAAC;IACF,KAAK,CAAClG,YAAY,CAAC,CAAC;EACtB;;EAEA;AACF;AACA;EACEoG,aAAaA,CAAA,EAAG;IACd7K,qBAAqB,CAACwC,gBAAgB,EAAE,IAAI,CAAC,CAACgI,OAAO,CAACM,KAAK,IAAI;MAC7D,IAAI,CAACJ,SAAS,EAAEC,QAAQ,CAAC,GAAGG,KAAK;MACjC,OAAO,IAAI,CAAC1G,MAAM,CAAC2G,GAAG,CAACL,SAAS,EAAEC,QAAQ,CAAC;IAC7C,CAAC,CAAC;IACF7J,gBAAgB,CAAC,IAAI,CAACsD,MAAM,EAAE,IAAI,CAACG,GAAG,CAAC;IACvC,IAAI,CAACH,MAAM,GAAG,IAAI;IAClB,KAAK,CAACyG,aAAa,CAAC,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,YAAYA,CAACC,WAAW,EAAE;IACxB,MAAMC,iBAAiB,GAAG1J,8BAA8B,CAAC,IAAI,CAAC+C,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC;IAChF,IAAI/C,yBAAyB,CAAC,IAAI,CAAC2C,MAAM,CAAC+G,SAAS,CAAC,CAAC,EAAED,iBAAiB,CAAC,EAAE;MACzE,IAAI,CAAC9G,MAAM,CAACgH,YAAY,CAACF,iBAAiB,CAAC;IAC7C;IACA,MAAMG,cAAc,GAAG,IAAI,CAAC9G,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC1C,UAAU,CAAC;IACzD,IAAIpB,SAAS,CAAC2K,cAAc,CAAC,IAAI3K,SAAS,CAAC2K,cAAc,CAAClH,SAAS,CAAC,IAAIkH,cAAc,CAAClH,SAAS,KAAK,IAAI,CAACA,SAAS,EAAE;MACnH,IAAI,CAACmH,WAAW,CAACD,cAAc,CAAClH,SAAS,CAAC;IAC5C;;IAEA;IACA;IACA,IAAI,CAAC8G,WAAW,CAACM,IAAI,IAAI,IAAI,CAACpH,SAAS,KAAK,IAAI,EAAE;MAChD,MAAMA,SAAS,GAAG,IAAI,CAACI,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAACqC,SAAS;MAC9D,IAAIA,SAAS,IAAI,IAAI,CAACC,MAAM,CAACS,cAAc,CAACV,SAAS,CAAC,EAAE;QACtD,IAAI,CAACmH,WAAW,CAAC,IAAI,CAACnH,SAAS,CAAC;MAClC,CAAC,MAAM;QACL,IAAI,CAACA,SAAS,GAAG,IAAI,CAACY,QAAQ,CAACZ,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAGqH,SAAS,EAAE,IAAI,CAACjH,GAAG,CAACS,kBAAkB,CAAC,CAAC,CAAC;MACnI;IACF;IACA,KAAK,CAACgG,YAAY,CAACC,WAAW,CAAC;EACjC;;EAEA;AACF;AACA;EACEQ,OAAOA,CAAA,EAAG;IACRzL,qBAAqB,CAACwC,gBAAgB,EAAE,IAAI,CAAC,CAACgI,OAAO,CAACkB,KAAK,IAAI;MAC7D,IAAIC,YAAY;MAChB,IAAI,CAACjB,SAAS,EAAEC,QAAQ,CAAC,GAAGe,KAAK;MACjC,OAAO,CAACC,YAAY,GAAG,IAAI,CAACvH,MAAM,MAAM,IAAI,IAAIuH,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACZ,GAAG,CAACL,SAAS,EAAEC,QAAQ,CAAC;IAC1H,CAAC,CAAC;IACF9K,qBAAqB,CAAC2C,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC;IACnD1B,gBAAgB,CAAC,IAAI,CAACsD,MAAM,EAAE,IAAI,CAACG,GAAG,CAAC;IACvC,IAAI,CAACH,MAAM,GAAG,IAAI;IAClB,KAAK,CAACqH,OAAO,CAAC,CAAC;EACjB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE1G,QAAQA,CAACZ,SAAS,EAAEyH,SAAS,EAAE;IAC7B,IAAIlL,SAAS,CAACkL,SAAS,CAAC,IAAI,CAAClK,eAAe,CAACkK,SAAS,CAAC,EAAE;MACvDpL,IAAI,CAAC,iDAAiD,CAAC;MACvD,OAAO,KAAK;IACd;IACA,IAAI2D,SAAS,KAAKqH,SAAS,IAAIrH,SAAS,KAAK,IAAI,IAAI,IAAI,CAACC,MAAM,CAACS,cAAc,CAACV,SAAS,CAAC,EAAE;MAC1F3D,IAAI,CAAC,8CAA8C,CAAC;MACpD,OAAO,KAAK;IACd;IACA,IAAI;MACF,MAAMqL,eAAe,GAAG,IAAI,CAACzH,MAAM,CAACW,QAAQ,CAACZ,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAGqH,SAAS,CAAC;MAChH,IAAII,SAAS,EAAE;QACb,IAAI,CAACxH,MAAM,CAAC0H,eAAe,CAAC,IAAI,CAAC1H,MAAM,CAACC,UAAU,CAACwH,eAAe,CAAC,EAAED,SAAS,CAAC;MACjF;MACA,OAAOC,eAAe;IACxB,CAAC,CAAC,OAAOzN,CAAC,EAAE;MACVoC,IAAI,CAACpC,CAAC,CAAC2N,OAAO,CAAC;MACf,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACET,WAAWA,CAACnH,SAAS,EAAE;IACrB,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAACV,SAAS,CAAC,EAAE;MAC1C5D,KAAK,CAAC,qBAAqB4D,SAAS,oCAAoC,CAAC;MACzE;IACF;IACA,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,MAAM6H,UAAU,GAAG,IAAI,CAAC5H,MAAM,CAAC6H,kBAAkB,CAAC,IAAI,CAAC/H,OAAO,CAAC;IAC/D,IAAI8H,UAAU,CAAC5L,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAACmE,GAAG,CAAC2H,QAAQ,CAACF,UAAU,EAAE,GAAGrK,gBAAgB,CAACG,UAAU,CAAC,cAAc,CAAC;IAC9E;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEqK,WAAWA,CAACC,GAAG,EAAE7C,MAAM,EAAE;IACvB,IAAI8C,KAAK,GAAGlM,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqL,SAAS,GAAGrL,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC+D,OAAO;IAC5F,MAAMoI,WAAW,GAAG,IAAI,CAAC/H,GAAG,CAACgI,aAAa,CAACH,GAAG,CAAC;IAC/C,MAAMI,cAAc,GAAG,IAAI,CAACjI,GAAG,CAACkI,gBAAgB,CAAClD,MAAM,CAAC;IACxD,IAAI+C,WAAW,KAAK,IAAI,IAAIE,cAAc,KAAK,IAAI,EAAE;MACnD,OAAO,IAAI,CAACpI,MAAM,CAAC+H,WAAW,CAAC;QAC7BE,KAAK;QACLD,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACN,GAAG,CAAC;QACtDO,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACnD,MAAM;MAC7D,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,OAAO,OAAO;IAChB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEqD,iBAAiBA,CAACR,GAAG,EAAE7C,MAAM,EAAE;IAC7B,IAAI8C,KAAK,GAAGlM,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqL,SAAS,GAAGrL,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC+D,OAAO;IAC5F,OAAO,IAAI,CAACE,MAAM,CAACyI,mBAAmB,CAAC;MACrCR,KAAK;MACLD,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACN,GAAG,CAAC;MACtDO,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACnD,MAAM;IAC7D,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEuD,qBAAqBA,CAACC,cAAc,EAAE;IACpC,IAAIC,UAAU,GAAG7M,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqL,SAAS,GAAGrL,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;IAC1F,MAAM8M,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAAC;IAClCH,cAAc,CAACvC,OAAO,CAAC2C,MAAM,IAAI;MAC/B,IAAIC,eAAe;MACnB;MACA,MAAMlJ,OAAO,GAAGiJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,IAAI,CAACC,eAAe,GAAGD,MAAM,CAACE,OAAO,MAAM,IAAI,IAAID,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACf,KAAK;MAClK,IAAInI,OAAO,KAAKsH,SAAS,EAAE;QACzB,IAAI,CAACyB,gBAAgB,CAACrN,GAAG,CAACsE,OAAO,CAAC,EAAE;UAClC+I,gBAAgB,CAAC1O,GAAG,CAAC2F,OAAO,CAAC;QAC/B;MACF;IACF,CAAC,CAAC;IACFnD,yBAAyB,CAAC,IAAI,CAACqD,MAAM,CAAC,CAACoG,OAAO,CAAC,CAAC8C,UAAU,EAAEpJ,OAAO,KAAK;MACtE,IAAI,CAAC8I,UAAU,IAAI9I,OAAO,KAAK,IAAI,CAACA,OAAO,KAAK+I,gBAAgB,CAACrN,GAAG,CAACsE,OAAO,CAAC,EAAE;QAC7E,IAAIqJ,gBAAgB;QACpBD,UAAU,CAACE,MAAM,CAAC,CAAC;QACnB,CAACD,gBAAgB,GAAGD,UAAU,CAACG,IAAI,MAAM,IAAI,IAAIF,gBAAgB,KAAK,KAAK,CAAC,IAAIA,gBAAgB,CAACG,kBAAkB,CAAC,CAAC;MACvH;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,sBAAsBA,CAACZ,cAAc,EAAE;IACrC,IAAIa,YAAY,GAAGzN,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqL,SAAS,GAAGrL,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;IACzF,MAAM0N,gBAAgB,GAAGV,MAAM,IAAI;MACjC,IAAIW,gBAAgB;MACpB,MAAM;QACJ1B,GAAG;QACHO,GAAG;QACHN;MACF,CAAC,GAAG,CAACyB,gBAAgB,GAAGX,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACE,OAAO,MAAM,IAAI,IAAIS,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC,CAAC;MACvJ,OAAOpN,SAAS,CAAC2L,KAAK,CAAC,GAAG,GAAGA,KAAK,IAAID,GAAG,IAAIO,GAAG,EAAE,GAAG,EAAE;IACzD,CAAC;IACD,MAAMoB,eAAe,GAAG,IAAIb,GAAG,CAACU,YAAY,CAACI,GAAG,CAACb,MAAM,IAAIU,gBAAgB,CAACV,MAAM,CAAC,CAAC,CAAC;IACrFJ,cAAc,CAACvC,OAAO,CAAC2C,MAAM,IAAI;MAC/B,IAAIc,gBAAgB,EAAEC,gBAAgB;MACtC,MAAM;QACJ9B,GAAG;QACHO;MACF,CAAC,GAAG,CAACsB,gBAAgB,GAAGd,MAAM,CAACE,OAAO,MAAM,IAAI,IAAIY,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC,CAAC;;MAEvG;MACA,IAAIvN,SAAS,CAAC0L,GAAG,CAAC,KAAK,KAAK,IAAI1L,SAAS,CAACiM,GAAG,CAAC,KAAK,KAAK,IAAIP,GAAG,IAAI,IAAI,CAAC7H,GAAG,CAAC4J,SAAS,CAAC,CAAC,IAAIxB,GAAG,IAAI,IAAI,CAACpI,GAAG,CAAC6J,SAAS,CAAC,CAAC,EAAE;QACtH;MACF;;MAEA;MACA,MAAMlK,OAAO,GAAGiJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,IAAI,CAACe,gBAAgB,GAAGf,MAAM,CAACE,OAAO,MAAM,IAAI,IAAIa,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAAC7B,KAAK;MACrK,MAAMgC,SAAS,GAAGR,gBAAgB,CAACV,MAAM,CAAC;;MAE1C;MACA;MACA,IAAIjJ,OAAO,KAAKsH,SAAS,IAAI,CAACuC,eAAe,CAACnO,GAAG,CAACyO,SAAS,CAAC,EAAE;QAC5D,MAAMC,QAAQ,GAAGvN,yBAAyB,CAAC,IAAI,CAACqD,MAAM,CAAC,CAACnE,GAAG,CAACiE,OAAO,CAAC;;QAEpE;QACA,IAAI,CAACoK,QAAQ,EAAE;UACb;QACF;;QAEA;QACAA,QAAQ,CAACC,YAAY,CAACD,QAAQ,CAACE,aAAa,CAACpC,GAAG,EAAEO,GAAG,CAAC,EAAE2B,QAAQ,CAACG,WAAW,CAACrC,GAAG,EAAEO,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;MACnG;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+B,oBAAoBA,CAACtC,GAAG,EAAE7C,MAAM,EAAEoF,QAAQ,EAAE;IAC1C,MAAMtB,OAAO,GAAG;MACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACN,GAAG,CAAC;MACtDO,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACnD,MAAM,CAAC;MAC5D8C,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACD,IAAI,CAAC,IAAI,CAACE,MAAM,CAACwK,6BAA6B,CAACvB,OAAO,CAAC,EAAE;MACvD7M,IAAI,CAAC,oCAAoCqO,IAAI,CAACC,SAAS,CAACzB,OAAO,CAAC,EAAE,CAAC;MACnE;IACF;IACA,MAAM0B,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACrC,GAAG,EAAE7C,MAAM,CAAC;IAClD,IAAIrI,MAAM,CAACyN,QAAQ,EAAEI,QAAQ,CAACC,IAAI,CAAC,EAAE;MACnC,IAAI7N,WAAW,CAACwN,QAAQ,EAAEI,QAAQ,CAACE,UAAU,CAAC,EAAE;QAC9C;QACAN,QAAQ,GAAGvN,iBAAiB,CAACuN,QAAQ,EAAEI,QAAQ,CAACE,UAAU,CAAC;MAC7D,CAAC,MAAM,IAAI1N,SAAS,CAACoN,QAAQ,CAAC,KAAK,KAAK,EAAE;QACxC;QACAA,QAAQ,GAAG,IAAIA,QAAQ,EAAE;MAC3B;IACF;IACA,OAAO,IAAI,CAACvK,MAAM,CAAC8K,eAAe,CAAC7B,OAAO,EAAEsB,QAAQ,CAAC;EACvD;AACF;AACA,SAASvI,iBAAiBA,CAACtH,KAAK,EAAEqQ,SAAS,EAAEC,IAAI,EAAE;EACjD,MAAMC,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACF,IAAI,CAAC;EAC7C,IAAI,IAAI,CAACxC,iBAAiB,CAACuC,SAAS,EAAEE,YAAY,CAAC,EAAE;IACnD,MAAMhC,OAAO,GAAG;MACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;MAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;MAClEhD,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACD,MAAM6K,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACU,SAAS,EAAEE,YAAY,CAAC;IAC9D,IAAIE,SAAS,GAAG,IAAI,CAACnL,MAAM,CAACoL,YAAY,CAACnC,OAAO,CAAC,CAAC,CAAC;;IAEnD,IAAI0B,QAAQ,CAACC,IAAI,KAAK,MAAM,IAAIvO,SAAS,CAAC8O,SAAS,CAAC,EAAE;MACpDA,SAAS,GAAGlO,oBAAoB,CAACkO,SAAS,EAAER,QAAQ,CAACE,UAAU,CAAC;IAClE;;IAEA;IACA,OAAO,OAAOM,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,GAAGA,SAAS,CAACzQ,KAAK,GAAGyQ,SAAS;EAC1F;EACA,OAAOzQ,KAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyL,iBAAiBA,CAACkF,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAE;EAC7D,MAAM;IACJvD,GAAG,EAAEwD,iBAAiB;IACtBjD,GAAG,EAAEkD;EACP,CAAC,GAAGH,WAAW,CAACI,iBAAiB,CAAC,CAAC;EACnC,MAAM;IACJ1D,GAAG,EAAE2D,kBAAkB;IACvBpD,GAAG,EAAEqD;EACP,CAAC,GAAGN,WAAW,CAACO,kBAAkB,CAAC,CAAC;EACpC,MAAM;IACJ7D,GAAG,EAAE8D,iBAAiB;IACtBvD,GAAG,EAAEwD;EACP,CAAC,GAAGR,WAAW,CAACG,iBAAiB,CAAC,CAAC;EACnC,MAAM;IACJ1D,GAAG,EAAEgE,kBAAkB;IACvBzD,GAAG,EAAE0D;EACP,CAAC,GAAGV,WAAW,CAACM,kBAAkB,CAAC,CAAC;EACpC,MAAMK,iBAAiB,GAAG;IACxBC,KAAK,EAAE;MACLnE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACkD,iBAAiB,CAAC;MACpEjD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACmD,oBAAoB,CAAC;MAC1ExD,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACDsM,GAAG,EAAE;MACHpE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACqD,kBAAkB,CAAC;MACrEpD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACsD,qBAAqB,CAAC;MAC3E3D,KAAK,EAAE,IAAI,CAACnI;IACd;EACF,CAAC;EACD,MAAMuM,iBAAiB,GAAG;IACxBF,KAAK,EAAE;MACLnE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACwD,iBAAiB,CAAC;MACpEvD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACyD,oBAAoB,CAAC;MAC1E9D,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACDsM,GAAG,EAAE;MACHpE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAAC0D,kBAAkB,CAAC;MACrEzD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2D,qBAAqB,CAAC;MAC3EhE,KAAK,EAAE,IAAI,CAACnI;IACd;EACF,CAAC;;EAED;EACA;EACA,IAAI,IAAI,CAACE,MAAM,CAACwK,6BAA6B,CAAC6B,iBAAiB,CAAC,KAAK,KAAK,EAAE;IAC1E,OAAO,KAAK;EACd;EACA,MAAMC,aAAa,GAAG,IAAI,CAACtM,MAAM,CAACuM,gBAAgB,CAACL,iBAAiB,EAAEG,iBAAiB,CAAC;EACxF,MAAM;IACJrE,GAAG,EAAEwE,cAAc;IACnBjE,GAAG,EAAEkE;EACP,CAAC,GAAGP,iBAAiB,CAACC,KAAK;EAC3B,MAAM;IACJnE,GAAG,EAAE0E,YAAY;IACjBnE,GAAG,EAAEoE;EACP,CAAC,GAAGT,iBAAiB,CAACE,GAAG;EACzB,MAAMQ,mBAAmB,GAAGF,YAAY,GAAGF,cAAc,GAAG,CAAC;EAC7D,MAAMK,sBAAsB,GAAGF,eAAe,GAAGF,iBAAiB,GAAG,CAAC;EACtE,KAAK,IAAIK,iBAAiB,GAAG,CAAC,EAAEA,iBAAiB,GAAGR,aAAa,CAACtQ,MAAM,EAAE8Q,iBAAiB,IAAI,CAAC,EAAE;IAChG,KAAK,IAAIC,oBAAoB,GAAG,CAAC,EAAEA,oBAAoB,GAAGT,aAAa,CAACQ,iBAAiB,CAAC,CAAC9Q,MAAM,EAAE+Q,oBAAoB,IAAI,CAAC,EAAE;MAC5H,MAAMC,cAAc,GAAGV,aAAa,CAACQ,iBAAiB,CAAC,CAACC,oBAAoB,CAAC;MAC7E,MAAME,SAAS,GAAGT,cAAc,GAAGM,iBAAiB,GAAGF,mBAAmB;MAC1E,MAAMM,YAAY,GAAGT,iBAAiB,GAAGM,oBAAoB,GAAGF,sBAAsB;MACtF,MAAMM,cAAc,GAAG,IAAI,CAAChN,GAAG,CAACkK,WAAW,CAAC4C,SAAS,EAAEC,YAAY,CAAC;MACpE,IAAIpQ,MAAM,CAACkQ,cAAc,EAAEG,cAAc,CAACvC,IAAI,CAAC,EAAE;QAC/C,IAAIoC,cAAc,CAACI,UAAU,CAAC,IAAI,CAAC,EAAE;UACnC;UACAd,aAAa,CAACQ,iBAAiB,CAAC,CAACC,oBAAoB,CAAC,GAAGC,cAAc,CAACK,KAAK,CAAC,CAAC,CAAC;QAClF,CAAC,MAAM,IAAI,IAAI,CAAC7E,iBAAiB,CAACyE,SAAS,EAAEC,YAAY,EAAE,IAAI,CAACpN,OAAO,CAAC,KAAK,KAAK,EAAE;UAClF;UACAwM,aAAa,CAACQ,iBAAiB,CAAC,CAACC,oBAAoB,CAAC,GAAG7P,kBAAkB,CAAC8P,cAAc,EAAEG,cAAc,CAACtC,UAAU,CAAC;QACxH;MACF;IACF;EACF;EACA,OAAOyB,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStL,iBAAiBA,CAACsM,UAAU,EAAEC,WAAW,EAAE;EAClD,IAAIvP,MAAM,GAAGjC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqL,SAAS,GAAGrL,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EACnF,IAAIiC,MAAM,CAACwP,QAAQ,CAACjQ,gBAAgB,CAACG,UAAU,CAAC,CAAC,EAAE;IACjD;EACF;;EAEA;EACA;EACAjC,qBAAqB,CAAC0C,+BAA+B,EAAE,IAAI,EAAE5B,WAAW,CAAC,IAAI,CAAC4D,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC+G,IAAI,CAAC,CAAC;AACxG;AACA;AACA;AACA;AACA,SAAS1B,qBAAqBA,CAAA,EAAG;EAC/B,MAAMgI,eAAe,GAAG,IAAI,CAACtN,GAAG,CAACS,kBAAkB,CAAC,CAAC;EACrD,IAAI8M,YAAY,GAAG,KAAK;EACxBD,eAAe,CAACrH,OAAO,CAAC,CAACuH,OAAO,EAAEC,QAAQ,KAAK;IAC7CD,OAAO,CAACvH,OAAO,CAAC,CAAC+E,SAAS,EAAE0C,WAAW,KAAK;MAC1C,MAAMlD,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACuD,QAAQ,EAAEC,WAAW,CAAC;MAC5D,MAAMhD,UAAU,GAAGF,QAAQ,CAACE,UAAU;MACtC,IAAI/N,MAAM,CAACqO,SAAS,EAAER,QAAQ,CAACC,IAAI,CAAC,EAAE;QACpC8C,YAAY,GAAG,IAAI;QACnB,IAAI3Q,WAAW,CAACoO,SAAS,EAAEN,UAAU,CAAC,EAAE;UACtC;UACA4C,eAAe,CAACG,QAAQ,CAAC,CAACC,WAAW,CAAC,GAAG7Q,iBAAiB,CAACmO,SAAS,EAAEN,UAAU,CAAC;QACnF,CAAC,MAAM,IAAI,IAAI,CAACrC,iBAAiB,CAACoF,QAAQ,EAAEC,WAAW,CAAC,KAAK,KAAK,EAAE;UAClE;UACAJ,eAAe,CAACG,QAAQ,CAAC,CAACC,WAAW,CAAC,GAAG,IAAI1C,SAAS,EAAE;QAC1D;MACF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAIuC,YAAY,KAAK,IAAI,EAAE;IACzBjS,qBAAqB,CAACwC,yBAAyB,EAAE,IAAI,EAAE,IAAI,CAAC;IAC5D,IAAI,CAAC+B,MAAM,CAAC0H,eAAe,CAAC,IAAI,CAAC5H,OAAO,EAAE2N,eAAe,CAAC;IAC1DhS,qBAAqB,CAACwC,yBAAyB,EAAE,IAAI,EAAE,KAAK,CAAC;EAC/D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkD,gBAAgBA,CAACmM,UAAU,EAAEC,WAAW,EAAE;EACjD,IAAIvP,MAAM,GAAGjC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqL,SAAS,GAAGrL,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EACnF,IAAIiC,MAAM,CAACwP,QAAQ,CAACjQ,gBAAgB,CAACG,UAAU,CAAC,CAAC,EAAE;IACjD;EACF;EACA,IAAI,CAACqC,SAAS,GAAGtD,UAAU,CAAC,IAAI,CAACuD,MAAM,EAAE,IAAI,CAACG,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAACqC,SAAS,CAAC;EACtF,IAAI,CAACnE,qBAAqB,CAACuC,+BAA+B,EAAE,IAAI,CAAC,EAAE;IACjE,MAAMsP,eAAe,GAAG,IAAI,CAACtN,GAAG,CAACS,kBAAkB,CAAC,CAAC;IACrD,IAAI,IAAI,CAACZ,MAAM,CAAC8N,iCAAiC,CAAC,IAAI,CAAChO,OAAO,EAAE2N,eAAe,CAAC,EAAE;MAChFhS,qBAAqB,CAACwC,yBAAyB,EAAE,IAAI,EAAE,IAAI,CAAC;MAC5D,MAAM0K,cAAc,GAAG,IAAI,CAAC3I,MAAM,CAAC0H,eAAe,CAAC,IAAI,CAAC5H,OAAO,EAAE2N,eAAe,CAAC;MACjF,IAAI,CAACxJ,WAAW,CAAC8J,iBAAiB,CAAC,IAAI,CAAC/N,MAAM,EAAE,IAAI,CAACF,OAAO,CAAC;MAC7D,IAAI,CAAC4I,qBAAqB,CAACC,cAAc,CAAC;MAC1ClN,qBAAqB,CAACwC,yBAAyB,EAAE,IAAI,EAAE,KAAK,CAAC;IAC/D;EACF,CAAC,MAAM;IACL,IAAI,CAACiJ,WAAW,CAAC,IAAI,CAACnH,SAAS,CAAC;EAClC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2B,aAAaA,CAACwG,WAAW,EAAE+C,YAAY,EAAE+C,WAAW,EAAEC,MAAM,EAAE;EACrE,IAAIA,MAAM,KAAK,KAAK,IAAIrS,qBAAqB,CAACqC,yBAAyB,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC8B,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,EAAE;IACxJ;EACF;EACA,MAAMgL,SAAS,GAAG,IAAI,CAAC5K,GAAG,CAAC+N,WAAW,CAAChG,WAAW,CAAC;EACnD,IAAI6C,SAAS,KAAK,IAAI,IAAIE,YAAY,KAAK,IAAI,EAAE;IAC/C;EACF;;EAEA;EACA,MAAMzC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACuC,SAAS,EAAEE,YAAY,CAAC;EACzE,IAAI,CAACzC,iBAAiB,EAAE;IACtB,MAAM2F,QAAQ,GAAG,IAAI,CAACpG,WAAW,CAACgD,SAAS,EAAEE,YAAY,CAAC;IAC1D,IAAIkD,QAAQ,KAAK,OAAO,EAAE;MACxB,IAAIvR,0BAA0B,CAACoR,WAAW,CAACtT,KAAK,CAAC,EAAE;QACjDsT,WAAW,CAACtT,KAAK,GAAGmC,yBAAyB,CAACmR,WAAW,CAACtT,KAAK,CAAC;MAClE;MACA;IACF;EACF;EACA,MAAMuO,OAAO,GAAG;IACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;IAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;IAClEhD,KAAK,EAAE,IAAI,CAACnI;EACd,CAAC;EACD,IAAIqL,SAAS,GAAG,IAAI,CAACnL,MAAM,CAACoL,YAAY,CAACnC,OAAO,CAAC,CAAC,CAAC;;EAEnD;EACA;EACA;EACA;EACA,IAAI0B,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACiO,YAAY,CAAC,CAAC,CAACC,IAAI,CAACC,cAAc,IAAIA,cAAc,CAACvD,SAAS,KAAKA,SAAS,IAAIuD,cAAc,CAACC,SAAS,KAAKtD,YAAY,CAAC;EAClJ,IAAIN,QAAQ,KAAKvD,SAAS,EAAE;IAC1BuD,QAAQ,GAAG,CAAC,CAAC;EACf;EACA,IAAIA,QAAQ,CAACC,IAAI,KAAK,MAAM,IAAIvO,SAAS,CAAC8O,SAAS,CAAC,EAAE;IACpDA,SAAS,GAAGlO,oBAAoB,CAACkO,SAAS,EAAER,QAAQ,CAACE,UAAU,CAAC;EAClE;;EAEA;EACA,MAAMnQ,KAAK,GAAG,OAAOyQ,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,GAAGA,SAAS,CAACzQ,KAAK,GAAGyQ,SAAS;EAC/F6C,WAAW,CAACtT,KAAK,GAAGA,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmH,mBAAmBA,CAACmG,GAAG,EAAEwG,YAAY,EAAER,WAAW,EAAEC,MAAM,EAAE;EACnE,IAAIA,MAAM,KAAK,KAAK,IAAIrS,qBAAqB,CAACqC,yBAAyB,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC8B,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,EAAE;IACxJ;EACF;EACA,MAAMgL,SAAS,GAAG,IAAI,CAAC5K,GAAG,CAAC+N,WAAW,CAAClG,GAAG,CAAC;EAC3C,MAAMiD,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACsD,YAAY,CAAC;EACrD,IAAIzD,SAAS,KAAK,IAAI,IAAIE,YAAY,KAAK,IAAI,EAAE;IAC/C;EACF;;EAEA;EACA,MAAMzC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACuC,SAAS,EAAEE,YAAY,CAAC;EACzE,IAAI,CAACzC,iBAAiB,EAAE;IACtB,MAAM2F,QAAQ,GAAG,IAAI,CAACpG,WAAW,CAACgD,SAAS,EAAEE,YAAY,CAAC;IAC1D,IAAIkD,QAAQ,KAAK,OAAO,EAAE;MACxB;IACF;EACF;EACA,MAAMM,UAAU,GAAG,IAAI,CAACzO,MAAM,CAAC0O,kBAAkB,CAAC,IAAI,CAAC1O,MAAM,CAACC,UAAU,CAAC,IAAI,CAACF,SAAS,CAAC,CAAC;;EAEzF;EACA;EACA;EACA;EACA,IAAI0O,UAAU,CAACE,KAAK,KAAK,CAAC,IAAIF,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE;IACrD;EACF;EACA,MAAM3F,OAAO,GAAG;IACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;IAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;IAClEhD,KAAK,EAAE,IAAI,CAACnI;EACd,CAAC;EACDkO,WAAW,CAACtT,KAAK,GAAG,IAAI,CAACsF,MAAM,CAAC6O,iBAAiB,CAAC5F,OAAO,CAAC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3G,qBAAqBA,CAACwM,OAAO,EAAE9Q,MAAM,EAAE;EAC9C,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAM+Q,kBAAkB,GAAG,EAAE;EAC7B,MAAMvF,YAAY,GAAG,EAAE;EACvB,MAAMb,cAAc,GAAG,IAAI,CAAC3I,MAAM,CAACgP,KAAK,CAAC,MAAM;IAC7CF,OAAO,CAAC1I,OAAO,CAAC6I,KAAK,IAAI;MACvB,IAAI,CAAClE,SAAS,EAAEC,IAAI,GAAGT,QAAQ,CAAC,GAAG0E,KAAK;MACxC,MAAMhE,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACF,IAAI,CAAC;MAC7C,MAAM9C,WAAW,GAAG,IAAI,CAAC/H,GAAG,CAACgI,aAAa,CAAC4C,SAAS,CAAC;MACrD,MAAM3C,cAAc,GAAG,IAAI,CAACjI,GAAG,CAACkI,gBAAgB,CAAC4C,YAAY,CAAC;MAC9D,MAAMhC,OAAO,GAAG;QACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;QAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;QAClEhD,KAAK,EAAE,IAAI,CAACnI;MACd,CAAC;MACD,IAAIoI,WAAW,KAAK,IAAI,IAAIE,cAAc,KAAK,IAAI,EAAE;QACnD,IAAI,CAACkC,oBAAoB,CAACS,SAAS,EAAEE,YAAY,EAAEV,QAAQ,CAAC;MAC9D,CAAC,MAAM;QACLwE,kBAAkB,CAACG,IAAI,CAAC,CAACnE,SAAS,EAAEE,YAAY,EAAEV,QAAQ,CAAC,CAAC;MAC9D;MACAf,YAAY,CAAC0F,IAAI,CAAC;QAChBjG;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAI8F,kBAAkB,CAAC/S,MAAM,EAAE;IAC7B;IACA;IACA,IAAI,CAACmE,GAAG,CAACkE,WAAW,CAAC,aAAa,EAAE,MAAM;MACxC,MAAM8K,yBAAyB,GAAG,IAAI,CAACnP,MAAM,CAACgP,KAAK,CAAC,MAAM;QACxDD,kBAAkB,CAAC3I,OAAO,CAACgJ,KAAK,IAAI;UAClC,IAAI,CAACpH,GAAG,EAAE7C,MAAM,EAAEoF,QAAQ,CAAC,GAAG6E,KAAK;UACnC,IAAI,CAAC9E,oBAAoB,CAACtC,GAAG,EAAE7C,MAAM,EAAEoF,QAAQ,CAAC;QAClD,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,IAAI,CAAC7B,qBAAqB,CAACyG,yBAAyB,EAAE,IAAI,CAAC;IAC7D,CAAC,CAAC;EACJ;EACA,IAAI,CAACzG,qBAAqB,CAACC,cAAc,CAAC;EAC1C,IAAI,CAACY,sBAAsB,CAACZ,cAAc,EAAEa,YAAY,CAAC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrH,2BAA2BA,CAAC2M,OAAO,EAAE9Q,MAAM,EAAE;EACpD,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAM2K,cAAc,GAAG,EAAE;EACzB,MAAMa,YAAY,GAAG,EAAE;EACvBsF,OAAO,CAAC1I,OAAO,CAACiJ,KAAK,IAAI;IACvB,IAAI,CAACtE,SAAS,EAAEC,IAAI,GAAGT,QAAQ,CAAC,GAAG8E,KAAK;IACxC,MAAMpE,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACF,IAAI,CAAC;IAC7C,IAAI,CAAC3O,SAAS,CAAC4O,YAAY,CAAC,EAAE;MAC5B;IACF;IACA,MAAMhC,OAAO,GAAG;MACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;MAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;MAClEhD,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACD,IAAI,CAAC,IAAI,CAACE,MAAM,CAACwK,6BAA6B,CAACvB,OAAO,CAAC,EAAE;MACvD7M,IAAI,CAAC,2CAA2CqO,IAAI,CAACC,SAAS,CAACzB,OAAO,CAAC,EAAE,CAAC;MAC1E;IACF;IACAO,YAAY,CAAC0F,IAAI,CAAC;MAChBjG;IACF,CAAC,CAAC;IACFN,cAAc,CAACuG,IAAI,CAAC,GAAG,IAAI,CAAClP,MAAM,CAAC8K,eAAe,CAAC7B,OAAO,EAAEsB,QAAQ,CAAC,CAAC;EACxE,CAAC,CAAC;EACF,IAAI,CAAC7B,qBAAqB,CAACC,cAAc,CAAC;EAC1C,IAAI,CAACY,sBAAsB,CAACZ,cAAc,EAAEa,YAAY,CAAC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7G,kBAAkBA,CAACoI,SAAS,EAAEuE,MAAM,EAAE;EAC7C,IAAIC,UAAU,GAAG,IAAI,CAACjL,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;EACxE,IAAIA,SAAS,IAAI,IAAI,CAAC5K,GAAG,CAAC4J,SAAS,CAAC,CAAC,EAAE;IACrCwF,UAAU,GAAGxE,SAAS,CAAC,CAAC;EAC1B;EACA,IAAI,IAAI,CAACjL,OAAO,KAAK,IAAI,IAAI,CAAC,IAAI,CAACE,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,IAAI,CAAC,IAAI,CAACC,MAAM,CAACwP,qBAAqB,CAAC,IAAI,CAAC1P,OAAO,EAAE,CAACyP,UAAU,EAAED,MAAM,CAAC,CAAC,EAAE;IAClJ,OAAO,KAAK;EACd;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASxM,kBAAkBA,CAACmI,YAAY,EAAEqE,MAAM,EAAE;EAChD,IAAIG,aAAa,GAAG,IAAI,CAACjL,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;EACjF,IAAIA,YAAY,IAAI,IAAI,CAAC9K,GAAG,CAAC6J,SAAS,CAAC,CAAC,EAAE;IACxCyF,aAAa,GAAGxE,YAAY,CAAC,CAAC;EAChC;EACA,IAAI,IAAI,CAACnL,OAAO,KAAK,IAAI,IAAI,CAAC,IAAI,CAACE,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,IAAI,CAAC,IAAI,CAACC,MAAM,CAAC0P,wBAAwB,CAAC,IAAI,CAAC5P,OAAO,EAAE,CAAC2P,aAAa,EAAEH,MAAM,CAAC,CAAC,EAAE;IACxJ,OAAO,KAAK;EACd;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/L,kBAAkBA,CAACyE,GAAG,EAAEsH,MAAM,EAAEK,YAAY,EAAE;EACrD,MAAMC,MAAM,GAAG,IAAI,CAACtL,aAAa,CAACuL,mBAAmB,CAACF,YAAY,CAAC;EACnE,MAAMG,QAAQ,GAAGF,MAAM,CAACG,KAAK,CAACC,KAAK,IAAI;IACrC,OAAO,IAAI,CAAChQ,MAAM,CAACiQ,wBAAwB,CAAC,IAAI,CAACnQ,OAAO,EAAE,CAACkQ,KAAK,EAAE,CAAC,CAAC,CAAC;EACvE,CAAC,CAAC;EACF,OAAOF,QAAQ,KAAK,KAAK,GAAG,KAAK,GAAG1I,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1D,kBAAkBA,CAAC6E,GAAG,EAAE+G,MAAM,EAAEY,eAAe,EAAE;EACxD,MAAMC,SAAS,GAAG,IAAI,CAAC3L,gBAAgB,CAACqL,mBAAmB,CAACK,eAAe,CAAC;EAC5E,MAAMJ,QAAQ,GAAGK,SAAS,CAACJ,KAAK,CAACK,QAAQ,IAAI;IAC3C,OAAO,IAAI,CAACpQ,MAAM,CAACqQ,2BAA2B,CAAC,IAAI,CAACvQ,OAAO,EAAE,CAACsQ,QAAQ,EAAE,CAAC,CAAC,CAAC;EAC7E,CAAC,CAAC;EACF,OAAON,QAAQ,KAAK,KAAK,GAAG,KAAK,GAAG1I,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnE,iBAAiBA,CAAC8H,SAAS,EAAEuE,MAAM,EAAEtR,MAAM,EAAE;EACpD,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAM8Q,OAAO,GAAG,IAAI,CAAC9O,MAAM,CAACsQ,OAAO,CAAC,IAAI,CAACxQ,OAAO,EAAE,CAAC,IAAI,CAACwE,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC,EAAEuE,MAAM,CAAC,CAAC;EACpH,IAAI,CAAC5G,qBAAqB,CAACoG,OAAO,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1L,iBAAiBA,CAAC6H,YAAY,EAAEqE,MAAM,EAAEtR,MAAM,EAAE;EACvD,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAM8Q,OAAO,GAAG,IAAI,CAAC9O,MAAM,CAACuQ,UAAU,CAAC,IAAI,CAACzQ,OAAO,EAAE,CAAC,IAAI,CAAC0E,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC,EAAEqE,MAAM,CAAC,CAAC;EAC7H,IAAI,CAAC5G,qBAAqB,CAACoG,OAAO,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjL,iBAAiBA,CAACmE,GAAG,EAAEsH,MAAM,EAAEK,YAAY,EAAE3R,MAAM,EAAE;EAC5D,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAMwS,gBAAgB,GAAG,IAAI,CAAClM,aAAa,CAACmM,mBAAmB,CAAC,CAAC,CAACC,IAAI,CAAC,CAACzW,CAAC,EAAE0W,CAAC,KAAKA,CAAC,GAAG1W,CAAC,CAAC,CAAC,CAAC;;EAEzF,MAAM6U,OAAO,GAAG,IAAI,CAAC9O,MAAM,CAACgP,KAAK,CAAC,MAAM;IACtCwB,gBAAgB,CAACpK,OAAO,CAAC4J,KAAK,IAAI;MAChC,IAAI,CAAChQ,MAAM,CAAC4Q,UAAU,CAAC,IAAI,CAAC9Q,OAAO,EAAE,CAACkQ,KAAK,EAAE,CAAC,CAAC,CAAC;IAClD,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAI,CAACtH,qBAAqB,CAACoG,OAAO,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9K,iBAAiBA,CAACuE,GAAG,EAAE+G,MAAM,EAAEY,eAAe,EAAElS,MAAM,EAAE;EAC/D,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAM6S,mBAAmB,GAAG,IAAI,CAACrM,gBAAgB,CAACiM,mBAAmB,CAAC,CAAC,CAACC,IAAI,CAAC,CAACzW,CAAC,EAAE0W,CAAC,KAAKA,CAAC,GAAG1W,CAAC,CAAC,CAAC,CAAC;;EAE/F,MAAM6U,OAAO,GAAG,IAAI,CAAC9O,MAAM,CAACgP,KAAK,CAAC,MAAM;IACtC6B,mBAAmB,CAACzK,OAAO,CAACgK,QAAQ,IAAI;MACtC,IAAI,CAACpQ,MAAM,CAAC8Q,aAAa,CAAC,IAAI,CAAChR,OAAO,EAAE,CAACsQ,QAAQ,EAAE,CAAC,CAAC,CAAC;IACxD,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAI,CAAC1H,qBAAqB,CAACoG,OAAO,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9I,mBAAmBA,CAAC+K,MAAM,EAAEC,OAAO,EAAEC,oBAAoB,EAAE;EAClE,IAAIC,mBAAmB;EACvBzV,qBAAqB,CAACwC,yBAAyB,EAAE,IAAI,EAAE,IAAI,CAAC;EAC5D,MAAMkT,QAAQ,GAAG,IAAI,CAAChR,GAAG,CAACS,kBAAkB,CAACqQ,oBAAoB,EAAE,CAAC,EAAEA,oBAAoB,IAAI,CAAC,CAACC,mBAAmB,GAAGF,OAAO,CAACI,UAAU,MAAM,IAAI,IAAIF,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAAClV,MAAM,KAAK,CAAC,CAAC,EAAE,IAAI,CAACmE,GAAG,CAACkR,eAAe,CAAC,CAAC,CAAC;EAC9P5V,qBAAqB,CAACwC,yBAAyB,EAAE,IAAI,EAAE,KAAK,CAAC;EAC7DkT,QAAQ,CAAC/K,OAAO,CAAC,CAAC4B,GAAG,EAAEsJ,gBAAgB,KAAK;IAC1CtJ,GAAG,CAAC5B,OAAO,CAAC,CAAC1L,KAAK,EAAE6W,QAAQ,KAAK;MAC/B,IAAI,CAACvR,MAAM,CAAC8K,eAAe,CAAC;QAC1BvC,GAAG,EAAEgJ,QAAQ;QACbvJ,GAAG,EAAEiJ,oBAAoB,GAAGK,gBAAgB;QAC5CrJ,KAAK,EAAE,IAAI,CAACnI;MACd,CAAC,EAAE,CAAC,CAACpF,KAAK,CAAC,CAAC,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoE,sBAAsBA,CAACgQ,OAAO,EAAE;EACvC,IAAI,CAAC3O,GAAG,CAACqR,QAAQ,CAAC,2BAA2B,EAAE1C,OAAO,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7P,8BAA8BA,CAACwS,mBAAmB,EAAE3C,OAAO,EAAE;EACpE,IAAI,CAAC3O,GAAG,CAACqR,QAAQ,CAAC,2BAA2B,EAAEC,mBAAmB,EAAE3C,OAAO,CAAC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1P,gCAAgCA,CAACqS,mBAAmB,EAAE3C,OAAO,EAAE;EACtE,IAAI,CAAC3O,GAAG,CAACqR,QAAQ,CAAC,6BAA6B,EAAEC,mBAAmB,EAAE3C,OAAO,CAAC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvP,mBAAmBA,CAACmS,qBAAqB,EAAE;EAClD,IAAI,CAACvR,GAAG,CAACqR,QAAQ,CAAC,iBAAiB,EAAEE,qBAAqB,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShS,qBAAqBA,CAACiS,cAAc,EAAEC,cAAc,EAAE;EAC7D,IAAI,CAAC7R,SAAS,GAAG6R,cAAc;EAC/B,IAAI,CAACzR,GAAG,CAACqR,QAAQ,CAAC,mBAAmB,EAAEG,cAAc,EAAEC,cAAc,CAAC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/R,qBAAqBA,CAACgS,uBAAuB,EAAE/C,OAAO,EAAE;EAC/D,IAAI,CAAC3O,GAAG,CAACqR,QAAQ,CAAC,mBAAmB,EAAEK,uBAAuB,EAAE/C,OAAO,CAAC;AAC1E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}