{"ast":null,"code":"import { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { FullyVisibleColumnsCalculationType, FullyVisibleRowsCalculationType, PartiallyVisibleColumnsCalculationType, PartiallyVisibleRowsCalculationType, RenderedAllColumnsCalculationType, RenderedAllRowsCalculationType, RenderedColumnsCalculationType, RenderedRowsCalculationType, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\n * @class Viewport\n */\nclass Viewport {\n  /**\n   * @param {ViewportDao} dataAccessObject The Walkontable instance.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The instance event manager.\n   * @param {Table} wtTable The table.\n   */\n  constructor(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {\n    this.dataAccessObject = dataAccessObject;\n    // legacy support\n    this.wot = dataAccessObject.wot;\n    this.instance = this.wot;\n    this.domBindings = domBindings;\n    this.wtSettings = wtSettings;\n    this.wtTable = wtTable;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.rowsCalculatorTypes = new Map([['rendered', () => this.wtSettings.getSetting('renderAllRows') ? new RenderedAllRowsCalculationType() : new RenderedRowsCalculationType()], ['fullyVisible', () => new FullyVisibleRowsCalculationType()], ['partiallyVisible', () => new PartiallyVisibleRowsCalculationType()]]);\n    this.columnsCalculatorTypes = new Map([['rendered', () => this.wtSettings.getSetting('renderAllColumns') ? new RenderedAllColumnsCalculationType() : new RenderedColumnsCalculationType()], ['fullyVisible', () => new FullyVisibleColumnsCalculationType()], ['partiallyVisible', () => new PartiallyVisibleColumnsCalculationType()]]);\n    this.eventManager = eventManager;\n    this.eventManager.addEventListener(this.domBindings.rootWindow, 'resize', () => {\n      this.clientHeight = this.getWorkspaceHeight();\n    });\n  }\n\n  /**\n   * @returns {number}\n   */\n  getWorkspaceHeight() {\n    const currentDocument = this.domBindings.rootDocument;\n    const trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;\n    let height = 0;\n    if (trimmingContainer === this.domBindings.rootWindow) {\n      height = currentDocument.documentElement.clientHeight;\n    } else {\n      const elemHeight = outerHeight(trimmingContainer);\n\n      // returns height without DIV scrollbar\n      height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n    }\n    return height;\n  }\n  getWorkspaceWidth() {\n    const {\n      wtSettings\n    } = this;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;\n    const docOffsetWidth = rootDocument.documentElement.offsetWidth;\n    const totalColumns = wtSettings.getSetting('totalColumns');\n    const preventOverflow = wtSettings.getSetting('preventOverflow');\n    const isRtl = wtSettings.getSetting('rtlMode');\n    const tableRect = this.wtTable.TABLE.getBoundingClientRect();\n    const inlineStart = isRtl ? tableRect.right - docOffsetWidth : tableRect.left;\n    const tableOffset = docOffsetWidth - inlineStart;\n    let width;\n    let overflow;\n    if (preventOverflow) {\n      return outerWidth(this.wtTable.wtRootElement);\n    }\n    if (wtSettings.getSetting('freezeOverlays')) {\n      width = Math.min(tableOffset, docOffsetWidth);\n    } else {\n      width = Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);\n    }\n    if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n      // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n      // otherwise continue below, which will allow stretching\n      // this is used in `scroll_window.html`\n      // TODO test me\n      return rootDocument.documentElement.clientWidth;\n    }\n    if (trimmingContainer !== rootWindow) {\n      overflow = getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, 'overflow', rootWindow);\n      if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n        // this is used in `scroll.html`\n        // TODO test me\n        return Math.max(width, trimmingContainer.clientWidth);\n      }\n    }\n    const stretchSetting = wtSettings.getSetting('stretchH');\n    if (stretchSetting === 'none' || !stretchSetting) {\n      // if no stretching is used, return the maximum used workspace width\n      return Math.max(width, outerWidth(this.wtTable.TABLE));\n    }\n\n    // if stretching is used, return the actual container width, so the columns can fit inside it\n    return width;\n  }\n\n  /**\n   * Checks if viewport has vertical scroll.\n   *\n   * @returns {boolean}\n   */\n  hasVerticalScroll() {\n    return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();\n  }\n\n  /**\n   * Checks if viewport has horizontal scroll.\n   *\n   * @returns {boolean}\n   */\n  hasHorizontalScroll() {\n    return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();\n  }\n\n  /**\n   * @param {number} from The visual column index from the width sum is start calculated.\n   * @param {number} length The length of the column to traverse.\n   * @returns {number}\n   */\n  sumColumnWidths(from, length) {\n    let sum = 0;\n    let column = from;\n    while (column < length) {\n      sum += this.wtTable.getColumnWidth(column);\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getContainerFillWidth() {\n    if (this.containerWidth) {\n      return this.containerWidth;\n    }\n    const mainContainer = this.wtTable.holder;\n    const dummyElement = this.domBindings.rootDocument.createElement('div');\n    dummyElement.style.width = '100%';\n    dummyElement.style.height = '1px';\n    mainContainer.appendChild(dummyElement);\n    const fillWidth = dummyElement.offsetWidth;\n    this.containerWidth = fillWidth;\n    mainContainer.removeChild(dummyElement);\n    return fillWidth;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getWorkspaceOffset() {\n    return offset(this.wtTable.TABLE);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getColumnHeaderHeight() {\n    const columnHeaders = this.wtSettings.getSetting('columnHeaders');\n    if (!columnHeaders.length) {\n      this.columnHeaderHeight = 0;\n    } else if (isNaN(this.columnHeaderHeight)) {\n      this.columnHeaderHeight = outerHeight(this.wtTable.THEAD);\n    }\n    return this.columnHeaderHeight;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getViewportHeight() {\n    let containerHeight = this.getWorkspaceHeight();\n    if (containerHeight === Infinity) {\n      return containerHeight;\n    }\n    const columnHeaderHeight = this.getColumnHeaderHeight();\n    if (columnHeaderHeight > 0) {\n      containerHeight -= columnHeaderHeight;\n    }\n    return containerHeight;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getRowHeaderWidth() {\n    const rowHeadersWidthSetting = this.wtSettings.getSetting('rowHeaderWidth');\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    if (rowHeadersWidthSetting) {\n      this.rowHeaderWidth = 0;\n      for (let i = 0, len = rowHeaders.length; i < len; i++) {\n        this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n      }\n    }\n    if (isNaN(this.rowHeaderWidth)) {\n      if (rowHeaders.length) {\n        let TH = this.wtTable.TABLE.querySelector('TH');\n        this.rowHeaderWidth = 0;\n        for (let i = 0, len = rowHeaders.length; i < len; i++) {\n          if (TH) {\n            this.rowHeaderWidth += outerWidth(TH);\n            TH = TH.nextSibling;\n          } else {\n            // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n            // TODO: proper fix\n            this.rowHeaderWidth += 50;\n          }\n        }\n      } else {\n        this.rowHeaderWidth = 0;\n      }\n    }\n    this.rowHeaderWidth = this.wtSettings.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n    return this.rowHeaderWidth;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getViewportWidth() {\n    const containerWidth = this.getWorkspaceWidth();\n    if (containerWidth === Infinity) {\n      return containerWidth;\n    }\n    const rowHeaderWidth = this.getRowHeaderWidth();\n    if (rowHeaderWidth > 0) {\n      return containerWidth - rowHeaderWidth;\n    }\n    return containerWidth;\n  }\n\n  /**\n   * Creates rows calculators. The type of the calculations can be chosen from the list:\n   *  - 'rendered' Calculates rows that should be rendered within the current table's viewport;\n   *  - 'fullyVisible' Calculates rows that are fully visible (used mostly for scrolling purposes);\n   *  - 'partiallyVisible' Calculates rows that are partially visible (used mostly for scrolling purposes).\n   *\n   * @param {'rendered' | 'fullyVisible' | 'partiallyVisible'} calculatorTypes The list of the calculation types.\n   * @returns {ViewportRowsCalculator}\n   */\n  createRowsCalculator() {\n    let calculatorTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['rendered', 'fullyVisible', 'partiallyVisible'];\n    const {\n      wtSettings,\n      wtTable\n    } = this;\n    let height = this.getViewportHeight();\n    let scrollbarHeight;\n    let fixedRowsHeight;\n    this.rowHeaderWidth = NaN;\n    let pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;\n    const fixedRowsTop = wtSettings.getSetting('fixedRowsTop');\n    const fixedRowsBottom = wtSettings.getSetting('fixedRowsBottom');\n    const totalRows = wtSettings.getSetting('totalRows');\n    if (fixedRowsTop && pos >= 0) {\n      fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);\n      pos += fixedRowsHeight;\n      height -= fixedRowsHeight;\n    }\n    if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {\n      fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n      height -= fixedRowsHeight;\n    }\n    if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n      scrollbarHeight = 0;\n    } else {\n      scrollbarHeight = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    return new ViewportRowsCalculator({\n      calculationTypes: calculatorTypes.map(type => [type, this.rowsCalculatorTypes.get(type)()]),\n      viewportHeight: height,\n      scrollOffset: pos,\n      totalRows: wtSettings.getSetting('totalRows'),\n      rowHeightFn: sourceRow => wtTable.getRowHeight(sourceRow),\n      overrideFn: wtSettings.getSettingPure('viewportRowCalculatorOverride'),\n      horizontalScrollbarHeight: scrollbarHeight\n    });\n  }\n\n  /**\n   * Creates columns calculators. The type of the calculations can be chosen from the list:\n   *  - 'rendered' Calculates columns that should be rendered within the current table's viewport;\n   *  - 'fullyVisible' Calculates columns that are fully visible (used mostly for scrolling purposes);\n   *  - 'partiallyVisible' Calculates columns that are partially visible (used mostly for scrolling purposes).\n   *\n   * @param {'rendered' | 'fullyVisible' | 'partiallyVisible'} calculatorTypes The list of the calculation types.\n   * @returns {ViewportColumnsCalculator}\n   */\n  createColumnsCalculator() {\n    let calculatorTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['rendered', 'fullyVisible', 'partiallyVisible'];\n    const {\n      wtSettings,\n      wtTable\n    } = this;\n    let width = this.getViewportWidth();\n    let pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;\n    this.columnHeaderHeight = NaN;\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    if (fixedColumnsStart && pos >= 0) {\n      const fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);\n      pos += fixedColumnsWidth;\n      width -= fixedColumnsWidth;\n    }\n    if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n      width -= getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    return new ViewportColumnsCalculator({\n      calculationTypes: calculatorTypes.map(type => [type, this.columnsCalculatorTypes.get(type)()]),\n      viewportWidth: width,\n      scrollOffset: pos,\n      totalColumns: wtSettings.getSetting('totalColumns'),\n      columnWidthFn: sourceCol => wtTable.getColumnWidth(sourceCol),\n      overrideFn: wtSettings.getSettingPure('viewportColumnCalculatorOverride'),\n      inlineStartOffset: this.dataAccessObject.inlineStartParentOffset\n    });\n  }\n\n  /**\n   * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\n   * cols should be rendered).\n   *\n   * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\n   *                           If `false` or `undefined`, will perform a full redraw.\n   * @returns {boolean} The fastDraw value, possibly modified.\n   */\n  createCalculators() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtSettings\n    } = this;\n    const rowsCalculator = this.createRowsCalculator();\n    const columnsCalculator = this.createColumnsCalculator();\n    if (fastDraw && !wtSettings.getSetting('renderAllRows')) {\n      const proposedRowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');\n      fastDraw = this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator);\n    }\n    if (fastDraw && !wtSettings.getSetting('renderAllColumns')) {\n      const proposedColumnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');\n      fastDraw = this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator);\n    }\n    if (!fastDraw) {\n      this.rowsRenderCalculator = rowsCalculator.getResultsFor('rendered');\n      this.columnsRenderCalculator = columnsCalculator.getResultsFor('rendered');\n    }\n    this.rowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');\n    this.columnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');\n    this.rowsPartiallyVisibleCalculator = rowsCalculator.getResultsFor('partiallyVisible');\n    this.columnsPartiallyVisibleCalculator = columnsCalculator.getResultsFor('partiallyVisible');\n    return fastDraw;\n  }\n\n  /**\n   * Creates rows and columns calculators (after draw, to determine what are\n   * the actually fully visible and partially visible rows and columns).\n   */\n  createVisibleCalculators() {\n    const rowsCalculator = this.createRowsCalculator(['fullyVisible', 'partiallyVisible']);\n    const columnsCalculator = this.createColumnsCalculator(['fullyVisible', 'partiallyVisible']);\n    this.rowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');\n    this.columnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');\n    this.rowsPartiallyVisibleCalculator = rowsCalculator.getResultsFor('partiallyVisible');\n    this.columnsPartiallyVisibleCalculator = columnsCalculator.getResultsFor('partiallyVisible');\n  }\n\n  /**\n   * Returns information whether proposedRowsVisibleCalculator viewport\n   * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\n   *\n   * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\n   * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\n   *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\n   */\n  areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n    if (!this.rowsVisibleCalculator) {\n      return false;\n    }\n    let {\n      startRow,\n      endRow\n    } = proposedRowsVisibleCalculator;\n\n    // if there are no fully visible rows at all...\n    if (startRow === null && endRow === null) {\n      if (!proposedRowsVisibleCalculator.isVisibleInTrimmingContainer) {\n        return true;\n      }\n      // ...use partially visible rows calculator to determine what render type is needed\n      startRow = this.rowsPartiallyVisibleCalculator.startRow;\n      endRow = this.rowsPartiallyVisibleCalculator.endRow;\n    }\n    const {\n      startRow: renderedStartRow,\n      endRow: renderedEndRow\n    } = this.rowsRenderCalculator;\n    if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n      return false;\n    } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wtSettings.getSetting('totalRows') - 1) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns information whether proposedColumnsVisibleCalculator viewport\n   * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\n   *\n   * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\n   * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\n   *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\n   */\n  areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n    if (!this.columnsVisibleCalculator) {\n      return false;\n    }\n    let {\n      startColumn,\n      endColumn\n    } = proposedColumnsVisibleCalculator;\n\n    // if there are no fully visible columns at all...\n    if (startColumn === null && endColumn === null) {\n      if (!proposedColumnsVisibleCalculator.isVisibleInTrimmingContainer) {\n        return true;\n      }\n      // ...use partially visible columns calculator to determine what render type is needed\n      startColumn = this.columnsPartiallyVisibleCalculator.startColumn;\n      endColumn = this.columnsPartiallyVisibleCalculator.endColumn;\n    }\n    const {\n      startColumn: renderedStartColumn,\n      endColumn: renderedEndColumn\n    } = this.columnsRenderCalculator;\n    if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n      return false;\n    } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wtSettings.getSetting('totalColumns') - 1) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\n   */\n  resetHasOversizedColumnHeadersMarked() {\n    objectEach(this.hasOversizedColumnHeadersMarked, (value, key, object) => {\n      object[key] = undefined;\n    });\n  }\n}\nexport default Viewport;","map":{"version":3,"names":["getScrollbarWidth","getStyle","offset","outerHeight","outerWidth","objectEach","FullyVisibleColumnsCalculationType","FullyVisibleRowsCalculationType","PartiallyVisibleColumnsCalculationType","PartiallyVisibleRowsCalculationType","RenderedAllColumnsCalculationType","RenderedAllRowsCalculationType","RenderedColumnsCalculationType","RenderedRowsCalculationType","ViewportColumnsCalculator","ViewportRowsCalculator","Viewport","constructor","dataAccessObject","domBindings","wtSettings","eventManager","wtTable","wot","instance","oversizedRows","oversizedColumnHeaders","hasOversizedColumnHeadersMarked","clientHeight","containerWidth","NaN","rowHeaderWidth","rowsVisibleCalculator","columnsVisibleCalculator","rowsCalculatorTypes","Map","getSetting","columnsCalculatorTypes","addEventListener","rootWindow","getWorkspaceHeight","currentDocument","rootDocument","trimmingContainer","topOverlayTrimmingContainer","height","documentElement","elemHeight","Infinity","getWorkspaceWidth","inlineStartOverlayTrimmingContainer","docOffsetWidth","offsetWidth","totalColumns","preventOverflow","isRtl","tableRect","TABLE","getBoundingClientRect","inlineStart","right","left","tableOffset","width","overflow","wtRootElement","Math","min","getContainerFillWidth","sumColumnWidths","clientWidth","max","stretchSetting","hasVerticalScroll","hider","offsetHeight","hasHorizontalScroll","from","length","sum","column","getColumnWidth","mainContainer","holder","dummyElement","createElement","style","appendChild","fillWidth","removeChild","getWorkspaceOffset","getColumnHeaderHeight","columnHeaders","columnHeaderHeight","isNaN","THEAD","getViewportHeight","containerHeight","getRowHeaderWidth","rowHeadersWidthSetting","rowHeaders","i","len","TH","querySelector","nextSibling","getViewportWidth","createRowsCalculator","calculatorTypes","arguments","undefined","scrollbarHeight","fixedRowsHeight","pos","topScrollPosition","topParentOffset","fixedRowsTop","fixedRowsBottom","totalRows","topOverlay","sumCellSizes","bottomOverlay","clone","calculationTypes","map","type","get","viewportHeight","scrollOffset","rowHeightFn","sourceRow","getRowHeight","overrideFn","getSettingPure","horizontalScrollbarHeight","createColumnsCalculator","abs","inlineStartScrollPosition","inlineStartParentOffset","fixedColumnsStart","fixedColumnsWidth","inlineStartOverlay","viewportWidth","columnWidthFn","sourceCol","inlineStartOffset","createCalculators","fastDraw","rowsCalculator","columnsCalculator","proposedRowsVisibleCalculator","getResultsFor","areAllProposedVisibleRowsAlreadyRendered","proposedColumnsVisibleCalculator","areAllProposedVisibleColumnsAlreadyRendered","rowsRenderCalculator","columnsRenderCalculator","rowsPartiallyVisibleCalculator","columnsPartiallyVisibleCalculator","createVisibleCalculators","startRow","endRow","isVisibleInTrimmingContainer","renderedStartRow","renderedEndRow","startColumn","endColumn","renderedStartColumn","renderedEndColumn","resetHasOversizedColumnHeadersMarked","value","key","object"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/viewport.mjs"],"sourcesContent":["import { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { FullyVisibleColumnsCalculationType, FullyVisibleRowsCalculationType, PartiallyVisibleColumnsCalculationType, PartiallyVisibleRowsCalculationType, RenderedAllColumnsCalculationType, RenderedAllRowsCalculationType, RenderedColumnsCalculationType, RenderedRowsCalculationType, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\n * @class Viewport\n */\nclass Viewport {\n  /**\n   * @param {ViewportDao} dataAccessObject The Walkontable instance.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The instance event manager.\n   * @param {Table} wtTable The table.\n   */\n  constructor(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {\n    this.dataAccessObject = dataAccessObject;\n    // legacy support\n    this.wot = dataAccessObject.wot;\n    this.instance = this.wot;\n    this.domBindings = domBindings;\n    this.wtSettings = wtSettings;\n    this.wtTable = wtTable;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.rowsCalculatorTypes = new Map([['rendered', () => this.wtSettings.getSetting('renderAllRows') ? new RenderedAllRowsCalculationType() : new RenderedRowsCalculationType()], ['fullyVisible', () => new FullyVisibleRowsCalculationType()], ['partiallyVisible', () => new PartiallyVisibleRowsCalculationType()]]);\n    this.columnsCalculatorTypes = new Map([['rendered', () => this.wtSettings.getSetting('renderAllColumns') ? new RenderedAllColumnsCalculationType() : new RenderedColumnsCalculationType()], ['fullyVisible', () => new FullyVisibleColumnsCalculationType()], ['partiallyVisible', () => new PartiallyVisibleColumnsCalculationType()]]);\n    this.eventManager = eventManager;\n    this.eventManager.addEventListener(this.domBindings.rootWindow, 'resize', () => {\n      this.clientHeight = this.getWorkspaceHeight();\n    });\n  }\n\n  /**\n   * @returns {number}\n   */\n  getWorkspaceHeight() {\n    const currentDocument = this.domBindings.rootDocument;\n    const trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;\n    let height = 0;\n    if (trimmingContainer === this.domBindings.rootWindow) {\n      height = currentDocument.documentElement.clientHeight;\n    } else {\n      const elemHeight = outerHeight(trimmingContainer);\n\n      // returns height without DIV scrollbar\n      height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n    }\n    return height;\n  }\n  getWorkspaceWidth() {\n    const {\n      wtSettings\n    } = this;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;\n    const docOffsetWidth = rootDocument.documentElement.offsetWidth;\n    const totalColumns = wtSettings.getSetting('totalColumns');\n    const preventOverflow = wtSettings.getSetting('preventOverflow');\n    const isRtl = wtSettings.getSetting('rtlMode');\n    const tableRect = this.wtTable.TABLE.getBoundingClientRect();\n    const inlineStart = isRtl ? tableRect.right - docOffsetWidth : tableRect.left;\n    const tableOffset = docOffsetWidth - inlineStart;\n    let width;\n    let overflow;\n    if (preventOverflow) {\n      return outerWidth(this.wtTable.wtRootElement);\n    }\n    if (wtSettings.getSetting('freezeOverlays')) {\n      width = Math.min(tableOffset, docOffsetWidth);\n    } else {\n      width = Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);\n    }\n    if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n      // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n      // otherwise continue below, which will allow stretching\n      // this is used in `scroll_window.html`\n      // TODO test me\n      return rootDocument.documentElement.clientWidth;\n    }\n    if (trimmingContainer !== rootWindow) {\n      overflow = getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, 'overflow', rootWindow);\n      if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n        // this is used in `scroll.html`\n        // TODO test me\n        return Math.max(width, trimmingContainer.clientWidth);\n      }\n    }\n    const stretchSetting = wtSettings.getSetting('stretchH');\n    if (stretchSetting === 'none' || !stretchSetting) {\n      // if no stretching is used, return the maximum used workspace width\n      return Math.max(width, outerWidth(this.wtTable.TABLE));\n    }\n\n    // if stretching is used, return the actual container width, so the columns can fit inside it\n    return width;\n  }\n\n  /**\n   * Checks if viewport has vertical scroll.\n   *\n   * @returns {boolean}\n   */\n  hasVerticalScroll() {\n    return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();\n  }\n\n  /**\n   * Checks if viewport has horizontal scroll.\n   *\n   * @returns {boolean}\n   */\n  hasHorizontalScroll() {\n    return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();\n  }\n\n  /**\n   * @param {number} from The visual column index from the width sum is start calculated.\n   * @param {number} length The length of the column to traverse.\n   * @returns {number}\n   */\n  sumColumnWidths(from, length) {\n    let sum = 0;\n    let column = from;\n    while (column < length) {\n      sum += this.wtTable.getColumnWidth(column);\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getContainerFillWidth() {\n    if (this.containerWidth) {\n      return this.containerWidth;\n    }\n    const mainContainer = this.wtTable.holder;\n    const dummyElement = this.domBindings.rootDocument.createElement('div');\n    dummyElement.style.width = '100%';\n    dummyElement.style.height = '1px';\n    mainContainer.appendChild(dummyElement);\n    const fillWidth = dummyElement.offsetWidth;\n    this.containerWidth = fillWidth;\n    mainContainer.removeChild(dummyElement);\n    return fillWidth;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getWorkspaceOffset() {\n    return offset(this.wtTable.TABLE);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getColumnHeaderHeight() {\n    const columnHeaders = this.wtSettings.getSetting('columnHeaders');\n    if (!columnHeaders.length) {\n      this.columnHeaderHeight = 0;\n    } else if (isNaN(this.columnHeaderHeight)) {\n      this.columnHeaderHeight = outerHeight(this.wtTable.THEAD);\n    }\n    return this.columnHeaderHeight;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getViewportHeight() {\n    let containerHeight = this.getWorkspaceHeight();\n    if (containerHeight === Infinity) {\n      return containerHeight;\n    }\n    const columnHeaderHeight = this.getColumnHeaderHeight();\n    if (columnHeaderHeight > 0) {\n      containerHeight -= columnHeaderHeight;\n    }\n    return containerHeight;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getRowHeaderWidth() {\n    const rowHeadersWidthSetting = this.wtSettings.getSetting('rowHeaderWidth');\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    if (rowHeadersWidthSetting) {\n      this.rowHeaderWidth = 0;\n      for (let i = 0, len = rowHeaders.length; i < len; i++) {\n        this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n      }\n    }\n    if (isNaN(this.rowHeaderWidth)) {\n      if (rowHeaders.length) {\n        let TH = this.wtTable.TABLE.querySelector('TH');\n        this.rowHeaderWidth = 0;\n        for (let i = 0, len = rowHeaders.length; i < len; i++) {\n          if (TH) {\n            this.rowHeaderWidth += outerWidth(TH);\n            TH = TH.nextSibling;\n          } else {\n            // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n            // TODO: proper fix\n            this.rowHeaderWidth += 50;\n          }\n        }\n      } else {\n        this.rowHeaderWidth = 0;\n      }\n    }\n    this.rowHeaderWidth = this.wtSettings.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n    return this.rowHeaderWidth;\n  }\n\n  /**\n   * @returns {number}\n   */\n  getViewportWidth() {\n    const containerWidth = this.getWorkspaceWidth();\n    if (containerWidth === Infinity) {\n      return containerWidth;\n    }\n    const rowHeaderWidth = this.getRowHeaderWidth();\n    if (rowHeaderWidth > 0) {\n      return containerWidth - rowHeaderWidth;\n    }\n    return containerWidth;\n  }\n\n  /**\n   * Creates rows calculators. The type of the calculations can be chosen from the list:\n   *  - 'rendered' Calculates rows that should be rendered within the current table's viewport;\n   *  - 'fullyVisible' Calculates rows that are fully visible (used mostly for scrolling purposes);\n   *  - 'partiallyVisible' Calculates rows that are partially visible (used mostly for scrolling purposes).\n   *\n   * @param {'rendered' | 'fullyVisible' | 'partiallyVisible'} calculatorTypes The list of the calculation types.\n   * @returns {ViewportRowsCalculator}\n   */\n  createRowsCalculator() {\n    let calculatorTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['rendered', 'fullyVisible', 'partiallyVisible'];\n    const {\n      wtSettings,\n      wtTable\n    } = this;\n    let height = this.getViewportHeight();\n    let scrollbarHeight;\n    let fixedRowsHeight;\n    this.rowHeaderWidth = NaN;\n    let pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;\n    const fixedRowsTop = wtSettings.getSetting('fixedRowsTop');\n    const fixedRowsBottom = wtSettings.getSetting('fixedRowsBottom');\n    const totalRows = wtSettings.getSetting('totalRows');\n    if (fixedRowsTop && pos >= 0) {\n      fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);\n      pos += fixedRowsHeight;\n      height -= fixedRowsHeight;\n    }\n    if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {\n      fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n      height -= fixedRowsHeight;\n    }\n    if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n      scrollbarHeight = 0;\n    } else {\n      scrollbarHeight = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    return new ViewportRowsCalculator({\n      calculationTypes: calculatorTypes.map(type => [type, this.rowsCalculatorTypes.get(type)()]),\n      viewportHeight: height,\n      scrollOffset: pos,\n      totalRows: wtSettings.getSetting('totalRows'),\n      rowHeightFn: sourceRow => wtTable.getRowHeight(sourceRow),\n      overrideFn: wtSettings.getSettingPure('viewportRowCalculatorOverride'),\n      horizontalScrollbarHeight: scrollbarHeight\n    });\n  }\n\n  /**\n   * Creates columns calculators. The type of the calculations can be chosen from the list:\n   *  - 'rendered' Calculates columns that should be rendered within the current table's viewport;\n   *  - 'fullyVisible' Calculates columns that are fully visible (used mostly for scrolling purposes);\n   *  - 'partiallyVisible' Calculates columns that are partially visible (used mostly for scrolling purposes).\n   *\n   * @param {'rendered' | 'fullyVisible' | 'partiallyVisible'} calculatorTypes The list of the calculation types.\n   * @returns {ViewportColumnsCalculator}\n   */\n  createColumnsCalculator() {\n    let calculatorTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['rendered', 'fullyVisible', 'partiallyVisible'];\n    const {\n      wtSettings,\n      wtTable\n    } = this;\n    let width = this.getViewportWidth();\n    let pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;\n    this.columnHeaderHeight = NaN;\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    if (fixedColumnsStart && pos >= 0) {\n      const fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);\n      pos += fixedColumnsWidth;\n      width -= fixedColumnsWidth;\n    }\n    if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n      width -= getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    return new ViewportColumnsCalculator({\n      calculationTypes: calculatorTypes.map(type => [type, this.columnsCalculatorTypes.get(type)()]),\n      viewportWidth: width,\n      scrollOffset: pos,\n      totalColumns: wtSettings.getSetting('totalColumns'),\n      columnWidthFn: sourceCol => wtTable.getColumnWidth(sourceCol),\n      overrideFn: wtSettings.getSettingPure('viewportColumnCalculatorOverride'),\n      inlineStartOffset: this.dataAccessObject.inlineStartParentOffset\n    });\n  }\n\n  /**\n   * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\n   * cols should be rendered).\n   *\n   * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\n   *                           If `false` or `undefined`, will perform a full redraw.\n   * @returns {boolean} The fastDraw value, possibly modified.\n   */\n  createCalculators() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtSettings\n    } = this;\n    const rowsCalculator = this.createRowsCalculator();\n    const columnsCalculator = this.createColumnsCalculator();\n    if (fastDraw && !wtSettings.getSetting('renderAllRows')) {\n      const proposedRowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');\n      fastDraw = this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator);\n    }\n    if (fastDraw && !wtSettings.getSetting('renderAllColumns')) {\n      const proposedColumnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');\n      fastDraw = this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator);\n    }\n    if (!fastDraw) {\n      this.rowsRenderCalculator = rowsCalculator.getResultsFor('rendered');\n      this.columnsRenderCalculator = columnsCalculator.getResultsFor('rendered');\n    }\n    this.rowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');\n    this.columnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');\n    this.rowsPartiallyVisibleCalculator = rowsCalculator.getResultsFor('partiallyVisible');\n    this.columnsPartiallyVisibleCalculator = columnsCalculator.getResultsFor('partiallyVisible');\n    return fastDraw;\n  }\n\n  /**\n   * Creates rows and columns calculators (after draw, to determine what are\n   * the actually fully visible and partially visible rows and columns).\n   */\n  createVisibleCalculators() {\n    const rowsCalculator = this.createRowsCalculator(['fullyVisible', 'partiallyVisible']);\n    const columnsCalculator = this.createColumnsCalculator(['fullyVisible', 'partiallyVisible']);\n    this.rowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');\n    this.columnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');\n    this.rowsPartiallyVisibleCalculator = rowsCalculator.getResultsFor('partiallyVisible');\n    this.columnsPartiallyVisibleCalculator = columnsCalculator.getResultsFor('partiallyVisible');\n  }\n\n  /**\n   * Returns information whether proposedRowsVisibleCalculator viewport\n   * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\n   *\n   * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\n   * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\n   *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\n   */\n  areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n    if (!this.rowsVisibleCalculator) {\n      return false;\n    }\n    let {\n      startRow,\n      endRow\n    } = proposedRowsVisibleCalculator;\n\n    // if there are no fully visible rows at all...\n    if (startRow === null && endRow === null) {\n      if (!proposedRowsVisibleCalculator.isVisibleInTrimmingContainer) {\n        return true;\n      }\n      // ...use partially visible rows calculator to determine what render type is needed\n      startRow = this.rowsPartiallyVisibleCalculator.startRow;\n      endRow = this.rowsPartiallyVisibleCalculator.endRow;\n    }\n    const {\n      startRow: renderedStartRow,\n      endRow: renderedEndRow\n    } = this.rowsRenderCalculator;\n    if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n      return false;\n    } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wtSettings.getSetting('totalRows') - 1) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns information whether proposedColumnsVisibleCalculator viewport\n   * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\n   *\n   * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\n   * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\n   *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\n   */\n  areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n    if (!this.columnsVisibleCalculator) {\n      return false;\n    }\n    let {\n      startColumn,\n      endColumn\n    } = proposedColumnsVisibleCalculator;\n\n    // if there are no fully visible columns at all...\n    if (startColumn === null && endColumn === null) {\n      if (!proposedColumnsVisibleCalculator.isVisibleInTrimmingContainer) {\n        return true;\n      }\n      // ...use partially visible columns calculator to determine what render type is needed\n      startColumn = this.columnsPartiallyVisibleCalculator.startColumn;\n      endColumn = this.columnsPartiallyVisibleCalculator.endColumn;\n    }\n    const {\n      startColumn: renderedStartColumn,\n      endColumn: renderedEndColumn\n    } = this.columnsRenderCalculator;\n    if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n      return false;\n    } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wtSettings.getSetting('totalColumns') - 1) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\n   */\n  resetHasOversizedColumnHeadersMarked() {\n    objectEach(this.hasOversizedColumnHeadersMarked, (value, key, object) => {\n      object[key] = undefined;\n    });\n  }\n}\nexport default Viewport;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}