{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { extend } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for all of the Autofill-related operations on merged cells.\n *\n * @private\n * @class AutofillCalculations\n */\nclass AutofillCalculations {\n  constructor(plugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the MergedCellsCollection class instance.\n     *\n     * @type {MergedCellsCollection}\n     */\n    _defineProperty(this, \"mergedCellsCollection\", void 0);\n    /**\n     * Cache of the currently processed autofill data.\n     *\n     * @private\n     * @type {object}\n     */\n    _defineProperty(this, \"currentFillData\", null);\n    this.plugin = plugin;\n    this.mergedCellsCollection = this.plugin.mergedCellsCollection;\n  }\n\n  /**\n   * Correct the provided selection area, so it's not selecting only a part of a merged cell.\n   *\n   * @param {Array} selectionArea The selection to correct.\n   */\n  correctSelectionAreaSize(selectionArea) {\n    if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {\n      const mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);\n      if (mergedCell) {\n        selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;\n        selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;\n      }\n    }\n  }\n\n  /**\n   * Get the direction of the autofill process.\n   *\n   * @param {Array} selectionArea The selection area.\n   * @param {Array} finalArea The final area (base + drag).\n   * @returns {string} `up`, `down`, `left` or `right`.\n   */\n  getDirection(selectionArea, finalArea) {\n    let direction = null;\n    if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {\n      direction = 'down';\n    } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {\n      direction = 'up';\n    } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {\n      direction = 'right';\n    } else {\n      direction = 'left';\n    }\n    return direction;\n  }\n\n  /**\n   * Snap the drag area to the farthest merged cell, so it won't clip any of the merged cells.\n   *\n   * @param {Array} baseArea The base selected area.\n   * @param {Array} dragArea The drag area.\n   * @param {string} dragDirection The autofill drag direction.\n   * @param {Array} foundMergedCells MergeCellCoords found in the base selection area.\n   * @returns {Array} The new drag area.\n   */\n  snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {\n    const newDragArea = dragArea.slice(0);\n    const fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const verticalDirection = ['up', 'down'].indexOf(dragDirection) > -1;\n    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;\n    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;\n    const partials = fillSize - fulls;\n    const farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);\n    if (farthestCollection) {\n      if (dragDirection === 'down') {\n        const fill = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;\n        const newLimit = newDragArea[2] + fill;\n        if (newLimit >= this.plugin.hot.countRows()) {\n          newDragArea[2] -= partials;\n        } else {\n          newDragArea[2] += partials ? fill : 0;\n        }\n      } else if (dragDirection === 'right') {\n        const fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;\n        const newLimit = newDragArea[3] + fill;\n        if (newLimit >= this.plugin.hot.countCols()) {\n          newDragArea[3] -= partials;\n        } else {\n          newDragArea[3] += partials ? fill : 0;\n        }\n      } else if (dragDirection === 'up') {\n        const fill = baseAreaEndRow - partials - farthestCollection.row + 1;\n        const newLimit = newDragArea[0] + fill;\n        if (newLimit < 0) {\n          newDragArea[0] += partials;\n        } else {\n          newDragArea[0] -= partials ? fill : 0;\n        }\n      } else if (dragDirection === 'left') {\n        const fill = baseAreaEndColumn - partials - farthestCollection.col + 1;\n        const newLimit = newDragArea[1] + fill;\n        if (newLimit < 0) {\n          newDragArea[1] += partials;\n        } else {\n          newDragArea[1] -= partials ? fill : 0;\n        }\n      }\n    }\n    this.updateCurrentFillCache({\n      baseArea,\n      dragDirection,\n      foundMergedCells,\n      fillSize,\n      dragArea: newDragArea,\n      cycleLength: fullCycle\n    });\n    return newDragArea;\n  }\n\n  /**\n   * Update the current fill cache with the provided object.\n   *\n   * @private\n   * @param {object} updateObject The current filled object cache.\n   */\n  updateCurrentFillCache(updateObject) {\n    if (!this.currentFillData) {\n      this.currentFillData = {};\n    }\n    extend(this.currentFillData, updateObject);\n  }\n\n  /**\n   * Get the \"length\" of the drag area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} dragArea The drag area (containing the base area).\n   * @param {string} direction The drag direction.\n   * @returns {number|null} The \"length\" (height or width, depending on the direction) of the drag.\n   */\n  getAutofillSize(baseArea, dragArea, direction) {\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    switch (direction) {\n      case 'up':\n        return baseAreaStartRow - dragAreaStartRow;\n      case 'down':\n        return dragAreaEndRow - baseAreaEndRow;\n      case 'left':\n        return baseAreaStartColumn - dragAreaStartColumn;\n      case 'right':\n        return dragAreaEndColumn - baseAreaEndColumn;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Trim the default drag area (containing the selection area) to the drag-only area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} dragArea The base selection area extended by the drag area.\n   * @param {string} direction Drag direction.\n   * @returns {Array|null} Array representing the drag area coordinates.\n   */\n  getDragArea(baseArea, dragArea, direction) {\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    switch (direction) {\n      case 'up':\n        return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];\n      case 'down':\n        return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];\n      case 'left':\n        return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];\n      case 'right':\n        return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get the to-be-farthest merged cell in the newly filled area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} dragArea The drag area (containing the base area).\n   * @param {string} direction The drag direction.\n   * @param {Array} mergedCellArray Array of the merged cells found in the base area.\n   * @returns {MergedCellCoords|null}\n   */\n  getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const verticalDirection = ['up', 'down'].indexOf(direction) > -1;\n    const baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;\n    const baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;\n    const fillSize = this.getAutofillSize(baseArea, dragArea, direction);\n    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;\n    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;\n    const partials = fillSize - fulls;\n    let inclusionFunctionName = null;\n    let farthestCollection = null;\n    let endOfDragRecreationIndex = null;\n    switch (direction) {\n      case 'up':\n        inclusionFunctionName = 'includesVertically';\n        endOfDragRecreationIndex = baseEnd - partials + 1;\n        break;\n      case 'left':\n        inclusionFunctionName = 'includesHorizontally';\n        endOfDragRecreationIndex = baseEnd - partials + 1;\n        break;\n      case 'down':\n        inclusionFunctionName = 'includesVertically';\n        endOfDragRecreationIndex = baseStart + partials - 1;\n        break;\n      case 'right':\n        inclusionFunctionName = 'includesHorizontally';\n        endOfDragRecreationIndex = baseStart + partials - 1;\n        break;\n      default:\n    }\n    arrayEach(mergedCellArray, currentCollection => {\n      if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {\n        farthestCollection = currentCollection;\n      }\n    });\n    return farthestCollection;\n  }\n\n  /**\n   * Recreate the merged cells after the autofill process.\n   *\n   * @param {Array} changes Changes made.\n   */\n  recreateAfterDataPopulation(changes) {\n    if (!this.currentFillData) {\n      return;\n    }\n    const fillRange = this.getRangeFromChanges(changes);\n    const foundMergedCells = this.currentFillData.foundMergedCells;\n    const dragDirection = this.currentFillData.dragDirection;\n    const inBounds = (current, offset) => {\n      switch (dragDirection) {\n        case 'up':\n          return current.row - offset >= fillRange.from.row;\n        case 'down':\n          return current.row + current.rowspan - 1 + offset <= fillRange.to.row;\n        case 'left':\n          return current.col - offset >= fillRange.from.column;\n        case 'right':\n          return current.col + current.colspan - 1 + offset <= fillRange.to.column;\n        default:\n          return null;\n      }\n    };\n    let fillOffset = 0;\n    let current = null;\n    let multiplier = 1;\n    do {\n      for (let j = 0; j < foundMergedCells.length; j += 1) {\n        current = foundMergedCells[j];\n        fillOffset = multiplier * this.currentFillData.cycleLength;\n        if (inBounds(current, fillOffset)) {\n          switch (dragDirection) {\n            case 'up':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row - fillOffset,\n                rowspan: current.rowspan,\n                col: current.col,\n                colspan: current.colspan\n              });\n              break;\n            case 'down':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row + fillOffset,\n                rowspan: current.rowspan,\n                col: current.col,\n                colspan: current.colspan\n              });\n              break;\n            case 'left':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row,\n                rowspan: current.rowspan,\n                col: current.col - fillOffset,\n                colspan: current.colspan\n              });\n              break;\n            case 'right':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row,\n                rowspan: current.rowspan,\n                col: current.col + fillOffset,\n                colspan: current.colspan\n              });\n              break;\n            default:\n          }\n        }\n        if (j === foundMergedCells.length - 1) {\n          multiplier += 1;\n        }\n      }\n    } while (inBounds(current, fillOffset));\n    this.currentFillData = null;\n    this.plugin.hot.render();\n    if (foundMergedCells.length > 0) {\n      this.plugin.ifChromeForceRepaint();\n    }\n  }\n\n  /**\n   * Get the drag range from the changes made.\n   *\n   * @private\n   * @param {Array} changes The changes made.\n   * @returns {object} Object with `from` and `to` properties, both containing `row` and `column` keys.\n   */\n  getRangeFromChanges(changes) {\n    const rows = {\n      min: null,\n      max: null\n    };\n    const columns = {\n      min: null,\n      max: null\n    };\n    arrayEach(changes, change => {\n      const rowIndex = change[0];\n      const columnIndex = this.plugin.hot.propToCol(change[1]);\n      if (rows.min === null || rowIndex < rows.min) {\n        rows.min = rowIndex;\n      }\n      if (rows.max === null || rowIndex > rows.max) {\n        rows.max = rowIndex;\n      }\n      if (columns.min === null || columnIndex < columns.min) {\n        columns.min = columnIndex;\n      }\n      if (columns.max === null || columnIndex > columns.max) {\n        columns.max = columnIndex;\n      }\n    });\n    return {\n      from: {\n        row: rows.min,\n        column: columns.min\n      },\n      to: {\n        row: rows.max,\n        column: columns.max\n      }\n    };\n  }\n\n  /**\n   * Check if the drag area contains any merged cells.\n   *\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} fullArea The base area extended by the drag area.\n   * @param {string} direction Drag direction.\n   * @returns {boolean}\n   */\n  dragAreaOverlapsCollections(baseArea, fullArea, direction) {\n    const dragArea = this.getDragArea(baseArea, fullArea, direction);\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    const topLeft = this.plugin.hot._createCellCoords(dragAreaStartRow, dragAreaStartColumn);\n    const bottomRight = this.plugin.hot._createCellCoords(dragAreaEndRow, dragAreaEndColumn);\n    const dragRange = this.plugin.hot._createCellRange(topLeft, topLeft, bottomRight);\n    return this.mergedCellsCollection.getWithinRange(dragRange, true).length > 0;\n  }\n}\nexport default AutofillCalculations;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","extend","arrayEach","AutofillCalculations","constructor","plugin","mergedCellsCollection","correctSelectionAreaSize","selectionArea","mergedCell","get","rowspan","colspan","getDirection","finalArea","direction","snapDragArea","baseArea","dragArea","dragDirection","foundMergedCells","newDragArea","slice","fillSize","getAutofillSize","baseAreaStartRow","baseAreaStartColumn","baseAreaEndRow","baseAreaEndColumn","verticalDirection","indexOf","fullCycle","fulls","Math","floor","partials","farthestCollection","getFarthestCollection","fill","row","newLimit","hot","countRows","col","countCols","updateCurrentFillCache","cycleLength","updateObject","currentFillData","dragAreaStartRow","dragAreaStartColumn","dragAreaEndRow","dragAreaEndColumn","getDragArea","mergedCellArray","baseEnd","baseStart","inclusionFunctionName","endOfDragRecreationIndex","currentCollection","isFarther","recreateAfterDataPopulation","changes","fillRange","getRangeFromChanges","inBounds","current","offset","from","to","column","fillOffset","multiplier","j","length","add","render","ifChromeForceRepaint","rows","min","max","columns","change","rowIndex","columnIndex","propToCol","dragAreaOverlapsCollections","fullArea","topLeft","_createCellCoords","bottomRight","dragRange","_createCellRange","getWithinRange"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/mergeCells/calculations/autofill.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { extend } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for all of the Autofill-related operations on merged cells.\n *\n * @private\n * @class AutofillCalculations\n */\nclass AutofillCalculations {\n  constructor(plugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the MergedCellsCollection class instance.\n     *\n     * @type {MergedCellsCollection}\n     */\n    _defineProperty(this, \"mergedCellsCollection\", void 0);\n    /**\n     * Cache of the currently processed autofill data.\n     *\n     * @private\n     * @type {object}\n     */\n    _defineProperty(this, \"currentFillData\", null);\n    this.plugin = plugin;\n    this.mergedCellsCollection = this.plugin.mergedCellsCollection;\n  }\n\n  /**\n   * Correct the provided selection area, so it's not selecting only a part of a merged cell.\n   *\n   * @param {Array} selectionArea The selection to correct.\n   */\n  correctSelectionAreaSize(selectionArea) {\n    if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {\n      const mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);\n      if (mergedCell) {\n        selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;\n        selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;\n      }\n    }\n  }\n\n  /**\n   * Get the direction of the autofill process.\n   *\n   * @param {Array} selectionArea The selection area.\n   * @param {Array} finalArea The final area (base + drag).\n   * @returns {string} `up`, `down`, `left` or `right`.\n   */\n  getDirection(selectionArea, finalArea) {\n    let direction = null;\n    if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {\n      direction = 'down';\n    } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {\n      direction = 'up';\n    } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {\n      direction = 'right';\n    } else {\n      direction = 'left';\n    }\n    return direction;\n  }\n\n  /**\n   * Snap the drag area to the farthest merged cell, so it won't clip any of the merged cells.\n   *\n   * @param {Array} baseArea The base selected area.\n   * @param {Array} dragArea The drag area.\n   * @param {string} dragDirection The autofill drag direction.\n   * @param {Array} foundMergedCells MergeCellCoords found in the base selection area.\n   * @returns {Array} The new drag area.\n   */\n  snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {\n    const newDragArea = dragArea.slice(0);\n    const fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const verticalDirection = ['up', 'down'].indexOf(dragDirection) > -1;\n    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;\n    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;\n    const partials = fillSize - fulls;\n    const farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);\n    if (farthestCollection) {\n      if (dragDirection === 'down') {\n        const fill = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;\n        const newLimit = newDragArea[2] + fill;\n        if (newLimit >= this.plugin.hot.countRows()) {\n          newDragArea[2] -= partials;\n        } else {\n          newDragArea[2] += partials ? fill : 0;\n        }\n      } else if (dragDirection === 'right') {\n        const fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;\n        const newLimit = newDragArea[3] + fill;\n        if (newLimit >= this.plugin.hot.countCols()) {\n          newDragArea[3] -= partials;\n        } else {\n          newDragArea[3] += partials ? fill : 0;\n        }\n      } else if (dragDirection === 'up') {\n        const fill = baseAreaEndRow - partials - farthestCollection.row + 1;\n        const newLimit = newDragArea[0] + fill;\n        if (newLimit < 0) {\n          newDragArea[0] += partials;\n        } else {\n          newDragArea[0] -= partials ? fill : 0;\n        }\n      } else if (dragDirection === 'left') {\n        const fill = baseAreaEndColumn - partials - farthestCollection.col + 1;\n        const newLimit = newDragArea[1] + fill;\n        if (newLimit < 0) {\n          newDragArea[1] += partials;\n        } else {\n          newDragArea[1] -= partials ? fill : 0;\n        }\n      }\n    }\n    this.updateCurrentFillCache({\n      baseArea,\n      dragDirection,\n      foundMergedCells,\n      fillSize,\n      dragArea: newDragArea,\n      cycleLength: fullCycle\n    });\n    return newDragArea;\n  }\n\n  /**\n   * Update the current fill cache with the provided object.\n   *\n   * @private\n   * @param {object} updateObject The current filled object cache.\n   */\n  updateCurrentFillCache(updateObject) {\n    if (!this.currentFillData) {\n      this.currentFillData = {};\n    }\n    extend(this.currentFillData, updateObject);\n  }\n\n  /**\n   * Get the \"length\" of the drag area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} dragArea The drag area (containing the base area).\n   * @param {string} direction The drag direction.\n   * @returns {number|null} The \"length\" (height or width, depending on the direction) of the drag.\n   */\n  getAutofillSize(baseArea, dragArea, direction) {\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    switch (direction) {\n      case 'up':\n        return baseAreaStartRow - dragAreaStartRow;\n      case 'down':\n        return dragAreaEndRow - baseAreaEndRow;\n      case 'left':\n        return baseAreaStartColumn - dragAreaStartColumn;\n      case 'right':\n        return dragAreaEndColumn - baseAreaEndColumn;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Trim the default drag area (containing the selection area) to the drag-only area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} dragArea The base selection area extended by the drag area.\n   * @param {string} direction Drag direction.\n   * @returns {Array|null} Array representing the drag area coordinates.\n   */\n  getDragArea(baseArea, dragArea, direction) {\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    switch (direction) {\n      case 'up':\n        return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];\n      case 'down':\n        return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];\n      case 'left':\n        return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];\n      case 'right':\n        return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get the to-be-farthest merged cell in the newly filled area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} dragArea The drag area (containing the base area).\n   * @param {string} direction The drag direction.\n   * @param {Array} mergedCellArray Array of the merged cells found in the base area.\n   * @returns {MergedCellCoords|null}\n   */\n  getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {\n    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const verticalDirection = ['up', 'down'].indexOf(direction) > -1;\n    const baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;\n    const baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;\n    const fillSize = this.getAutofillSize(baseArea, dragArea, direction);\n    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;\n    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;\n    const partials = fillSize - fulls;\n    let inclusionFunctionName = null;\n    let farthestCollection = null;\n    let endOfDragRecreationIndex = null;\n    switch (direction) {\n      case 'up':\n        inclusionFunctionName = 'includesVertically';\n        endOfDragRecreationIndex = baseEnd - partials + 1;\n        break;\n      case 'left':\n        inclusionFunctionName = 'includesHorizontally';\n        endOfDragRecreationIndex = baseEnd - partials + 1;\n        break;\n      case 'down':\n        inclusionFunctionName = 'includesVertically';\n        endOfDragRecreationIndex = baseStart + partials - 1;\n        break;\n      case 'right':\n        inclusionFunctionName = 'includesHorizontally';\n        endOfDragRecreationIndex = baseStart + partials - 1;\n        break;\n      default:\n    }\n    arrayEach(mergedCellArray, currentCollection => {\n      if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {\n        farthestCollection = currentCollection;\n      }\n    });\n    return farthestCollection;\n  }\n\n  /**\n   * Recreate the merged cells after the autofill process.\n   *\n   * @param {Array} changes Changes made.\n   */\n  recreateAfterDataPopulation(changes) {\n    if (!this.currentFillData) {\n      return;\n    }\n    const fillRange = this.getRangeFromChanges(changes);\n    const foundMergedCells = this.currentFillData.foundMergedCells;\n    const dragDirection = this.currentFillData.dragDirection;\n    const inBounds = (current, offset) => {\n      switch (dragDirection) {\n        case 'up':\n          return current.row - offset >= fillRange.from.row;\n        case 'down':\n          return current.row + current.rowspan - 1 + offset <= fillRange.to.row;\n        case 'left':\n          return current.col - offset >= fillRange.from.column;\n        case 'right':\n          return current.col + current.colspan - 1 + offset <= fillRange.to.column;\n        default:\n          return null;\n      }\n    };\n    let fillOffset = 0;\n    let current = null;\n    let multiplier = 1;\n    do {\n      for (let j = 0; j < foundMergedCells.length; j += 1) {\n        current = foundMergedCells[j];\n        fillOffset = multiplier * this.currentFillData.cycleLength;\n        if (inBounds(current, fillOffset)) {\n          switch (dragDirection) {\n            case 'up':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row - fillOffset,\n                rowspan: current.rowspan,\n                col: current.col,\n                colspan: current.colspan\n              });\n              break;\n            case 'down':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row + fillOffset,\n                rowspan: current.rowspan,\n                col: current.col,\n                colspan: current.colspan\n              });\n              break;\n            case 'left':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row,\n                rowspan: current.rowspan,\n                col: current.col - fillOffset,\n                colspan: current.colspan\n              });\n              break;\n            case 'right':\n              this.plugin.mergedCellsCollection.add({\n                row: current.row,\n                rowspan: current.rowspan,\n                col: current.col + fillOffset,\n                colspan: current.colspan\n              });\n              break;\n            default:\n          }\n        }\n        if (j === foundMergedCells.length - 1) {\n          multiplier += 1;\n        }\n      }\n    } while (inBounds(current, fillOffset));\n    this.currentFillData = null;\n    this.plugin.hot.render();\n    if (foundMergedCells.length > 0) {\n      this.plugin.ifChromeForceRepaint();\n    }\n  }\n\n  /**\n   * Get the drag range from the changes made.\n   *\n   * @private\n   * @param {Array} changes The changes made.\n   * @returns {object} Object with `from` and `to` properties, both containing `row` and `column` keys.\n   */\n  getRangeFromChanges(changes) {\n    const rows = {\n      min: null,\n      max: null\n    };\n    const columns = {\n      min: null,\n      max: null\n    };\n    arrayEach(changes, change => {\n      const rowIndex = change[0];\n      const columnIndex = this.plugin.hot.propToCol(change[1]);\n      if (rows.min === null || rowIndex < rows.min) {\n        rows.min = rowIndex;\n      }\n      if (rows.max === null || rowIndex > rows.max) {\n        rows.max = rowIndex;\n      }\n      if (columns.min === null || columnIndex < columns.min) {\n        columns.min = columnIndex;\n      }\n      if (columns.max === null || columnIndex > columns.max) {\n        columns.max = columnIndex;\n      }\n    });\n    return {\n      from: {\n        row: rows.min,\n        column: columns.min\n      },\n      to: {\n        row: rows.max,\n        column: columns.max\n      }\n    };\n  }\n\n  /**\n   * Check if the drag area contains any merged cells.\n   *\n   * @param {Array} baseArea The base selection area.\n   * @param {Array} fullArea The base area extended by the drag area.\n   * @param {string} direction Drag direction.\n   * @returns {boolean}\n   */\n  dragAreaOverlapsCollections(baseArea, fullArea, direction) {\n    const dragArea = this.getDragArea(baseArea, fullArea, direction);\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    const topLeft = this.plugin.hot._createCellCoords(dragAreaStartRow, dragAreaStartColumn);\n    const bottomRight = this.plugin.hot._createCellCoords(dragAreaEndRow, dragAreaEndColumn);\n    const dragRange = this.plugin.hot._createCellRange(topLeft, topLeft, bottomRight);\n    return this.mergedCellsCollection.getWithinRange(dragRange, true).length > 0;\n  }\n}\nexport default AutofillCalculations;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}