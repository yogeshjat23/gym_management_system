{"ast":null,"code":"import { stopImmediatePropagation } from \"../../../helpers/dom/event.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { hasClass } from \"../../../helpers/dom/element.mjs\";\nimport BaseUI from \"./_base.mjs\";\nimport HeadersUI from \"./headers.mjs\";\n/**\n * Class responsible for the UI for collapsing and expanding groups.\n *\n * @private\n * @class\n * @augments BaseUI\n */\nclass CollapsingUI extends BaseUI {\n  constructor(nestedRowsPlugin, hotInstance) {\n    var _this;\n    /**\n     * Reference to the TrimRows plugin.\n     */\n    super(nestedRowsPlugin, hotInstance);\n    _this = this;\n    this.dataManager = this.plugin.dataManager;\n    this.collapsedRows = [];\n    this.collapsedRowsStash = {\n      stash: function () {\n        let forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        _this.lastCollapsedRows = _this.collapsedRows.slice(0);\n\n        // Workaround for wrong indexes being set in the trimRows plugin\n        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);\n      },\n      shiftStash: function (baseIndex, targetIndex) {\n        let delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        if (targetIndex === null || targetIndex === undefined) {\n          targetIndex = Infinity;\n        }\n        arrayEach(_this.lastCollapsedRows, (elem, i) => {\n          if (elem >= baseIndex && elem < targetIndex) {\n            _this.lastCollapsedRows[i] = elem + delta;\n          }\n        });\n      },\n      applyStash: function () {\n        let forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);\n        _this.lastCollapsedRows = undefined;\n      },\n      trimStash: (realElementIndex, amount) => {\n        rangeEach(realElementIndex, realElementIndex + amount - 1, i => {\n          const indexOfElement = this.lastCollapsedRows.indexOf(i);\n          if (indexOfElement > -1) {\n            this.lastCollapsedRows.splice(indexOfElement, 1);\n          }\n        });\n      }\n    };\n  }\n\n  /**\n   * Collapse the children of the row passed as an argument.\n   *\n   * @param {number|object} row The parent row.\n   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   * @returns {Array}\n   */\n  collapseChildren(row) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToCollapse = [];\n    let rowObject = null;\n    let rowIndex = null;\n    let rowsToTrim = null;\n    if (isNaN(row)) {\n      rowObject = row;\n      rowIndex = this.dataManager.getRowIndex(rowObject);\n    } else {\n      rowObject = this.dataManager.getDataObject(row);\n      rowIndex = row;\n    }\n    if (this.dataManager.hasChildren(rowObject)) {\n      arrayEach(rowObject.__children, elem => {\n        rowsToCollapse.push(this.dataManager.getRowIndex(elem));\n      });\n    }\n    rowsToTrim = this.collapseRows(rowsToCollapse, true, false);\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n    if (this.collapsedRows.indexOf(rowIndex) === -1) {\n      this.collapsedRows.push(rowIndex);\n    }\n    return rowsToTrim;\n  }\n\n  /**\n   * Collapse multiple children.\n   *\n   * @param {Array} rows Rows to collapse (including their children).\n   * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   */\n  collapseMultipleChildren(rows) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToTrim = [];\n    arrayEach(rows, elem => {\n      rowsToTrim.push(...this.collapseChildren(elem, false, false));\n    });\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n  }\n\n  /**\n   * Collapse a single row.\n   *\n   * @param {number} rowIndex Index of the row to collapse.\n   * @param {boolean} [recursive=true] `true` if it should collapse the row's children.\n   */\n  collapseRow(rowIndex) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.collapseRows([rowIndex], recursive);\n  }\n\n  /**\n   * Collapse multiple rows.\n   *\n   * @param {Array} rowIndexes Array of row indexes to collapse.\n   * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).\n   */\n  collapseRows(rowIndexes) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const rowsToTrim = [];\n    arrayEach(rowIndexes, elem => {\n      rowsToTrim.push(elem);\n      if (recursive) {\n        this.collapseChildRows(elem, rowsToTrim);\n      }\n    });\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    return rowsToTrim;\n  }\n\n  /**\n   * Collapse child rows of the row at the provided index.\n   *\n   * @param {number} parentIndex Index of the parent node.\n   * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.\n   * @param {boolean} [recursive] `true` if the collapsing process should be recursive.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   */\n  collapseChildRows(parentIndex) {\n    let rowsToTrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let recursive = arguments.length > 2 ? arguments[2] : undefined;\n    let doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (this.dataManager.hasChildren(parentIndex)) {\n      const parentObject = this.dataManager.getDataObject(parentIndex);\n      arrayEach(parentObject.__children, elem => {\n        const elemIndex = this.dataManager.getRowIndex(elem);\n        rowsToTrim.push(elemIndex);\n        this.collapseChildRows(elemIndex, rowsToTrim);\n      });\n    }\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n  }\n\n  /**\n   * Expand a single row.\n   *\n   * @param {number} rowIndex Index of the row to expand.\n   * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.\n   */\n  expandRow(rowIndex) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.expandRows([rowIndex], recursive);\n  }\n\n  /**\n   * Expand multiple rows.\n   *\n   * @param {Array} rowIndexes Array of indexes of the rows to expand.\n   * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   * @returns {Array} Array of row indexes to be untrimmed.\n   */\n  expandRows(rowIndexes) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const rowsToUntrim = [];\n    arrayEach(rowIndexes, elem => {\n      rowsToUntrim.push(elem);\n      if (recursive) {\n        this.expandChildRows(elem, rowsToUntrim);\n      }\n    });\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    return rowsToUntrim;\n  }\n\n  /**\n   * Expand child rows of the provided index.\n   *\n   * @param {number} parentIndex Index of the parent row.\n   * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.\n   * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.\n   * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.\n   */\n  expandChildRows(parentIndex) {\n    let rowsToUntrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let recursive = arguments.length > 2 ? arguments[2] : undefined;\n    let doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (this.dataManager.hasChildren(parentIndex)) {\n      const parentObject = this.dataManager.getDataObject(parentIndex);\n      arrayEach(parentObject.__children, elem => {\n        if (!this.isAnyParentCollapsed(elem)) {\n          const elemIndex = this.dataManager.getRowIndex(elem);\n          rowsToUntrim.push(elemIndex);\n          this.expandChildRows(elemIndex, rowsToUntrim);\n        }\n      });\n    }\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n  }\n\n  /**\n   * Expand the children of the row passed as an argument.\n   *\n   * @param {number|object} row Parent row.\n   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\n   * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.\n   * @returns {number[]}\n   */\n  expandChildren(row) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToExpand = [];\n    let rowObject = null;\n    let rowIndex = null;\n    let rowsToUntrim = null;\n    if (isNaN(row)) {\n      rowObject = row;\n      rowIndex = this.dataManager.getRowIndex(row);\n    } else {\n      rowObject = this.dataManager.getDataObject(row);\n      rowIndex = row;\n    }\n    this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);\n    if (this.dataManager.hasChildren(rowObject)) {\n      arrayEach(rowObject.__children, elem => {\n        const childIndex = this.dataManager.getRowIndex(elem);\n        rowsToExpand.push(childIndex);\n      });\n    }\n    rowsToUntrim = this.expandRows(rowsToExpand, true, false);\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n    return rowsToUntrim;\n  }\n\n  /**\n   * Expand multiple rows' children.\n   *\n   * @param {Array} rows Array of rows which children are about to be expanded.\n   * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.\n   * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.\n   */\n  expandMultipleChildren(rows) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToUntrim = [];\n    arrayEach(rows, elem => {\n      rowsToUntrim.push(...this.expandChildren(elem, false, false));\n    });\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n  }\n\n  /**\n   * Collapse all collapsable rows.\n   */\n  collapseAll() {\n    const data = this.dataManager.getData();\n    const parentsToCollapse = [];\n    arrayEach(data, elem => {\n      if (this.dataManager.hasChildren(elem)) {\n        parentsToCollapse.push(elem);\n      }\n    });\n    this.collapseMultipleChildren(parentsToCollapse);\n    this.renderAndAdjust();\n  }\n\n  /**\n   * Expand all collapsable rows.\n   */\n  expandAll() {\n    const data = this.dataManager.getData();\n    const parentsToExpand = [];\n    arrayEach(data, elem => {\n      if (this.dataManager.hasChildren(elem)) {\n        parentsToExpand.push(elem);\n      }\n    });\n    this.expandMultipleChildren(parentsToExpand);\n    this.renderAndAdjust();\n  }\n\n  /**\n   * Trim rows.\n   *\n   * @param {Array} rows Physical row indexes.\n   */\n  trimRows(rows) {\n    this.hot.batchExecution(() => {\n      arrayEach(rows, physicalRow => {\n        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);\n      });\n    }, true);\n  }\n\n  /**\n   * Untrim rows.\n   *\n   * @param {Array} rows Physical row indexes.\n   */\n  untrimRows(rows) {\n    this.hot.batchExecution(() => {\n      arrayEach(rows, physicalRow => {\n        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);\n      });\n    }, true);\n  }\n\n  /**\n   * Check if all child rows are collapsed.\n   *\n   * @private\n   * @param {number|object|null} row The parent row. `null` for the top level.\n   * @returns {boolean}\n   */\n  areChildrenCollapsed(row) {\n    let rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);\n    let allCollapsed = true;\n\n    // Checking the children of the top-level \"parent\"\n    if (rowObj === null) {\n      rowObj = {\n        __children: this.dataManager.data\n      };\n    }\n    if (this.dataManager.hasChildren(rowObj)) {\n      arrayEach(rowObj.__children, elem => {\n        const rowIndex = this.dataManager.getRowIndex(elem);\n        if (!this.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {\n          allCollapsed = false;\n          return false;\n        }\n      });\n    }\n    return allCollapsed;\n  }\n\n  /**\n   * Check if any of the row object parents are collapsed.\n   *\n   * @private\n   * @param {object} rowObj Row object.\n   * @returns {boolean}\n   */\n  isAnyParentCollapsed(rowObj) {\n    let parent = rowObj;\n    while (parent !== null) {\n      parent = this.dataManager.getRowParent(parent);\n      const parentIndex = this.dataManager.getRowIndex(parent);\n      if (this.collapsedRows.indexOf(parentIndex) > -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.\n   *\n   * @private\n   * @param {MouseEvent} event `mousedown` event.\n   * @param {object} coords Coordinates of the clicked cell/header.\n   */\n  toggleState(event, coords) {\n    if (coords.col >= 0) {\n      return;\n    }\n    const row = this.translateTrimmedRow(coords.row);\n    if (hasClass(event.target, HeadersUI.CSS_CLASSES.button)) {\n      if (this.areChildrenCollapsed(row)) {\n        this.expandChildren(row);\n      } else {\n        this.collapseChildren(row);\n      }\n      stopImmediatePropagation(event);\n    }\n  }\n\n  /**\n   * Translate visual row after trimming to physical base row index.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number} Base row index.\n   */\n  translateTrimmedRow(row) {\n    return this.hot.toPhysicalRow(row);\n  }\n\n  /**\n   * Translate physical row after trimming to visual base row index.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number} Base row index.\n   */\n  untranslateTrimmedRow(row) {\n    return this.hot.toVisualRow(row);\n  }\n\n  /**\n   * Helper function to render the table and call the `adjustElementsSize` method.\n   *\n   * @private\n   */\n  renderAndAdjust() {\n    this.hot.render();\n\n    // Dirty workaround to prevent scroll height not adjusting to the table height. Needs refactoring in the future.\n    this.hot.view.adjustElementsSize();\n  }\n}\nexport default CollapsingUI;","map":{"version":3,"names":["stopImmediatePropagation","arrayEach","rangeEach","hasClass","BaseUI","HeadersUI","CollapsingUI","constructor","nestedRowsPlugin","hotInstance","_this","dataManager","plugin","collapsedRows","collapsedRowsStash","stash","forceRender","arguments","length","undefined","lastCollapsedRows","slice","expandMultipleChildren","shiftStash","baseIndex","targetIndex","delta","Infinity","elem","i","applyStash","collapseMultipleChildren","trimStash","realElementIndex","amount","indexOfElement","indexOf","splice","collapseChildren","row","doTrimming","rowsToCollapse","rowObject","rowIndex","rowsToTrim","isNaN","getRowIndex","getDataObject","hasChildren","__children","push","collapseRows","trimRows","renderAndAdjust","rows","collapseRow","recursive","rowIndexes","collapseChildRows","parentIndex","parentObject","elemIndex","expandRow","expandRows","rowsToUntrim","expandChildRows","untrimRows","isAnyParentCollapsed","expandChildren","rowsToExpand","childIndex","collapseAll","data","getData","parentsToCollapse","expandAll","parentsToExpand","hot","batchExecution","physicalRow","collapsedRowsMap","setValueAtIndex","areChildrenCollapsed","rowObj","allCollapsed","getValueAtIndex","parent","getRowParent","toggleState","event","coords","col","translateTrimmedRow","target","CSS_CLASSES","button","toPhysicalRow","untranslateTrimmedRow","toVisualRow","render","view","adjustElementsSize"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedRows/ui/collapsing.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport { stopImmediatePropagation } from \"../../../helpers/dom/event.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { hasClass } from \"../../../helpers/dom/element.mjs\";\nimport BaseUI from \"./_base.mjs\";\nimport HeadersUI from \"./headers.mjs\";\n/**\n * Class responsible for the UI for collapsing and expanding groups.\n *\n * @private\n * @class\n * @augments BaseUI\n */\nclass CollapsingUI extends BaseUI {\n  constructor(nestedRowsPlugin, hotInstance) {\n    var _this;\n    /**\n     * Reference to the TrimRows plugin.\n     */\n    super(nestedRowsPlugin, hotInstance);\n    _this = this;\n    this.dataManager = this.plugin.dataManager;\n    this.collapsedRows = [];\n    this.collapsedRowsStash = {\n      stash: function () {\n        let forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        _this.lastCollapsedRows = _this.collapsedRows.slice(0);\n\n        // Workaround for wrong indexes being set in the trimRows plugin\n        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);\n      },\n      shiftStash: function (baseIndex, targetIndex) {\n        let delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        if (targetIndex === null || targetIndex === undefined) {\n          targetIndex = Infinity;\n        }\n        arrayEach(_this.lastCollapsedRows, (elem, i) => {\n          if (elem >= baseIndex && elem < targetIndex) {\n            _this.lastCollapsedRows[i] = elem + delta;\n          }\n        });\n      },\n      applyStash: function () {\n        let forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);\n        _this.lastCollapsedRows = undefined;\n      },\n      trimStash: (realElementIndex, amount) => {\n        rangeEach(realElementIndex, realElementIndex + amount - 1, i => {\n          const indexOfElement = this.lastCollapsedRows.indexOf(i);\n          if (indexOfElement > -1) {\n            this.lastCollapsedRows.splice(indexOfElement, 1);\n          }\n        });\n      }\n    };\n  }\n\n  /**\n   * Collapse the children of the row passed as an argument.\n   *\n   * @param {number|object} row The parent row.\n   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   * @returns {Array}\n   */\n  collapseChildren(row) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToCollapse = [];\n    let rowObject = null;\n    let rowIndex = null;\n    let rowsToTrim = null;\n    if (isNaN(row)) {\n      rowObject = row;\n      rowIndex = this.dataManager.getRowIndex(rowObject);\n    } else {\n      rowObject = this.dataManager.getDataObject(row);\n      rowIndex = row;\n    }\n    if (this.dataManager.hasChildren(rowObject)) {\n      arrayEach(rowObject.__children, elem => {\n        rowsToCollapse.push(this.dataManager.getRowIndex(elem));\n      });\n    }\n    rowsToTrim = this.collapseRows(rowsToCollapse, true, false);\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n    if (this.collapsedRows.indexOf(rowIndex) === -1) {\n      this.collapsedRows.push(rowIndex);\n    }\n    return rowsToTrim;\n  }\n\n  /**\n   * Collapse multiple children.\n   *\n   * @param {Array} rows Rows to collapse (including their children).\n   * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   */\n  collapseMultipleChildren(rows) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToTrim = [];\n    arrayEach(rows, elem => {\n      rowsToTrim.push(...this.collapseChildren(elem, false, false));\n    });\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n  }\n\n  /**\n   * Collapse a single row.\n   *\n   * @param {number} rowIndex Index of the row to collapse.\n   * @param {boolean} [recursive=true] `true` if it should collapse the row's children.\n   */\n  collapseRow(rowIndex) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.collapseRows([rowIndex], recursive);\n  }\n\n  /**\n   * Collapse multiple rows.\n   *\n   * @param {Array} rowIndexes Array of row indexes to collapse.\n   * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).\n   */\n  collapseRows(rowIndexes) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const rowsToTrim = [];\n    arrayEach(rowIndexes, elem => {\n      rowsToTrim.push(elem);\n      if (recursive) {\n        this.collapseChildRows(elem, rowsToTrim);\n      }\n    });\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    return rowsToTrim;\n  }\n\n  /**\n   * Collapse child rows of the row at the provided index.\n   *\n   * @param {number} parentIndex Index of the parent node.\n   * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.\n   * @param {boolean} [recursive] `true` if the collapsing process should be recursive.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   */\n  collapseChildRows(parentIndex) {\n    let rowsToTrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let recursive = arguments.length > 2 ? arguments[2] : undefined;\n    let doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (this.dataManager.hasChildren(parentIndex)) {\n      const parentObject = this.dataManager.getDataObject(parentIndex);\n      arrayEach(parentObject.__children, elem => {\n        const elemIndex = this.dataManager.getRowIndex(elem);\n        rowsToTrim.push(elemIndex);\n        this.collapseChildRows(elemIndex, rowsToTrim);\n      });\n    }\n    if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n  }\n\n  /**\n   * Expand a single row.\n   *\n   * @param {number} rowIndex Index of the row to expand.\n   * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.\n   */\n  expandRow(rowIndex) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.expandRows([rowIndex], recursive);\n  }\n\n  /**\n   * Expand multiple rows.\n   *\n   * @param {Array} rowIndexes Array of indexes of the rows to expand.\n   * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\n   * @returns {Array} Array of row indexes to be untrimmed.\n   */\n  expandRows(rowIndexes) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const rowsToUntrim = [];\n    arrayEach(rowIndexes, elem => {\n      rowsToUntrim.push(elem);\n      if (recursive) {\n        this.expandChildRows(elem, rowsToUntrim);\n      }\n    });\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    return rowsToUntrim;\n  }\n\n  /**\n   * Expand child rows of the provided index.\n   *\n   * @param {number} parentIndex Index of the parent row.\n   * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.\n   * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.\n   * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.\n   */\n  expandChildRows(parentIndex) {\n    let rowsToUntrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let recursive = arguments.length > 2 ? arguments[2] : undefined;\n    let doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (this.dataManager.hasChildren(parentIndex)) {\n      const parentObject = this.dataManager.getDataObject(parentIndex);\n      arrayEach(parentObject.__children, elem => {\n        if (!this.isAnyParentCollapsed(elem)) {\n          const elemIndex = this.dataManager.getRowIndex(elem);\n          rowsToUntrim.push(elemIndex);\n          this.expandChildRows(elemIndex, rowsToUntrim);\n        }\n      });\n    }\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n  }\n\n  /**\n   * Expand the children of the row passed as an argument.\n   *\n   * @param {number|object} row Parent row.\n   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\n   * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.\n   * @returns {number[]}\n   */\n  expandChildren(row) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToExpand = [];\n    let rowObject = null;\n    let rowIndex = null;\n    let rowsToUntrim = null;\n    if (isNaN(row)) {\n      rowObject = row;\n      rowIndex = this.dataManager.getRowIndex(row);\n    } else {\n      rowObject = this.dataManager.getDataObject(row);\n      rowIndex = row;\n    }\n    this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);\n    if (this.dataManager.hasChildren(rowObject)) {\n      arrayEach(rowObject.__children, elem => {\n        const childIndex = this.dataManager.getRowIndex(elem);\n        rowsToExpand.push(childIndex);\n      });\n    }\n    rowsToUntrim = this.expandRows(rowsToExpand, true, false);\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n    return rowsToUntrim;\n  }\n\n  /**\n   * Expand multiple rows' children.\n   *\n   * @param {Array} rows Array of rows which children are about to be expanded.\n   * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.\n   * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.\n   */\n  expandMultipleChildren(rows) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rowsToUntrim = [];\n    arrayEach(rows, elem => {\n      rowsToUntrim.push(...this.expandChildren(elem, false, false));\n    });\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    if (forceRender) {\n      this.renderAndAdjust();\n    }\n  }\n\n  /**\n   * Collapse all collapsable rows.\n   */\n  collapseAll() {\n    const data = this.dataManager.getData();\n    const parentsToCollapse = [];\n    arrayEach(data, elem => {\n      if (this.dataManager.hasChildren(elem)) {\n        parentsToCollapse.push(elem);\n      }\n    });\n    this.collapseMultipleChildren(parentsToCollapse);\n    this.renderAndAdjust();\n  }\n\n  /**\n   * Expand all collapsable rows.\n   */\n  expandAll() {\n    const data = this.dataManager.getData();\n    const parentsToExpand = [];\n    arrayEach(data, elem => {\n      if (this.dataManager.hasChildren(elem)) {\n        parentsToExpand.push(elem);\n      }\n    });\n    this.expandMultipleChildren(parentsToExpand);\n    this.renderAndAdjust();\n  }\n\n  /**\n   * Trim rows.\n   *\n   * @param {Array} rows Physical row indexes.\n   */\n  trimRows(rows) {\n    this.hot.batchExecution(() => {\n      arrayEach(rows, physicalRow => {\n        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);\n      });\n    }, true);\n  }\n\n  /**\n   * Untrim rows.\n   *\n   * @param {Array} rows Physical row indexes.\n   */\n  untrimRows(rows) {\n    this.hot.batchExecution(() => {\n      arrayEach(rows, physicalRow => {\n        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);\n      });\n    }, true);\n  }\n\n  /**\n   * Check if all child rows are collapsed.\n   *\n   * @private\n   * @param {number|object|null} row The parent row. `null` for the top level.\n   * @returns {boolean}\n   */\n  areChildrenCollapsed(row) {\n    let rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);\n    let allCollapsed = true;\n\n    // Checking the children of the top-level \"parent\"\n    if (rowObj === null) {\n      rowObj = {\n        __children: this.dataManager.data\n      };\n    }\n    if (this.dataManager.hasChildren(rowObj)) {\n      arrayEach(rowObj.__children, elem => {\n        const rowIndex = this.dataManager.getRowIndex(elem);\n        if (!this.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {\n          allCollapsed = false;\n          return false;\n        }\n      });\n    }\n    return allCollapsed;\n  }\n\n  /**\n   * Check if any of the row object parents are collapsed.\n   *\n   * @private\n   * @param {object} rowObj Row object.\n   * @returns {boolean}\n   */\n  isAnyParentCollapsed(rowObj) {\n    let parent = rowObj;\n    while (parent !== null) {\n      parent = this.dataManager.getRowParent(parent);\n      const parentIndex = this.dataManager.getRowIndex(parent);\n      if (this.collapsedRows.indexOf(parentIndex) > -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.\n   *\n   * @private\n   * @param {MouseEvent} event `mousedown` event.\n   * @param {object} coords Coordinates of the clicked cell/header.\n   */\n  toggleState(event, coords) {\n    if (coords.col >= 0) {\n      return;\n    }\n    const row = this.translateTrimmedRow(coords.row);\n    if (hasClass(event.target, HeadersUI.CSS_CLASSES.button)) {\n      if (this.areChildrenCollapsed(row)) {\n        this.expandChildren(row);\n      } else {\n        this.collapseChildren(row);\n      }\n      stopImmediatePropagation(event);\n    }\n  }\n\n  /**\n   * Translate visual row after trimming to physical base row index.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number} Base row index.\n   */\n  translateTrimmedRow(row) {\n    return this.hot.toPhysicalRow(row);\n  }\n\n  /**\n   * Translate physical row after trimming to visual base row index.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number} Base row index.\n   */\n  untranslateTrimmedRow(row) {\n    return this.hot.toVisualRow(row);\n  }\n\n  /**\n   * Helper function to render the table and call the `adjustElementsSize` method.\n   *\n   * @private\n   */\n  renderAndAdjust() {\n    this.hot.render();\n\n    // Dirty workaround to prevent scroll height not adjusting to the table height. Needs refactoring in the future.\n    this.hot.view.adjustElementsSize();\n  }\n}\nexport default CollapsingUI;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}