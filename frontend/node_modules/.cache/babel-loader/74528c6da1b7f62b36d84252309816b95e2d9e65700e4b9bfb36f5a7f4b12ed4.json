{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport Highlight, { AREA_TYPE, HEADER_TYPE, FOCUS_TYPE } from \"./highlight/highlight.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { clamp } from \"./../helpers/number.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\nimport { A11Y_SELECTED } from \"../helpers/a11y.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar _transformation = /*#__PURE__*/new WeakMap();\nvar _focusTransformation = /*#__PURE__*/new WeakMap();\nvar _isFocusSelectionChanged = /*#__PURE__*/new WeakMap();\nvar _disableHeadersHighlight = /*#__PURE__*/new WeakMap();\nvar _selectionSource = /*#__PURE__*/new WeakMap();\nvar _expectedLayersCount = /*#__PURE__*/new WeakMap();\nclass Selection {\n  constructor(settings, tableProps) {\n    var _this = this;\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"tableProps\", void 0);\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    _defineProperty(this, \"selectedRange\", new SelectionRange((highlight, from, to) => {\n      return this.tableProps.createCellRange(highlight, from, to);\n    }));\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    _defineProperty(this, \"highlight\", void 0);\n    /**\n     * The module for modifying coordinates of the start and end selection.\n     *\n     * @type {Transformation}\n     */\n    _classPrivateFieldInitSpec(this, _transformation, void 0);\n    /**\n     * The module for modifying coordinates of the focus selection.\n     *\n     * @type {Transformation}\n     */\n    _classPrivateFieldInitSpec(this, _focusTransformation, void 0);\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByRowHeader\", new Set());\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByColumnHeader\", new Set());\n    /**\n     * The flag which determines if the focus selection was changed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isFocusSelectionChanged, false);\n    /**\n     * When sets disable highlighting the headers even when the logical coordinates points on them.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, false);\n    /**\n     * The source of the selection. It can be one of the following values: `mouse`, `unknown` or any other string.\n     *\n     * @type {'mouse' | 'unknown' | string}\n     */\n    _classPrivateFieldInitSpec(this, _selectionSource, 'unknown');\n    /**\n     * The number of expected layers. It is used mostly to track when the last selection layer of non-contiguous\n     * selection is applied, thus the viewport scroll is triggered.\n     *\n     * @param {number}\n     */\n    _classPrivateFieldInitSpec(this, _expectedLayersCount, -1);\n    this.settings = settings;\n    this.tableProps = tableProps;\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      cellAttributes: [A11Y_SELECTED()],\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),\n      cellCornerVisible: function () {\n        return _this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: function () {\n        return _this.isAreaCornerVisible(...arguments);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)\n    });\n    _classPrivateFieldSet(_transformation, this, new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => this.tableProps.countRenderableRows(),\n      countRenderableColumns: () => this.tableProps.countRenderableColumns(),\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      findFirstNonHiddenRenderableRow: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);\n      },\n      findFirstNonHiddenRenderableColumn: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);\n      },\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n      autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => settings.autoWrapCol\n    }));\n    _classPrivateFieldSet(_focusTransformation, this, new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => {\n        const range = this.selectedRange.current();\n        return this.tableProps.countRenderableRowsInRange(0, range.getOuterBottomEndCorner().row);\n      },\n      countRenderableColumns: () => {\n        const range = this.selectedRange.current();\n        return this.tableProps.countRenderableColumnsInRange(0, range.getOuterBottomEndCorner().col);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      findFirstNonHiddenRenderableRow: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);\n      },\n      findFirstNonHiddenRenderableColumn: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);\n      },\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      fixedRowsBottom: () => 0,\n      minSpareRows: () => 0,\n      minSpareCols: () => 0,\n      autoWrapRow: () => true,\n      autoWrapCol: () => true\n    }));\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks('beforeModifyTransformStart', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks('afterModifyTransformStart', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks('afterModifyTransformEnd', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks('insertRowRequire', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks('insertColRequire', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeRowWrap', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.runLocalHooks('beforeRowWrap', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeColumnWrap', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _this.runLocalHooks('beforeColumnWrap', ...args);\n    });\n    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('beforeTransformStart', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _this.runLocalHooks('beforeModifyTransformFocus', ...args);\n    });\n    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('afterTransformStart', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _this.runLocalHooks('afterModifyTransformFocus', ...args);\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  getSelectedRange() {\n    return this.selectedRange;\n  }\n\n  /**\n   * Marks the source of the selection. It can be one of the following values: `mouse`, or any other string.\n   *\n   * @param {'mouse' | 'unknown' | string} sourceName The source name.\n   */\n  markSource(sourceName) {\n    _classPrivateFieldSet(_selectionSource, this, sourceName);\n  }\n\n  /**\n   * Marks end of the selection source. It restores the selection source to default value which is 'unknown'.\n   */\n  markEndSource() {\n    _classPrivateFieldSet(_selectionSource, this, 'unknown');\n  }\n\n  /**\n   * Returns the source of the selection.\n   *\n   * @returns {'mouse' | 'unknown' | string}\n   */\n  getSelectionSource() {\n    return _classPrivateFieldGet(_selectionSource, this);\n  }\n\n  /**\n   * Set the number of expected layers. The method is not obligatory to call. It is used mostly internally\n   * to determine when the last selection layer of non-contiguous is applied, thus the viewport scroll is triggered.\n   *\n   * @param {number} layersCount The number of expected layers.\n   */\n  setExpectedLayers(layersCount) {\n    _classPrivateFieldSet(_expectedLayersCount, this, layersCount);\n  }\n\n  /**\n   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.\n   */\n  begin() {\n    this.inProgress = true;\n  }\n\n  /**\n   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.\n   */\n  finish() {\n    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n    this.inProgress = false;\n    _classPrivateFieldSet(_expectedLayersCount, this, -1);\n  }\n\n  /**\n   * Check if the process of selecting the cell/cells is in progress.\n   *\n   * @returns {boolean}\n   */\n  isInProgress() {\n    return this.inProgress;\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;\n    const isMultipleMode = this.settings.selectionMode === 'multiple';\n    const isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n    // should be handled by next methods.\n    const coordsClone = coords.clone();\n    _classPrivateFieldSet(_isFocusSelectionChanged, this, false);\n    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);\n    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n      this.selectedRange.clear();\n    }\n    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());\n    if (this.getLayerLevel() === 0) {\n      this.selectedByRowHeader.clear();\n      this.selectedByColumnHeader.clear();\n    }\n    if (!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStartOnly(coords, multipleSelection) {\n    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;\n    this.setRangeStart(coords, multipleSelection, true, highlightCoords);\n  }\n\n  /**\n   * Ends selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   */\n  setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const coordsClone = coords.clone();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();\n\n    // Ignore processing the end range when the header selection starts overlapping the corner and\n    // the selection is not a single header highlight.\n    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {\n      return;\n    }\n    this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n    this.begin();\n    const cellRange = this.selectedRange.current();\n    if (!this.settings.navigableHeaders) {\n      cellRange.highlight.normalize();\n    }\n    if (this.settings.selectionMode === 'single') {\n      cellRange.setFrom(cellRange.highlight);\n      cellRange.setTo(cellRange.highlight);\n    } else {\n      const horizontalDir = cellRange.getHorizontalDirection();\n      const verticalDir = cellRange.getVerticalDirection();\n      const isMultiple = this.isMultiple();\n      cellRange.setTo(coordsClone);\n      if (isMultiple && (horizontalDir !== cellRange.getHorizontalDirection() || cellRange.getWidth() === 1 && !cellRange.includes(cellRange.highlight))) {\n        cellRange.from.assign({\n          col: cellRange.highlight.col\n        });\n      }\n      if (isMultiple && (verticalDir !== cellRange.getVerticalDirection() || cellRange.getHeight() === 1 && !cellRange.includes(cellRange.highlight))) {\n        cellRange.from.assign({\n          row: cellRange.highlight.row\n        });\n      }\n    }\n\n    // Prevent creating \"area\" selection that overlaps headers.\n    if (countRows > 0 && countCols > 0) {\n      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {\n        cellRange.to.normalize();\n      }\n    }\n    this.runLocalHooks('beforeHighlightSet');\n    this.setRangeFocus(this.selectedRange.current().highlight);\n    this.applyAndCommit();\n    const isLastLayer = _classPrivateFieldGet(_expectedLayersCount, this) === -1 || this.selectedRange.size() === _classPrivateFieldGet(_expectedLayersCount, this);\n    this.runLocalHooks('afterSetRangeEnd', coords, isLastLayer);\n  }\n\n  /**\n   * Applies and commits the selection to all layers (using the Walkontable Selection API) based on the selection (CellRanges)\n   * collected in the `selectedRange` module.\n   *\n   * @param {CellRange} [cellRange] The cell range to apply. If not provided, the current selection is used.\n   * @param {number} [layerLevel] The layer level to apply. If not provided, the current layer level is used.\n   */\n  applyAndCommit() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedRange.current();\n    let layerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLayerLevel();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n\n    // If the next layer level is lower than previous then clear all area and header highlights. This is the\n    // indication that the new selection is performing.\n    if (layerLevel < this.highlight.layerLevel) {\n      arrayEach(this.highlight.getAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getLayeredAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHighlights(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHighlights(), highlight => void highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n    const areaHighlight = this.highlight.createArea();\n    const layeredAreaHighlight = this.highlight.createLayeredArea();\n    const rowHeaderHighlight = this.highlight.createRowHeader();\n    const columnHeaderHighlight = this.highlight.createColumnHeader();\n    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n    const rowHighlight = this.highlight.createRowHighlight();\n    const columnHighlight = this.highlight.createColumnHighlight();\n    areaHighlight.clear();\n    layeredAreaHighlight.clear();\n    rowHeaderHighlight.clear();\n    columnHeaderHighlight.clear();\n    activeRowHeaderHighlight.clear();\n    activeColumnHeaderHighlight.clear();\n    activeCornerHeaderHighlight.clear();\n    rowHighlight.clear();\n    columnHighlight.clear();\n    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n      areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if (layerLevel === 1) {\n        // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n        const previousRange = this.selectedRange.previous();\n        this.highlight.useLayerLevel(layerLevel - 1);\n        this.highlight.createArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.createLayeredArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      if (!cellRange.isSingleHeader()) {\n        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);\n        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);\n        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));\n        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);\n        if (this.settings.selectionMode === 'single') {\n          rowHeaderHighlight.add(rowCoordsFrom).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).commit();\n          rowHighlight.add(rowCoordsFrom).commit();\n          columnHighlight.add(columnCoordsFrom).commit();\n        } else {\n          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n        }\n      }\n      const highlightRowHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());\n      const highlightColumnHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());\n      if (highlightRowHeaders) {\n        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();\n      }\n      if (highlightColumnHeaders) {\n        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();\n      }\n      if (highlightRowHeaders && highlightColumnHeaders) {\n        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();\n      }\n    }\n  }\n\n  /**\n   * Sets the selection focus position at the specified coordinates.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   */\n  setRangeFocus(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const cellRange = this.selectedRange.current();\n    if (!this.inProgress) {\n      this.runLocalHooks('beforeSetFocus', coords);\n    }\n    const focusHighlight = this.highlight.getFocus();\n    focusHighlight.clear();\n    cellRange.setHighlight(coords);\n    if (!this.inProgress) {\n      this.runLocalHooks('beforeHighlightSet');\n    }\n    if (this.highlight.isEnabledFor(FOCUS_TYPE, cellRange.highlight)) {\n      focusHighlight.add(cellRange.highlight).commit().syncWith(cellRange);\n    }\n    if (!this.inProgress) {\n      _classPrivateFieldSet(_isFocusSelectionChanged, this, true);\n      this.runLocalHooks('afterSetFocus', cellRange.highlight);\n    }\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.\n   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.settings.navigableHeaders) {\n      _classPrivateFieldGet(_transformation, this).setOffsetSize({\n        x: this.tableProps.countRowHeaders(),\n        y: this.tableProps.countColHeaders()\n      });\n    } else {\n      _classPrivateFieldGet(_transformation, this).resetOffsetSize();\n    }\n    this.setRangeStart(_classPrivateFieldGet(_transformation, this).transformStart(rowDelta, colDelta, createMissingRecords));\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformEnd(rowDelta, colDelta) {\n    if (this.settings.navigableHeaders) {\n      _classPrivateFieldGet(_transformation, this).setOffsetSize({\n        x: this.tableProps.countRowHeaders(),\n        y: this.tableProps.countColHeaders()\n      });\n    } else {\n      _classPrivateFieldGet(_transformation, this).resetOffsetSize();\n    }\n    this.setRangeEnd(_classPrivateFieldGet(_transformation, this).transformEnd(rowDelta, colDelta));\n  }\n\n  /**\n   * Transforms the focus cell selection relative to the current focus position.\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformFocus(rowDelta, colDelta) {\n    const range = this.selectedRange.current();\n    const {\n      row,\n      col\n    } = range.getOuterTopStartCorner();\n    const columnsInRange = this.tableProps.countRenderableColumnsInRange(0, col - 1);\n    const rowsInRange = this.tableProps.countRenderableRowsInRange(0, row - 1);\n    if (range.highlight.isHeader()) {\n      // for header focus selection calculate the new coords based on the selection including headers\n      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({\n        x: col < 0 ? Math.abs(col) : -columnsInRange,\n        y: row < 0 ? Math.abs(row) : -rowsInRange\n      });\n    } else {\n      // for focus selection in cells calculate the new coords only based on the selected cells\n      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({\n        x: col < 0 ? 0 : -columnsInRange,\n        y: row < 0 ? 0 : -rowsInRange\n      });\n    }\n    const focusCoords = _classPrivateFieldGet(_focusTransformation, this).transformStart(rowDelta, colDelta);\n    this.setRangeFocus(focusCoords.normalize());\n  }\n\n  /**\n   * Transforms the last selection layer down or up by the index count.\n   *\n   * @param {number} visualRowIndex Visual row index from which the selection will be shifted.\n   * @param {number} amount The number of rows to shift the selection.\n   */\n  shiftRows(visualRowIndex, amount) {\n    if (!this.isSelected()) {\n      return;\n    }\n    const range = this.selectedRange.current();\n    if (this.isSelectedByCorner()) {\n      this.selectAll(true, true, {\n        disableHeadersHighlight: true\n      });\n    } else if (this.isSelectedByColumnHeader() || range.getOuterTopStartCorner().row >= visualRowIndex) {\n      const {\n        from,\n        to,\n        highlight\n      } = range;\n      const countRows = this.tableProps.countRows();\n      const isSelectedByRowHeader = this.isSelectedByRowHeader();\n      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();\n      const minRow = isSelectedByColumnHeader ? -1 : 0;\n      const coordsStartAmount = isSelectedByColumnHeader ? 0 : amount;\n\n      // Remove from the stack the last added selection as that selection below will be\n      // replaced by new transformed selection.\n      this.getSelectedRange().pop();\n      const coordsStart = this.tableProps.createCellCoords(clamp(from.row + coordsStartAmount, minRow, countRows - 1), from.col);\n      const coordsEnd = this.tableProps.createCellCoords(clamp(to.row + amount, minRow, countRows - 1), to.col);\n      this.markSource('shift');\n      if (highlight.row >= visualRowIndex) {\n        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(clamp(highlight.row + amount, 0, countRows - 1), highlight.col));\n      } else {\n        this.setRangeStartOnly(coordsStart, true);\n      }\n      if (isSelectedByRowHeader) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (isSelectedByColumnHeader) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      this.setRangeEnd(coordsEnd);\n      this.markEndSource();\n    }\n  }\n\n  /**\n   * Transforms the last selection layer left or right by the index count.\n   *\n   * @param {number} visualColumnIndex Visual column index from which the selection will be shifted.\n   * @param {number} amount The number of columns to shift the selection.\n   */\n  shiftColumns(visualColumnIndex, amount) {\n    if (!this.isSelected()) {\n      return;\n    }\n    const range = this.selectedRange.current();\n    if (this.isSelectedByCorner()) {\n      this.selectAll(true, true, {\n        disableHeadersHighlight: true\n      });\n    } else if (this.isSelectedByRowHeader() || range.getOuterTopStartCorner().col >= visualColumnIndex) {\n      const {\n        from,\n        to,\n        highlight\n      } = range;\n      const countCols = this.tableProps.countCols();\n      const isSelectedByRowHeader = this.isSelectedByRowHeader();\n      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();\n      const minColumn = isSelectedByRowHeader ? -1 : 0;\n      const coordsStartAmount = isSelectedByRowHeader ? 0 : amount;\n\n      // Remove from the stack the last added selection as that selection below will be\n      // replaced by new transformed selection.\n      this.getSelectedRange().pop();\n      const coordsStart = this.tableProps.createCellCoords(from.row, clamp(from.col + coordsStartAmount, minColumn, countCols - 1));\n      const coordsEnd = this.tableProps.createCellCoords(to.row, clamp(to.col + amount, minColumn, countCols - 1));\n      this.markSource('shift');\n      if (highlight.col >= visualColumnIndex) {\n        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(highlight.row, clamp(highlight.col + amount, 0, countCols - 1)));\n      } else {\n        this.setRangeStartOnly(coordsStart, true);\n      }\n      if (isSelectedByRowHeader) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (isSelectedByColumnHeader) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      this.setRangeEnd(coordsEnd);\n      this.markEndSource();\n    }\n  }\n\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n   */\n  getLayerLevel() {\n    return this.selectedRange.size() - 1;\n  }\n\n  /**\n   * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n   *\n   * @returns {boolean}\n   */\n  isSelected() {\n    return !this.selectedRange.isEmpty();\n  }\n\n  /**\n   * Returns information if we have a multi-selection. This method check multi-selection only on the latest layer of\n   * the selection.\n   *\n   * @returns {boolean}\n   */\n  isMultiple() {\n    if (!this.isSelected()) {\n      return false;\n    }\n    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n    return isMultipleListener.value;\n  }\n\n  /**\n   * Checks if the last selection involves changing the focus cell position only.\n   *\n   * @returns {boolean}\n   */\n  isFocusSelectionChanged() {\n    return this.isSelected() && _classPrivateFieldGet(_isFocusSelectionChanged, this);\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        col\n      } = range.getOuterTopStartCorner();\n      const rowHeaders = this.tableProps.countRowHeaders();\n      const countCols = this.tableProps.countCols();\n      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        row\n      } = range.getOuterTopStartCorner();\n      const colHeaders = this.tableProps.countColHeaders();\n      const countRows = this.tableProps.countRows();\n      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() {\n    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() {\n    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    return this.selectedRange.includes(coords);\n  }\n\n  /**\n   * Returns `true` if the cell corner should be visible.\n   *\n   * @private\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isCellCornerVisible() {\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n  }\n\n  /**\n   * Returns `true` if the cell coordinates are visible (renderable).\n   *\n   * @private\n   * @param {CellCoords} coords The cell coordinates to check.\n   * @returns {boolean}\n   */\n  isCellVisible(coords) {\n    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);\n    return renderableCoords.row !== null && renderableCoords.col !== null;\n  }\n\n  /**\n   * Returns `true` if the area corner should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n      return false;\n    }\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n\n  /**\n   * Clear the selection by resetting the collected ranges and highlights.\n   */\n  clear() {\n    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n    this.selectedRange.clear();\n    this.highlight.clear();\n  }\n\n  /**\n   * Deselects all selected cells.\n   */\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    this.inProgress = false;\n    this.clear();\n    this.runLocalHooks('afterDeselect');\n  }\n\n  /**\n   * Selects all cells and headers.\n   *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   * @param {object} [options] Additional object with options.\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed.\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  selectAll() {\n    var _this$getSelectedRang;\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      focusPosition: false,\n      disableHeadersHighlight: false\n    };\n    const nrOfRows = this.tableProps.countRows();\n    const nrOfColumns = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;\n    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;\n\n    // We can't select cells when there is no data.\n    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {\n      return;\n    }\n    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;\n    const {\n      focusPosition,\n      disableHeadersHighlight\n    } = options;\n    _classPrivateFieldSet(_disableHeadersHighlight, this, disableHeadersHighlight);\n    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n      highlight = this.tableProps.createCellCoords(clamp(focusPosition.row, rowFrom, nrOfRows - 1), clamp(focusPosition.col, columnFrom, nrOfColumns - 1));\n    }\n    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);\n    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    this.clear();\n    this.setRangeStartOnly(startCoords, undefined, highlight);\n    if (columnFrom < 0) {\n      this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if (rowFrom < 0) {\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    this.setRangeEnd(endCoords);\n    this.finish();\n    _classPrivateFieldSet(_disableHeadersHighlight, this, false);\n  }\n\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n   * If the passed ranges have another format the exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    var _this2 = this;\n    const selectionType = detectSelectionType(selectionRanges);\n    if (selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: function () {\n        return _this2.tableProps.createCellCoords(...arguments);\n      },\n      createCellRange: function () {\n        return _this2.tableProps.createCellRange(...arguments);\n      },\n      propToCol: prop => this.tableProps.propToCol(prop),\n      keepDirection: true\n    });\n    const navigableHeaders = this.settings.navigableHeaders;\n    const tableParams = {\n      countRows: this.tableProps.countRows(),\n      countCols: this.tableProps.countCols(),\n      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,\n      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0\n    };\n\n    // Check if every layer of the coordinates are valid.\n    const isValid = !selectionRanges.some(selection => {\n      const cellRange = selectionSchemaNormalizer(selection);\n      const rangeValidity = cellRange.isValid(tableParams);\n      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());\n    });\n    if (isValid) {\n      this.clear();\n      this.setExpectedLayers(selectionRanges.length);\n      arrayEach(selectionRanges, selection => {\n        const {\n          from,\n          to\n        } = selectionSchemaNormalizer(selection);\n        this.setRangeStartOnly(from.clone(), false);\n        this.setRangeEnd(to.clone());\n      });\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n   * `endColumn`.\n   *\n   * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus\n   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive\n   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus\n   * position horizontally.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;\n    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);\n    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders: 0,\n      countColHeaders\n    });\n    if (isValid) {\n      let highlightRow = 0;\n      let highlightColumn = 0;\n      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n        highlightRow = clamp(focusPosition.row, columnHeaderLastIndex, countRows - 1);\n        highlightColumn = clamp(focusPosition.col, Math.min(start, end), Math.max(start, end));\n      } else {\n        highlightRow = clamp(focusPosition, columnHeaderLastIndex, countRows - 1);\n        highlightColumn = start;\n      }\n      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);\n      const fromRow = countColHeaders === 0 ? 0 : clamp(highlight.row, columnHeaderLastIndex, -1);\n      const toRow = countRows - 1;\n      const from = this.tableProps.createCellCoords(fromRow, start);\n      const to = this.tableProps.createCellCoords(toRow, end);\n      this.runLocalHooks('beforeSelectColumns', from, to, highlight);\n\n      // disallow modifying row axis for that hooks\n      from.row = fromRow;\n      to.row = toRow;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectColumns', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which the selection starts.\n   * @param {number} [endRow] Visual row index from to the selection finishes.\n   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus\n   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive\n   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus\n   * position horizontally.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;\n    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);\n    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders,\n      countColHeaders: 0\n    });\n    if (isValid) {\n      let highlightRow = 0;\n      let highlightColumn = 0;\n      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n        highlightRow = clamp(focusPosition.row, Math.min(startRow, endRow), Math.max(startRow, endRow));\n        highlightColumn = clamp(focusPosition.col, rowHeaderLastIndex, countCols - 1);\n      } else {\n        highlightRow = startRow;\n        highlightColumn = clamp(focusPosition, rowHeaderLastIndex, countCols - 1);\n      }\n      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);\n      const fromColumn = countRowHeaders === 0 ? 0 : clamp(highlight.col, rowHeaderLastIndex, -1);\n      const toColumn = countCols - 1;\n      const from = this.tableProps.createCellCoords(startRow, fromColumn);\n      const to = this.tableProps.createCellCoords(endRow, toColumn);\n      this.runLocalHooks('beforeSelectRows', from, to, highlight);\n\n      // disallow modifying column axis for that hooks\n      from.col = fromColumn;\n      to.col = toColumn;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectRows', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Refreshes the whole selection by clearing, reapplying and committing the renderable selection (Walkontable Selection API)\n   * by using already added visual ranges.\n   */\n  refresh() {\n    if (!this.isSelected()) {\n      return;\n    }\n    const countRows = this.tableProps.countRows();\n    const countColumns = this.tableProps.countCols();\n    if (countRows === 0 || countColumns === 0) {\n      this.deselect();\n      return;\n    }\n    const range = this.selectedRange.peekByIndex(this.selectedRange.size() - 1);\n    const {\n      from,\n      to,\n      highlight\n    } = range;\n    this.clear();\n    highlight.assign({\n      row: clamp(highlight.row, -Infinity, countRows - 1),\n      col: clamp(highlight.col, -Infinity, countColumns - 1)\n    });\n    from.assign({\n      row: clamp(from.row, -Infinity, countRows - 1),\n      col: clamp(from.col, -Infinity, countColumns - 1)\n    });\n    to.assign({\n      row: clamp(to.row, 0, countRows - 1),\n      col: clamp(to.col, 0, countColumns - 1)\n    });\n    this.selectedRange.ranges.push(range);\n    this.highlight.getFocus().add(highlight).commit().syncWith(range);\n    this.applyAndCommit(range);\n  }\n\n  /**\n   * Refreshes the whole selection by recommitting (recalculating visual indexes to renderable ones) the renderable selection\n   * that was already added.\n   */\n  commit() {\n    const customSelections = this.highlight.getCustomSelections();\n    customSelections.forEach(customSelection => {\n      customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      return;\n    }\n    const focusHighlight = this.highlight.getFocus();\n    const currentLayer = this.getLayerLevel();\n    focusHighlight.commit().syncWith(this.selectedRange.current());\n\n    // Rewriting rendered ranges going through all layers.\n    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n      this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = this.highlight.createArea();\n      const areaLayeredHighlight = this.highlight.createLayeredArea();\n      const rowHeaderHighlight = this.highlight.createRowHeader();\n      const columnHeaderHighlight = this.highlight.createColumnHeader();\n      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n      const rowHighlight = this.highlight.createRowHighlight();\n      const columnHighlight = this.highlight.createColumnHighlight();\n      areaHighlight.commit();\n      areaLayeredHighlight.commit();\n      rowHeaderHighlight.commit();\n      columnHeaderHighlight.commit();\n      activeRowHeaderHighlight.commit();\n      activeColumnHeaderHighlight.commit();\n      activeCornerHeaderHighlight.commit();\n      rowHighlight.commit();\n      columnHighlight.commit();\n    }\n\n    // Reverting starting layer for the Highlight.\n    this.highlight.useLayerLevel(currentLayer);\n  }\n}\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","n","arguments","length","Highlight","AREA_TYPE","HEADER_TYPE","FOCUS_TYPE","SelectionRange","createObjectPropListener","mixin","isUndefined","clamp","arrayEach","localHooks","Transformation","detectSelectionType","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","A11Y_SELECTED","_transformation","WeakMap","_focusTransformation","_isFocusSelectionChanged","_disableHeadersHighlight","_selectionSource","_expectedLayersCount","Selection","constructor","settings","tableProps","_this","highlight","from","to","createCellRange","Set","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","cellAttributes","rowIndexMapper","columnIndexMapper","disabledCellSelection","row","column","isDisabledCellSelection","cellCornerVisible","isCellCornerVisible","areaCornerVisible","isAreaCornerVisible","visualToRenderableCoords","coords","renderableToVisualCoords","createCellCoords","selectedRange","countRenderableRows","countRenderableColumns","findFirstNonHiddenRenderableRow","findFirstNonHiddenRenderableColumn","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","range","current","countRenderableRowsInRange","getOuterBottomEndCorner","countRenderableColumnsInRange","col","addLocalHook","_len","args","Array","_key","runLocalHooks","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","_len9","_key9","_len10","_key10","getSelectedRange","markSource","sourceName","markEndSource","getSelectionSource","setExpectedLayers","layersCount","begin","inProgress","finish","isInProgress","setRangeStart","multipleSelection","fragment","undefined","highlightCoords","isMultipleMode","selectionMode","isMultipleSelection","getShortcutManager","isCtrlPressed","coordsClone","clone","clear","add","setHighlight","getLayerLevel","selectedByRowHeader","selectedByColumnHeader","setRangeEnd","setRangeStartOnly","isEmpty","countRows","countCols","isSingle","setTo","isSingleHeader","cellRange","navigableHeaders","normalize","setFrom","horizontalDir","getHorizontalDirection","verticalDir","getVerticalDirection","isMultiple","getWidth","includes","assign","getHeight","setRangeFocus","applyAndCommit","isLastLayer","size","layerLevel","getAreas","getLayeredAreas","getRowHeaders","getColumnHeaders","getActiveRowHeaders","getActiveColumnHeaders","getActiveCornerHeaders","getRowHighlights","getColumnHighlights","useLayerLevel","areaHighlight","createArea","layeredAreaHighlight","createLayeredArea","rowHeaderHighlight","createRowHeader","columnHeaderHighlight","createColumnHeader","activeRowHeaderHighlight","createActiveRowHeader","activeColumnHeaderHighlight","createActiveColumnHeader","activeCornerHeaderHighlight","createActiveCornerHeader","rowHighlight","createRowHighlight","columnHighlight","createColumnHighlight","isEnabledFor","commit","previousRange","previous","syncWith","rowCoordsFrom","Math","max","rowCoordsTo","columnCoordsFrom","columnCoordsTo","highlightRowHeaders","isEntireRowSelected","isSelectedByRowHeader","highlightColumnHeaders","isEntireColumnSelected","isSelectedByColumnHeader","min","countRowHeaders","countColHeaders","focusHighlight","getFocus","transformStart","rowDelta","colDelta","createMissingRecords","setOffsetSize","x","y","resetOffsetSize","transformEnd","transformFocus","getOuterTopStartCorner","columnsInRange","rowsInRange","isHeader","abs","focusCoords","shiftRows","visualRowIndex","amount","isSelected","isSelectedByCorner","selectAll","disableHeadersHighlight","minRow","coordsStartAmount","pop","coordsStart","coordsEnd","shiftColumns","visualColumnIndex","minColumn","isMultipleListener","isFocusSelectionChanged","tester","rowHeaders","some","peekByIndex","colHeaders","isSelectedByAnyHeader","inInSelection","fillHandle","isEditorOpened","isCellVisible","renderableCoords","isInteger","deselect","_this$getSelectedRang","includeRowHeaders","includeColumnHeaders","options","focusPosition","nrOfRows","nrOfColumns","rowFrom","columnFrom","startCoords","endCoords","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","tableParams","isValid","selection","rangeValidity","containsHeaders","selectColumns","startColumn","endColumn","start","end","columnHeaderLastIndex","fromCoords","toCoords","highlightRow","highlightColumn","fromRow","toRow","selectRows","startRow","endRow","rowHeaderLastIndex","fromColumn","toColumn","refresh","countColumns","Infinity","ranges","push","customSelections","getCustomSelections","forEach","customSelection","currentLayer","areaLayeredHighlight"],"sources":["D:/gym-project/frontend/node_modules/handsontable/selection/selection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport Highlight, { AREA_TYPE, HEADER_TYPE, FOCUS_TYPE } from \"./highlight/highlight.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { clamp } from \"./../helpers/number.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\nimport { A11Y_SELECTED } from \"../helpers/a11y.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar _transformation = /*#__PURE__*/new WeakMap();\nvar _focusTransformation = /*#__PURE__*/new WeakMap();\nvar _isFocusSelectionChanged = /*#__PURE__*/new WeakMap();\nvar _disableHeadersHighlight = /*#__PURE__*/new WeakMap();\nvar _selectionSource = /*#__PURE__*/new WeakMap();\nvar _expectedLayersCount = /*#__PURE__*/new WeakMap();\nclass Selection {\n  constructor(settings, tableProps) {\n    var _this = this;\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"tableProps\", void 0);\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    _defineProperty(this, \"selectedRange\", new SelectionRange((highlight, from, to) => {\n      return this.tableProps.createCellRange(highlight, from, to);\n    }));\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    _defineProperty(this, \"highlight\", void 0);\n    /**\n     * The module for modifying coordinates of the start and end selection.\n     *\n     * @type {Transformation}\n     */\n    _classPrivateFieldInitSpec(this, _transformation, void 0);\n    /**\n     * The module for modifying coordinates of the focus selection.\n     *\n     * @type {Transformation}\n     */\n    _classPrivateFieldInitSpec(this, _focusTransformation, void 0);\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByRowHeader\", new Set());\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByColumnHeader\", new Set());\n    /**\n     * The flag which determines if the focus selection was changed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isFocusSelectionChanged, false);\n    /**\n     * When sets disable highlighting the headers even when the logical coordinates points on them.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, false);\n    /**\n     * The source of the selection. It can be one of the following values: `mouse`, `unknown` or any other string.\n     *\n     * @type {'mouse' | 'unknown' | string}\n     */\n    _classPrivateFieldInitSpec(this, _selectionSource, 'unknown');\n    /**\n     * The number of expected layers. It is used mostly to track when the last selection layer of non-contiguous\n     * selection is applied, thus the viewport scroll is triggered.\n     *\n     * @param {number}\n     */\n    _classPrivateFieldInitSpec(this, _expectedLayersCount, -1);\n    this.settings = settings;\n    this.tableProps = tableProps;\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      cellAttributes: [A11Y_SELECTED()],\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),\n      cellCornerVisible: function () {\n        return _this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: function () {\n        return _this.isAreaCornerVisible(...arguments);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)\n    });\n    _classPrivateFieldSet(_transformation, this, new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => this.tableProps.countRenderableRows(),\n      countRenderableColumns: () => this.tableProps.countRenderableColumns(),\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      findFirstNonHiddenRenderableRow: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);\n      },\n      findFirstNonHiddenRenderableColumn: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);\n      },\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n      autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => settings.autoWrapCol\n    }));\n    _classPrivateFieldSet(_focusTransformation, this, new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => {\n        const range = this.selectedRange.current();\n        return this.tableProps.countRenderableRowsInRange(0, range.getOuterBottomEndCorner().row);\n      },\n      countRenderableColumns: () => {\n        const range = this.selectedRange.current();\n        return this.tableProps.countRenderableColumnsInRange(0, range.getOuterBottomEndCorner().col);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      findFirstNonHiddenRenderableRow: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);\n      },\n      findFirstNonHiddenRenderableColumn: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);\n      },\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      fixedRowsBottom: () => 0,\n      minSpareRows: () => 0,\n      minSpareCols: () => 0,\n      autoWrapRow: () => true,\n      autoWrapCol: () => true\n    }));\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks('beforeModifyTransformStart', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks('afterModifyTransformStart', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks('afterModifyTransformEnd', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks('insertRowRequire', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks('insertColRequire', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeRowWrap', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.runLocalHooks('beforeRowWrap', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeColumnWrap', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _this.runLocalHooks('beforeColumnWrap', ...args);\n    });\n    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('beforeTransformStart', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _this.runLocalHooks('beforeModifyTransformFocus', ...args);\n    });\n    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('afterTransformStart', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _this.runLocalHooks('afterModifyTransformFocus', ...args);\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  getSelectedRange() {\n    return this.selectedRange;\n  }\n\n  /**\n   * Marks the source of the selection. It can be one of the following values: `mouse`, or any other string.\n   *\n   * @param {'mouse' | 'unknown' | string} sourceName The source name.\n   */\n  markSource(sourceName) {\n    _classPrivateFieldSet(_selectionSource, this, sourceName);\n  }\n\n  /**\n   * Marks end of the selection source. It restores the selection source to default value which is 'unknown'.\n   */\n  markEndSource() {\n    _classPrivateFieldSet(_selectionSource, this, 'unknown');\n  }\n\n  /**\n   * Returns the source of the selection.\n   *\n   * @returns {'mouse' | 'unknown' | string}\n   */\n  getSelectionSource() {\n    return _classPrivateFieldGet(_selectionSource, this);\n  }\n\n  /**\n   * Set the number of expected layers. The method is not obligatory to call. It is used mostly internally\n   * to determine when the last selection layer of non-contiguous is applied, thus the viewport scroll is triggered.\n   *\n   * @param {number} layersCount The number of expected layers.\n   */\n  setExpectedLayers(layersCount) {\n    _classPrivateFieldSet(_expectedLayersCount, this, layersCount);\n  }\n\n  /**\n   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.\n   */\n  begin() {\n    this.inProgress = true;\n  }\n\n  /**\n   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.\n   */\n  finish() {\n    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n    this.inProgress = false;\n    _classPrivateFieldSet(_expectedLayersCount, this, -1);\n  }\n\n  /**\n   * Check if the process of selecting the cell/cells is in progress.\n   *\n   * @returns {boolean}\n   */\n  isInProgress() {\n    return this.inProgress;\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;\n    const isMultipleMode = this.settings.selectionMode === 'multiple';\n    const isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n    // should be handled by next methods.\n    const coordsClone = coords.clone();\n    _classPrivateFieldSet(_isFocusSelectionChanged, this, false);\n    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);\n    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n      this.selectedRange.clear();\n    }\n    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());\n    if (this.getLayerLevel() === 0) {\n      this.selectedByRowHeader.clear();\n      this.selectedByColumnHeader.clear();\n    }\n    if (!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStartOnly(coords, multipleSelection) {\n    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;\n    this.setRangeStart(coords, multipleSelection, true, highlightCoords);\n  }\n\n  /**\n   * Ends selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   */\n  setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const coordsClone = coords.clone();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();\n\n    // Ignore processing the end range when the header selection starts overlapping the corner and\n    // the selection is not a single header highlight.\n    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {\n      return;\n    }\n    this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n    this.begin();\n    const cellRange = this.selectedRange.current();\n    if (!this.settings.navigableHeaders) {\n      cellRange.highlight.normalize();\n    }\n    if (this.settings.selectionMode === 'single') {\n      cellRange.setFrom(cellRange.highlight);\n      cellRange.setTo(cellRange.highlight);\n    } else {\n      const horizontalDir = cellRange.getHorizontalDirection();\n      const verticalDir = cellRange.getVerticalDirection();\n      const isMultiple = this.isMultiple();\n      cellRange.setTo(coordsClone);\n      if (isMultiple && (horizontalDir !== cellRange.getHorizontalDirection() || cellRange.getWidth() === 1 && !cellRange.includes(cellRange.highlight))) {\n        cellRange.from.assign({\n          col: cellRange.highlight.col\n        });\n      }\n      if (isMultiple && (verticalDir !== cellRange.getVerticalDirection() || cellRange.getHeight() === 1 && !cellRange.includes(cellRange.highlight))) {\n        cellRange.from.assign({\n          row: cellRange.highlight.row\n        });\n      }\n    }\n\n    // Prevent creating \"area\" selection that overlaps headers.\n    if (countRows > 0 && countCols > 0) {\n      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {\n        cellRange.to.normalize();\n      }\n    }\n    this.runLocalHooks('beforeHighlightSet');\n    this.setRangeFocus(this.selectedRange.current().highlight);\n    this.applyAndCommit();\n    const isLastLayer = _classPrivateFieldGet(_expectedLayersCount, this) === -1 || this.selectedRange.size() === _classPrivateFieldGet(_expectedLayersCount, this);\n    this.runLocalHooks('afterSetRangeEnd', coords, isLastLayer);\n  }\n\n  /**\n   * Applies and commits the selection to all layers (using the Walkontable Selection API) based on the selection (CellRanges)\n   * collected in the `selectedRange` module.\n   *\n   * @param {CellRange} [cellRange] The cell range to apply. If not provided, the current selection is used.\n   * @param {number} [layerLevel] The layer level to apply. If not provided, the current layer level is used.\n   */\n  applyAndCommit() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedRange.current();\n    let layerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLayerLevel();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n\n    // If the next layer level is lower than previous then clear all area and header highlights. This is the\n    // indication that the new selection is performing.\n    if (layerLevel < this.highlight.layerLevel) {\n      arrayEach(this.highlight.getAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getLayeredAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHighlights(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHighlights(), highlight => void highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n    const areaHighlight = this.highlight.createArea();\n    const layeredAreaHighlight = this.highlight.createLayeredArea();\n    const rowHeaderHighlight = this.highlight.createRowHeader();\n    const columnHeaderHighlight = this.highlight.createColumnHeader();\n    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n    const rowHighlight = this.highlight.createRowHighlight();\n    const columnHighlight = this.highlight.createColumnHighlight();\n    areaHighlight.clear();\n    layeredAreaHighlight.clear();\n    rowHeaderHighlight.clear();\n    columnHeaderHighlight.clear();\n    activeRowHeaderHighlight.clear();\n    activeColumnHeaderHighlight.clear();\n    activeCornerHeaderHighlight.clear();\n    rowHighlight.clear();\n    columnHighlight.clear();\n    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n      areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if (layerLevel === 1) {\n        // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n        const previousRange = this.selectedRange.previous();\n        this.highlight.useLayerLevel(layerLevel - 1);\n        this.highlight.createArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.createLayeredArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      if (!cellRange.isSingleHeader()) {\n        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);\n        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);\n        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));\n        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);\n        if (this.settings.selectionMode === 'single') {\n          rowHeaderHighlight.add(rowCoordsFrom).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).commit();\n          rowHighlight.add(rowCoordsFrom).commit();\n          columnHighlight.add(columnCoordsFrom).commit();\n        } else {\n          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n        }\n      }\n      const highlightRowHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());\n      const highlightColumnHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());\n      if (highlightRowHeaders) {\n        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();\n      }\n      if (highlightColumnHeaders) {\n        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();\n      }\n      if (highlightRowHeaders && highlightColumnHeaders) {\n        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();\n      }\n    }\n  }\n\n  /**\n   * Sets the selection focus position at the specified coordinates.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   */\n  setRangeFocus(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const cellRange = this.selectedRange.current();\n    if (!this.inProgress) {\n      this.runLocalHooks('beforeSetFocus', coords);\n    }\n    const focusHighlight = this.highlight.getFocus();\n    focusHighlight.clear();\n    cellRange.setHighlight(coords);\n    if (!this.inProgress) {\n      this.runLocalHooks('beforeHighlightSet');\n    }\n    if (this.highlight.isEnabledFor(FOCUS_TYPE, cellRange.highlight)) {\n      focusHighlight.add(cellRange.highlight).commit().syncWith(cellRange);\n    }\n    if (!this.inProgress) {\n      _classPrivateFieldSet(_isFocusSelectionChanged, this, true);\n      this.runLocalHooks('afterSetFocus', cellRange.highlight);\n    }\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.\n   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.settings.navigableHeaders) {\n      _classPrivateFieldGet(_transformation, this).setOffsetSize({\n        x: this.tableProps.countRowHeaders(),\n        y: this.tableProps.countColHeaders()\n      });\n    } else {\n      _classPrivateFieldGet(_transformation, this).resetOffsetSize();\n    }\n    this.setRangeStart(_classPrivateFieldGet(_transformation, this).transformStart(rowDelta, colDelta, createMissingRecords));\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformEnd(rowDelta, colDelta) {\n    if (this.settings.navigableHeaders) {\n      _classPrivateFieldGet(_transformation, this).setOffsetSize({\n        x: this.tableProps.countRowHeaders(),\n        y: this.tableProps.countColHeaders()\n      });\n    } else {\n      _classPrivateFieldGet(_transformation, this).resetOffsetSize();\n    }\n    this.setRangeEnd(_classPrivateFieldGet(_transformation, this).transformEnd(rowDelta, colDelta));\n  }\n\n  /**\n   * Transforms the focus cell selection relative to the current focus position.\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformFocus(rowDelta, colDelta) {\n    const range = this.selectedRange.current();\n    const {\n      row,\n      col\n    } = range.getOuterTopStartCorner();\n    const columnsInRange = this.tableProps.countRenderableColumnsInRange(0, col - 1);\n    const rowsInRange = this.tableProps.countRenderableRowsInRange(0, row - 1);\n    if (range.highlight.isHeader()) {\n      // for header focus selection calculate the new coords based on the selection including headers\n      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({\n        x: col < 0 ? Math.abs(col) : -columnsInRange,\n        y: row < 0 ? Math.abs(row) : -rowsInRange\n      });\n    } else {\n      // for focus selection in cells calculate the new coords only based on the selected cells\n      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({\n        x: col < 0 ? 0 : -columnsInRange,\n        y: row < 0 ? 0 : -rowsInRange\n      });\n    }\n    const focusCoords = _classPrivateFieldGet(_focusTransformation, this).transformStart(rowDelta, colDelta);\n    this.setRangeFocus(focusCoords.normalize());\n  }\n\n  /**\n   * Transforms the last selection layer down or up by the index count.\n   *\n   * @param {number} visualRowIndex Visual row index from which the selection will be shifted.\n   * @param {number} amount The number of rows to shift the selection.\n   */\n  shiftRows(visualRowIndex, amount) {\n    if (!this.isSelected()) {\n      return;\n    }\n    const range = this.selectedRange.current();\n    if (this.isSelectedByCorner()) {\n      this.selectAll(true, true, {\n        disableHeadersHighlight: true\n      });\n    } else if (this.isSelectedByColumnHeader() || range.getOuterTopStartCorner().row >= visualRowIndex) {\n      const {\n        from,\n        to,\n        highlight\n      } = range;\n      const countRows = this.tableProps.countRows();\n      const isSelectedByRowHeader = this.isSelectedByRowHeader();\n      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();\n      const minRow = isSelectedByColumnHeader ? -1 : 0;\n      const coordsStartAmount = isSelectedByColumnHeader ? 0 : amount;\n\n      // Remove from the stack the last added selection as that selection below will be\n      // replaced by new transformed selection.\n      this.getSelectedRange().pop();\n      const coordsStart = this.tableProps.createCellCoords(clamp(from.row + coordsStartAmount, minRow, countRows - 1), from.col);\n      const coordsEnd = this.tableProps.createCellCoords(clamp(to.row + amount, minRow, countRows - 1), to.col);\n      this.markSource('shift');\n      if (highlight.row >= visualRowIndex) {\n        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(clamp(highlight.row + amount, 0, countRows - 1), highlight.col));\n      } else {\n        this.setRangeStartOnly(coordsStart, true);\n      }\n      if (isSelectedByRowHeader) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (isSelectedByColumnHeader) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      this.setRangeEnd(coordsEnd);\n      this.markEndSource();\n    }\n  }\n\n  /**\n   * Transforms the last selection layer left or right by the index count.\n   *\n   * @param {number} visualColumnIndex Visual column index from which the selection will be shifted.\n   * @param {number} amount The number of columns to shift the selection.\n   */\n  shiftColumns(visualColumnIndex, amount) {\n    if (!this.isSelected()) {\n      return;\n    }\n    const range = this.selectedRange.current();\n    if (this.isSelectedByCorner()) {\n      this.selectAll(true, true, {\n        disableHeadersHighlight: true\n      });\n    } else if (this.isSelectedByRowHeader() || range.getOuterTopStartCorner().col >= visualColumnIndex) {\n      const {\n        from,\n        to,\n        highlight\n      } = range;\n      const countCols = this.tableProps.countCols();\n      const isSelectedByRowHeader = this.isSelectedByRowHeader();\n      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();\n      const minColumn = isSelectedByRowHeader ? -1 : 0;\n      const coordsStartAmount = isSelectedByRowHeader ? 0 : amount;\n\n      // Remove from the stack the last added selection as that selection below will be\n      // replaced by new transformed selection.\n      this.getSelectedRange().pop();\n      const coordsStart = this.tableProps.createCellCoords(from.row, clamp(from.col + coordsStartAmount, minColumn, countCols - 1));\n      const coordsEnd = this.tableProps.createCellCoords(to.row, clamp(to.col + amount, minColumn, countCols - 1));\n      this.markSource('shift');\n      if (highlight.col >= visualColumnIndex) {\n        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(highlight.row, clamp(highlight.col + amount, 0, countCols - 1)));\n      } else {\n        this.setRangeStartOnly(coordsStart, true);\n      }\n      if (isSelectedByRowHeader) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (isSelectedByColumnHeader) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      this.setRangeEnd(coordsEnd);\n      this.markEndSource();\n    }\n  }\n\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n   */\n  getLayerLevel() {\n    return this.selectedRange.size() - 1;\n  }\n\n  /**\n   * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n   *\n   * @returns {boolean}\n   */\n  isSelected() {\n    return !this.selectedRange.isEmpty();\n  }\n\n  /**\n   * Returns information if we have a multi-selection. This method check multi-selection only on the latest layer of\n   * the selection.\n   *\n   * @returns {boolean}\n   */\n  isMultiple() {\n    if (!this.isSelected()) {\n      return false;\n    }\n    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n    return isMultipleListener.value;\n  }\n\n  /**\n   * Checks if the last selection involves changing the focus cell position only.\n   *\n   * @returns {boolean}\n   */\n  isFocusSelectionChanged() {\n    return this.isSelected() && _classPrivateFieldGet(_isFocusSelectionChanged, this);\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        col\n      } = range.getOuterTopStartCorner();\n      const rowHeaders = this.tableProps.countRowHeaders();\n      const countCols = this.tableProps.countCols();\n      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        row\n      } = range.getOuterTopStartCorner();\n      const colHeaders = this.tableProps.countColHeaders();\n      const countRows = this.tableProps.countRows();\n      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() {\n    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() {\n    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    return this.selectedRange.includes(coords);\n  }\n\n  /**\n   * Returns `true` if the cell corner should be visible.\n   *\n   * @private\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isCellCornerVisible() {\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n  }\n\n  /**\n   * Returns `true` if the cell coordinates are visible (renderable).\n   *\n   * @private\n   * @param {CellCoords} coords The cell coordinates to check.\n   * @returns {boolean}\n   */\n  isCellVisible(coords) {\n    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);\n    return renderableCoords.row !== null && renderableCoords.col !== null;\n  }\n\n  /**\n   * Returns `true` if the area corner should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n      return false;\n    }\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n\n  /**\n   * Clear the selection by resetting the collected ranges and highlights.\n   */\n  clear() {\n    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n    this.selectedRange.clear();\n    this.highlight.clear();\n  }\n\n  /**\n   * Deselects all selected cells.\n   */\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    this.inProgress = false;\n    this.clear();\n    this.runLocalHooks('afterDeselect');\n  }\n\n  /**\n   * Selects all cells and headers.\n   *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   * @param {object} [options] Additional object with options.\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed.\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  selectAll() {\n    var _this$getSelectedRang;\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      focusPosition: false,\n      disableHeadersHighlight: false\n    };\n    const nrOfRows = this.tableProps.countRows();\n    const nrOfColumns = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;\n    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;\n\n    // We can't select cells when there is no data.\n    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {\n      return;\n    }\n    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;\n    const {\n      focusPosition,\n      disableHeadersHighlight\n    } = options;\n    _classPrivateFieldSet(_disableHeadersHighlight, this, disableHeadersHighlight);\n    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n      highlight = this.tableProps.createCellCoords(clamp(focusPosition.row, rowFrom, nrOfRows - 1), clamp(focusPosition.col, columnFrom, nrOfColumns - 1));\n    }\n    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);\n    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    this.clear();\n    this.setRangeStartOnly(startCoords, undefined, highlight);\n    if (columnFrom < 0) {\n      this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if (rowFrom < 0) {\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    this.setRangeEnd(endCoords);\n    this.finish();\n    _classPrivateFieldSet(_disableHeadersHighlight, this, false);\n  }\n\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n   * If the passed ranges have another format the exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    var _this2 = this;\n    const selectionType = detectSelectionType(selectionRanges);\n    if (selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: function () {\n        return _this2.tableProps.createCellCoords(...arguments);\n      },\n      createCellRange: function () {\n        return _this2.tableProps.createCellRange(...arguments);\n      },\n      propToCol: prop => this.tableProps.propToCol(prop),\n      keepDirection: true\n    });\n    const navigableHeaders = this.settings.navigableHeaders;\n    const tableParams = {\n      countRows: this.tableProps.countRows(),\n      countCols: this.tableProps.countCols(),\n      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,\n      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0\n    };\n\n    // Check if every layer of the coordinates are valid.\n    const isValid = !selectionRanges.some(selection => {\n      const cellRange = selectionSchemaNormalizer(selection);\n      const rangeValidity = cellRange.isValid(tableParams);\n      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());\n    });\n    if (isValid) {\n      this.clear();\n      this.setExpectedLayers(selectionRanges.length);\n      arrayEach(selectionRanges, selection => {\n        const {\n          from,\n          to\n        } = selectionSchemaNormalizer(selection);\n        this.setRangeStartOnly(from.clone(), false);\n        this.setRangeEnd(to.clone());\n      });\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n   * `endColumn`.\n   *\n   * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus\n   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive\n   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus\n   * position horizontally.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;\n    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);\n    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders: 0,\n      countColHeaders\n    });\n    if (isValid) {\n      let highlightRow = 0;\n      let highlightColumn = 0;\n      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n        highlightRow = clamp(focusPosition.row, columnHeaderLastIndex, countRows - 1);\n        highlightColumn = clamp(focusPosition.col, Math.min(start, end), Math.max(start, end));\n      } else {\n        highlightRow = clamp(focusPosition, columnHeaderLastIndex, countRows - 1);\n        highlightColumn = start;\n      }\n      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);\n      const fromRow = countColHeaders === 0 ? 0 : clamp(highlight.row, columnHeaderLastIndex, -1);\n      const toRow = countRows - 1;\n      const from = this.tableProps.createCellCoords(fromRow, start);\n      const to = this.tableProps.createCellCoords(toRow, end);\n      this.runLocalHooks('beforeSelectColumns', from, to, highlight);\n\n      // disallow modifying row axis for that hooks\n      from.row = fromRow;\n      to.row = toRow;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectColumns', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which the selection starts.\n   * @param {number} [endRow] Visual row index from to the selection finishes.\n   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus\n   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive\n   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus\n   * position horizontally.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;\n    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);\n    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders,\n      countColHeaders: 0\n    });\n    if (isValid) {\n      let highlightRow = 0;\n      let highlightColumn = 0;\n      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n        highlightRow = clamp(focusPosition.row, Math.min(startRow, endRow), Math.max(startRow, endRow));\n        highlightColumn = clamp(focusPosition.col, rowHeaderLastIndex, countCols - 1);\n      } else {\n        highlightRow = startRow;\n        highlightColumn = clamp(focusPosition, rowHeaderLastIndex, countCols - 1);\n      }\n      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);\n      const fromColumn = countRowHeaders === 0 ? 0 : clamp(highlight.col, rowHeaderLastIndex, -1);\n      const toColumn = countCols - 1;\n      const from = this.tableProps.createCellCoords(startRow, fromColumn);\n      const to = this.tableProps.createCellCoords(endRow, toColumn);\n      this.runLocalHooks('beforeSelectRows', from, to, highlight);\n\n      // disallow modifying column axis for that hooks\n      from.col = fromColumn;\n      to.col = toColumn;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectRows', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Refreshes the whole selection by clearing, reapplying and committing the renderable selection (Walkontable Selection API)\n   * by using already added visual ranges.\n   */\n  refresh() {\n    if (!this.isSelected()) {\n      return;\n    }\n    const countRows = this.tableProps.countRows();\n    const countColumns = this.tableProps.countCols();\n    if (countRows === 0 || countColumns === 0) {\n      this.deselect();\n      return;\n    }\n    const range = this.selectedRange.peekByIndex(this.selectedRange.size() - 1);\n    const {\n      from,\n      to,\n      highlight\n    } = range;\n    this.clear();\n    highlight.assign({\n      row: clamp(highlight.row, -Infinity, countRows - 1),\n      col: clamp(highlight.col, -Infinity, countColumns - 1)\n    });\n    from.assign({\n      row: clamp(from.row, -Infinity, countRows - 1),\n      col: clamp(from.col, -Infinity, countColumns - 1)\n    });\n    to.assign({\n      row: clamp(to.row, 0, countRows - 1),\n      col: clamp(to.col, 0, countColumns - 1)\n    });\n    this.selectedRange.ranges.push(range);\n    this.highlight.getFocus().add(highlight).commit().syncWith(range);\n    this.applyAndCommit(range);\n  }\n\n  /**\n   * Refreshes the whole selection by recommitting (recalculating visual indexes to renderable ones) the renderable selection\n   * that was already added.\n   */\n  commit() {\n    const customSelections = this.highlight.getCustomSelections();\n    customSelections.forEach(customSelection => {\n      customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      return;\n    }\n    const focusHighlight = this.highlight.getFocus();\n    const currentLayer = this.getLayerLevel();\n    focusHighlight.commit().syncWith(this.selectedRange.current());\n\n    // Rewriting rendered ranges going through all layers.\n    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n      this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = this.highlight.createArea();\n      const areaLayeredHighlight = this.highlight.createLayeredArea();\n      const rowHeaderHighlight = this.highlight.createRowHeader();\n      const columnHeaderHighlight = this.highlight.createColumnHeader();\n      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n      const rowHighlight = this.highlight.createRowHighlight();\n      const columnHighlight = this.highlight.createColumnHighlight();\n      areaHighlight.commit();\n      areaLayeredHighlight.commit();\n      rowHeaderHighlight.commit();\n      columnHeaderHighlight.commit();\n      activeRowHeaderHighlight.commit();\n      activeColumnHeaderHighlight.commit();\n      activeCornerHeaderHighlight.commit();\n      rowHighlight.commit();\n      columnHighlight.commit();\n    }\n\n    // Reverting starting layer for the Highlight.\n    this.highlight.useLayerLevel(currentLayer);\n  }\n}\nmixin(Selection, localHooks);\nexport default Selection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}