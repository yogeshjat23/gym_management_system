{"ast":null,"code":"/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * SheetClip - Spreadsheet Clipboard Parser.\n * version 0.2\n *\n * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,\n * Google Docs and Microsoft Excel.\n *\n * Copyright 2012, Marcin Warpechowski\n * Licensed under the MIT license.\n * http://github.com/warpech/sheetclip/\n */\n\nconst regUniversalNewLine = /^(\\r\\n|\\n\\r|\\r|\\n)/;\nconst regNextCellNoQuotes = /^[^\\t\\r\\n]+/;\nconst regNextEmptyCell = /^\\t/;\n\n/**\n * Decode spreadsheet string into array.\n *\n * @param {string} str The string to parse.\n * @returns {Array}\n */\nexport function parse(str) {\n  const arr = [['']];\n  if (str.length === 0) {\n    return arr;\n  }\n  let column = 0;\n  let row = 0;\n  let lastLength;\n  while (str.length > 0) {\n    if (lastLength === str.length) {\n      // In the case If in last cycle we didn't match anything, we have to leave the infinite loop\n      break;\n    }\n    lastLength = str.length;\n    if (str.match(regNextEmptyCell)) {\n      str = str.replace(regNextEmptyCell, '');\n      column += 1;\n      arr[row][column] = '';\n    } else if (str.match(regUniversalNewLine)) {\n      str = str.replace(regUniversalNewLine, '');\n      column = 0;\n      row += 1;\n      arr[row] = [''];\n    } else {\n      let nextCell = '';\n      if (str.startsWith('\"')) {\n        let quoteNo = 0;\n        let isStillCell = true;\n        while (isStillCell) {\n          const nextChar = str.slice(0, 1);\n          if (nextChar === '\"') {\n            quoteNo += 1;\n          }\n          nextCell += nextChar;\n          str = str.slice(1);\n          if (str.length === 0 || str.match(/^[\\t\\r\\n]/) && quoteNo % 2 === 0) {\n            isStillCell = false;\n          }\n        }\n        nextCell = nextCell.replace(/^\"/, '').replace(/\"$/, '').replace(/[\"]*/g, match => new Array(Math.floor(match.length / 2)).fill('\"').join(''));\n      } else {\n        const matchedText = str.match(regNextCellNoQuotes);\n        nextCell = matchedText ? matchedText[0] : '';\n        str = str.slice(nextCell.length);\n      }\n      arr[row][column] = nextCell;\n    }\n  }\n  return arr;\n}\n\n/**\n * Encode array into valid spreadsheet string.\n *\n * @param {Array} arr An array of arrays to stringify.\n * @returns {string}\n */\nexport function stringify(arr) {\n  let r;\n  let rLen;\n  let c;\n  let cLen;\n  let str = '';\n  let val;\n  for (r = 0, rLen = arr.length; r < rLen; r += 1) {\n    cLen = arr[r].length;\n    for (c = 0; c < cLen; c += 1) {\n      if (c > 0) {\n        str += '\\t';\n      }\n      val = arr[r][c];\n      if (typeof val === 'string') {\n        if (val.indexOf('\\n') > -1) {\n          str += `\"${val.replace(/\"/g, '\"\"')}\"`;\n        } else {\n          str += val;\n        }\n      } else if (val === null || val === undefined) {\n        // undefined resolves to undefined\n        str += '';\n      } else {\n        str += val;\n      }\n    }\n    if (r !== rLen - 1) {\n      str += '\\n';\n    }\n  }\n  return str;\n}","map":{"version":3,"names":["regUniversalNewLine","regNextCellNoQuotes","regNextEmptyCell","parse","str","arr","length","column","row","lastLength","match","replace","nextCell","startsWith","quoteNo","isStillCell","nextChar","slice","Array","Math","floor","fill","join","matchedText","stringify","r","rLen","c","cLen","val","indexOf","undefined"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/SheetClip/SheetClip.mjs"],"sourcesContent":["/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * SheetClip - Spreadsheet Clipboard Parser.\n * version 0.2\n *\n * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,\n * Google Docs and Microsoft Excel.\n *\n * Copyright 2012, Marcin Warpechowski\n * Licensed under the MIT license.\n * http://github.com/warpech/sheetclip/\n */\n\nconst regUniversalNewLine = /^(\\r\\n|\\n\\r|\\r|\\n)/;\nconst regNextCellNoQuotes = /^[^\\t\\r\\n]+/;\nconst regNextEmptyCell = /^\\t/;\n\n/**\n * Decode spreadsheet string into array.\n *\n * @param {string} str The string to parse.\n * @returns {Array}\n */\nexport function parse(str) {\n  const arr = [['']];\n  if (str.length === 0) {\n    return arr;\n  }\n  let column = 0;\n  let row = 0;\n  let lastLength;\n  while (str.length > 0) {\n    if (lastLength === str.length) {\n      // In the case If in last cycle we didn't match anything, we have to leave the infinite loop\n      break;\n    }\n    lastLength = str.length;\n    if (str.match(regNextEmptyCell)) {\n      str = str.replace(regNextEmptyCell, '');\n      column += 1;\n      arr[row][column] = '';\n    } else if (str.match(regUniversalNewLine)) {\n      str = str.replace(regUniversalNewLine, '');\n      column = 0;\n      row += 1;\n      arr[row] = [''];\n    } else {\n      let nextCell = '';\n      if (str.startsWith('\"')) {\n        let quoteNo = 0;\n        let isStillCell = true;\n        while (isStillCell) {\n          const nextChar = str.slice(0, 1);\n          if (nextChar === '\"') {\n            quoteNo += 1;\n          }\n          nextCell += nextChar;\n          str = str.slice(1);\n          if (str.length === 0 || str.match(/^[\\t\\r\\n]/) && quoteNo % 2 === 0) {\n            isStillCell = false;\n          }\n        }\n        nextCell = nextCell.replace(/^\"/, '').replace(/\"$/, '').replace(/[\"]*/g, match => new Array(Math.floor(match.length / 2)).fill('\"').join(''));\n      } else {\n        const matchedText = str.match(regNextCellNoQuotes);\n        nextCell = matchedText ? matchedText[0] : '';\n        str = str.slice(nextCell.length);\n      }\n      arr[row][column] = nextCell;\n    }\n  }\n  return arr;\n}\n\n/**\n * Encode array into valid spreadsheet string.\n *\n * @param {Array} arr An array of arrays to stringify.\n * @returns {string}\n */\nexport function stringify(arr) {\n  let r;\n  let rLen;\n  let c;\n  let cLen;\n  let str = '';\n  let val;\n  for (r = 0, rLen = arr.length; r < rLen; r += 1) {\n    cLen = arr[r].length;\n    for (c = 0; c < cLen; c += 1) {\n      if (c > 0) {\n        str += '\\t';\n      }\n      val = arr[r][c];\n      if (typeof val === 'string') {\n        if (val.indexOf('\\n') > -1) {\n          str += `\"${val.replace(/\"/g, '\"\"')}\"`;\n        } else {\n          str += val;\n        }\n      } else if (val === null || val === undefined) {\n        // undefined resolves to undefined\n        str += '';\n      } else {\n        str += val;\n      }\n    }\n    if (r !== rLen - 1) {\n      str += '\\n';\n    }\n  }\n  return str;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}