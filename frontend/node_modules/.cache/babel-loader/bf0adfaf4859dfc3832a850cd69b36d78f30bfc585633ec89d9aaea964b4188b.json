{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { fastInnerText } from \"../../../../helpers/dom/element.mjs\";\nimport { randomString } from \"../../../../helpers/string.mjs\";\nimport EventManager from \"../../../../eventManager.mjs\";\nimport Scroll from \"../scroll.mjs\";\nimport CellCoords from \"../cell/coords.mjs\";\nimport CellRange from \"../cell/range.mjs\";\n/**\n * @abstract\n * @class Walkontable\n */\nexport default class CoreAbstract {\n  get eventManager() {\n    return new EventManager(this);\n  }\n\n  /**\n   * @param {HTMLTableElement} table Main table.\n   * @param {Settings} settings The Walkontable settings.\n   */\n  constructor(table, settings) {\n    _defineProperty(this, \"wtTable\", void 0);\n    _defineProperty(this, \"wtScroll\", void 0);\n    _defineProperty(this, \"wtViewport\", void 0);\n    _defineProperty(this, \"wtOverlays\", void 0);\n    _defineProperty(this, \"selectionManager\", void 0);\n    _defineProperty(this, \"wtEvent\", void 0);\n    /**\n     * The walkontable instance id.\n     *\n     * @public\n     * @type {Readonly<string>}\n     */\n    _defineProperty(this, \"guid\", `wt_${randomString()}`);\n    _defineProperty(this, \"drawInterrupted\", false);\n    _defineProperty(this, \"drawn\", false);\n    /**\n     * The DOM bindings.\n     *\n     * @public\n     * @type {DomBindings}\n     */\n    _defineProperty(this, \"domBindings\", void 0);\n    /**\n     * Settings.\n     *\n     * @public\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n      rootDocument: table.ownerDocument,\n      rootWindow: table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    this.wtScroll = new Scroll(this.createScrollDao());\n  }\n  findOriginalHeaders() {\n    const originalHeaders = [];\n\n    // find original headers\n    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n      for (let c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n      }\n      if (!this.wtSettings.getSetting('columnHeaders').length) {\n        this.wtSettings.update('columnHeaders', [function (column, TH) {\n          fastInnerText(TH, originalHeaders[column]);\n        }]);\n      }\n    }\n  }\n\n  /**\n   * Creates and returns the CellCoords object.\n   *\n   * @param {*} row The row index.\n   * @param {*} column The column index.\n   * @returns {CellCoords}\n   */\n  createCellCoords(row, column) {\n    return new CellCoords(row, column, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Creates and returns the CellRange object.\n   *\n   * @param {CellCoords} highlight The highlight coordinates.\n   * @param {CellCoords} from The from coordinates.\n   * @param {CellCoords} to The to coordinates.\n   * @returns {CellRange}\n   */\n  createCellRange(highlight, from, to) {\n    return new CellRange(highlight, from, to, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Force rerender of Walkontable.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   * @returns {Walkontable}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.drawInterrupted = false;\n    if (!this.wtTable.isVisible()) {\n      // draw interrupted because TABLE is not visible\n      this.drawInterrupted = true;\n    } else {\n      this.wtTable.draw(fastDraw);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n   * if not set or set to false, returns TD from the master table.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\n   *                                  from the top overlay.\n   * @returns {HTMLElement}\n   */\n  getCell(coords) {\n    let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!topmost) {\n      return this.wtTable.getCell(coords);\n    }\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n    if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n      return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < fixedRowsTop) {\n      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n      }\n    } else if (coords.col < fixedColumnsStart) {\n      return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n      }\n    }\n    return this.wtTable.getCell(coords);\n  }\n\n  /**\n   * Scrolls the viewport to a cell (rerenders if needed).\n   *\n   * @param {CellCoords} coords The cell coordinates to scroll to.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    if (coords.col < 0 || coords.row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a column (rerenders if needed).\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    if (column < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a row (rerenders if needed).\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    if (row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * @returns {Array}\n   */\n  getViewport() {\n    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n  }\n\n  /**\n   * Destroy instance.\n   */\n  destroy() {\n    this.wtOverlays.destroy();\n    this.wtEvent.destroy();\n  }\n\n  /**\n   * Create data access object for scroll.\n   *\n   * @protected\n   * @returns {ScrollDao}\n   */\n  createScrollDao() {\n    const wot = this;\n    return {\n      get drawn() {\n        return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)\n      },\n      get topOverlay() {\n        return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n      get inlineStartOverlay() {\n        return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtSettings() {\n        return wot.wtSettings;\n      },\n      get rootWindow() {\n        return wot.domBindings.rootWindow; // TODO refactoring: move outside dao\n      },\n      // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)\n      get totalRows() {\n        return wot.wtSettings.getSetting('totalRows');\n      },\n      get totalColumns() {\n        return wot.wtSettings.getSetting('totalColumns');\n      },\n      get fixedRowsTop() {\n        return wot.wtSettings.getSetting('fixedRowsTop');\n      },\n      get fixedRowsBottom() {\n        return wot.wtSettings.getSetting('fixedRowsBottom');\n      },\n      get fixedColumnsStart() {\n        return wot.wtSettings.getSetting('fixedColumnsStart');\n      }\n    };\n  }\n  // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide\n  // dynamically access to related objects\n  /**\n   * Create data access object for wtTable.\n   *\n   * @protected\n   * @returns {TableDao}\n   */\n  getTableDao() {\n    const wot = this;\n    return {\n      get wot() {\n        return wot;\n      },\n      get parentTableOffset() {\n        return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.\n      },\n      get cloneSource() {\n        return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.\n      },\n      get workspaceWidth() {\n        return wot.wtViewport.getWorkspaceWidth();\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtOverlays() {\n        return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC\n      },\n      get selectionManager() {\n        return wot.selectionManager; // TODO refactoring: move outside dao, use IOC\n      },\n      get drawn() {\n        return wot.drawn;\n      },\n      set drawn(v) {\n        // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.\n        wot.drawn = v;\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: it provides itself\n      },\n      get startColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.startColumn;\n      },\n      get startColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.startColumn;\n      },\n      get startColumnPartiallyVisible() {\n        return wot.wtViewport.columnsPartiallyVisibleCalculator.startColumn;\n      },\n      get endColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.endColumn;\n      },\n      get endColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.endColumn;\n      },\n      get endColumnPartiallyVisible() {\n        return wot.wtViewport.columnsPartiallyVisibleCalculator.endColumn;\n      },\n      get countColumnsRendered() {\n        return wot.wtViewport.columnsRenderCalculator.count;\n      },\n      get countColumnsVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.count;\n      },\n      get startRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.startRow;\n      },\n      get startRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.startRow;\n      },\n      get startRowPartiallyVisible() {\n        return wot.wtViewport.rowsPartiallyVisibleCalculator.startRow;\n      },\n      get endRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.endRow;\n      },\n      get endRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.endRow;\n      },\n      get endRowPartiallyVisible() {\n        return wot.wtViewport.rowsPartiallyVisibleCalculator.endRow;\n      },\n      get countRowsRendered() {\n        return wot.wtViewport.rowsRenderCalculator.count;\n      },\n      get countRowsVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.count;\n      },\n      get columnHeaders() {\n        return wot.wtSettings.getSetting('columnHeaders');\n      },\n      get rowHeaders() {\n        return wot.wtSettings.getSetting('rowHeaders');\n      }\n    };\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","fastInnerText","randomString","EventManager","Scroll","CellCoords","CellRange","CoreAbstract","eventManager","constructor","table","settings","domBindings","rootTable","rootDocument","ownerDocument","rootWindow","defaultView","wtSettings","wtScroll","createScrollDao","findOriginalHeaders","originalHeaders","wtTable","THEAD","childNodes","length","c","clen","push","innerHTML","getSetting","update","column","TH","createCellCoords","row","createCellRange","highlight","from","to","draw","fastDraw","arguments","undefined","drawInterrupted","isVisible","getCell","coords","topmost","totalRows","fixedRowsTop","fixedRowsBottom","fixedColumnsStart","col","wtOverlays","topInlineStartCornerOverlay","clone","topOverlay","bottomInlineStartCornerOverlay","inlineStartOverlay","bottomOverlay","scrollViewport","snapToTop","snapToRight","snapToBottom","snapToLeft","scrollViewportHorizontally","scrollViewportVertically","getViewport","getFirstVisibleRow","getFirstVisibleColumn","getLastVisibleRow","getLastVisibleColumn","destroy","wtEvent","wot","drawn","wtViewport","totalColumns","getTableDao","parentTableOffset","cloneSource","tableOffset","workspaceWidth","getWorkspaceWidth","selectionManager","v","startColumnRendered","columnsRenderCalculator","startColumn","startColumnVisible","columnsVisibleCalculator","startColumnPartiallyVisible","columnsPartiallyVisibleCalculator","endColumnRendered","endColumn","endColumnVisible","endColumnPartiallyVisible","countColumnsRendered","count","countColumnsVisible","startRowRendered","rowsRenderCalculator","startRow","startRowVisible","rowsVisibleCalculator","startRowPartiallyVisible","rowsPartiallyVisibleCalculator","endRowRendered","endRow","endRowVisible","endRowPartiallyVisible","countRowsRendered","countRowsVisible","columnHeaders","rowHeaders"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/core/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { fastInnerText } from \"../../../../helpers/dom/element.mjs\";\nimport { randomString } from \"../../../../helpers/string.mjs\";\nimport EventManager from \"../../../../eventManager.mjs\";\nimport Scroll from \"../scroll.mjs\";\nimport CellCoords from \"../cell/coords.mjs\";\nimport CellRange from \"../cell/range.mjs\";\n/**\n * @abstract\n * @class Walkontable\n */\nexport default class CoreAbstract {\n  get eventManager() {\n    return new EventManager(this);\n  }\n\n  /**\n   * @param {HTMLTableElement} table Main table.\n   * @param {Settings} settings The Walkontable settings.\n   */\n  constructor(table, settings) {\n    _defineProperty(this, \"wtTable\", void 0);\n    _defineProperty(this, \"wtScroll\", void 0);\n    _defineProperty(this, \"wtViewport\", void 0);\n    _defineProperty(this, \"wtOverlays\", void 0);\n    _defineProperty(this, \"selectionManager\", void 0);\n    _defineProperty(this, \"wtEvent\", void 0);\n    /**\n     * The walkontable instance id.\n     *\n     * @public\n     * @type {Readonly<string>}\n     */\n    _defineProperty(this, \"guid\", `wt_${randomString()}`);\n    _defineProperty(this, \"drawInterrupted\", false);\n    _defineProperty(this, \"drawn\", false);\n    /**\n     * The DOM bindings.\n     *\n     * @public\n     * @type {DomBindings}\n     */\n    _defineProperty(this, \"domBindings\", void 0);\n    /**\n     * Settings.\n     *\n     * @public\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n      rootDocument: table.ownerDocument,\n      rootWindow: table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    this.wtScroll = new Scroll(this.createScrollDao());\n  }\n  findOriginalHeaders() {\n    const originalHeaders = [];\n\n    // find original headers\n    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n      for (let c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n      }\n      if (!this.wtSettings.getSetting('columnHeaders').length) {\n        this.wtSettings.update('columnHeaders', [function (column, TH) {\n          fastInnerText(TH, originalHeaders[column]);\n        }]);\n      }\n    }\n  }\n\n  /**\n   * Creates and returns the CellCoords object.\n   *\n   * @param {*} row The row index.\n   * @param {*} column The column index.\n   * @returns {CellCoords}\n   */\n  createCellCoords(row, column) {\n    return new CellCoords(row, column, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Creates and returns the CellRange object.\n   *\n   * @param {CellCoords} highlight The highlight coordinates.\n   * @param {CellCoords} from The from coordinates.\n   * @param {CellCoords} to The to coordinates.\n   * @returns {CellRange}\n   */\n  createCellRange(highlight, from, to) {\n    return new CellRange(highlight, from, to, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Force rerender of Walkontable.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   * @returns {Walkontable}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.drawInterrupted = false;\n    if (!this.wtTable.isVisible()) {\n      // draw interrupted because TABLE is not visible\n      this.drawInterrupted = true;\n    } else {\n      this.wtTable.draw(fastDraw);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n   * if not set or set to false, returns TD from the master table.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\n   *                                  from the top overlay.\n   * @returns {HTMLElement}\n   */\n  getCell(coords) {\n    let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!topmost) {\n      return this.wtTable.getCell(coords);\n    }\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n    if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n      return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < fixedRowsTop) {\n      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n      }\n    } else if (coords.col < fixedColumnsStart) {\n      return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n      }\n    }\n    return this.wtTable.getCell(coords);\n  }\n\n  /**\n   * Scrolls the viewport to a cell (rerenders if needed).\n   *\n   * @param {CellCoords} coords The cell coordinates to scroll to.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    if (coords.col < 0 || coords.row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a column (rerenders if needed).\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    if (column < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a row (rerenders if needed).\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    if (row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * @returns {Array}\n   */\n  getViewport() {\n    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n  }\n\n  /**\n   * Destroy instance.\n   */\n  destroy() {\n    this.wtOverlays.destroy();\n    this.wtEvent.destroy();\n  }\n\n  /**\n   * Create data access object for scroll.\n   *\n   * @protected\n   * @returns {ScrollDao}\n   */\n  createScrollDao() {\n    const wot = this;\n    return {\n      get drawn() {\n        return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)\n      },\n      get topOverlay() {\n        return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n      get inlineStartOverlay() {\n        return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtSettings() {\n        return wot.wtSettings;\n      },\n      get rootWindow() {\n        return wot.domBindings.rootWindow; // TODO refactoring: move outside dao\n      },\n      // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)\n      get totalRows() {\n        return wot.wtSettings.getSetting('totalRows');\n      },\n      get totalColumns() {\n        return wot.wtSettings.getSetting('totalColumns');\n      },\n      get fixedRowsTop() {\n        return wot.wtSettings.getSetting('fixedRowsTop');\n      },\n      get fixedRowsBottom() {\n        return wot.wtSettings.getSetting('fixedRowsBottom');\n      },\n      get fixedColumnsStart() {\n        return wot.wtSettings.getSetting('fixedColumnsStart');\n      }\n    };\n  }\n  // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide\n  // dynamically access to related objects\n  /**\n   * Create data access object for wtTable.\n   *\n   * @protected\n   * @returns {TableDao}\n   */\n  getTableDao() {\n    const wot = this;\n    return {\n      get wot() {\n        return wot;\n      },\n      get parentTableOffset() {\n        return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.\n      },\n      get cloneSource() {\n        return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.\n      },\n      get workspaceWidth() {\n        return wot.wtViewport.getWorkspaceWidth();\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtOverlays() {\n        return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC\n      },\n      get selectionManager() {\n        return wot.selectionManager; // TODO refactoring: move outside dao, use IOC\n      },\n      get drawn() {\n        return wot.drawn;\n      },\n      set drawn(v) {\n        // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.\n        wot.drawn = v;\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: it provides itself\n      },\n      get startColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.startColumn;\n      },\n      get startColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.startColumn;\n      },\n      get startColumnPartiallyVisible() {\n        return wot.wtViewport.columnsPartiallyVisibleCalculator.startColumn;\n      },\n      get endColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.endColumn;\n      },\n      get endColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.endColumn;\n      },\n      get endColumnPartiallyVisible() {\n        return wot.wtViewport.columnsPartiallyVisibleCalculator.endColumn;\n      },\n      get countColumnsRendered() {\n        return wot.wtViewport.columnsRenderCalculator.count;\n      },\n      get countColumnsVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.count;\n      },\n      get startRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.startRow;\n      },\n      get startRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.startRow;\n      },\n      get startRowPartiallyVisible() {\n        return wot.wtViewport.rowsPartiallyVisibleCalculator.startRow;\n      },\n      get endRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.endRow;\n      },\n      get endRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.endRow;\n      },\n      get endRowPartiallyVisible() {\n        return wot.wtViewport.rowsPartiallyVisibleCalculator.endRow;\n      },\n      get countRowsRendered() {\n        return wot.wtViewport.rowsRenderCalculator.count;\n      },\n      get countRowsVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.count;\n      },\n      get columnHeaders() {\n        return wot.wtSettings.getSetting('columnHeaders');\n      },\n      get rowHeaders() {\n        return wot.wtSettings.getSetting('rowHeaders');\n      }\n    };\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}