{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @class LazyFactoryMap\n *\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\n * regular Map. Once created, items can be moved around a grid depending on the operations\n * performed on that grid - adding or removing rows. The collection requires \"key\"\n * to be a zero-based index.\n *\n * It's essential to notice that the \"key\" index under which the item was created\n * is volatile. After altering the grid, the \"key\" index can change.\n *\n * Having created N items with corresponding example data where the data has 10\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\n * +------+------+------+------+------+.\n *    │      │      │      │      │\n * +------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\n * +------+------+------+------+------+.\n *\n * Map.obtain(0) // returns \"AAA\"\n * map.obtain(2) // returns \"CCC\".\n *\n * After inserting 2 new rows, keys that hold the data positioned after the place\n * where the new rows are added are upshifted by 2.\n *               │\n *               │ Insert 2 rows\n *              \\│/\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\n * +------+------+------+------+------+.\n *\n *                / 2 new rows \\\n * +------+------+------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+.\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * Now at index 2 and 3 we have access to new items.\n *\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\n *\n * after removing 4 rows, keys that hold the data positioned after the place where the\n * rows are removed are downshifted by 4.\n *        │\n *        │ Remove 4 rows\n *        ├───────────────────────────┐\n *       \\│/                          │\n * +------+------+------+------+------+------+------+\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * +------+------+------+\n * | 0/10 | 1/13 | 2/14 |  Keys after\n * +------+------+------+\n *    │       │      │\n *    │       │      └─────────────┐\n *    │       └────────────┐       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *           /│\\   /│\\                   /│\\   /│\\\n *            └──┬──┘                     └──┬──┘\n *           This data is marked as \"hole\" which\n *           means that can be replaced by new item\n *           when that will be created.\n *\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\n *               // changed (the key was downshifted). However, the internal index has not changed,\n *               // which means that the data does not need to be changed (spliced) too.\n *\n * After previous remove operation which creates some \"holes\" obtaining new\n * items replaces that \"holes\" as follows:\n *\n * // Obtains new item\n * map.obtain(90) // Returns \"NEW\" value\n *\n * +------+------+------+...+------+\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\n * +------+------+------+...+------+\n *    │       │      │          │\n *    │       │      └──────────┼────────────┐\n *    │       └─────────────────┼─────┐      │\n *    └──────────┐              │     │      │\n *               │              │     │      │\n *    ┌──────────┼──────────────┘     │      │\n *    │          │                    │      │\n * +------+...+------+------+------+------+------+-----+\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\n * +------+...+------+------+------+------+------+-----+\n *   /│\\\n *    │\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nexport default class LazyFactoryMap {\n  constructor(valueFactory) {\n    /**\n     * The data factory function.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"valueFactory\", void 0);\n    /**\n     * An array which contains data.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"data\", []);\n    /**\n     * An array of indexes where the key of the array is mapped to the value which points to the\n     * specific position of the data array.\n     *\n     * @type {number[]}\n     */\n    _defineProperty(this, \"index\", []);\n    /**\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\n     * ones. The \"holes\" are an intended effect of deleting entries.\n     *\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\n     * items from the collection.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"holes\", new Set());\n    this.valueFactory = valueFactory;\n  }\n\n  /**\n   * Gets or if data not exist creates and returns new data.\n   *\n   * @param {number} key The item key as zero-based index.\n   * @returns {*}\n   */\n  obtain(key) {\n    assert(() => isUnsignedNumber(key), 'Expecting an unsigned number.');\n    const dataIndex = this._getStorageIndexByKey(key);\n    let result;\n    if (dataIndex >= 0) {\n      result = this.data[dataIndex];\n      if (result === undefined) {\n        result = this.valueFactory(key);\n        this.data[dataIndex] = result;\n      }\n    } else {\n      result = this.valueFactory(key);\n      if (this.holes.size > 0) {\n        const reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n        this.holes.delete(reuseIndex);\n        this.data[reuseIndex] = result;\n        this.index[key] = reuseIndex;\n      } else {\n        this.data.push(result);\n        this.index[key] = this.data.length - 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Inserts an empty data to the map. This method creates an empty space for obtaining\n   * new data.\n   *\n   * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\n   * @param {number} [amount=1] Ammount of data to insert.\n   */\n  insert(key) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    assert(() => isUnsignedNumber(key) || isNullish(key), 'Expecting an unsigned number or null/undefined argument.');\n    const newIndexes = [];\n    const dataLength = this.data.length;\n    for (let i = 0; i < amount; i++) {\n      newIndexes.push(dataLength + i);\n      this.data.push(undefined);\n    }\n    const insertionIndex = isNullish(key) ? this.index.length : key;\n    this.index = [...this.index.slice(0, insertionIndex), ...newIndexes, ...this.index.slice(insertionIndex)];\n  }\n\n  /**\n   * Removes (soft remove) data from \"index\" and according to the amount of data.\n   *\n   * @param {number} key The key as volatile zero-based index at which to begin removing the data.\n   * @param {number} [amount=1] Ammount data to remove.\n   */\n  remove(key) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    assert(() => isUnsignedNumber(key) || isNullish(key), 'Expecting an unsigned number or null/undefined argument.');\n    const removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n    for (let i = 0; i < removed.length; i++) {\n      const removedIndex = removed[i];\n      if (typeof removedIndex === 'number') {\n        this.holes.add(removedIndex);\n      }\n    }\n  }\n\n  /**\n   * Returns the size of the data which this map holds.\n   *\n   * @returns {number}\n   */\n  size() {\n    return this.data.length - this.holes.size;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each item in the LazyMap object.\n   *\n   * @returns {Iterator}\n   */\n  values() {\n    return arrayFilter(this.data, (_, index) => !this.holes.has(index))[Symbol.iterator]();\n  }\n\n  /**\n   * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\n   *\n   * @returns {Iterator}\n   */\n  entries() {\n    const validEntries = [];\n    for (let i = 0; i < this.data.length; i++) {\n      const keyIndex = this._getKeyByStorageIndex(i);\n      if (keyIndex !== -1) {\n        validEntries.push([keyIndex, this.data[i]]);\n      }\n    }\n    let dataIndex = 0;\n    return {\n      next: () => {\n        if (dataIndex < validEntries.length) {\n          const value = validEntries[dataIndex];\n          dataIndex += 1;\n          return {\n            value,\n            done: false\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  }\n\n  /**\n   * Clears the map.\n   */\n  clear() {\n    this.data = [];\n    this.index = [];\n    this.holes.clear();\n  }\n\n  /**\n   * Gets storage index calculated from the key associated with the specified value.\n   *\n   * @param {number} key Volatile zero-based index.\n   * @returns {number} Returns index 0-N or -1 if no storage index found.\n   */\n  _getStorageIndexByKey(key) {\n    return this.index.length > key ? this.index[key] : -1;\n  }\n\n  /**\n   * Gets the key associated with the specified value calculated from storage index.\n   *\n   * @param {number} dataIndex Zero-based storage index.\n   * @returns {number} Returns index 0-N or -1 if no key found.\n   */\n  _getKeyByStorageIndex(dataIndex) {\n    return this.index.indexOf(dataIndex);\n  }\n\n  /**\n   * Makes this object iterable.\n   *\n   * @returns {Iterator}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","arrayFilter","assert","isUnsignedNumber","isNullish","LazyFactoryMap","constructor","valueFactory","Set","obtain","key","dataIndex","_getStorageIndexByKey","result","data","undefined","holes","size","reuseIndex","values","next","delete","index","push","length","insert","amount","arguments","newIndexes","dataLength","insertionIndex","slice","remove","removed","splice","removedIndex","add","_","has","iterator","entries","validEntries","keyIndex","_getKeyByStorageIndex","done","clear","indexOf"],"sources":["D:/gym-project/frontend/node_modules/handsontable/dataMap/metaManager/lazyFactoryMap.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @class LazyFactoryMap\n *\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\n * regular Map. Once created, items can be moved around a grid depending on the operations\n * performed on that grid - adding or removing rows. The collection requires \"key\"\n * to be a zero-based index.\n *\n * It's essential to notice that the \"key\" index under which the item was created\n * is volatile. After altering the grid, the \"key\" index can change.\n *\n * Having created N items with corresponding example data where the data has 10\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\n * +------+------+------+------+------+.\n *    │      │      │      │      │\n * +------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\n * +------+------+------+------+------+.\n *\n * Map.obtain(0) // returns \"AAA\"\n * map.obtain(2) // returns \"CCC\".\n *\n * After inserting 2 new rows, keys that hold the data positioned after the place\n * where the new rows are added are upshifted by 2.\n *               │\n *               │ Insert 2 rows\n *              \\│/\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\n * +------+------+------+------+------+.\n *\n *                / 2 new rows \\\n * +------+------+------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+.\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * Now at index 2 and 3 we have access to new items.\n *\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\n *\n * after removing 4 rows, keys that hold the data positioned after the place where the\n * rows are removed are downshifted by 4.\n *        │\n *        │ Remove 4 rows\n *        ├───────────────────────────┐\n *       \\│/                          │\n * +------+------+------+------+------+------+------+\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * +------+------+------+\n * | 0/10 | 1/13 | 2/14 |  Keys after\n * +------+------+------+\n *    │       │      │\n *    │       │      └─────────────┐\n *    │       └────────────┐       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *           /│\\   /│\\                   /│\\   /│\\\n *            └──┬──┘                     └──┬──┘\n *           This data is marked as \"hole\" which\n *           means that can be replaced by new item\n *           when that will be created.\n *\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\n *               // changed (the key was downshifted). However, the internal index has not changed,\n *               // which means that the data does not need to be changed (spliced) too.\n *\n * After previous remove operation which creates some \"holes\" obtaining new\n * items replaces that \"holes\" as follows:\n *\n * // Obtains new item\n * map.obtain(90) // Returns \"NEW\" value\n *\n * +------+------+------+...+------+\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\n * +------+------+------+...+------+\n *    │       │      │          │\n *    │       │      └──────────┼────────────┐\n *    │       └─────────────────┼─────┐      │\n *    └──────────┐              │     │      │\n *               │              │     │      │\n *    ┌──────────┼──────────────┘     │      │\n *    │          │                    │      │\n * +------+...+------+------+------+------+------+-----+\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\n * +------+...+------+------+------+------+------+-----+\n *   /│\\\n *    │\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nexport default class LazyFactoryMap {\n  constructor(valueFactory) {\n    /**\n     * The data factory function.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"valueFactory\", void 0);\n    /**\n     * An array which contains data.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"data\", []);\n    /**\n     * An array of indexes where the key of the array is mapped to the value which points to the\n     * specific position of the data array.\n     *\n     * @type {number[]}\n     */\n    _defineProperty(this, \"index\", []);\n    /**\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\n     * ones. The \"holes\" are an intended effect of deleting entries.\n     *\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\n     * items from the collection.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"holes\", new Set());\n    this.valueFactory = valueFactory;\n  }\n\n  /**\n   * Gets or if data not exist creates and returns new data.\n   *\n   * @param {number} key The item key as zero-based index.\n   * @returns {*}\n   */\n  obtain(key) {\n    assert(() => isUnsignedNumber(key), 'Expecting an unsigned number.');\n    const dataIndex = this._getStorageIndexByKey(key);\n    let result;\n    if (dataIndex >= 0) {\n      result = this.data[dataIndex];\n      if (result === undefined) {\n        result = this.valueFactory(key);\n        this.data[dataIndex] = result;\n      }\n    } else {\n      result = this.valueFactory(key);\n      if (this.holes.size > 0) {\n        const reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n        this.holes.delete(reuseIndex);\n        this.data[reuseIndex] = result;\n        this.index[key] = reuseIndex;\n      } else {\n        this.data.push(result);\n        this.index[key] = this.data.length - 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Inserts an empty data to the map. This method creates an empty space for obtaining\n   * new data.\n   *\n   * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\n   * @param {number} [amount=1] Ammount of data to insert.\n   */\n  insert(key) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    assert(() => isUnsignedNumber(key) || isNullish(key), 'Expecting an unsigned number or null/undefined argument.');\n    const newIndexes = [];\n    const dataLength = this.data.length;\n    for (let i = 0; i < amount; i++) {\n      newIndexes.push(dataLength + i);\n      this.data.push(undefined);\n    }\n    const insertionIndex = isNullish(key) ? this.index.length : key;\n    this.index = [...this.index.slice(0, insertionIndex), ...newIndexes, ...this.index.slice(insertionIndex)];\n  }\n\n  /**\n   * Removes (soft remove) data from \"index\" and according to the amount of data.\n   *\n   * @param {number} key The key as volatile zero-based index at which to begin removing the data.\n   * @param {number} [amount=1] Ammount data to remove.\n   */\n  remove(key) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    assert(() => isUnsignedNumber(key) || isNullish(key), 'Expecting an unsigned number or null/undefined argument.');\n    const removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n    for (let i = 0; i < removed.length; i++) {\n      const removedIndex = removed[i];\n      if (typeof removedIndex === 'number') {\n        this.holes.add(removedIndex);\n      }\n    }\n  }\n\n  /**\n   * Returns the size of the data which this map holds.\n   *\n   * @returns {number}\n   */\n  size() {\n    return this.data.length - this.holes.size;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each item in the LazyMap object.\n   *\n   * @returns {Iterator}\n   */\n  values() {\n    return arrayFilter(this.data, (_, index) => !this.holes.has(index))[Symbol.iterator]();\n  }\n\n  /**\n   * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\n   *\n   * @returns {Iterator}\n   */\n  entries() {\n    const validEntries = [];\n    for (let i = 0; i < this.data.length; i++) {\n      const keyIndex = this._getKeyByStorageIndex(i);\n      if (keyIndex !== -1) {\n        validEntries.push([keyIndex, this.data[i]]);\n      }\n    }\n    let dataIndex = 0;\n    return {\n      next: () => {\n        if (dataIndex < validEntries.length) {\n          const value = validEntries[dataIndex];\n          dataIndex += 1;\n          return {\n            value,\n            done: false\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  }\n\n  /**\n   * Clears the map.\n   */\n  clear() {\n    this.data = [];\n    this.index = [];\n    this.holes.clear();\n  }\n\n  /**\n   * Gets storage index calculated from the key associated with the specified value.\n   *\n   * @param {number} key Volatile zero-based index.\n   * @returns {number} Returns index 0-N or -1 if no storage index found.\n   */\n  _getStorageIndexByKey(key) {\n    return this.index.length > key ? this.index[key] : -1;\n  }\n\n  /**\n   * Gets the key associated with the specified value calculated from storage index.\n   *\n   * @param {number} dataIndex Zero-based storage index.\n   * @returns {number} Returns index 0-N or -1 if no key found.\n   */\n  _getKeyByStorageIndex(dataIndex) {\n    return this.index.indexOf(dataIndex);\n  }\n\n  /**\n   * Makes this object iterable.\n   *\n   * @returns {Iterator}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n}"],"mappings":"AASA,SAASA,eAAeA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAAE,OAAO,CAACD,CAAC,GAAGE,cAAc,CAACF,CAAC,CAAC,KAAKD,CAAC,GAAGI,MAAM,CAACC,cAAc,CAACL,CAAC,EAAEC,CAAC,EAAE;IAAEK,KAAK,EAAEJ,CAAC;IAAEK,UAAU,EAAE,CAAC,CAAC;IAAEC,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGT,CAAC,CAACC,CAAC,CAAC,GAAGC,CAAC,EAAEF,CAAC;AAAE;AACnL,SAASG,cAAcA,CAACD,CAAC,EAAE;EAAE,IAAIQ,CAAC,GAAGC,YAAY,CAACT,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOQ,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAACT,CAAC,EAAED,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOC,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIF,CAAC,GAAGE,CAAC,CAACU,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKb,CAAC,EAAE;IAAE,IAAIU,CAAC,GAAGV,CAAC,CAACc,IAAI,CAACZ,CAAC,EAAED,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOS,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIK,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKd,CAAC,GAAGe,MAAM,GAAGC,MAAM,EAAEf,CAAC,CAAC;AAAE;AACvT,SAASgB,WAAW,QAAQ,yBAAyB;AACrD,SAASC,MAAM,EAAEC,gBAAgB,EAAEC,SAAS,QAAQ,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,cAAc,CAAC;EAClCC,WAAWA,CAACC,YAAY,EAAE;IACxB;AACJ;AACA;AACA;AACA;IACIzB,eAAe,CAAC,IAAI,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;IAC7C;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,CAAC;IACjC;AACJ;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE,CAAC;IAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI0B,GAAG,CAAC,CAAC,CAAC;IACzC,IAAI,CAACD,YAAY,GAAGA,YAAY;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEE,MAAMA,CAACC,GAAG,EAAE;IACVR,MAAM,CAAC,MAAMC,gBAAgB,CAACO,GAAG,CAAC,EAAE,+BAA+B,CAAC;IACpE,MAAMC,SAAS,GAAG,IAAI,CAACC,qBAAqB,CAACF,GAAG,CAAC;IACjD,IAAIG,MAAM;IACV,IAAIF,SAAS,IAAI,CAAC,EAAE;MAClBE,MAAM,GAAG,IAAI,CAACC,IAAI,CAACH,SAAS,CAAC;MAC7B,IAAIE,MAAM,KAAKE,SAAS,EAAE;QACxBF,MAAM,GAAG,IAAI,CAACN,YAAY,CAACG,GAAG,CAAC;QAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}