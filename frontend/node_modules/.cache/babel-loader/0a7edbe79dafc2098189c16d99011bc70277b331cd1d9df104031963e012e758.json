{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\n/**\n * The utils class produces the selection ranges in the `{startRow, startCol, endRow, endCol}` format\n * based on the current table selection. The CopyPaste plugin consumes that ranges to generate\n * appropriate data ready to copy to the clipboard.\n *\n * @private\n */\nvar _selectedRange = /*#__PURE__*/new WeakMap();\nvar _countRows = /*#__PURE__*/new WeakMap();\nvar _countColumns = /*#__PURE__*/new WeakMap();\nvar _rowsLimit = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nvar _countColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _CopyableRangesFactory_brand = /*#__PURE__*/new WeakSet();\nexport class CopyableRangesFactory {\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @param {{\n   *   countRows: function(): number,\n   *   countColumns: function(): number,\n   *   rowsLimit: function(): number,\n   *   columnsLimit: function(): number,\n   *   countColumnHeaders: function(): number\n   * }} dependencies The utils class dependencies.\n   */\n  constructor(_ref) {\n    let {\n      countRows,\n      countColumns,\n      rowsLimit,\n      columnsLimit,\n      countColumnHeaders\n    } = _ref;\n    /**\n     * Trimmed the columns range to the limit.\n     *\n     * @param {*} startColumn The lowest column index in the range.\n     * @param {*} endColumn The highest column index in the range.\n     * @returns {number} Returns trimmed column index if it exceeds the limit.\n     */\n    _classPrivateMethodInitSpec(this, _CopyableRangesFactory_brand);\n    /**\n     * @type {CellRange}\n     */\n    _classPrivateFieldInitSpec(this, _selectedRange, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _countRows, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _countColumns, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _rowsLimit, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _countColumnHeaders, void 0);\n    _classPrivateFieldSet(_countRows, this, countRows);\n    _classPrivateFieldSet(_countColumns, this, countColumns);\n    _classPrivateFieldSet(_rowsLimit, this, rowsLimit);\n    _classPrivateFieldSet(_columnsLimit, this, columnsLimit);\n    _classPrivateFieldSet(_countColumnHeaders, this, countColumnHeaders);\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Sets the selection range to be processed.\n   *\n   * @param {CellRange} selectedRange The selection range represented by the CellRange class.\n   */\n  setSelectedRange(selectedRange) {\n    _classPrivateFieldSet(_selectedRange, this, selectedRange);\n  }\n\n  /**\n   * Returns a new coords object within the dataset range (cells) with `startRow`, `startCol`, `endRow`\n   * and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}\n   */\n  getCellsRange() {\n    if (_classPrivateFieldGet(_countRows, this).call(this) === 0 || _classPrivateFieldGet(_countColumns, this).call(this) === 0) {\n      return null;\n    }\n    const {\n      row: startRow,\n      col: startCol\n    } = _classPrivateFieldGet(_selectedRange, this).getTopStartCorner();\n    const {\n      row: endRow,\n      col: endCol\n    } = _classPrivateFieldGet(_selectedRange, this).getBottomEndCorner();\n    const finalEndRow = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimRowsRange).call(this, startRow, endRow);\n    const finalEndCol = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimColumnsRange).call(this, startCol, endCol);\n    const isRangeTrimmed = endRow !== finalEndRow || endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow,\n      startCol,\n      endRow: finalEndRow,\n      endCol: finalEndCol\n    };\n  }\n\n  /**\n   * Returns a new coords object within the most-bottom column headers range with `startRow`,\n   * `startCol`, `endRow` and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}\n   */\n  getMostBottomColumnHeadersRange() {\n    if (_classPrivateFieldGet(_countColumns, this).call(this) === 0 || _classPrivateFieldGet(_countColumnHeaders, this).call(this) === 0) {\n      return null;\n    }\n    const {\n      col: startCol\n    } = _classPrivateFieldGet(_selectedRange, this).getTopStartCorner();\n    const {\n      col: endCol\n    } = _classPrivateFieldGet(_selectedRange, this).getBottomEndCorner();\n    const finalEndCol = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimColumnsRange).call(this, startCol, endCol);\n    const isRangeTrimmed = endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow: -1,\n      startCol,\n      endRow: -1,\n      endCol: finalEndCol\n    };\n  }\n\n  /**\n   * Returns a new coords object within all column headers layers (including nested headers) range with\n   * `startRow`, `startCol`, `endRow` and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}\n   */\n  getAllColumnHeadersRange() {\n    if (_classPrivateFieldGet(_countColumns, this).call(this) === 0 || _classPrivateFieldGet(_countColumnHeaders, this).call(this) === 0) {\n      return null;\n    }\n    const {\n      col: startCol\n    } = _classPrivateFieldGet(_selectedRange, this).getTopStartCorner();\n    const {\n      col: endCol\n    } = _classPrivateFieldGet(_selectedRange, this).getBottomEndCorner();\n    const finalEndCol = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimColumnsRange).call(this, startCol, endCol);\n    const isRangeTrimmed = endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow: -_classPrivateFieldGet(_countColumnHeaders, this).call(this),\n      startCol,\n      endRow: -1,\n      endCol: finalEndCol\n    };\n  }\n}\n\n/**\n * Returns an object with `rows` and `columns` keys. The arrays contains sorted indexes\n * generated according to the given `ranges` array.\n *\n * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges The range to process.\n * @returns {{rows: number[], columns: number[]}}\n */\nfunction _trimColumnsRange(startColumn, endColumn) {\n  return Math.min(endColumn, Math.max(startColumn + _classPrivateFieldGet(_columnsLimit, this).call(this) - 1, startColumn));\n}\n/**\n * Trimmed the rows range to the limit.\n *\n * @param {*} startRow The lowest row index in the range.\n * @param {*} endRow The highest row index in the range.\n * @returns {number} Returns trimmed row index if it exceeds the limit.\n */\nfunction _trimRowsRange(startRow, endRow) {\n  return Math.min(endRow, Math.max(startRow + _classPrivateFieldGet(_rowsLimit, this).call(this) - 1, startRow));\n}\nexport function normalizeRanges(ranges) {\n  const rows = [];\n  const columns = [];\n  arrayEach(ranges, range => {\n    const minRow = Math.min(range.startRow, range.endRow);\n    const maxRow = Math.max(range.startRow, range.endRow);\n    rangeEach(minRow, maxRow, row => {\n      if (rows.indexOf(row) === -1) {\n        rows.push(row);\n      }\n    });\n    const minColumn = Math.min(range.startCol, range.endCol);\n    const maxColumn = Math.max(range.startCol, range.endCol);\n    rangeEach(minColumn, maxColumn, column => {\n      if (columns.indexOf(column) === -1) {\n        columns.push(column);\n      }\n    });\n  });\n  return {\n    rows,\n    columns\n  };\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","arrayEach","rangeEach","_selectedRange","WeakMap","_countRows","_countColumns","_rowsLimit","_columnsLimit","_countColumnHeaders","_CopyableRangesFactory_brand","WeakSet","CopyableRangesFactory","constructor","_ref","countRows","countColumns","rowsLimit","columnsLimit","countColumnHeaders","setSelectedRange","selectedRange","getCellsRange","call","row","startRow","col","startCol","getTopStartCorner","endRow","endCol","getBottomEndCorner","finalEndRow","_trimRowsRange","finalEndCol","_trimColumnsRange","isRangeTrimmed","getMostBottomColumnHeadersRange","getAllColumnHeadersRange","startColumn","endColumn","Math","min","max","normalizeRanges","ranges","rows","columns","range","minRow","maxRow","indexOf","push","minColumn","maxColumn","column"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/copyPaste/copyableRanges.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\n/**\n * The utils class produces the selection ranges in the `{startRow, startCol, endRow, endCol}` format\n * based on the current table selection. The CopyPaste plugin consumes that ranges to generate\n * appropriate data ready to copy to the clipboard.\n *\n * @private\n */\nvar _selectedRange = /*#__PURE__*/new WeakMap();\nvar _countRows = /*#__PURE__*/new WeakMap();\nvar _countColumns = /*#__PURE__*/new WeakMap();\nvar _rowsLimit = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nvar _countColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _CopyableRangesFactory_brand = /*#__PURE__*/new WeakSet();\nexport class CopyableRangesFactory {\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @param {{\n   *   countRows: function(): number,\n   *   countColumns: function(): number,\n   *   rowsLimit: function(): number,\n   *   columnsLimit: function(): number,\n   *   countColumnHeaders: function(): number\n   * }} dependencies The utils class dependencies.\n   */\n  constructor(_ref) {\n    let {\n      countRows,\n      countColumns,\n      rowsLimit,\n      columnsLimit,\n      countColumnHeaders\n    } = _ref;\n    /**\n     * Trimmed the columns range to the limit.\n     *\n     * @param {*} startColumn The lowest column index in the range.\n     * @param {*} endColumn The highest column index in the range.\n     * @returns {number} Returns trimmed column index if it exceeds the limit.\n     */\n    _classPrivateMethodInitSpec(this, _CopyableRangesFactory_brand);\n    /**\n     * @type {CellRange}\n     */\n    _classPrivateFieldInitSpec(this, _selectedRange, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _countRows, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _countColumns, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _rowsLimit, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, void 0);\n    /**\n     * @type {function(): number}\n     */\n    _classPrivateFieldInitSpec(this, _countColumnHeaders, void 0);\n    _classPrivateFieldSet(_countRows, this, countRows);\n    _classPrivateFieldSet(_countColumns, this, countColumns);\n    _classPrivateFieldSet(_rowsLimit, this, rowsLimit);\n    _classPrivateFieldSet(_columnsLimit, this, columnsLimit);\n    _classPrivateFieldSet(_countColumnHeaders, this, countColumnHeaders);\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Sets the selection range to be processed.\n   *\n   * @param {CellRange} selectedRange The selection range represented by the CellRange class.\n   */\n  setSelectedRange(selectedRange) {\n    _classPrivateFieldSet(_selectedRange, this, selectedRange);\n  }\n\n  /**\n   * Returns a new coords object within the dataset range (cells) with `startRow`, `startCol`, `endRow`\n   * and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}\n   */\n  getCellsRange() {\n    if (_classPrivateFieldGet(_countRows, this).call(this) === 0 || _classPrivateFieldGet(_countColumns, this).call(this) === 0) {\n      return null;\n    }\n    const {\n      row: startRow,\n      col: startCol\n    } = _classPrivateFieldGet(_selectedRange, this).getTopStartCorner();\n    const {\n      row: endRow,\n      col: endCol\n    } = _classPrivateFieldGet(_selectedRange, this).getBottomEndCorner();\n    const finalEndRow = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimRowsRange).call(this, startRow, endRow);\n    const finalEndCol = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimColumnsRange).call(this, startCol, endCol);\n    const isRangeTrimmed = endRow !== finalEndRow || endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow,\n      startCol,\n      endRow: finalEndRow,\n      endCol: finalEndCol\n    };\n  }\n\n  /**\n   * Returns a new coords object within the most-bottom column headers range with `startRow`,\n   * `startCol`, `endRow` and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}\n   */\n  getMostBottomColumnHeadersRange() {\n    if (_classPrivateFieldGet(_countColumns, this).call(this) === 0 || _classPrivateFieldGet(_countColumnHeaders, this).call(this) === 0) {\n      return null;\n    }\n    const {\n      col: startCol\n    } = _classPrivateFieldGet(_selectedRange, this).getTopStartCorner();\n    const {\n      col: endCol\n    } = _classPrivateFieldGet(_selectedRange, this).getBottomEndCorner();\n    const finalEndCol = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimColumnsRange).call(this, startCol, endCol);\n    const isRangeTrimmed = endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow: -1,\n      startCol,\n      endRow: -1,\n      endCol: finalEndCol\n    };\n  }\n\n  /**\n   * Returns a new coords object within all column headers layers (including nested headers) range with\n   * `startRow`, `startCol`, `endRow` and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}\n   */\n  getAllColumnHeadersRange() {\n    if (_classPrivateFieldGet(_countColumns, this).call(this) === 0 || _classPrivateFieldGet(_countColumnHeaders, this).call(this) === 0) {\n      return null;\n    }\n    const {\n      col: startCol\n    } = _classPrivateFieldGet(_selectedRange, this).getTopStartCorner();\n    const {\n      col: endCol\n    } = _classPrivateFieldGet(_selectedRange, this).getBottomEndCorner();\n    const finalEndCol = _assertClassBrand(_CopyableRangesFactory_brand, this, _trimColumnsRange).call(this, startCol, endCol);\n    const isRangeTrimmed = endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow: -_classPrivateFieldGet(_countColumnHeaders, this).call(this),\n      startCol,\n      endRow: -1,\n      endCol: finalEndCol\n    };\n  }\n}\n\n/**\n * Returns an object with `rows` and `columns` keys. The arrays contains sorted indexes\n * generated according to the given `ranges` array.\n *\n * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges The range to process.\n * @returns {{rows: number[], columns: number[]}}\n */\nfunction _trimColumnsRange(startColumn, endColumn) {\n  return Math.min(endColumn, Math.max(startColumn + _classPrivateFieldGet(_columnsLimit, this).call(this) - 1, startColumn));\n}\n/**\n * Trimmed the rows range to the limit.\n *\n * @param {*} startRow The lowest row index in the range.\n * @param {*} endRow The highest row index in the range.\n * @returns {number} Returns trimmed row index if it exceeds the limit.\n */\nfunction _trimRowsRange(startRow, endRow) {\n  return Math.min(endRow, Math.max(startRow + _classPrivateFieldGet(_rowsLimit, this).call(this) - 1, startRow));\n}\nexport function normalizeRanges(ranges) {\n  const rows = [];\n  const columns = [];\n  arrayEach(ranges, range => {\n    const minRow = Math.min(range.startRow, range.endRow);\n    const maxRow = Math.max(range.startRow, range.endRow);\n    rangeEach(minRow, maxRow, row => {\n      if (rows.indexOf(row) === -1) {\n        rows.push(row);\n      }\n    });\n    const minColumn = Math.min(range.startCol, range.endCol);\n    const maxColumn = Math.max(range.startCol, range.endCol);\n    rangeEach(minColumn, maxColumn, column => {\n      if (columns.indexOf(column) === -1) {\n        columns.push(column);\n      }\n    });\n  });\n  return {\n    rows,\n    columns\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}