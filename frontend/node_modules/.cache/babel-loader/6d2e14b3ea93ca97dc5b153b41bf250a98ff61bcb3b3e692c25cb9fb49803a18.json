{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * Refactored implementation of LinkedList (part of javascript-algorithms project) by Github users:\n * mgechev, AndriiHeonia, Microfed and Jakeh (part of javascript-algorithms project - all project contributors\n * at repository website).\n *\n * Link to repository: https://github.com/mgechev/javascript-algorithms.\n */\n\n/**\n * Linked list node.\n *\n * @class NodeStructure\n * @util\n */\nclass NodeStructure {\n  constructor(data) {\n    /**\n     * Data of the node.\n     *\n     * @member {object}\n     */\n    _defineProperty(this, \"data\", void 0);\n    /**\n     * Next node.\n     *\n     * @member {NodeStructure}\n     */\n    _defineProperty(this, \"next\", null);\n    /**\n     * Previous node.\n     *\n     * @member {NodeStructure}\n     */\n    _defineProperty(this, \"prev\", null);\n    this.data = data;\n  }\n}\n\n/**\n * Linked list.\n *\n * @class LinkedList\n * @util\n */\nclass LinkedList {\n  constructor() {\n    _defineProperty(this, \"first\", null);\n    _defineProperty(this, \"last\", null);\n  }\n  /**\n   * Add data to the end of linked list.\n   *\n   * @param {object} data Data which should be added.\n   * @returns {NodeStructure} Returns the node which has been added.\n   */\n  push(data) {\n    const node = new NodeStructure(data);\n    if (this.first === null) {\n      this.first = node;\n      this.last = node;\n    } else {\n      const temp = this.last;\n      this.last = node;\n      node.prev = temp;\n      temp.next = node;\n    }\n    return node;\n  }\n\n  /**\n   * Add data to the beginning of linked list.\n   *\n   * @param {object} data Data which should be added.\n   */\n  unshift(data) {\n    const node = new NodeStructure(data);\n    if (this.first === null) {\n      this.first = node;\n      this.last = node;\n    } else {\n      const temp = this.first;\n      this.first = node;\n      node.next = temp;\n      temp.prev = node;\n    }\n  }\n\n  /**\n   * In order traversal of the linked list.\n   *\n   * @param {Function} callback Callback which should be executed on each node.\n   */\n  inorder(callback) {\n    let temp = this.first;\n    while (temp) {\n      const interrupt = callback(temp);\n      if (temp === this.last || interrupt === true) {\n        break;\n      }\n      temp = temp.next;\n    }\n  }\n\n  /**\n   * Remove data from the linked list.\n   *\n   * @param {object} data Data which should be removed.\n   * @returns {boolean} Returns true if data has been removed.\n   */\n  remove(data) {\n    if (this.first === null) {\n      return false;\n    }\n    let temp = this.first;\n    let next;\n    let prev;\n    while (temp) {\n      if (temp.data === data) {\n        next = temp.next;\n        prev = temp.prev;\n        if (next) {\n          next.prev = prev;\n        }\n        if (prev) {\n          prev.next = next;\n        }\n        if (temp === this.first) {\n          this.first = next;\n        }\n        if (temp === this.last) {\n          this.last = prev;\n        }\n        return true;\n      }\n      temp = temp.next;\n    }\n    return false;\n  }\n\n  /**\n   * Check if linked list contains cycle.\n   *\n   * @returns {boolean} Returns true if linked list contains cycle.\n   */\n  hasCycle() {\n    let fast = this.first;\n    let slow = this.first;\n    while (true) {\n      if (fast === null) {\n        return false;\n      }\n      fast = fast.next;\n      if (fast === null) {\n        return false;\n      }\n      fast = fast.next;\n      slow = slow.next;\n      if (fast === slow) {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Return last node from the linked list.\n   *\n   * @returns {NodeStructure} Last node.\n   */\n  pop() {\n    if (this.last === null) {\n      return null;\n    }\n    const temp = this.last;\n    this.last = this.last.prev;\n    return temp;\n  }\n\n  /**\n   * Return first node from the linked list.\n   *\n   * @returns {NodeStructure} First node.\n   */\n  shift() {\n    if (this.first === null) {\n      return null;\n    }\n    const temp = this.first;\n    this.first = this.first.next;\n    return temp;\n  }\n\n  /**\n   * Reverses the linked list recursively.\n   */\n  recursiveReverse() {\n    /**\n     * @param {*} current The current value.\n     * @param {*} next The next value.\n     */\n    function inverse(current, next) {\n      if (!next) {\n        return;\n      }\n      inverse(next, next.next);\n      next.next = current;\n    }\n    if (!this.first) {\n      return;\n    }\n    inverse(this.first, this.first.next);\n    this.first.next = null;\n    const temp = this.first;\n    this.first = this.last;\n    this.last = temp;\n  }\n\n  /**\n   * Reverses the linked list iteratively.\n   */\n  reverse() {\n    if (!this.first || !this.first.next) {\n      return;\n    }\n    let current = this.first.next;\n    let prev = this.first;\n    let temp;\n    while (current) {\n      temp = current.next;\n      current.next = prev;\n      prev.prev = current;\n      prev = current;\n      current = temp;\n    }\n    this.first.next = null;\n    this.last.prev = null;\n    temp = this.first;\n    this.first = prev;\n    this.last = temp;\n  }\n}\nexport { NodeStructure };\nexport default LinkedList;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","NodeStructure","constructor","data","LinkedList","push","node","first","last","temp","prev","next","unshift","inorder","callback","interrupt","remove","hasCycle","fast","slow","pop","shift","recursiveReverse","inverse","current","reverse"],"sources":["D:/gym-project/frontend/node_modules/handsontable/utils/dataStructures/linkedList.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Refactored implementation of LinkedList (part of javascript-algorithms project) by Github users:\n * mgechev, AndriiHeonia, Microfed and Jakeh (part of javascript-algorithms project - all project contributors\n * at repository website).\n *\n * Link to repository: https://github.com/mgechev/javascript-algorithms.\n */\n\n/**\n * Linked list node.\n *\n * @class NodeStructure\n * @util\n */\nclass NodeStructure {\n  constructor(data) {\n    /**\n     * Data of the node.\n     *\n     * @member {object}\n     */\n    _defineProperty(this, \"data\", void 0);\n    /**\n     * Next node.\n     *\n     * @member {NodeStructure}\n     */\n    _defineProperty(this, \"next\", null);\n    /**\n     * Previous node.\n     *\n     * @member {NodeStructure}\n     */\n    _defineProperty(this, \"prev\", null);\n    this.data = data;\n  }\n}\n\n/**\n * Linked list.\n *\n * @class LinkedList\n * @util\n */\nclass LinkedList {\n  constructor() {\n    _defineProperty(this, \"first\", null);\n    _defineProperty(this, \"last\", null);\n  }\n  /**\n   * Add data to the end of linked list.\n   *\n   * @param {object} data Data which should be added.\n   * @returns {NodeStructure} Returns the node which has been added.\n   */\n  push(data) {\n    const node = new NodeStructure(data);\n    if (this.first === null) {\n      this.first = node;\n      this.last = node;\n    } else {\n      const temp = this.last;\n      this.last = node;\n      node.prev = temp;\n      temp.next = node;\n    }\n    return node;\n  }\n\n  /**\n   * Add data to the beginning of linked list.\n   *\n   * @param {object} data Data which should be added.\n   */\n  unshift(data) {\n    const node = new NodeStructure(data);\n    if (this.first === null) {\n      this.first = node;\n      this.last = node;\n    } else {\n      const temp = this.first;\n      this.first = node;\n      node.next = temp;\n      temp.prev = node;\n    }\n  }\n\n  /**\n   * In order traversal of the linked list.\n   *\n   * @param {Function} callback Callback which should be executed on each node.\n   */\n  inorder(callback) {\n    let temp = this.first;\n    while (temp) {\n      const interrupt = callback(temp);\n      if (temp === this.last || interrupt === true) {\n        break;\n      }\n      temp = temp.next;\n    }\n  }\n\n  /**\n   * Remove data from the linked list.\n   *\n   * @param {object} data Data which should be removed.\n   * @returns {boolean} Returns true if data has been removed.\n   */\n  remove(data) {\n    if (this.first === null) {\n      return false;\n    }\n    let temp = this.first;\n    let next;\n    let prev;\n    while (temp) {\n      if (temp.data === data) {\n        next = temp.next;\n        prev = temp.prev;\n        if (next) {\n          next.prev = prev;\n        }\n        if (prev) {\n          prev.next = next;\n        }\n        if (temp === this.first) {\n          this.first = next;\n        }\n        if (temp === this.last) {\n          this.last = prev;\n        }\n        return true;\n      }\n      temp = temp.next;\n    }\n    return false;\n  }\n\n  /**\n   * Check if linked list contains cycle.\n   *\n   * @returns {boolean} Returns true if linked list contains cycle.\n   */\n  hasCycle() {\n    let fast = this.first;\n    let slow = this.first;\n    while (true) {\n      if (fast === null) {\n        return false;\n      }\n      fast = fast.next;\n      if (fast === null) {\n        return false;\n      }\n      fast = fast.next;\n      slow = slow.next;\n      if (fast === slow) {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Return last node from the linked list.\n   *\n   * @returns {NodeStructure} Last node.\n   */\n  pop() {\n    if (this.last === null) {\n      return null;\n    }\n    const temp = this.last;\n    this.last = this.last.prev;\n    return temp;\n  }\n\n  /**\n   * Return first node from the linked list.\n   *\n   * @returns {NodeStructure} First node.\n   */\n  shift() {\n    if (this.first === null) {\n      return null;\n    }\n    const temp = this.first;\n    this.first = this.first.next;\n    return temp;\n  }\n\n  /**\n   * Reverses the linked list recursively.\n   */\n  recursiveReverse() {\n    /**\n     * @param {*} current The current value.\n     * @param {*} next The next value.\n     */\n    function inverse(current, next) {\n      if (!next) {\n        return;\n      }\n      inverse(next, next.next);\n      next.next = current;\n    }\n    if (!this.first) {\n      return;\n    }\n    inverse(this.first, this.first.next);\n    this.first.next = null;\n    const temp = this.first;\n    this.first = this.last;\n    this.last = temp;\n  }\n\n  /**\n   * Reverses the linked list iteratively.\n   */\n  reverse() {\n    if (!this.first || !this.first.next) {\n      return;\n    }\n    let current = this.first.next;\n    let prev = this.first;\n    let temp;\n    while (current) {\n      temp = current.next;\n      current.next = prev;\n      prev.prev = current;\n      prev = current;\n      current = temp;\n    }\n    this.first.next = null;\n    this.last.prev = null;\n    temp = this.first;\n    this.first = prev;\n    this.last = temp;\n  }\n}\nexport { NodeStructure };\nexport default LinkedList;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}