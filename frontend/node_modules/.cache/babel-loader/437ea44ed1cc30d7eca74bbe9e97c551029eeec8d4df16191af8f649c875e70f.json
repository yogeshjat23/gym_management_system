{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @private\n * @class SelectionCalculations\n */\nclass SelectionCalculations {\n  constructor(plugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"fullySelectedMergedCellClassName\", 'fullySelectedMergedCell');\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n  }\n\n  /**\n   * Generate an additional class name for the entirely-selected merged cells.\n   *\n   * @param {number} currentRow Visual row index of the currently processed cell.\n   * @param {number} currentColumn Visual column index of the currently cell.\n   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n   */\n  getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n    const startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n    const startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n    const endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n    const endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n    if (layerLevel === undefined) {\n      return;\n    }\n    const isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);\n\n    // We add extra classes just to the first renderable merged cell.\n    if (!isFirstRenderableMergedCell) {\n      return;\n    }\n    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n    if (!mergedCell) {\n      return;\n    }\n    const mergeRowEnd = mergedCell.getLastRow();\n    const mergeColumnEnd = mergedCell.getLastColumn();\n    const fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n    if (fullMergeAreaWithinSelection) {\n      return `${this.fullySelectedMergedCellClassName}-${layerLevel}`;\n    } else if (this.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n      return `${this.fullySelectedMergedCellClassName}-multiple`;\n    }\n  }\n\n  /**\n   * Check if the provided merged cell is fully selected (by one or many layers of selection).\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n   * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n   * @returns {boolean}\n   */\n  isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n    const mergedCellIndividualCoords = [];\n    if (!selectionRangesArray || !mergedCell) {\n      return false;\n    }\n    for (let r = 0; r < mergedCell.rowspan; r += 1) {\n      for (let c = 0; c < mergedCell.colspan; c += 1) {\n        mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));\n      }\n    }\n    for (let i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n      const insideSelections = [];\n      for (let s = 0; s < selectionRangesArray.length; s += 1) {\n        insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n      }\n      if (!insideSelections.includes(true)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Generate an array of the entirely-selected merged cells' class names.\n   *\n   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n   */\n  getSelectedMergedCellClassNameToRemove() {\n    const classNames = [];\n    for (let i = 0; i <= 7; i += 1) {\n      classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);\n    }\n    classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);\n    return classNames;\n  }\n}\nexport default SelectionCalculations;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","SelectionCalculations","constructor","plugin","hot","getSelectedMergedCellClassName","currentRow","currentColumn","cornersOfSelection","layerLevel","startRow","Math","min","startColumn","endRow","max","endColumn","undefined","isFirstRenderableMergedCell","mergedCellsCollection","mergedCell","get","mergeRowEnd","getLastRow","mergeColumnEnd","getLastColumn","fullMergeAreaWithinSelection","row","col","fullySelectedMergedCellClassName","isMergeCellFullySelected","getSelectedRange","selectionRangesArray","mergedCellIndividualCoords","rowspan","c","colspan","push","_createCellCoords","length","insideSelections","s","includes","getSelectedMergedCellClassNameToRemove","classNames"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @private\n * @class SelectionCalculations\n */\nclass SelectionCalculations {\n  constructor(plugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"fullySelectedMergedCellClassName\", 'fullySelectedMergedCell');\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n  }\n\n  /**\n   * Generate an additional class name for the entirely-selected merged cells.\n   *\n   * @param {number} currentRow Visual row index of the currently processed cell.\n   * @param {number} currentColumn Visual column index of the currently cell.\n   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n   */\n  getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n    const startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n    const startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n    const endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n    const endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n    if (layerLevel === undefined) {\n      return;\n    }\n    const isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);\n\n    // We add extra classes just to the first renderable merged cell.\n    if (!isFirstRenderableMergedCell) {\n      return;\n    }\n    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n    if (!mergedCell) {\n      return;\n    }\n    const mergeRowEnd = mergedCell.getLastRow();\n    const mergeColumnEnd = mergedCell.getLastColumn();\n    const fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n    if (fullMergeAreaWithinSelection) {\n      return `${this.fullySelectedMergedCellClassName}-${layerLevel}`;\n    } else if (this.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n      return `${this.fullySelectedMergedCellClassName}-multiple`;\n    }\n  }\n\n  /**\n   * Check if the provided merged cell is fully selected (by one or many layers of selection).\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n   * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n   * @returns {boolean}\n   */\n  isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n    const mergedCellIndividualCoords = [];\n    if (!selectionRangesArray || !mergedCell) {\n      return false;\n    }\n    for (let r = 0; r < mergedCell.rowspan; r += 1) {\n      for (let c = 0; c < mergedCell.colspan; c += 1) {\n        mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));\n      }\n    }\n    for (let i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n      const insideSelections = [];\n      for (let s = 0; s < selectionRangesArray.length; s += 1) {\n        insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n      }\n      if (!insideSelections.includes(true)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Generate an array of the entirely-selected merged cells' class names.\n   *\n   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n   */\n  getSelectedMergedCellClassNameToRemove() {\n    const classNames = [];\n    for (let i = 0; i <= 7; i += 1) {\n      classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);\n    }\n    classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);\n    return classNames;\n  }\n}\nexport default SelectionCalculations;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}