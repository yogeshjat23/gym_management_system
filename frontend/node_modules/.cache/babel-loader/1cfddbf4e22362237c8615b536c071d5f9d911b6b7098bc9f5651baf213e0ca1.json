{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_PRE = 'DF-pre-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nexport function depthFirstPreOrder(callback, context) {\n  let continueTraverse = callback.call(context, this);\n  for (let i = 0; i < this.childs.length; i++) {\n    if (continueTraverse === false) {\n      return false;\n    }\n    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);\n  }\n  return continueTraverse;\n}\n\n/**\n * Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_POST = 'DF-post-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nfunction depthFirstPostOrder(callback, context) {\n  for (let i = 0; i < this.childs.length; i++) {\n    const continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);\n    if (continueTraverse === false) {\n      return false;\n    }\n  }\n  return callback.call(context, this);\n}\n\n/**\n * Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n *\n * @type {string}\n */\nexport const TRAVERSAL_BF = 'BF';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n */\nfunction breadthFirst(callback, context) {\n  const queue = [this];\n\n  /**\n   * Internal processor.\n   */\n  function process() {\n    if (queue.length === 0) {\n      return;\n    }\n    const node = queue.shift();\n    queue.push(...node.childs);\n    if (callback.call(context, node) !== false) {\n      process();\n    }\n  }\n  process();\n}\n\n/**\n * Default strategy for tree traversal.\n *\n * @type {string}\n */\nconst DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;\n/**\n * Collection of all available tree traversal strategies.\n *\n * @type {Map<string, Function>}\n */\nconst TRAVERSAL_STRATEGIES = new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);\n\n/**\n *\n */\nexport default class TreeNode {\n  constructor(data) {\n    /**\n     * A tree data.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"data\", {});\n    /**\n     * A parent node.\n     *\n     * @type {TreeNode}\n     */\n    _defineProperty(this, \"parent\", null);\n    /**\n     * A tree leaves.\n     *\n     * @type {TreeNode[]}\n     */\n    _defineProperty(this, \"childs\", []);\n    this.data = data;\n  }\n\n  /**\n   * Adds a node to tree leaves. Added node is linked with the parent node through \"parent\" property.\n   *\n   * @param {TreeNode} node A TreeNode to add.\n   */\n  addChild(node) {\n    node.parent = this;\n    this.childs.push(node);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof TreeNode#\n   * @function cloneTree\n   *\n   * Clones a tree structure deeply.\n   *\n   * For example, for giving a tree structure:\n   *      .--(B1)--.\n   *   .-(C1)   .-(C2)-.----.\n   *  (D1)     (D2)   (D3) (D4)\n   *\n   * Cloning a tree starting from C2 node creates a mirrored tree structure.\n   *     .-(C2')-.-----.\n   *    (D2')   (D3') (D4')\n   *\n   * The cloned tree can be safely modified without affecting the original structure.\n   * After modification, the clone can be merged with a tree using the \"replaceTreeWith\" method.\n   *\n   * @param {TreeNode} [nodeTree=this] A TreeNode to clone.\n   * @returns {TreeNode}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  cloneTree() {\n    let nodeTree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n    const clonedNode = new TreeNode({\n      ...nodeTree.data\n    });\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));\n    }\n    return clonedNode;\n  }\n\n  /**\n   * Replaces the current node with a passed tree structure.\n   *\n   * @param {TreeNode} nodeTree A TreeNode to replace with.\n   */\n  replaceTreeWith(nodeTree) {\n    this.data = {\n      ...nodeTree.data\n    };\n    this.childs = [];\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      this.addChild(nodeTree.childs[i]);\n    }\n  }\n\n  /**\n   * Traverses the tree structure through node childs. The walk down traversing supports\n   * a three different strategies.\n   *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));\n   *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));\n   *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.\n   */\n  walkDown(callback) {\n    let traversalStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;\n    if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {\n      throw new Error(`Traversal strategy \"${traversalStrategy}\" does not exist`);\n    }\n    TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);\n  }\n\n  /**\n   * Traverses the tree structure through node parents.\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   */\n  walkUp(callback) {\n    const context = this;\n    const process = node => {\n      const continueTraverse = callback.call(context, node);\n      if (continueTraverse !== false && node.parent !== null) {\n        process(node.parent);\n      }\n    };\n    process(this);\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","TRAVERSAL_DF_PRE","depthFirstPreOrder","callback","context","continueTraverse","childs","length","TRAVERSAL_DF_POST","depthFirstPostOrder","TRAVERSAL_BF","breadthFirst","queue","process","node","shift","push","DEFAULT_TRAVERSAL_STRATEGY","TRAVERSAL_STRATEGIES","Map","TreeNode","constructor","data","addChild","parent","cloneTree","nodeTree","arguments","undefined","clonedNode","replaceTreeWith","walkDown","traversalStrategy","has","Error","get","walkUp"],"sources":["D:/gym-project/frontend/node_modules/handsontable/utils/dataStructures/tree.mjs"],"sourcesContent":["function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\n/**\n * Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_PRE = 'DF-pre-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nexport function depthFirstPreOrder(callback, context) {\n  let continueTraverse = callback.call(context, this);\n  for (let i = 0; i < this.childs.length; i++) {\n    if (continueTraverse === false) {\n      return false;\n    }\n    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);\n  }\n  return continueTraverse;\n}\n\n/**\n * Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_POST = 'DF-post-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nfunction depthFirstPostOrder(callback, context) {\n  for (let i = 0; i < this.childs.length; i++) {\n    const continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);\n    if (continueTraverse === false) {\n      return false;\n    }\n  }\n  return callback.call(context, this);\n}\n\n/**\n * Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n *\n * @type {string}\n */\nexport const TRAVERSAL_BF = 'BF';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n */\nfunction breadthFirst(callback, context) {\n  const queue = [this];\n\n  /**\n   * Internal processor.\n   */\n  function process() {\n    if (queue.length === 0) {\n      return;\n    }\n    const node = queue.shift();\n    queue.push(...node.childs);\n    if (callback.call(context, node) !== false) {\n      process();\n    }\n  }\n  process();\n}\n\n/**\n * Default strategy for tree traversal.\n *\n * @type {string}\n */\nconst DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;\n/**\n * Collection of all available tree traversal strategies.\n *\n * @type {Map<string, Function>}\n */\nconst TRAVERSAL_STRATEGIES = new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);\n\n/**\n *\n */\nexport default class TreeNode {\n  constructor(data) {\n    /**\n     * A tree data.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"data\", {});\n    /**\n     * A parent node.\n     *\n     * @type {TreeNode}\n     */\n    _defineProperty(this, \"parent\", null);\n    /**\n     * A tree leaves.\n     *\n     * @type {TreeNode[]}\n     */\n    _defineProperty(this, \"childs\", []);\n    this.data = data;\n  }\n\n  /**\n   * Adds a node to tree leaves. Added node is linked with the parent node through \"parent\" property.\n   *\n   * @param {TreeNode} node A TreeNode to add.\n   */\n  addChild(node) {\n    node.parent = this;\n    this.childs.push(node);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof TreeNode#\n   * @function cloneTree\n   *\n   * Clones a tree structure deeply.\n   *\n   * For example, for giving a tree structure:\n   *      .--(B1)--.\n   *   .-(C1)   .-(C2)-.----.\n   *  (D1)     (D2)   (D3) (D4)\n   *\n   * Cloning a tree starting from C2 node creates a mirrored tree structure.\n   *     .-(C2')-.-----.\n   *    (D2')   (D3') (D4')\n   *\n   * The cloned tree can be safely modified without affecting the original structure.\n   * After modification, the clone can be merged with a tree using the \"replaceTreeWith\" method.\n   *\n   * @param {TreeNode} [nodeTree=this] A TreeNode to clone.\n   * @returns {TreeNode}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  cloneTree() {\n    let nodeTree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n    const clonedNode = new TreeNode({\n      ...nodeTree.data\n    });\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));\n    }\n    return clonedNode;\n  }\n\n  /**\n   * Replaces the current node with a passed tree structure.\n   *\n   * @param {TreeNode} nodeTree A TreeNode to replace with.\n   */\n  replaceTreeWith(nodeTree) {\n    this.data = {\n      ...nodeTree.data\n    };\n    this.childs = [];\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      this.addChild(nodeTree.childs[i]);\n    }\n  }\n\n  /**\n   * Traverses the tree structure through node childs. The walk down traversing supports\n   * a three different strategies.\n   *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));\n   *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));\n   *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.\n   */\n  walkDown(callback) {\n    let traversalStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;\n    if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {\n      throw new Error(`Traversal strategy \"${traversalStrategy}\" does not exist`);\n    }\n    TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);\n  }\n\n  /**\n   * Traverses the tree structure through node parents.\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   */\n  walkUp(callback) {\n    const context = this;\n    const process = node => {\n      const continueTraverse = callback.call(context, node);\n      if (continueTraverse !== false && node.parent !== null) {\n        process(node.parent);\n      }\n    };\n    process(this);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}