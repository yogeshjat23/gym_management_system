{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { MapCollection } from \"./mapCollection.mjs\";\nimport { arrayMap } from \"../../helpers/array.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\n/**\n * Collection of maps. This collection aggregate maps with the same type of values. Values from the registered maps\n * can be used to calculate a single result for particular index.\n */\nexport class AggregatedCollection extends MapCollection {\n  constructor(aggregationFunction, fallbackValue) {\n    super();\n    /**\n     * List of merged values. Value for each index is calculated using values inside registered maps.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedValuesCache\", []);\n    /**\n     * Function which do aggregation on the values for particular index.\n     */\n    _defineProperty(this, \"aggregationFunction\", void 0);\n    /**\n     * Fallback value when there is no calculated value for particular index.\n     */\n    _defineProperty(this, \"fallbackValue\", void 0);\n    this.aggregationFunction = aggregationFunction;\n    this.fallbackValue = fallbackValue;\n  }\n\n  /**\n   * Get merged values for all indexes.\n   *\n   * @param {boolean} [readFromCache=true] Determine if read results from the cache.\n   * @returns {Array}\n   */\n  getMergedValues() {\n    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (readFromCache === true) {\n      return this.mergedValuesCache;\n    }\n    if (this.getLength() === 0) {\n      return [];\n    }\n\n    // Below variable stores values for every particular map. Example describing situation when we have 2 registered maps,\n    // with length equal to 5.\n    //\n    // +---------+---------------------------------------------+\n    // |         |                  indexes                    |\n    // +---------+---------------------------------------------+\n    // |   maps  |     0    |   1   |    2  |   3   |    4     |\n    // +---------+----------+-------+-------+-------+----------+\n    // |    0    | [[ value,  value,  value,  value,  value ], |\n    // |    1    | [  value,  value,  value,  value,  value ]] |\n    // +---------+----------+-------+-------+-------+----------+\n    const mapsValuesMatrix = arrayMap(this.get(), map => map.getValues());\n    // Below variable stores values for every particular index. Example describing situation when we have 2 registered maps,\n    // with length equal to 5.\n    //\n    // +---------+---------------------+\n    // |         |         maps        |\n    // +---------+---------------------+\n    // | indexes |     0    |    1     |\n    // +---------+----------+----------+\n    // |    0    | [[ value,  value ], |\n    // |    1    | [  value,  value ], |\n    // |    2    | [  value,  value ], |\n    // |    3    | [  value,  value ], |\n    // |    4    | [  value,  value ]] |\n    // +---------+----------+----------+\n    const indexesValuesMatrix = [];\n    const mapsLength = isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;\n    for (let index = 0; index < mapsLength; index += 1) {\n      const valuesForIndex = [];\n      for (let mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {\n        valuesForIndex.push(mapsValuesMatrix[mapIndex][index]);\n      }\n      indexesValuesMatrix.push(valuesForIndex);\n    }\n    return arrayMap(indexesValuesMatrix, this.aggregationFunction);\n  }\n\n  /**\n   * Get merged value for particular index.\n   *\n   * @param {number} index Index for which we calculate single result.\n   * @param {boolean} [readFromCache=true] Determine if read results from the cache.\n   * @returns {*}\n   */\n  getMergedValueAtIndex(index, readFromCache) {\n    const valueAtIndex = this.getMergedValues(readFromCache)[index];\n    return isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;\n  }\n\n  /**\n   * Rebuild cache for the collection.\n   */\n  updateCache() {\n    this.mergedValuesCache = this.getMergedValues(false);\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","MapCollection","arrayMap","isDefined","AggregatedCollection","constructor","aggregationFunction","fallbackValue","getMergedValues","readFromCache","arguments","length","undefined","mergedValuesCache","getLength","mapsValuesMatrix","get","map","getValues","indexesValuesMatrix","mapsLength","index","valuesForIndex","mapIndex","push","getMergedValueAtIndex","valueAtIndex","updateCache"],"sources":["D:/gym-project/frontend/node_modules/handsontable/translations/mapCollections/aggregatedCollection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { MapCollection } from \"./mapCollection.mjs\";\nimport { arrayMap } from \"../../helpers/array.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\n/**\n * Collection of maps. This collection aggregate maps with the same type of values. Values from the registered maps\n * can be used to calculate a single result for particular index.\n */\nexport class AggregatedCollection extends MapCollection {\n  constructor(aggregationFunction, fallbackValue) {\n    super();\n    /**\n     * List of merged values. Value for each index is calculated using values inside registered maps.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedValuesCache\", []);\n    /**\n     * Function which do aggregation on the values for particular index.\n     */\n    _defineProperty(this, \"aggregationFunction\", void 0);\n    /**\n     * Fallback value when there is no calculated value for particular index.\n     */\n    _defineProperty(this, \"fallbackValue\", void 0);\n    this.aggregationFunction = aggregationFunction;\n    this.fallbackValue = fallbackValue;\n  }\n\n  /**\n   * Get merged values for all indexes.\n   *\n   * @param {boolean} [readFromCache=true] Determine if read results from the cache.\n   * @returns {Array}\n   */\n  getMergedValues() {\n    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (readFromCache === true) {\n      return this.mergedValuesCache;\n    }\n    if (this.getLength() === 0) {\n      return [];\n    }\n\n    // Below variable stores values for every particular map. Example describing situation when we have 2 registered maps,\n    // with length equal to 5.\n    //\n    // +---------+---------------------------------------------+\n    // |         |                  indexes                    |\n    // +---------+---------------------------------------------+\n    // |   maps  |     0    |   1   |    2  |   3   |    4     |\n    // +---------+----------+-------+-------+-------+----------+\n    // |    0    | [[ value,  value,  value,  value,  value ], |\n    // |    1    | [  value,  value,  value,  value,  value ]] |\n    // +---------+----------+-------+-------+-------+----------+\n    const mapsValuesMatrix = arrayMap(this.get(), map => map.getValues());\n    // Below variable stores values for every particular index. Example describing situation when we have 2 registered maps,\n    // with length equal to 5.\n    //\n    // +---------+---------------------+\n    // |         |         maps        |\n    // +---------+---------------------+\n    // | indexes |     0    |    1     |\n    // +---------+----------+----------+\n    // |    0    | [[ value,  value ], |\n    // |    1    | [  value,  value ], |\n    // |    2    | [  value,  value ], |\n    // |    3    | [  value,  value ], |\n    // |    4    | [  value,  value ]] |\n    // +---------+----------+----------+\n    const indexesValuesMatrix = [];\n    const mapsLength = isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;\n    for (let index = 0; index < mapsLength; index += 1) {\n      const valuesForIndex = [];\n      for (let mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {\n        valuesForIndex.push(mapsValuesMatrix[mapIndex][index]);\n      }\n      indexesValuesMatrix.push(valuesForIndex);\n    }\n    return arrayMap(indexesValuesMatrix, this.aggregationFunction);\n  }\n\n  /**\n   * Get merged value for particular index.\n   *\n   * @param {number} index Index for which we calculate single result.\n   * @param {boolean} [readFromCache=true] Determine if read results from the cache.\n   * @returns {*}\n   */\n  getMergedValueAtIndex(index, readFromCache) {\n    const valueAtIndex = this.getMergedValues(readFromCache)[index];\n    return isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;\n  }\n\n  /**\n   * Rebuild cache for the collection.\n   */\n  updateCache() {\n    this.mergedValuesCache = this.getMergedValues(false);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}