{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { isObject } from \"./../helpers/object.mjs\";\nimport { rangeEach } from \"./../helpers/number.mjs\";\nimport { stringify } from \"./../helpers/mixed.mjs\";\n/**\n * @class SamplesGenerator\n */\nclass SamplesGenerator {\n  /**\n   * Number of samples to take of each value length.\n   *\n   * @type {number}\n   */\n  static get SAMPLE_COUNT() {\n    return 3;\n  }\n  /**\n   * Samples prepared for calculations.\n   *\n   * @type {Map}\n   * @default {null}\n   */\n\n  constructor(dataFactory) {\n    _defineProperty(this, \"samples\", null);\n    /**\n     * Function which give the data to collect samples.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"dataFactory\", null);\n    /**\n     * Custom number of samples to take of each value length.\n     *\n     * @type {number}\n     * @default {null}\n     */\n    _defineProperty(this, \"customSampleCount\", null);\n    /**\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\n     *\n     * @type {boolean}\n     * @default {false}\n     */\n    _defineProperty(this, \"allowDuplicates\", false);\n    this.dataFactory = dataFactory;\n  }\n\n  /**\n   * Get the sample count for this instance.\n   *\n   * @returns {number}\n   */\n  getSampleCount() {\n    if (this.customSampleCount) {\n      return this.customSampleCount;\n    }\n    return SamplesGenerator.SAMPLE_COUNT;\n  }\n\n  /**\n   * Set the sample count.\n   *\n   * @param {number} sampleCount Number of samples to be collected.\n   */\n  setSampleCount(sampleCount) {\n    this.customSampleCount = sampleCount;\n  }\n\n  /**\n   * Set if the generator should accept duplicate values.\n   *\n   * @param {boolean} allowDuplicates `true` to allow duplicate values.\n   */\n  setAllowDuplicates(allowDuplicates) {\n    this.allowDuplicates = allowDuplicates;\n  }\n\n  /**\n   * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\n   *\n   * @param {object|number} rowRange The rows range to generate the samples.\n   * @param {object} colRange The column range to generate the samples.\n   * @returns {object}\n   */\n  generateRowSamples(rowRange, colRange) {\n    return this.generateSamples('row', colRange, rowRange);\n  }\n\n  /**\n   * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\n   *\n   * @param {object} colRange Column index.\n   * @param {object} rowRange Column index.\n   * @returns {object}\n   */\n  generateColumnSamples(colRange, rowRange) {\n    return this.generateSamples('col', rowRange, colRange);\n  }\n\n  /**\n   * Generate collection of samples.\n   *\n   * @param {string} type Type to generate. Can be `col` or `row`.\n   * @param {object} range The range to generate the samples.\n   * @param {object|number} specifierRange The range to generate the samples.\n   * @returns {Map}\n   */\n  generateSamples(type, range, specifierRange) {\n    const samples = new Map();\n    const {\n      from,\n      to\n    } = typeof specifierRange === 'number' ? {\n      from: specifierRange,\n      to: specifierRange\n    } : specifierRange;\n    rangeEach(from, to, index => {\n      const sample = this.generateSample(type, range, index);\n      samples.set(index, sample);\n    });\n    return samples;\n  }\n\n  /**\n   * Generate sample for specified type (`row` or `col`).\n   *\n   * @param {string} type Samples type `row` or `col`.\n   * @param {object} range The range to generate the samples.\n   * @param {number} specifierValue The range to generate the samples.\n   * @returns {Map}\n   */\n  generateSample(type, range, specifierValue) {\n    if (type !== 'row' && type !== 'col') {\n      throw new Error('Unsupported sample type');\n    }\n    const samples = new Map();\n    const computedKey = type === 'row' ? 'col' : 'row';\n    const sampledValues = [];\n    rangeEach(range.from, range.to, index => {\n      const data = type === 'row' ? this.dataFactory(specifierValue, index) : this.dataFactory(index, specifierValue);\n      if (data === false) {\n        return;\n      }\n      const {\n        value,\n        bundleSeed\n      } = data;\n      const hasCustomBundleSeed = typeof bundleSeed === 'string' && bundleSeed.length > 0;\n      let seed;\n      if (hasCustomBundleSeed) {\n        seed = bundleSeed;\n      } else if (isObject(value)) {\n        seed = `${Object.keys(value).length}`;\n      } else if (Array.isArray(value)) {\n        seed = `${value.length}`;\n      } else {\n        seed = `${stringify(value).length}`;\n      }\n      if (!samples.has(seed)) {\n        samples.set(seed, {\n          needed: this.getSampleCount(),\n          strings: []\n        });\n      }\n      const sample = samples.get(seed);\n      if (sample.needed) {\n        const duplicate = sampledValues.indexOf(value) > -1;\n        if (!duplicate || this.allowDuplicates || hasCustomBundleSeed) {\n          sample.strings.push({\n            value,\n            [computedKey]: index\n          });\n          sampledValues.push(value);\n          sample.needed -= 1;\n        }\n      }\n    });\n    return samples;\n  }\n}\nexport default SamplesGenerator;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","isObject","rangeEach","stringify","SamplesGenerator","SAMPLE_COUNT","constructor","dataFactory","getSampleCount","customSampleCount","setSampleCount","sampleCount","setAllowDuplicates","allowDuplicates","generateRowSamples","rowRange","colRange","generateSamples","generateColumnSamples","type","range","specifierRange","samples","Map","from","to","index","sample","generateSample","set","specifierValue","Error","computedKey","sampledValues","data","bundleSeed","hasCustomBundleSeed","length","seed","keys","Array","isArray","has","needed","strings","get","duplicate","indexOf","push"],"sources":["D:/gym-project/frontend/node_modules/handsontable/utils/samplesGenerator.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { isObject } from \"./../helpers/object.mjs\";\nimport { rangeEach } from \"./../helpers/number.mjs\";\nimport { stringify } from \"./../helpers/mixed.mjs\";\n/**\n * @class SamplesGenerator\n */\nclass SamplesGenerator {\n  /**\n   * Number of samples to take of each value length.\n   *\n   * @type {number}\n   */\n  static get SAMPLE_COUNT() {\n    return 3;\n  }\n  /**\n   * Samples prepared for calculations.\n   *\n   * @type {Map}\n   * @default {null}\n   */\n\n  constructor(dataFactory) {\n    _defineProperty(this, \"samples\", null);\n    /**\n     * Function which give the data to collect samples.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"dataFactory\", null);\n    /**\n     * Custom number of samples to take of each value length.\n     *\n     * @type {number}\n     * @default {null}\n     */\n    _defineProperty(this, \"customSampleCount\", null);\n    /**\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\n     *\n     * @type {boolean}\n     * @default {false}\n     */\n    _defineProperty(this, \"allowDuplicates\", false);\n    this.dataFactory = dataFactory;\n  }\n\n  /**\n   * Get the sample count for this instance.\n   *\n   * @returns {number}\n   */\n  getSampleCount() {\n    if (this.customSampleCount) {\n      return this.customSampleCount;\n    }\n    return SamplesGenerator.SAMPLE_COUNT;\n  }\n\n  /**\n   * Set the sample count.\n   *\n   * @param {number} sampleCount Number of samples to be collected.\n   */\n  setSampleCount(sampleCount) {\n    this.customSampleCount = sampleCount;\n  }\n\n  /**\n   * Set if the generator should accept duplicate values.\n   *\n   * @param {boolean} allowDuplicates `true` to allow duplicate values.\n   */\n  setAllowDuplicates(allowDuplicates) {\n    this.allowDuplicates = allowDuplicates;\n  }\n\n  /**\n   * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\n   *\n   * @param {object|number} rowRange The rows range to generate the samples.\n   * @param {object} colRange The column range to generate the samples.\n   * @returns {object}\n   */\n  generateRowSamples(rowRange, colRange) {\n    return this.generateSamples('row', colRange, rowRange);\n  }\n\n  /**\n   * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\n   *\n   * @param {object} colRange Column index.\n   * @param {object} rowRange Column index.\n   * @returns {object}\n   */\n  generateColumnSamples(colRange, rowRange) {\n    return this.generateSamples('col', rowRange, colRange);\n  }\n\n  /**\n   * Generate collection of samples.\n   *\n   * @param {string} type Type to generate. Can be `col` or `row`.\n   * @param {object} range The range to generate the samples.\n   * @param {object|number} specifierRange The range to generate the samples.\n   * @returns {Map}\n   */\n  generateSamples(type, range, specifierRange) {\n    const samples = new Map();\n    const {\n      from,\n      to\n    } = typeof specifierRange === 'number' ? {\n      from: specifierRange,\n      to: specifierRange\n    } : specifierRange;\n    rangeEach(from, to, index => {\n      const sample = this.generateSample(type, range, index);\n      samples.set(index, sample);\n    });\n    return samples;\n  }\n\n  /**\n   * Generate sample for specified type (`row` or `col`).\n   *\n   * @param {string} type Samples type `row` or `col`.\n   * @param {object} range The range to generate the samples.\n   * @param {number} specifierValue The range to generate the samples.\n   * @returns {Map}\n   */\n  generateSample(type, range, specifierValue) {\n    if (type !== 'row' && type !== 'col') {\n      throw new Error('Unsupported sample type');\n    }\n    const samples = new Map();\n    const computedKey = type === 'row' ? 'col' : 'row';\n    const sampledValues = [];\n    rangeEach(range.from, range.to, index => {\n      const data = type === 'row' ? this.dataFactory(specifierValue, index) : this.dataFactory(index, specifierValue);\n      if (data === false) {\n        return;\n      }\n      const {\n        value,\n        bundleSeed\n      } = data;\n      const hasCustomBundleSeed = typeof bundleSeed === 'string' && bundleSeed.length > 0;\n      let seed;\n      if (hasCustomBundleSeed) {\n        seed = bundleSeed;\n      } else if (isObject(value)) {\n        seed = `${Object.keys(value).length}`;\n      } else if (Array.isArray(value)) {\n        seed = `${value.length}`;\n      } else {\n        seed = `${stringify(value).length}`;\n      }\n      if (!samples.has(seed)) {\n        samples.set(seed, {\n          needed: this.getSampleCount(),\n          strings: []\n        });\n      }\n      const sample = samples.get(seed);\n      if (sample.needed) {\n        const duplicate = sampledValues.indexOf(value) > -1;\n        if (!duplicate || this.allowDuplicates || hasCustomBundleSeed) {\n          sample.strings.push({\n            value,\n            [computedKey]: index\n          });\n          sampledValues.push(value);\n          sample.needed -= 1;\n        }\n      }\n    });\n    return samples;\n  }\n}\nexport default SamplesGenerator;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}