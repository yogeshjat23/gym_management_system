{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { IndexMap } from \"./indexMap.mjs\";\nimport { getListWithRemovedItems, getListWithInsertedItems } from \"./utils/physicallyIndexed.mjs\";\nimport { getListWithRemovedItems as getListWithoutIndexes } from \"./utils/indexesSequence.mjs\";\nimport { getDecreasedIndexes, getIncreasedIndexes } from \"./utils/actionsOnIndexes.mjs\";\nimport { isFunction } from \"../../helpers/function.mjs\";\n/**\n * Map for storing mappings from an physical index to a value. Those entries are linked and stored in a certain order.\n *\n * It does not update stored values on remove/add row or column action. Otherwise, order of entries is updated after\n * such changes.\n *\n * @class LinkedPhysicalIndexToValueMap\n */\nexport class LinkedPhysicalIndexToValueMap extends IndexMap {\n  constructor() {\n    super(...arguments);\n    /**\n     * Indexes and values corresponding to them (entries) are stored in a certain order.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _defineProperty(this, \"orderOfIndexes\", []);\n  }\n  /**\n   * Get full list of ordered values for particular indexes.\n   *\n   * @returns {Array}\n   */\n  getValues() {\n    return this.orderOfIndexes.map(physicalIndex => this.indexedValues[physicalIndex]);\n  }\n\n  /**\n   * Set new values for particular indexes. Entries are linked and stored in a certain order.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @param {Array} values List of set values.\n   */\n  setValues(values) {\n    this.orderOfIndexes = [...Array(values.length).keys()];\n    super.setValues(values);\n  }\n\n  /**\n   * Set value at index and add it to the linked list of entries. Entries are stored in a certain order.\n   *\n   * Note: Value will be added at the end of the queue.\n   *\n   * @param {number} index The index.\n   * @param {*} value The value to save.\n   * @param {number} position Position to which entry will be added.\n   *\n   * @returns {boolean}\n   */\n  setValueAtIndex(index, value) {\n    let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.orderOfIndexes.length;\n    if (index < this.indexedValues.length) {\n      this.indexedValues[index] = value;\n      if (this.orderOfIndexes.includes(index) === false) {\n        this.orderOfIndexes.splice(position, 0, index);\n      }\n      this.runLocalHooks('change');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear value for particular index.\n   *\n   * @param {number} physicalIndex Physical index.\n   */\n  clearValue(physicalIndex) {\n    this.orderOfIndexes = getListWithoutIndexes(this.orderOfIndexes, [physicalIndex]);\n    if (isFunction(this.initValueOrFn)) {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn(physicalIndex));\n    } else {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn);\n    }\n  }\n\n  /**\n   * Get length of the index map.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    return this.orderOfIndexes.length;\n  }\n\n  /**\n   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @private\n   * @param {number} [length] Length of list.\n   */\n  setDefaultValues() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.indexedValues.length;\n    this.orderOfIndexes.length = 0;\n    super.setDefaultValues(length);\n  }\n\n  /**\n   * Add values to list and reorganize. It updates list of indexes related to ordered values.\n   *\n   * @private\n   * @param {number} insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) {\n    this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);\n    this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, insertedIndexes);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n\n  /**\n   * Remove values from the list and reorganize. It updates list of indexes related to ordered values.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  remove(removedIndexes) {\n    this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);\n    this.orderOfIndexes = getListWithoutIndexes(this.orderOfIndexes, removedIndexes);\n    this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, removedIndexes);\n    super.remove(removedIndexes);\n  }\n\n  /**\n   * Get every entry containing index and value, respecting order of indexes.\n   *\n   * @returns {Array}\n   */\n  getEntries() {\n    return this.orderOfIndexes.map(physicalIndex => [physicalIndex, this.getValueAtIndex(physicalIndex)]);\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","IndexMap","getListWithRemovedItems","getListWithInsertedItems","getListWithoutIndexes","getDecreasedIndexes","getIncreasedIndexes","isFunction","LinkedPhysicalIndexToValueMap","constructor","arguments","getValues","orderOfIndexes","map","physicalIndex","indexedValues","setValues","values","Array","length","keys","setValueAtIndex","index","position","undefined","includes","splice","runLocalHooks","clearValue","initValueOrFn","getLength","setDefaultValues","insert","insertionIndex","insertedIndexes","remove","removedIndexes","getEntries","getValueAtIndex"],"sources":["D:/gym-project/frontend/node_modules/handsontable/translations/maps/linkedPhysicalIndexToValueMap.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { IndexMap } from \"./indexMap.mjs\";\nimport { getListWithRemovedItems, getListWithInsertedItems } from \"./utils/physicallyIndexed.mjs\";\nimport { getListWithRemovedItems as getListWithoutIndexes } from \"./utils/indexesSequence.mjs\";\nimport { getDecreasedIndexes, getIncreasedIndexes } from \"./utils/actionsOnIndexes.mjs\";\nimport { isFunction } from \"../../helpers/function.mjs\";\n/**\n * Map for storing mappings from an physical index to a value. Those entries are linked and stored in a certain order.\n *\n * It does not update stored values on remove/add row or column action. Otherwise, order of entries is updated after\n * such changes.\n *\n * @class LinkedPhysicalIndexToValueMap\n */\nexport class LinkedPhysicalIndexToValueMap extends IndexMap {\n  constructor() {\n    super(...arguments);\n    /**\n     * Indexes and values corresponding to them (entries) are stored in a certain order.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _defineProperty(this, \"orderOfIndexes\", []);\n  }\n  /**\n   * Get full list of ordered values for particular indexes.\n   *\n   * @returns {Array}\n   */\n  getValues() {\n    return this.orderOfIndexes.map(physicalIndex => this.indexedValues[physicalIndex]);\n  }\n\n  /**\n   * Set new values for particular indexes. Entries are linked and stored in a certain order.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @param {Array} values List of set values.\n   */\n  setValues(values) {\n    this.orderOfIndexes = [...Array(values.length).keys()];\n    super.setValues(values);\n  }\n\n  /**\n   * Set value at index and add it to the linked list of entries. Entries are stored in a certain order.\n   *\n   * Note: Value will be added at the end of the queue.\n   *\n   * @param {number} index The index.\n   * @param {*} value The value to save.\n   * @param {number} position Position to which entry will be added.\n   *\n   * @returns {boolean}\n   */\n  setValueAtIndex(index, value) {\n    let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.orderOfIndexes.length;\n    if (index < this.indexedValues.length) {\n      this.indexedValues[index] = value;\n      if (this.orderOfIndexes.includes(index) === false) {\n        this.orderOfIndexes.splice(position, 0, index);\n      }\n      this.runLocalHooks('change');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear value for particular index.\n   *\n   * @param {number} physicalIndex Physical index.\n   */\n  clearValue(physicalIndex) {\n    this.orderOfIndexes = getListWithoutIndexes(this.orderOfIndexes, [physicalIndex]);\n    if (isFunction(this.initValueOrFn)) {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn(physicalIndex));\n    } else {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn);\n    }\n  }\n\n  /**\n   * Get length of the index map.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    return this.orderOfIndexes.length;\n  }\n\n  /**\n   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @private\n   * @param {number} [length] Length of list.\n   */\n  setDefaultValues() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.indexedValues.length;\n    this.orderOfIndexes.length = 0;\n    super.setDefaultValues(length);\n  }\n\n  /**\n   * Add values to list and reorganize. It updates list of indexes related to ordered values.\n   *\n   * @private\n   * @param {number} insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) {\n    this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);\n    this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, insertedIndexes);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n\n  /**\n   * Remove values from the list and reorganize. It updates list of indexes related to ordered values.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  remove(removedIndexes) {\n    this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);\n    this.orderOfIndexes = getListWithoutIndexes(this.orderOfIndexes, removedIndexes);\n    this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, removedIndexes);\n    super.remove(removedIndexes);\n  }\n\n  /**\n   * Get every entry containing index and value, respecting order of indexes.\n   *\n   * @returns {Array}\n   */\n  getEntries() {\n    return this.orderOfIndexes.map(physicalIndex => [physicalIndex, this.getValueAtIndex(physicalIndex)]);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}