{"ast":null,"code":"import { isEmpty } from \"./../helpers/mixed.mjs\";\nconst ESCAPED_HTML_CHARS = {\n  '&nbsp;': '\\x20',\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>'\n};\nconst regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map(key => `(${key})`).join('|'), 'gi');\n\n/**\n * Verifies if node is an HTMLTable element.\n *\n * @param {Node} element Node to verify if it's an HTMLTable.\n * @returns {boolean}\n */\nfunction isHTMLTable(element) {\n  return (element && element.nodeName || '') === 'TABLE';\n}\n\n/**\n * Converts Handsontable into HTMLTableElement.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {string} OuterHTML of the HTMLTableElement.\n */\nexport function instanceToHTML(instance) {\n  const hasColumnHeaders = instance.hasColHeaders();\n  const hasRowHeaders = instance.hasRowHeaders();\n  const coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];\n  const data = instance.getData(...coords);\n  const countRows = data.length;\n  const countCols = countRows > 0 ? data[0].length : 0;\n  const TABLE = ['<table>', '</table>'];\n  const THEAD = hasColumnHeaders ? ['<thead>', '</thead>'] : [];\n  const TBODY = ['<tbody>', '</tbody>'];\n  const rowModifier = hasRowHeaders ? 1 : 0;\n  const columnModifier = hasColumnHeaders ? 1 : 0;\n  for (let row = 0; row < countRows; row += 1) {\n    const isColumnHeadersRow = hasColumnHeaders && row === 0;\n    const CELLS = [];\n    for (let column = 0; column < countCols; column += 1) {\n      const isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;\n      let cell = '';\n      if (isColumnHeadersRow) {\n        cell = `<th>${instance.getColHeader(column - rowModifier)}</th>`;\n      } else if (isRowHeadersColumn) {\n        cell = `<th>${instance.getRowHeader(row - columnModifier)}</th>`;\n      } else {\n        const cellData = data[row][column];\n        const {\n          hidden,\n          rowspan,\n          colspan\n        } = instance.getCellMeta(row - columnModifier, column - rowModifier);\n        if (!hidden) {\n          const attrs = [];\n          if (rowspan) {\n            attrs.push(`rowspan=\"${rowspan}\"`);\n          }\n          if (colspan) {\n            attrs.push(`colspan=\"${colspan}\"`);\n          }\n          if (isEmpty(cellData)) {\n            cell = `<td ${attrs.join(' ')}></td>`;\n          } else {\n            const value = cellData.toString().replace('<', '&lt;').replace('>', '&gt;').replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, '<br>\\r\\n').replace(/\\x20/gi, '&nbsp;').replace(/\\t/gi, '&#9;');\n            cell = `<td ${attrs.join(' ')}>${value}</td>`;\n          }\n        }\n      }\n      CELLS.push(cell);\n    }\n    const TR = ['<tr>', ...CELLS, '</tr>'].join('');\n    if (isColumnHeadersRow) {\n      THEAD.splice(1, 0, TR);\n    } else {\n      TBODY.splice(-1, 0, TR);\n    }\n  }\n  TABLE.splice(1, 0, THEAD.join(''), TBODY.join(''));\n  return TABLE.join('');\n}\n\n/**\n * Converts 2D array into HTMLTableElement.\n *\n * @param {Array} input Input array which will be converted to HTMLTable.\n * @returns {string} OuterHTML of the HTMLTableElement.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function _dataToHTML(input) {\n  const inputLen = input.length;\n  const result = ['<table>'];\n  for (let row = 0; row < inputLen; row += 1) {\n    const rowData = input[row];\n    const columnsLen = rowData.length;\n    const columnsResult = [];\n    if (row === 0) {\n      result.push('<tbody>');\n    }\n    for (let column = 0; column < columnsLen; column += 1) {\n      const cellData = rowData[column];\n      const parsedCellData = isEmpty(cellData) ? '' : cellData.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, '<br>\\r\\n').replace(/\\x20{2,}/gi, substring => {\n        // The way how Excel serializes data with at least two spaces.\n        return `<span style=\"mso-spacerun: yes\">${'&nbsp;'.repeat(substring.length - 1)} </span>`;\n      }).replace(/\\t/gi, '&#9;');\n      columnsResult.push(`<td>${parsedCellData}</td>`);\n    }\n    result.push('<tr>', ...columnsResult, '</tr>');\n    if (row + 1 === inputLen) {\n      result.push('</tbody>');\n    }\n  }\n  result.push('</table>');\n  return result.join('');\n}\n\n/**\n * Converts HTMLTable or string into Handsontable configuration object.\n *\n * @param {Element|string} element Node element which should contain `<table>...</table>`.\n * @param {Document} [rootDocument] The document window owner.\n * @returns {object} Return configuration object. Contains keys as DefaultSettings.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function htmlToGridSettings(element) {\n  let rootDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  const settingsObj = {};\n  const fragment = rootDocument.createDocumentFragment();\n  const tempElem = rootDocument.createElement('div');\n  fragment.appendChild(tempElem);\n  let checkElement = element;\n  if (typeof checkElement === 'string') {\n    const escapedAdjacentHTML = checkElement.replace(/<td\\b[^>]*?>([\\s\\S]*?)<\\/\\s*td>/g, cellFragment => {\n      const openingTag = cellFragment.match(/<td\\b[^>]*?>/g)[0];\n      const paragraphRegexp = /<p.*?>/g;\n      const cellValue = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf('<')).trim() // Removing whitespaces from the start and the end of HTML fragment\n      .replaceAll(/\\n\\s+/g, ' ') // HTML tags may be split using multiple new lines and whitespaces\n      .replaceAll(paragraphRegexp, '\\n') // Only paragraphs should split text using new line characters\n      .replace('\\n', '') // First paragraph shouldn't start with new line characters\n      .replaceAll(/<\\/(.*)>\\s+$/mg, '</$1>') // HTML tags may end with whitespace.\n      .replace(/(<(?!br)([^>]+)>)/gi, '') // Removing HTML tags\n      .replaceAll(/^&nbsp;$/mg, ''); // Removing single &nbsp; characters separating new lines\n      const closingTag = '</td>';\n      return `${openingTag}${cellValue}${closingTag}`;\n    });\n    tempElem.insertAdjacentHTML('afterbegin', `${escapedAdjacentHTML}`);\n    checkElement = tempElem.querySelector('table');\n  }\n  if (!checkElement || !isHTMLTable(checkElement)) {\n    return;\n  }\n  const generator = tempElem.querySelector('meta[name$=\"enerator\"]');\n  const hasRowHeaders = checkElement.querySelector('tbody th') !== null;\n  const trElement = checkElement.querySelector('tr');\n  const countCols = !trElement ? 0 : Array.from(trElement.cells).reduce((cols, cell) => cols + cell.colSpan, 0) - (hasRowHeaders ? 1 : 0);\n  const fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];\n  const fixedRowsTop = [];\n  let hasColHeaders = false;\n  let thRowsLen = 0;\n  let countRows = 0;\n  if (checkElement.tHead) {\n    const thRows = Array.from(checkElement.tHead.rows).filter(tr => {\n      const isDataRow = tr.querySelector('td') !== null;\n      if (isDataRow) {\n        fixedRowsTop.push(tr);\n      }\n      return !isDataRow;\n    });\n    thRowsLen = thRows.length;\n    hasColHeaders = thRowsLen > 0;\n    if (thRowsLen > 1) {\n      settingsObj.nestedHeaders = Array.from(thRows).reduce((rows, row) => {\n        const headersRow = Array.from(row.cells).reduce((headers, header, currentIndex) => {\n          if (hasRowHeaders && currentIndex === 0) {\n            return headers;\n          }\n          const {\n            colSpan: colspan,\n            innerHTML\n          } = header;\n          const nextHeader = colspan > 1 ? {\n            label: innerHTML,\n            colspan\n          } : innerHTML;\n          headers.push(nextHeader);\n          return headers;\n        }, []);\n        rows.push(headersRow);\n        return rows;\n      }, []);\n    } else if (hasColHeaders) {\n      settingsObj.colHeaders = Array.from(thRows[0].children).reduce((headers, header, index) => {\n        if (hasRowHeaders && index === 0) {\n          return headers;\n        }\n        headers.push(header.innerHTML);\n        return headers;\n      }, []);\n    }\n  }\n  if (fixedRowsTop.length) {\n    settingsObj.fixedRowsTop = fixedRowsTop.length;\n  }\n  if (fixedRowsBottom.length) {\n    settingsObj.fixedRowsBottom = fixedRowsBottom.length;\n  }\n  const dataRows = [...fixedRowsTop, ...Array.from(checkElement.tBodies).reduce((sections, section) => {\n    sections.push(...Array.from(section.rows));\n    return sections;\n  }, []), ...fixedRowsBottom];\n  countRows = dataRows.length;\n  const dataArr = new Array(countRows);\n  for (let r = 0; r < countRows; r++) {\n    dataArr[r] = new Array(countCols);\n  }\n  const mergeCells = [];\n  const rowHeaders = [];\n  for (let row = 0; row < countRows; row++) {\n    const tr = dataRows[row];\n    const cells = Array.from(tr.cells);\n    const cellsLen = cells.length;\n    for (let cellId = 0; cellId < cellsLen; cellId++) {\n      const cell = cells[cellId];\n      const {\n        nodeName,\n        innerHTML,\n        rowSpan: rowspan,\n        colSpan: colspan\n      } = cell;\n      const col = dataArr[row].findIndex(value => value === undefined);\n      if (nodeName === 'TD') {\n        if (rowspan > 1 || colspan > 1) {\n          for (let rstart = row; rstart < row + rowspan; rstart++) {\n            if (rstart < countRows) {\n              for (let cstart = col; cstart < col + colspan; cstart++) {\n                dataArr[rstart][cstart] = null;\n              }\n            }\n          }\n          const styleAttr = cell.getAttribute('style');\n          const ignoreMerge = styleAttr && styleAttr.includes('mso-ignore:colspan');\n          if (!ignoreMerge) {\n            mergeCells.push({\n              col,\n              row,\n              rowspan,\n              colspan\n            });\n          }\n        }\n        let cellValue = '';\n        if (generator && /excel/gi.test(generator.content)) {\n          cellValue = innerHTML.replace(/[\\r\\n][\\x20]{0,2}/g, '\\x20').replace(/<br(\\s*|\\/)>[\\r\\n]?[\\x20]{0,3}/gim, '\\r\\n');\n        } else {\n          cellValue = innerHTML.replace(/<br(\\s*|\\/)>[\\r\\n]?/gim, '\\r\\n');\n        }\n        dataArr[row][col] = cellValue.replace(regEscapedChars, match => ESCAPED_HTML_CHARS[match]);\n      } else {\n        rowHeaders.push(innerHTML);\n      }\n    }\n  }\n  if (mergeCells.length) {\n    settingsObj.mergeCells = mergeCells;\n  }\n  if (rowHeaders.length) {\n    settingsObj.rowHeaders = rowHeaders;\n  }\n  if (dataArr.length) {\n    settingsObj.data = dataArr;\n  }\n  return settingsObj;\n}","map":{"version":3,"names":["isEmpty","ESCAPED_HTML_CHARS","regEscapedChars","RegExp","Object","keys","map","key","join","isHTMLTable","element","nodeName","instanceToHTML","instance","hasColumnHeaders","hasColHeaders","hasRowHeaders","coords","countRows","countCols","data","getData","length","TABLE","THEAD","TBODY","rowModifier","columnModifier","row","isColumnHeadersRow","CELLS","column","isRowHeadersColumn","cell","getColHeader","getRowHeader","cellData","hidden","rowspan","colspan","getCellMeta","attrs","push","value","toString","replace","TR","splice","_dataToHTML","input","inputLen","result","rowData","columnsLen","columnsResult","parsedCellData","substring","repeat","htmlToGridSettings","rootDocument","arguments","undefined","document","settingsObj","fragment","createDocumentFragment","tempElem","createElement","appendChild","checkElement","escapedAdjacentHTML","cellFragment","openingTag","match","paragraphRegexp","cellValue","lastIndexOf","trim","replaceAll","closingTag","insertAdjacentHTML","querySelector","generator","trElement","Array","from","cells","reduce","cols","colSpan","fixedRowsBottom","tFoot","rows","fixedRowsTop","thRowsLen","tHead","thRows","filter","tr","isDataRow","nestedHeaders","headersRow","headers","header","currentIndex","innerHTML","nextHeader","label","colHeaders","children","index","dataRows","tBodies","sections","section","dataArr","r","mergeCells","rowHeaders","cellsLen","cellId","rowSpan","col","findIndex","rstart","cstart","styleAttr","getAttribute","ignoreMerge","includes","test","content"],"sources":["D:/gym-project/frontend/node_modules/handsontable/utils/parseTable.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport { isEmpty } from \"./../helpers/mixed.mjs\";\nconst ESCAPED_HTML_CHARS = {\n  '&nbsp;': '\\x20',\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>'\n};\nconst regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map(key => `(${key})`).join('|'), 'gi');\n\n/**\n * Verifies if node is an HTMLTable element.\n *\n * @param {Node} element Node to verify if it's an HTMLTable.\n * @returns {boolean}\n */\nfunction isHTMLTable(element) {\n  return (element && element.nodeName || '') === 'TABLE';\n}\n\n/**\n * Converts Handsontable into HTMLTableElement.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {string} OuterHTML of the HTMLTableElement.\n */\nexport function instanceToHTML(instance) {\n  const hasColumnHeaders = instance.hasColHeaders();\n  const hasRowHeaders = instance.hasRowHeaders();\n  const coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];\n  const data = instance.getData(...coords);\n  const countRows = data.length;\n  const countCols = countRows > 0 ? data[0].length : 0;\n  const TABLE = ['<table>', '</table>'];\n  const THEAD = hasColumnHeaders ? ['<thead>', '</thead>'] : [];\n  const TBODY = ['<tbody>', '</tbody>'];\n  const rowModifier = hasRowHeaders ? 1 : 0;\n  const columnModifier = hasColumnHeaders ? 1 : 0;\n  for (let row = 0; row < countRows; row += 1) {\n    const isColumnHeadersRow = hasColumnHeaders && row === 0;\n    const CELLS = [];\n    for (let column = 0; column < countCols; column += 1) {\n      const isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;\n      let cell = '';\n      if (isColumnHeadersRow) {\n        cell = `<th>${instance.getColHeader(column - rowModifier)}</th>`;\n      } else if (isRowHeadersColumn) {\n        cell = `<th>${instance.getRowHeader(row - columnModifier)}</th>`;\n      } else {\n        const cellData = data[row][column];\n        const {\n          hidden,\n          rowspan,\n          colspan\n        } = instance.getCellMeta(row - columnModifier, column - rowModifier);\n        if (!hidden) {\n          const attrs = [];\n          if (rowspan) {\n            attrs.push(`rowspan=\"${rowspan}\"`);\n          }\n          if (colspan) {\n            attrs.push(`colspan=\"${colspan}\"`);\n          }\n          if (isEmpty(cellData)) {\n            cell = `<td ${attrs.join(' ')}></td>`;\n          } else {\n            const value = cellData.toString().replace('<', '&lt;').replace('>', '&gt;').replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, '<br>\\r\\n').replace(/\\x20/gi, '&nbsp;').replace(/\\t/gi, '&#9;');\n            cell = `<td ${attrs.join(' ')}>${value}</td>`;\n          }\n        }\n      }\n      CELLS.push(cell);\n    }\n    const TR = ['<tr>', ...CELLS, '</tr>'].join('');\n    if (isColumnHeadersRow) {\n      THEAD.splice(1, 0, TR);\n    } else {\n      TBODY.splice(-1, 0, TR);\n    }\n  }\n  TABLE.splice(1, 0, THEAD.join(''), TBODY.join(''));\n  return TABLE.join('');\n}\n\n/**\n * Converts 2D array into HTMLTableElement.\n *\n * @param {Array} input Input array which will be converted to HTMLTable.\n * @returns {string} OuterHTML of the HTMLTableElement.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function _dataToHTML(input) {\n  const inputLen = input.length;\n  const result = ['<table>'];\n  for (let row = 0; row < inputLen; row += 1) {\n    const rowData = input[row];\n    const columnsLen = rowData.length;\n    const columnsResult = [];\n    if (row === 0) {\n      result.push('<tbody>');\n    }\n    for (let column = 0; column < columnsLen; column += 1) {\n      const cellData = rowData[column];\n      const parsedCellData = isEmpty(cellData) ? '' : cellData.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, '<br>\\r\\n').replace(/\\x20{2,}/gi, substring => {\n        // The way how Excel serializes data with at least two spaces.\n        return `<span style=\"mso-spacerun: yes\">${'&nbsp;'.repeat(substring.length - 1)} </span>`;\n      }).replace(/\\t/gi, '&#9;');\n      columnsResult.push(`<td>${parsedCellData}</td>`);\n    }\n    result.push('<tr>', ...columnsResult, '</tr>');\n    if (row + 1 === inputLen) {\n      result.push('</tbody>');\n    }\n  }\n  result.push('</table>');\n  return result.join('');\n}\n\n/**\n * Converts HTMLTable or string into Handsontable configuration object.\n *\n * @param {Element|string} element Node element which should contain `<table>...</table>`.\n * @param {Document} [rootDocument] The document window owner.\n * @returns {object} Return configuration object. Contains keys as DefaultSettings.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function htmlToGridSettings(element) {\n  let rootDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  const settingsObj = {};\n  const fragment = rootDocument.createDocumentFragment();\n  const tempElem = rootDocument.createElement('div');\n  fragment.appendChild(tempElem);\n  let checkElement = element;\n  if (typeof checkElement === 'string') {\n    const escapedAdjacentHTML = checkElement.replace(/<td\\b[^>]*?>([\\s\\S]*?)<\\/\\s*td>/g, cellFragment => {\n      const openingTag = cellFragment.match(/<td\\b[^>]*?>/g)[0];\n      const paragraphRegexp = /<p.*?>/g;\n      const cellValue = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf('<')).trim() // Removing whitespaces from the start and the end of HTML fragment\n      .replaceAll(/\\n\\s+/g, ' ') // HTML tags may be split using multiple new lines and whitespaces\n      .replaceAll(paragraphRegexp, '\\n') // Only paragraphs should split text using new line characters\n      .replace('\\n', '') // First paragraph shouldn't start with new line characters\n      .replaceAll(/<\\/(.*)>\\s+$/mg, '</$1>') // HTML tags may end with whitespace.\n      .replace(/(<(?!br)([^>]+)>)/gi, '') // Removing HTML tags\n      .replaceAll(/^&nbsp;$/mg, ''); // Removing single &nbsp; characters separating new lines\n      const closingTag = '</td>';\n      return `${openingTag}${cellValue}${closingTag}`;\n    });\n    tempElem.insertAdjacentHTML('afterbegin', `${escapedAdjacentHTML}`);\n    checkElement = tempElem.querySelector('table');\n  }\n  if (!checkElement || !isHTMLTable(checkElement)) {\n    return;\n  }\n  const generator = tempElem.querySelector('meta[name$=\"enerator\"]');\n  const hasRowHeaders = checkElement.querySelector('tbody th') !== null;\n  const trElement = checkElement.querySelector('tr');\n  const countCols = !trElement ? 0 : Array.from(trElement.cells).reduce((cols, cell) => cols + cell.colSpan, 0) - (hasRowHeaders ? 1 : 0);\n  const fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];\n  const fixedRowsTop = [];\n  let hasColHeaders = false;\n  let thRowsLen = 0;\n  let countRows = 0;\n  if (checkElement.tHead) {\n    const thRows = Array.from(checkElement.tHead.rows).filter(tr => {\n      const isDataRow = tr.querySelector('td') !== null;\n      if (isDataRow) {\n        fixedRowsTop.push(tr);\n      }\n      return !isDataRow;\n    });\n    thRowsLen = thRows.length;\n    hasColHeaders = thRowsLen > 0;\n    if (thRowsLen > 1) {\n      settingsObj.nestedHeaders = Array.from(thRows).reduce((rows, row) => {\n        const headersRow = Array.from(row.cells).reduce((headers, header, currentIndex) => {\n          if (hasRowHeaders && currentIndex === 0) {\n            return headers;\n          }\n          const {\n            colSpan: colspan,\n            innerHTML\n          } = header;\n          const nextHeader = colspan > 1 ? {\n            label: innerHTML,\n            colspan\n          } : innerHTML;\n          headers.push(nextHeader);\n          return headers;\n        }, []);\n        rows.push(headersRow);\n        return rows;\n      }, []);\n    } else if (hasColHeaders) {\n      settingsObj.colHeaders = Array.from(thRows[0].children).reduce((headers, header, index) => {\n        if (hasRowHeaders && index === 0) {\n          return headers;\n        }\n        headers.push(header.innerHTML);\n        return headers;\n      }, []);\n    }\n  }\n  if (fixedRowsTop.length) {\n    settingsObj.fixedRowsTop = fixedRowsTop.length;\n  }\n  if (fixedRowsBottom.length) {\n    settingsObj.fixedRowsBottom = fixedRowsBottom.length;\n  }\n  const dataRows = [...fixedRowsTop, ...Array.from(checkElement.tBodies).reduce((sections, section) => {\n    sections.push(...Array.from(section.rows));\n    return sections;\n  }, []), ...fixedRowsBottom];\n  countRows = dataRows.length;\n  const dataArr = new Array(countRows);\n  for (let r = 0; r < countRows; r++) {\n    dataArr[r] = new Array(countCols);\n  }\n  const mergeCells = [];\n  const rowHeaders = [];\n  for (let row = 0; row < countRows; row++) {\n    const tr = dataRows[row];\n    const cells = Array.from(tr.cells);\n    const cellsLen = cells.length;\n    for (let cellId = 0; cellId < cellsLen; cellId++) {\n      const cell = cells[cellId];\n      const {\n        nodeName,\n        innerHTML,\n        rowSpan: rowspan,\n        colSpan: colspan\n      } = cell;\n      const col = dataArr[row].findIndex(value => value === undefined);\n      if (nodeName === 'TD') {\n        if (rowspan > 1 || colspan > 1) {\n          for (let rstart = row; rstart < row + rowspan; rstart++) {\n            if (rstart < countRows) {\n              for (let cstart = col; cstart < col + colspan; cstart++) {\n                dataArr[rstart][cstart] = null;\n              }\n            }\n          }\n          const styleAttr = cell.getAttribute('style');\n          const ignoreMerge = styleAttr && styleAttr.includes('mso-ignore:colspan');\n          if (!ignoreMerge) {\n            mergeCells.push({\n              col,\n              row,\n              rowspan,\n              colspan\n            });\n          }\n        }\n        let cellValue = '';\n        if (generator && /excel/gi.test(generator.content)) {\n          cellValue = innerHTML.replace(/[\\r\\n][\\x20]{0,2}/g, '\\x20').replace(/<br(\\s*|\\/)>[\\r\\n]?[\\x20]{0,3}/gim, '\\r\\n');\n        } else {\n          cellValue = innerHTML.replace(/<br(\\s*|\\/)>[\\r\\n]?/gim, '\\r\\n');\n        }\n        dataArr[row][col] = cellValue.replace(regEscapedChars, match => ESCAPED_HTML_CHARS[match]);\n      } else {\n        rowHeaders.push(innerHTML);\n      }\n    }\n  }\n  if (mergeCells.length) {\n    settingsObj.mergeCells = mergeCells;\n  }\n  if (rowHeaders.length) {\n    settingsObj.rowHeaders = rowHeaders;\n  }\n  if (dataArr.length) {\n    settingsObj.data = dataArr;\n  }\n  return settingsObj;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}