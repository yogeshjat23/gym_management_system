{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport LinkedList from \"../../utils/dataStructures/linkedList.mjs\";\n/**\n * Class responsible for providing the correct focus order (vertical and horizontal) within a selection that\n * contains merged cells.\n *\n * @private\n */\nvar _cellsHorizontalOrder = /*#__PURE__*/new WeakMap();\nvar _cellsVerticalOrder = /*#__PURE__*/new WeakMap();\nvar _currentHorizontalLinkedNode = /*#__PURE__*/new WeakMap();\nvar _currentVerticalLinkedNode = /*#__PURE__*/new WeakMap();\nvar _mergedCellsGetter = /*#__PURE__*/new WeakMap();\nvar _rowIndexMapper = /*#__PURE__*/new WeakMap();\nvar _columnIndexMapper = /*#__PURE__*/new WeakMap();\nvar _FocusOrder_brand = /*#__PURE__*/new WeakSet();\nexport class FocusOrder {\n  constructor(_ref) {\n    let {\n      mergedCellsGetter,\n      rowIndexMapper,\n      columnIndexMapper\n    } = _ref;\n    /**\n     * Pushes a new node to the provided list order.\n     *\n     * @param {CellRange} selectedRange The selected range to build the focus order for.\n     * @param {LinkedList} listOrder The list order to push the node to.\n     * @param {WeakSet} mergeCellsVisitor The set of visited cells.\n     * @param {number} row The visual row index.\n     * @param {number} column The visual column index.\n     * @returns {NodeStructure | null}\n     */\n    _classPrivateMethodInitSpec(this, _FocusOrder_brand);\n    /**\n     * The linked list of the all cells within the current selection in horizontal order. The list is\n     * recreated every time the selection is changed.\n     *\n     * @type {LinkedList}\n     */\n    _classPrivateFieldInitSpec(this, _cellsHorizontalOrder, new LinkedList());\n    /**\n     * The linked list of the all cells within the current selection in horizontal order. The list is\n     * recreated every time the selection is changed.\n     *\n     * @type {LinkedList}\n     */\n    _classPrivateFieldInitSpec(this, _cellsVerticalOrder, new LinkedList());\n    /**\n     * The currently highlighted cell within the horizontal linked list.\n     *\n     * @type {NodeStructure | null}\n     */\n    _classPrivateFieldInitSpec(this, _currentHorizontalLinkedNode, null);\n    /**\n     * The currently highlighted cell within the vertical linked list.\n     *\n     * @type {NodeStructure | null}\n     */\n    _classPrivateFieldInitSpec(this, _currentVerticalLinkedNode, null);\n    /**\n     * The merged cells getter function.\n     *\n     * @type {function(): {row: number, col: number, rowspan: number, colspan: number} | null}}\n     */\n    _classPrivateFieldInitSpec(this, _mergedCellsGetter, null);\n    /**\n     * The row index mapper.\n     *\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _rowIndexMapper, null);\n    /**\n     * The column index mapper.\n     *\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _columnIndexMapper, null);\n    _classPrivateFieldSet(_mergedCellsGetter, this, mergedCellsGetter);\n    _classPrivateFieldSet(_rowIndexMapper, this, rowIndexMapper);\n    _classPrivateFieldSet(_columnIndexMapper, this, columnIndexMapper);\n  }\n\n  /**\n   * Gets the currently selected node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getCurrentVerticalNode() {\n    return _classPrivateFieldGet(_currentVerticalLinkedNode, this).data;\n  }\n\n  /**\n   * Gets the first node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getFirstVerticalNode() {\n    return _classPrivateFieldGet(_cellsVerticalOrder, this).first.data;\n  }\n\n  /**\n   * Gets the next selected node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getNextVerticalNode() {\n    return _classPrivateFieldGet(_currentVerticalLinkedNode, this).next.data;\n  }\n\n  /**\n   * Gets the previous selected node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getPrevVerticalNode() {\n    return _classPrivateFieldGet(_currentVerticalLinkedNode, this).prev.data;\n  }\n\n  /**\n   * Gets the currently selected node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getCurrentHorizontalNode() {\n    return _classPrivateFieldGet(_currentHorizontalLinkedNode, this).data;\n  }\n\n  /**\n   * Gets the first node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getFirstHorizontalNode() {\n    return _classPrivateFieldGet(_cellsHorizontalOrder, this).first.data;\n  }\n\n  /**\n   * Gets the next selected node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getNextHorizontalNode() {\n    return _classPrivateFieldGet(_currentHorizontalLinkedNode, this).next.data;\n  }\n\n  /**\n   * Gets the previous selected node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getPrevHorizontalNode() {\n    return _classPrivateFieldGet(_currentHorizontalLinkedNode, this).prev.data;\n  }\n\n  /**\n   * Sets the previous node from the vertical focus order list as active.\n   */\n  setPrevNodeAsActive() {\n    _classPrivateFieldSet(_currentVerticalLinkedNode, this, _classPrivateFieldGet(_currentVerticalLinkedNode, this).prev);\n    _classPrivateFieldSet(_currentHorizontalLinkedNode, this, _classPrivateFieldGet(_currentHorizontalLinkedNode, this).prev);\n  }\n\n  /**\n   * Sets the previous node from the horizontal focus order list as active.\n   */\n  setNextNodeAsActive() {\n    _classPrivateFieldSet(_currentVerticalLinkedNode, this, _classPrivateFieldGet(_currentVerticalLinkedNode, this).next);\n    _classPrivateFieldSet(_currentHorizontalLinkedNode, this, _classPrivateFieldGet(_currentHorizontalLinkedNode, this).next);\n  }\n\n  /**\n   * Rebuilds the focus order list based on the provided selection.\n   *\n   * @param {CellRange} selectedRange The selected range to build the focus order for.\n   */\n  buildFocusOrder(selectedRange) {\n    const topStart = selectedRange.getTopStartCorner();\n    const bottomEnd = selectedRange.getBottomEndCorner();\n    const visitedHorizontalCells = new WeakSet();\n    _classPrivateFieldSet(_cellsHorizontalOrder, this, new LinkedList());\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      if (_classPrivateFieldGet(_rowIndexMapper, this).isHidden(r)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (_classPrivateFieldGet(_columnIndexMapper, this).isHidden(c)) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        const node = _assertClassBrand(_FocusOrder_brand, this, _pushOrderNode).call(this, selectedRange, _classPrivateFieldGet(_cellsHorizontalOrder, this), visitedHorizontalCells, r, c);\n        if (node) {\n          _classPrivateFieldSet(_currentHorizontalLinkedNode, this, node);\n        }\n      }\n    }\n\n    // create circular linked list\n    if (_classPrivateFieldGet(_cellsHorizontalOrder, this).first) {\n      _classPrivateFieldGet(_cellsHorizontalOrder, this).first.prev = _classPrivateFieldGet(_cellsHorizontalOrder, this).last;\n      _classPrivateFieldGet(_cellsHorizontalOrder, this).last.next = _classPrivateFieldGet(_cellsHorizontalOrder, this).first;\n    }\n    const visitedVerticalCells = new WeakSet();\n    _classPrivateFieldSet(_cellsVerticalOrder, this, new LinkedList());\n    for (let c = topStart.col; c <= bottomEnd.col; c++) {\n      if (_classPrivateFieldGet(_columnIndexMapper, this).isHidden(c)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      for (let r = topStart.row; r <= bottomEnd.row; r++) {\n        if (_classPrivateFieldGet(_rowIndexMapper, this).isHidden(r)) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        const node = _assertClassBrand(_FocusOrder_brand, this, _pushOrderNode).call(this, selectedRange, _classPrivateFieldGet(_cellsVerticalOrder, this), visitedVerticalCells, r, c);\n        if (node) {\n          _classPrivateFieldSet(_currentVerticalLinkedNode, this, node);\n        }\n      }\n    }\n\n    // create circular linked list\n    if (_classPrivateFieldGet(_cellsVerticalOrder, this).first) {\n      _classPrivateFieldGet(_cellsVerticalOrder, this).first.prev = _classPrivateFieldGet(_cellsVerticalOrder, this).last;\n      _classPrivateFieldGet(_cellsVerticalOrder, this).last.next = _classPrivateFieldGet(_cellsVerticalOrder, this).first;\n    }\n  }\n  /**\n   * Sets the active node based on the provided row and column.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} column The visual column index.\n   * @returns {FocusOrder}\n   */\n  setActiveNode(row, column) {\n    _classPrivateFieldGet(_cellsHorizontalOrder, this).inorder(node => {\n      const {\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd\n      } = node.data;\n      if (row >= rowStart && row <= rowEnd && column >= colStart && column <= colEnd) {\n        _classPrivateFieldSet(_currentHorizontalLinkedNode, this, node);\n        return false;\n      }\n    });\n    _classPrivateFieldGet(_cellsVerticalOrder, this).inorder(node => {\n      const {\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd\n      } = node.data;\n      if (row >= rowStart && row <= rowEnd && column >= colStart && column <= colEnd) {\n        _classPrivateFieldSet(_currentVerticalLinkedNode, this, node);\n        return false;\n      }\n    });\n    return this;\n  }\n}\nfunction _pushOrderNode(selectedRange, listOrder, mergeCellsVisitor, row, column) {\n  const topStart = selectedRange.getTopStartCorner();\n  const bottomEnd = selectedRange.getBottomEndCorner();\n  const highlight = selectedRange.highlight.clone().normalize();\n  const mergeParent = _classPrivateFieldGet(_mergedCellsGetter, this).call(this, row, column);\n  if (mergeParent && mergeCellsVisitor.has(mergeParent)) {\n    return null;\n  }\n  const node = {\n    colStart: column,\n    colEnd: column,\n    rowStart: row,\n    rowEnd: row\n  };\n  if (mergeParent) {\n    mergeCellsVisitor.add(mergeParent);\n    if (mergeParent.row < topStart.row || mergeParent.row + mergeParent.rowspan - 1 > bottomEnd.row || mergeParent.col < topStart.col || mergeParent.col + mergeParent.colspan - 1 > bottomEnd.col) {\n      return null;\n    }\n    node.colStart = mergeParent.col;\n    node.colEnd = mergeParent.col + mergeParent.colspan - 1;\n    node.rowStart = mergeParent.row;\n    node.rowEnd = mergeParent.row + mergeParent.rowspan - 1;\n  }\n  const linkedNode = listOrder.push(node);\n  if (row === highlight.row && column === highlight.col || mergeParent && highlight.row >= mergeParent.row && highlight.row <= mergeParent.row + mergeParent.rowspan - 1 && highlight.col >= mergeParent.col && highlight.col <= mergeParent.col + mergeParent.colspan - 1) {\n    return linkedNode;\n  }\n  return null;\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","LinkedList","_cellsHorizontalOrder","WeakMap","_cellsVerticalOrder","_currentHorizontalLinkedNode","_currentVerticalLinkedNode","_mergedCellsGetter","_rowIndexMapper","_columnIndexMapper","_FocusOrder_brand","WeakSet","FocusOrder","constructor","_ref","mergedCellsGetter","rowIndexMapper","columnIndexMapper","getCurrentVerticalNode","data","getFirstVerticalNode","first","getNextVerticalNode","next","getPrevVerticalNode","prev","getCurrentHorizontalNode","getFirstHorizontalNode","getNextHorizontalNode","getPrevHorizontalNode","setPrevNodeAsActive","setNextNodeAsActive","buildFocusOrder","selectedRange","topStart","getTopStartCorner","bottomEnd","getBottomEndCorner","visitedHorizontalCells","row","isHidden","c","col","node","_pushOrderNode","call","last","visitedVerticalCells","setActiveNode","column","inorder","rowStart","rowEnd","colStart","colEnd","listOrder","mergeCellsVisitor","highlight","clone","normalize","mergeParent","rowspan","colspan","linkedNode","push"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/mergeCells/focusOrder.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport LinkedList from \"../../utils/dataStructures/linkedList.mjs\";\n/**\n * Class responsible for providing the correct focus order (vertical and horizontal) within a selection that\n * contains merged cells.\n *\n * @private\n */\nvar _cellsHorizontalOrder = /*#__PURE__*/new WeakMap();\nvar _cellsVerticalOrder = /*#__PURE__*/new WeakMap();\nvar _currentHorizontalLinkedNode = /*#__PURE__*/new WeakMap();\nvar _currentVerticalLinkedNode = /*#__PURE__*/new WeakMap();\nvar _mergedCellsGetter = /*#__PURE__*/new WeakMap();\nvar _rowIndexMapper = /*#__PURE__*/new WeakMap();\nvar _columnIndexMapper = /*#__PURE__*/new WeakMap();\nvar _FocusOrder_brand = /*#__PURE__*/new WeakSet();\nexport class FocusOrder {\n  constructor(_ref) {\n    let {\n      mergedCellsGetter,\n      rowIndexMapper,\n      columnIndexMapper\n    } = _ref;\n    /**\n     * Pushes a new node to the provided list order.\n     *\n     * @param {CellRange} selectedRange The selected range to build the focus order for.\n     * @param {LinkedList} listOrder The list order to push the node to.\n     * @param {WeakSet} mergeCellsVisitor The set of visited cells.\n     * @param {number} row The visual row index.\n     * @param {number} column The visual column index.\n     * @returns {NodeStructure | null}\n     */\n    _classPrivateMethodInitSpec(this, _FocusOrder_brand);\n    /**\n     * The linked list of the all cells within the current selection in horizontal order. The list is\n     * recreated every time the selection is changed.\n     *\n     * @type {LinkedList}\n     */\n    _classPrivateFieldInitSpec(this, _cellsHorizontalOrder, new LinkedList());\n    /**\n     * The linked list of the all cells within the current selection in horizontal order. The list is\n     * recreated every time the selection is changed.\n     *\n     * @type {LinkedList}\n     */\n    _classPrivateFieldInitSpec(this, _cellsVerticalOrder, new LinkedList());\n    /**\n     * The currently highlighted cell within the horizontal linked list.\n     *\n     * @type {NodeStructure | null}\n     */\n    _classPrivateFieldInitSpec(this, _currentHorizontalLinkedNode, null);\n    /**\n     * The currently highlighted cell within the vertical linked list.\n     *\n     * @type {NodeStructure | null}\n     */\n    _classPrivateFieldInitSpec(this, _currentVerticalLinkedNode, null);\n    /**\n     * The merged cells getter function.\n     *\n     * @type {function(): {row: number, col: number, rowspan: number, colspan: number} | null}}\n     */\n    _classPrivateFieldInitSpec(this, _mergedCellsGetter, null);\n    /**\n     * The row index mapper.\n     *\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _rowIndexMapper, null);\n    /**\n     * The column index mapper.\n     *\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _columnIndexMapper, null);\n    _classPrivateFieldSet(_mergedCellsGetter, this, mergedCellsGetter);\n    _classPrivateFieldSet(_rowIndexMapper, this, rowIndexMapper);\n    _classPrivateFieldSet(_columnIndexMapper, this, columnIndexMapper);\n  }\n\n  /**\n   * Gets the currently selected node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getCurrentVerticalNode() {\n    return _classPrivateFieldGet(_currentVerticalLinkedNode, this).data;\n  }\n\n  /**\n   * Gets the first node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getFirstVerticalNode() {\n    return _classPrivateFieldGet(_cellsVerticalOrder, this).first.data;\n  }\n\n  /**\n   * Gets the next selected node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getNextVerticalNode() {\n    return _classPrivateFieldGet(_currentVerticalLinkedNode, this).next.data;\n  }\n\n  /**\n   * Gets the previous selected node data from the vertical focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getPrevVerticalNode() {\n    return _classPrivateFieldGet(_currentVerticalLinkedNode, this).prev.data;\n  }\n\n  /**\n   * Gets the currently selected node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getCurrentHorizontalNode() {\n    return _classPrivateFieldGet(_currentHorizontalLinkedNode, this).data;\n  }\n\n  /**\n   * Gets the first node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getFirstHorizontalNode() {\n    return _classPrivateFieldGet(_cellsHorizontalOrder, this).first.data;\n  }\n\n  /**\n   * Gets the next selected node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getNextHorizontalNode() {\n    return _classPrivateFieldGet(_currentHorizontalLinkedNode, this).next.data;\n  }\n\n  /**\n   * Gets the previous selected node data from the horizontal focus order list.\n   *\n   * @returns {NodeStructure}\n   */\n  getPrevHorizontalNode() {\n    return _classPrivateFieldGet(_currentHorizontalLinkedNode, this).prev.data;\n  }\n\n  /**\n   * Sets the previous node from the vertical focus order list as active.\n   */\n  setPrevNodeAsActive() {\n    _classPrivateFieldSet(_currentVerticalLinkedNode, this, _classPrivateFieldGet(_currentVerticalLinkedNode, this).prev);\n    _classPrivateFieldSet(_currentHorizontalLinkedNode, this, _classPrivateFieldGet(_currentHorizontalLinkedNode, this).prev);\n  }\n\n  /**\n   * Sets the previous node from the horizontal focus order list as active.\n   */\n  setNextNodeAsActive() {\n    _classPrivateFieldSet(_currentVerticalLinkedNode, this, _classPrivateFieldGet(_currentVerticalLinkedNode, this).next);\n    _classPrivateFieldSet(_currentHorizontalLinkedNode, this, _classPrivateFieldGet(_currentHorizontalLinkedNode, this).next);\n  }\n\n  /**\n   * Rebuilds the focus order list based on the provided selection.\n   *\n   * @param {CellRange} selectedRange The selected range to build the focus order for.\n   */\n  buildFocusOrder(selectedRange) {\n    const topStart = selectedRange.getTopStartCorner();\n    const bottomEnd = selectedRange.getBottomEndCorner();\n    const visitedHorizontalCells = new WeakSet();\n    _classPrivateFieldSet(_cellsHorizontalOrder, this, new LinkedList());\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      if (_classPrivateFieldGet(_rowIndexMapper, this).isHidden(r)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (_classPrivateFieldGet(_columnIndexMapper, this).isHidden(c)) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        const node = _assertClassBrand(_FocusOrder_brand, this, _pushOrderNode).call(this, selectedRange, _classPrivateFieldGet(_cellsHorizontalOrder, this), visitedHorizontalCells, r, c);\n        if (node) {\n          _classPrivateFieldSet(_currentHorizontalLinkedNode, this, node);\n        }\n      }\n    }\n\n    // create circular linked list\n    if (_classPrivateFieldGet(_cellsHorizontalOrder, this).first) {\n      _classPrivateFieldGet(_cellsHorizontalOrder, this).first.prev = _classPrivateFieldGet(_cellsHorizontalOrder, this).last;\n      _classPrivateFieldGet(_cellsHorizontalOrder, this).last.next = _classPrivateFieldGet(_cellsHorizontalOrder, this).first;\n    }\n    const visitedVerticalCells = new WeakSet();\n    _classPrivateFieldSet(_cellsVerticalOrder, this, new LinkedList());\n    for (let c = topStart.col; c <= bottomEnd.col; c++) {\n      if (_classPrivateFieldGet(_columnIndexMapper, this).isHidden(c)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      for (let r = topStart.row; r <= bottomEnd.row; r++) {\n        if (_classPrivateFieldGet(_rowIndexMapper, this).isHidden(r)) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        const node = _assertClassBrand(_FocusOrder_brand, this, _pushOrderNode).call(this, selectedRange, _classPrivateFieldGet(_cellsVerticalOrder, this), visitedVerticalCells, r, c);\n        if (node) {\n          _classPrivateFieldSet(_currentVerticalLinkedNode, this, node);\n        }\n      }\n    }\n\n    // create circular linked list\n    if (_classPrivateFieldGet(_cellsVerticalOrder, this).first) {\n      _classPrivateFieldGet(_cellsVerticalOrder, this).first.prev = _classPrivateFieldGet(_cellsVerticalOrder, this).last;\n      _classPrivateFieldGet(_cellsVerticalOrder, this).last.next = _classPrivateFieldGet(_cellsVerticalOrder, this).first;\n    }\n  }\n  /**\n   * Sets the active node based on the provided row and column.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} column The visual column index.\n   * @returns {FocusOrder}\n   */\n  setActiveNode(row, column) {\n    _classPrivateFieldGet(_cellsHorizontalOrder, this).inorder(node => {\n      const {\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd\n      } = node.data;\n      if (row >= rowStart && row <= rowEnd && column >= colStart && column <= colEnd) {\n        _classPrivateFieldSet(_currentHorizontalLinkedNode, this, node);\n        return false;\n      }\n    });\n    _classPrivateFieldGet(_cellsVerticalOrder, this).inorder(node => {\n      const {\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd\n      } = node.data;\n      if (row >= rowStart && row <= rowEnd && column >= colStart && column <= colEnd) {\n        _classPrivateFieldSet(_currentVerticalLinkedNode, this, node);\n        return false;\n      }\n    });\n    return this;\n  }\n}\nfunction _pushOrderNode(selectedRange, listOrder, mergeCellsVisitor, row, column) {\n  const topStart = selectedRange.getTopStartCorner();\n  const bottomEnd = selectedRange.getBottomEndCorner();\n  const highlight = selectedRange.highlight.clone().normalize();\n  const mergeParent = _classPrivateFieldGet(_mergedCellsGetter, this).call(this, row, column);\n  if (mergeParent && mergeCellsVisitor.has(mergeParent)) {\n    return null;\n  }\n  const node = {\n    colStart: column,\n    colEnd: column,\n    rowStart: row,\n    rowEnd: row\n  };\n  if (mergeParent) {\n    mergeCellsVisitor.add(mergeParent);\n    if (mergeParent.row < topStart.row || mergeParent.row + mergeParent.rowspan - 1 > bottomEnd.row || mergeParent.col < topStart.col || mergeParent.col + mergeParent.colspan - 1 > bottomEnd.col) {\n      return null;\n    }\n    node.colStart = mergeParent.col;\n    node.colEnd = mergeParent.col + mergeParent.colspan - 1;\n    node.rowStart = mergeParent.row;\n    node.rowEnd = mergeParent.row + mergeParent.rowspan - 1;\n  }\n  const linkedNode = listOrder.push(node);\n  if (row === highlight.row && column === highlight.col || mergeParent && highlight.row >= mergeParent.row && highlight.row <= mergeParent.row + mergeParent.rowspan - 1 && highlight.col >= mergeParent.col && highlight.col <= mergeParent.col + mergeParent.colspan - 1) {\n    return linkedNode;\n  }\n  return null;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}