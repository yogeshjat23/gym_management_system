{"ast":null,"code":"import { GRID_GROUP } from \"../../shortcutContexts/index.mjs\";\nimport { installFocusDetector } from \"./focusDetector.mjs\";\n/**\n * Installs a focus catcher module. The module observes when the table is focused and depending on\n * from the which side it was focused on it selects a specified cell or releases the TAB navigation\n * to the browser.\n *\n * @param {Core} hot The Handsontable instance.\n */\nexport function installFocusCatcher(hot) {\n  const clampCoordsIfNeeded = normalizeCoordsIfNeeded(hot);\n  let recentlyAddedFocusCoords;\n  const {\n    activate,\n    deactivate\n  } = installFocusDetector(hot, {\n    onFocusFromTop() {\n      var _clampCoordsIfNeeded;\n      const mostTopStartCoords = (_clampCoordsIfNeeded = clampCoordsIfNeeded(recentlyAddedFocusCoords)) !== null && _clampCoordsIfNeeded !== void 0 ? _clampCoordsIfNeeded : getMostTopStartPosition(hot);\n      if (mostTopStartCoords) {\n        hot.runHooks('modifyFocusOnTabNavigation', 'from_above', mostTopStartCoords);\n        hot.selectCell(mostTopStartCoords.row, mostTopStartCoords.col);\n      }\n      hot.listen();\n    },\n    onFocusFromBottom() {\n      var _clampCoordsIfNeeded2;\n      const mostBottomEndCoords = (_clampCoordsIfNeeded2 = clampCoordsIfNeeded(recentlyAddedFocusCoords)) !== null && _clampCoordsIfNeeded2 !== void 0 ? _clampCoordsIfNeeded2 : getMostBottomEndPosition(hot);\n      if (mostBottomEndCoords) {\n        hot.runHooks('modifyFocusOnTabNavigation', 'from_below', mostBottomEndCoords);\n        hot.selectCell(mostBottomEndCoords.row, mostBottomEndCoords.col);\n      }\n      hot.listen();\n    }\n  });\n  const rowWrapState = {\n    wrapped: false,\n    flipped: false\n  };\n  let isSavingCoordsEnabled = true;\n  let isTabOrShiftTabPressed = false;\n  let preventViewportScroll = false;\n  hot.addHook('afterListen', () => deactivate());\n  hot.addHook('afterUnlisten', () => activate());\n  hot.addHook('afterSelection', (row, column, row2, column2, preventScrolling) => {\n    if (isTabOrShiftTabPressed && (rowWrapState.wrapped && rowWrapState.flipped || preventViewportScroll)) {\n      preventViewportScroll = false;\n      preventScrolling.value = true;\n    }\n    if (isSavingCoordsEnabled) {\n      var _hot$getSelectedRange;\n      recentlyAddedFocusCoords = (_hot$getSelectedRange = hot.getSelectedRangeLast()) === null || _hot$getSelectedRange === void 0 ? void 0 : _hot$getSelectedRange.highlight;\n    }\n  });\n  hot.addHook('beforeRowWrap', (interruptedByAutoInsertMode, newCoords, isFlipped) => {\n    rowWrapState.wrapped = true;\n    rowWrapState.flipped = isFlipped;\n  });\n\n  /**\n   * Unselects the cell and deactivates the table.\n   */\n  function deactivateTable() {\n    rowWrapState.wrapped = false;\n    rowWrapState.flipped = false;\n    hot.deselectCell();\n    hot.unlisten();\n  }\n  const shortcutOptions = {\n    keys: [['Tab'], ['Shift', 'Tab']],\n    preventDefault: false,\n    stopPropagation: false,\n    relativeToGroup: GRID_GROUP,\n    group: 'focusCatcher'\n  };\n  hot.getShortcutManager().getContext('grid').addShortcuts([{\n    ...shortcutOptions,\n    callback: () => {\n      const {\n        tabNavigation\n      } = hot.getSettings();\n      isTabOrShiftTabPressed = true;\n      if (hot.getSelectedRangeLast() && !tabNavigation) {\n        isSavingCoordsEnabled = false;\n      }\n      if (!tabNavigation) {\n        preventViewportScroll = true;\n      }\n    },\n    position: 'before'\n  }, {\n    ...shortcutOptions,\n    callback: event => {\n      const {\n        tabNavigation,\n        autoWrapRow\n      } = hot.getSettings();\n      isTabOrShiftTabPressed = false;\n      isSavingCoordsEnabled = true;\n      if (!tabNavigation || !hot.selection.isSelected() || autoWrapRow && rowWrapState.wrapped && rowWrapState.flipped || !autoWrapRow && rowWrapState.wrapped) {\n        if (autoWrapRow && rowWrapState.wrapped && rowWrapState.flipped) {\n          recentlyAddedFocusCoords = event.shiftKey ? getMostTopStartPosition(hot) : getMostBottomEndPosition(hot);\n        }\n        deactivateTable();\n        return false;\n      }\n\n      // if the selection is still within the table's range then prevent default action\n      event.preventDefault();\n    },\n    position: 'after'\n  }]);\n}\n\n/**\n * Gets the coordinates of the most top-start cell or header (depends on the table settings and its size).\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {CellCoords|null}\n */\nfunction getMostTopStartPosition(hot) {\n  const {\n    rowIndexMapper,\n    columnIndexMapper\n  } = hot;\n  const {\n    navigableHeaders\n  } = hot.getSettings();\n  let topRow = navigableHeaders && hot.countColHeaders() > 0 ? -hot.countColHeaders() : 0;\n  let startColumn = navigableHeaders && hot.countRowHeaders() > 0 ? -hot.countRowHeaders() : 0;\n  if (topRow === 0) {\n    topRow = rowIndexMapper.getVisualFromRenderableIndex(topRow);\n  }\n  if (startColumn === 0) {\n    startColumn = columnIndexMapper.getVisualFromRenderableIndex(startColumn);\n  }\n  if (topRow === null || startColumn === null) {\n    return null;\n  }\n  return hot._createCellCoords(topRow, startColumn);\n}\n\n/**\n * Gets the coordinates of the most bottom-end cell or header (depends on the table settings and its size).\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {CellCoords|null}\n */\nfunction getMostBottomEndPosition(hot) {\n  var _rowIndexMapper$getVi, _columnIndexMapper$ge;\n  const {\n    rowIndexMapper,\n    columnIndexMapper\n  } = hot;\n  const {\n    navigableHeaders\n  } = hot.getSettings();\n  let bottomRow = rowIndexMapper.getRenderableIndexesLength() - 1;\n  let endColumn = columnIndexMapper.getRenderableIndexesLength() - 1;\n  if (bottomRow < 0) {\n    if (!navigableHeaders || hot.countColHeaders() === 0) {\n      return null;\n    }\n    bottomRow = -1;\n  }\n  if (endColumn < 0) {\n    if (!navigableHeaders || hot.countColHeaders() === 0) {\n      return null;\n    }\n    endColumn = -1;\n  }\n  return hot._createCellCoords((_rowIndexMapper$getVi = rowIndexMapper.getVisualFromRenderableIndex(bottomRow)) !== null && _rowIndexMapper$getVi !== void 0 ? _rowIndexMapper$getVi : bottomRow, (_columnIndexMapper$ge = columnIndexMapper.getVisualFromRenderableIndex(endColumn)) !== null && _columnIndexMapper$ge !== void 0 ? _columnIndexMapper$ge : endColumn);\n}\n\n/**\n * Normalizes the coordinates (clamps to nearest visible cell position within dataset range).\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {function(Coords | undefined): Coords | null}\n */\nfunction normalizeCoordsIfNeeded(hot) {\n  return coords => {\n    if (!coords) {\n      return null;\n    }\n    const mostTopStartCoords = getMostTopStartPosition(hot);\n    const mostBottomEndCoords = getMostBottomEndPosition(hot);\n    if (coords.col < mostTopStartCoords.col) {\n      coords.col = mostTopStartCoords.col;\n    }\n    if (coords.col > mostBottomEndCoords.col) {\n      coords.col = mostBottomEndCoords.col;\n    }\n    if (coords.row < mostTopStartCoords.row) {\n      coords.row = mostTopStartCoords.row;\n    }\n    if (coords.row > mostBottomEndCoords.row) {\n      coords.row = mostBottomEndCoords.row;\n    }\n    return coords;\n  };\n}","map":{"version":3,"names":["GRID_GROUP","installFocusDetector","installFocusCatcher","hot","clampCoordsIfNeeded","normalizeCoordsIfNeeded","recentlyAddedFocusCoords","activate","deactivate","onFocusFromTop","_clampCoordsIfNeeded","mostTopStartCoords","getMostTopStartPosition","runHooks","selectCell","row","col","listen","onFocusFromBottom","_clampCoordsIfNeeded2","mostBottomEndCoords","getMostBottomEndPosition","rowWrapState","wrapped","flipped","isSavingCoordsEnabled","isTabOrShiftTabPressed","preventViewportScroll","addHook","column","row2","column2","preventScrolling","value","_hot$getSelectedRange","getSelectedRangeLast","highlight","interruptedByAutoInsertMode","newCoords","isFlipped","deactivateTable","deselectCell","unlisten","shortcutOptions","keys","preventDefault","stopPropagation","relativeToGroup","group","getShortcutManager","getContext","addShortcuts","callback","tabNavigation","getSettings","position","event","autoWrapRow","selection","isSelected","shiftKey","rowIndexMapper","columnIndexMapper","navigableHeaders","topRow","countColHeaders","startColumn","countRowHeaders","getVisualFromRenderableIndex","_createCellCoords","_rowIndexMapper$getVi","_columnIndexMapper$ge","bottomRow","getRenderableIndexesLength","endColumn","coords"],"sources":["D:/gym-project/frontend/node_modules/handsontable/core/focusCatcher/index.mjs"],"sourcesContent":["import { GRID_GROUP } from \"../../shortcutContexts/index.mjs\";\nimport { installFocusDetector } from \"./focusDetector.mjs\";\n/**\n * Installs a focus catcher module. The module observes when the table is focused and depending on\n * from the which side it was focused on it selects a specified cell or releases the TAB navigation\n * to the browser.\n *\n * @param {Core} hot The Handsontable instance.\n */\nexport function installFocusCatcher(hot) {\n  const clampCoordsIfNeeded = normalizeCoordsIfNeeded(hot);\n  let recentlyAddedFocusCoords;\n  const {\n    activate,\n    deactivate\n  } = installFocusDetector(hot, {\n    onFocusFromTop() {\n      var _clampCoordsIfNeeded;\n      const mostTopStartCoords = (_clampCoordsIfNeeded = clampCoordsIfNeeded(recentlyAddedFocusCoords)) !== null && _clampCoordsIfNeeded !== void 0 ? _clampCoordsIfNeeded : getMostTopStartPosition(hot);\n      if (mostTopStartCoords) {\n        hot.runHooks('modifyFocusOnTabNavigation', 'from_above', mostTopStartCoords);\n        hot.selectCell(mostTopStartCoords.row, mostTopStartCoords.col);\n      }\n      hot.listen();\n    },\n    onFocusFromBottom() {\n      var _clampCoordsIfNeeded2;\n      const mostBottomEndCoords = (_clampCoordsIfNeeded2 = clampCoordsIfNeeded(recentlyAddedFocusCoords)) !== null && _clampCoordsIfNeeded2 !== void 0 ? _clampCoordsIfNeeded2 : getMostBottomEndPosition(hot);\n      if (mostBottomEndCoords) {\n        hot.runHooks('modifyFocusOnTabNavigation', 'from_below', mostBottomEndCoords);\n        hot.selectCell(mostBottomEndCoords.row, mostBottomEndCoords.col);\n      }\n      hot.listen();\n    }\n  });\n  const rowWrapState = {\n    wrapped: false,\n    flipped: false\n  };\n  let isSavingCoordsEnabled = true;\n  let isTabOrShiftTabPressed = false;\n  let preventViewportScroll = false;\n  hot.addHook('afterListen', () => deactivate());\n  hot.addHook('afterUnlisten', () => activate());\n  hot.addHook('afterSelection', (row, column, row2, column2, preventScrolling) => {\n    if (isTabOrShiftTabPressed && (rowWrapState.wrapped && rowWrapState.flipped || preventViewportScroll)) {\n      preventViewportScroll = false;\n      preventScrolling.value = true;\n    }\n    if (isSavingCoordsEnabled) {\n      var _hot$getSelectedRange;\n      recentlyAddedFocusCoords = (_hot$getSelectedRange = hot.getSelectedRangeLast()) === null || _hot$getSelectedRange === void 0 ? void 0 : _hot$getSelectedRange.highlight;\n    }\n  });\n  hot.addHook('beforeRowWrap', (interruptedByAutoInsertMode, newCoords, isFlipped) => {\n    rowWrapState.wrapped = true;\n    rowWrapState.flipped = isFlipped;\n  });\n\n  /**\n   * Unselects the cell and deactivates the table.\n   */\n  function deactivateTable() {\n    rowWrapState.wrapped = false;\n    rowWrapState.flipped = false;\n    hot.deselectCell();\n    hot.unlisten();\n  }\n  const shortcutOptions = {\n    keys: [['Tab'], ['Shift', 'Tab']],\n    preventDefault: false,\n    stopPropagation: false,\n    relativeToGroup: GRID_GROUP,\n    group: 'focusCatcher'\n  };\n  hot.getShortcutManager().getContext('grid').addShortcuts([{\n    ...shortcutOptions,\n    callback: () => {\n      const {\n        tabNavigation\n      } = hot.getSettings();\n      isTabOrShiftTabPressed = true;\n      if (hot.getSelectedRangeLast() && !tabNavigation) {\n        isSavingCoordsEnabled = false;\n      }\n      if (!tabNavigation) {\n        preventViewportScroll = true;\n      }\n    },\n    position: 'before'\n  }, {\n    ...shortcutOptions,\n    callback: event => {\n      const {\n        tabNavigation,\n        autoWrapRow\n      } = hot.getSettings();\n      isTabOrShiftTabPressed = false;\n      isSavingCoordsEnabled = true;\n      if (!tabNavigation || !hot.selection.isSelected() || autoWrapRow && rowWrapState.wrapped && rowWrapState.flipped || !autoWrapRow && rowWrapState.wrapped) {\n        if (autoWrapRow && rowWrapState.wrapped && rowWrapState.flipped) {\n          recentlyAddedFocusCoords = event.shiftKey ? getMostTopStartPosition(hot) : getMostBottomEndPosition(hot);\n        }\n        deactivateTable();\n        return false;\n      }\n\n      // if the selection is still within the table's range then prevent default action\n      event.preventDefault();\n    },\n    position: 'after'\n  }]);\n}\n\n/**\n * Gets the coordinates of the most top-start cell or header (depends on the table settings and its size).\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {CellCoords|null}\n */\nfunction getMostTopStartPosition(hot) {\n  const {\n    rowIndexMapper,\n    columnIndexMapper\n  } = hot;\n  const {\n    navigableHeaders\n  } = hot.getSettings();\n  let topRow = navigableHeaders && hot.countColHeaders() > 0 ? -hot.countColHeaders() : 0;\n  let startColumn = navigableHeaders && hot.countRowHeaders() > 0 ? -hot.countRowHeaders() : 0;\n  if (topRow === 0) {\n    topRow = rowIndexMapper.getVisualFromRenderableIndex(topRow);\n  }\n  if (startColumn === 0) {\n    startColumn = columnIndexMapper.getVisualFromRenderableIndex(startColumn);\n  }\n  if (topRow === null || startColumn === null) {\n    return null;\n  }\n  return hot._createCellCoords(topRow, startColumn);\n}\n\n/**\n * Gets the coordinates of the most bottom-end cell or header (depends on the table settings and its size).\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {CellCoords|null}\n */\nfunction getMostBottomEndPosition(hot) {\n  var _rowIndexMapper$getVi, _columnIndexMapper$ge;\n  const {\n    rowIndexMapper,\n    columnIndexMapper\n  } = hot;\n  const {\n    navigableHeaders\n  } = hot.getSettings();\n  let bottomRow = rowIndexMapper.getRenderableIndexesLength() - 1;\n  let endColumn = columnIndexMapper.getRenderableIndexesLength() - 1;\n  if (bottomRow < 0) {\n    if (!navigableHeaders || hot.countColHeaders() === 0) {\n      return null;\n    }\n    bottomRow = -1;\n  }\n  if (endColumn < 0) {\n    if (!navigableHeaders || hot.countColHeaders() === 0) {\n      return null;\n    }\n    endColumn = -1;\n  }\n  return hot._createCellCoords((_rowIndexMapper$getVi = rowIndexMapper.getVisualFromRenderableIndex(bottomRow)) !== null && _rowIndexMapper$getVi !== void 0 ? _rowIndexMapper$getVi : bottomRow, (_columnIndexMapper$ge = columnIndexMapper.getVisualFromRenderableIndex(endColumn)) !== null && _columnIndexMapper$ge !== void 0 ? _columnIndexMapper$ge : endColumn);\n}\n\n/**\n * Normalizes the coordinates (clamps to nearest visible cell position within dataset range).\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {function(Coords | undefined): Coords | null}\n */\nfunction normalizeCoordsIfNeeded(hot) {\n  return coords => {\n    if (!coords) {\n      return null;\n    }\n    const mostTopStartCoords = getMostTopStartPosition(hot);\n    const mostBottomEndCoords = getMostBottomEndPosition(hot);\n    if (coords.col < mostTopStartCoords.col) {\n      coords.col = mostTopStartCoords.col;\n    }\n    if (coords.col > mostBottomEndCoords.col) {\n      coords.col = mostBottomEndCoords.col;\n    }\n    if (coords.row < mostTopStartCoords.row) {\n      coords.row = mostTopStartCoords.row;\n    }\n    if (coords.row > mostBottomEndCoords.row) {\n      coords.row = mostBottomEndCoords.row;\n    }\n    return coords;\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}