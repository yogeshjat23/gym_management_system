{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { getStyle } from \"../../helpers/dom/element.mjs\";\nimport { isChrome } from \"../../helpers/browser.mjs\";\nimport { FocusOrder } from \"./focusOrder.mjs\";\nimport { createMergeCellRenderer } from \"./renderer.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport const PLUGIN_KEY = 'mergeCells';\nexport const PLUGIN_PRIORITY = 150;\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin MergeCells\n * @class MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   // enable plugin\n *   mergeCells={[\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *   ]}\n * />\n * ```\n * :::\n */\nvar _lastSelectedFocus = /*#__PURE__*/new WeakMap();\nvar _lastFocusDelta = /*#__PURE__*/new WeakMap();\nvar _focusOrder = /*#__PURE__*/new WeakMap();\nvar _cellRenderer = /*#__PURE__*/new WeakMap();\nvar _MergeCells_brand = /*#__PURE__*/new WeakSet();\nexport class MergeCells extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _MergeCells_brand);\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n    _defineProperty(this, \"mergedCellsCollection\", null);\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n    _defineProperty(this, \"autofillCalculations\", null);\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n    _defineProperty(this, \"selectionCalculations\", null);\n    /**\n     * The holder for the last selected focus coordinates. This allows keeping the correct coordinates in cases after the\n     * focus is moved out of the merged cell.\n     *\n     * @type {CellCoords}\n     */\n    _classPrivateFieldInitSpec(this, _lastSelectedFocus, null);\n    /**\n     * The last used transformation delta.\n     *\n     * @type {{ row: number, col: number }}\n     */\n    _classPrivateFieldInitSpec(this, _lastFocusDelta, {\n      row: 0,\n      col: 0\n    });\n    /**\n     * The module responsible for providing the correct focus order (vertical and horizontal) within a selection that\n     * contains merged cells.\n     *\n     * @type {FocusOrder}\n     */\n    _classPrivateFieldInitSpec(this, _focusOrder, new FocusOrder({\n      mergedCellsGetter: (row, column) => this.mergedCellsCollection.get(row, column),\n      rowIndexMapper: this.hot.rowIndexMapper,\n      columnIndexMapper: this.hot.columnIndexMapper\n    }));\n    /**\n     * The cell renderer responsible for rendering the merged cells.\n     *\n     * @type {{before: Function, after: Function}}\n     */\n    _classPrivateFieldInitSpec(this, _cellRenderer, createMergeCellRenderer(this));\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.mergedCellsCollection = new MergedCellsCollection(this);\n    this.autofillCalculations = new AutofillCalculations(this);\n    this.selectionCalculations = new SelectionCalculations(this);\n    this.addHook('afterInit', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterInit).call(_this, ...args);\n    });\n    this.addHook('modifyTransformFocus', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyTransformFocus).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyTransformStart).call(_this, ...args);\n    });\n    this.addHook('modifyTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyTransformEnd).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSelectionHighlightSet).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStart', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSetRangeStart).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStartOnly', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSetRangeStart).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionFocusSet', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSelectionFocusSet).call(_this, ...args);\n    });\n    this.addHook('afterSelectionFocusSet', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterSelectionFocusSet).call(_this, ...args);\n    });\n    this.addHook('afterSelectionEnd', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterSelectionEnd).call(_this, ...args);\n    });\n    this.addHook('modifyGetCellCoords', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyGetCellCoords).call(_this, ...args);\n    });\n    this.addHook('afterIsMultipleSelection', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterIsMultipleSelection).call(_this, ...args);\n    });\n    this.addHook('afterRenderer', function () {\n      return _classPrivateFieldGet(_cellRenderer, _this).after(...arguments);\n    });\n    this.addHook('afterContextMenuDefaultOptions', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _addMergeActionsToContextMenu).call(_this, ...args);\n    });\n    this.addHook('afterGetCellMeta', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterGetCellMeta).call(_this, ...args);\n    });\n    this.addHook('afterViewportRowCalculatorOverride', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterViewportRowCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterViewportColumnCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('modifyAutofillRange', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyAutofillRange).call(_this, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterCreateCol).call(_this, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterRemoveCol).call(_this, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterCreateRow).call(_this, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterRemoveRow).call(_this, ...args);\n    });\n    this.addHook('afterChange', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterChange).call(_this, ...args);\n    });\n    this.addHook('beforeDrawBorders', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeDrawAreaBorders).call(_this, ...args);\n    });\n    this.addHook('afterDrawSelection', function () {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterDrawSelection).call(_this, ...args);\n    });\n    this.addHook('beforeRemoveCellClassNames', function () {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeRemoveCellClassNames).call(_this, ...args);\n    });\n    this.addHook('beforeBeginEditing', function () {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeBeginEditing).call(_this, ...args);\n    });\n    this.addHook('modifyRowHeightByOverlayName', function () {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyRowHeightByOverlayName).call(_this, ...args);\n    });\n    this.addHook('beforeUndoStackChange', (action, source) => {\n      if (source === 'MergeCells') {\n        return false;\n      }\n    });\n    this.registerShortcuts();\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearCollections();\n    this.unregisterShortcuts();\n    this.hot.render();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the\n   * following configuration options:\n   *  - [`mergeCells`](@/api/options.md#mergecells)\n   */\n  updatePlugin() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    this.disablePlugin();\n    this.enablePlugin();\n    this.generateFromSettings(settings);\n    super.updatePlugin();\n  }\n\n  /**\n   * If the browser is recognized as Chrome, force an additional repaint to prevent showing the effects of a Chrome bug.\n   *\n   * Issue described in https://github.com/handsontable/dev-handsontable/issues/521.\n   *\n   * @private\n   */\n  ifChromeForceRepaint() {\n    if (!isChrome()) {\n      return;\n    }\n    const rowsToRefresh = [];\n    let rowIndexesToRefresh = [];\n    this.mergedCellsCollection.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        rowspan\n      } = mergedCell;\n      for (let r = row + 1; r < row + rowspan; r++) {\n        rowIndexesToRefresh.push(r);\n      }\n    });\n\n    // Remove duplicates\n    rowIndexesToRefresh = [...new Set(rowIndexesToRefresh)];\n    rowIndexesToRefresh.forEach(rowIndex => {\n      const renderableRowIndex = this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);\n      this.hot.view._wt.wtOverlays.getOverlays(true).map(overlay => (overlay === null || overlay === void 0 ? void 0 : overlay.name) === 'master' ? overlay : overlay.clone.wtTable).forEach(wtTableRef => {\n        const rowToRefresh = wtTableRef.getRow(renderableRowIndex);\n        if (rowToRefresh) {\n          // Modify the TR's `background` property to later modify it asynchronously.\n          // The background color is getting modified only with the alpha, so the change should not be visible (and is\n          // covered by the TDs' background color).\n          rowToRefresh.style.background = getStyle(rowToRefresh, 'backgroundColor').replace(')', ', 0.99)');\n          rowsToRefresh.push(rowToRefresh);\n        }\n      });\n    });\n\n    // Asynchronously revert the TRs' `background` property to force a fresh repaint.\n    this.hot._registerTimeout(() => {\n      rowsToRefresh.forEach(rowElement => {\n        rowElement.style.background = getStyle(rowElement, 'backgroundColor').replace(', 0.99)', ')');\n      });\n    }, 1);\n  }\n\n  /**\n   * Validates a single setting object, represented by a single merged cell information object.\n   *\n   * @private\n   * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  validateSetting(setting) {\n    if (!setting) {\n      return false;\n    }\n    if (MergedCellCoords.containsNegativeValues(setting)) {\n      warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n      return false;\n    }\n    if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n      warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n      return false;\n    }\n    if (MergedCellCoords.isSingleCell(setting)) {\n      warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n      return false;\n    }\n    if (MergedCellCoords.containsZeroSpan(setting)) {\n      warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Generates the merged cells from the settings provided to the plugin.\n   *\n   * @private\n   * @param {Array|boolean} settings The settings provided to the plugin.\n   */\n  generateFromSettings(settings) {\n    if (!Array.isArray(settings)) {\n      return;\n    }\n    const validSettings = settings.filter(mergeCellInfo => this.validateSetting(mergeCellInfo));\n    const nonOverlappingSettings = this.mergedCellsCollection.filterOverlappingMergeCells(validSettings);\n    const populatedNulls = [];\n    nonOverlappingSettings.forEach(mergeCellInfo => {\n      const {\n        row,\n        col,\n        rowspan,\n        colspan\n      } = mergeCellInfo;\n      const from = this.hot._createCellCoords(row, col);\n      const to = this.hot._createCellCoords(row + rowspan - 1, col + colspan - 1);\n      const mergeRange = this.hot._createCellRange(from, from, to);\n\n      // Merging without data population.\n      this.mergeRange(mergeRange, true, true);\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          // Not resetting a cell representing a merge area's value.\n          if (r !== row || c !== col) {\n            populatedNulls.push([r, c, null]);\n          }\n        }\n      }\n    });\n\n    // There are no merged cells. Thus, no data population is needed.\n    if (populatedNulls.length === 0) {\n      return;\n    }\n\n    // TODO: Change the `source` argument to a more meaningful value, e.g. `${this.pluginName}.clearCells`.\n    this.hot.setDataAtCell(populatedNulls, undefined, undefined, this.pluginName);\n  }\n\n  /**\n   * Clears the merged cells from the merged cell container.\n   */\n  clearCollections() {\n    this.mergedCellsCollection.clear();\n  }\n\n  /**\n   * Returns `true` if a range is mergeable.\n   *\n   * @private\n   * @param {object} newMergedCellInfo Merged cell information object to test.\n   * @param {boolean} [auto=false] `true` if triggered at initialization.\n   * @returns {boolean}\n   */\n  canMergeRange(newMergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return auto ? true : this.validateSetting(newMergedCellInfo);\n  }\n\n  /**\n   * Merges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  mergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    cellRange.setDirection(this.hot.isRtl() ? 'NE-SW' : 'NW-SE');\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.mergeRange(cellRange);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  unmergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Merges cells in the provided cell range.\n   *\n   * @private\n   * @param {CellRange} cellRange Cell range to merge.\n   * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\n   * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end,\n   *   but rather return its arguments.\n   * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to\n   *   true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  mergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const topStart = cellRange.getTopStartCorner();\n    const bottomEnd = cellRange.getBottomEndCorner();\n    const mergeParent = {\n      row: topStart.row,\n      col: topStart.col,\n      rowspan: bottomEnd.row - topStart.row + 1,\n      colspan: bottomEnd.col - topStart.col + 1\n    };\n    const clearedData = [];\n    let populationInfo = null;\n    if (!this.canMergeRange(mergeParent, auto)) {\n      return false;\n    }\n    this.hot.runHooks('beforeMergeCells', cellRange, auto);\n    rangeEach(0, mergeParent.rowspan - 1, i => {\n      rangeEach(0, mergeParent.colspan - 1, j => {\n        let clearedValue = null;\n        if (!clearedData[i]) {\n          clearedData[i] = [];\n        }\n        if (i === 0 && j === 0) {\n          clearedValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), this.hot.toPhysicalColumn(mergeParent.col));\n        } else {\n          this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n        }\n        clearedData[i][j] = clearedValue;\n      });\n    });\n    this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n    const mergedCellAdded = this.mergedCellsCollection.add(mergeParent, auto);\n    if (mergedCellAdded) {\n      if (preventPopulation) {\n        populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n      } else {\n        // TODO: Change the `source` argument to a more meaningful value, e.g. `${this.pluginName}.clearCells`.\n        this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, undefined, undefined, this.pluginName);\n      }\n      if (!auto) {\n        this.ifChromeForceRepaint();\n      }\n      this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n      return populationInfo;\n    }\n    return true;\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n   *\n   * @private\n   * @param {CellRange} cellRange Selection cell range.\n   * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n   *\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n    if (mergedCells.length === 0) {\n      return;\n    }\n    this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n    arrayEach(mergedCells, currentCollection => {\n      this.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n      rangeEach(0, currentCollection.rowspan - 1, i => {\n        rangeEach(0, currentCollection.colspan - 1, j => {\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'copyable');\n        });\n      });\n      this.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n    });\n    this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    this.hot.render();\n  }\n\n  /**\n   * Merges or unmerges, based on the cell range provided as `cellRange`.\n   *\n   * @private\n   * @param {CellRange} cellRange The cell range to merge or unmerged.\n   */\n  toggleMerge(cellRange) {\n    const mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n    const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n    if (mergedCellCoversWholeRange) {\n      this.unmergeRange(cellRange);\n    } else {\n      this.mergeSelection(cellRange);\n    }\n  }\n\n  /**\n   * Merges the specified range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  merge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.mergeRange(this.hot._createCellRange(start, start, end));\n  }\n\n  /**\n   * Unmerges the merged cell in the provided range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmerge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.unmergeRange(this.hot._createCellRange(start, start, end));\n  }\n  /**\n   * Register shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.addShortcut({\n      keys: [['Control', 'm']],\n      callback: () => {\n        const range = this.hot.getSelectedRangeLast();\n        if (range && !range.isSingleHeader()) {\n          this.toggleMerge(range);\n          this.hot.render();\n        }\n      },\n      runOnlyIf: event => !event.altKey,\n      // right ALT in some systems triggers ALT+CTRL\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n\n  /**\n   * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection`\n   * hook callback.\n   *\n   * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\n   * @returns {boolean}\n   */\n\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowStart(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startRow) {\n          // We extend viewport when some rows have been merged.\n          calc.startRow = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowEnd(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n        const renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endRow) {\n          // We extend the viewport when some rows have been merged.\n          calc.endRow = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   * `afterViewportColumnCalculatorOverride` hook callback.\n   *\n   * @param {object} calc The column calculator object.\n   */\n\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnStart(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startColumn) {\n          // We extend viewport when some columns have been merged.\n          calc.startColumn = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnEnd(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n        const renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endColumn) {\n          // We extend the viewport when some columns have been merged.\n          calc.endColumn = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   * Translates merged cell coordinates to renderable indexes.\n   *\n   * @private\n   * @param {number} parentRow Visual row index.\n   * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\n   *                         to calculate renderable index which points to the most bottom\n   *                         index position. Pass rowspan as `0` to calculate the most top\n   *                         index position.\n   * @param {number} parentColumn Visual column index.\n   * @param {number} colspan Colspan which describes shift which will be applied to parent column\n   *                         to calculate renderable index which points to the most right\n   *                         index position. Pass colspan as `0` to calculate the most left\n   *                         index position.\n   * @returns {number[]}\n   */\n  translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: columnMapper\n    } = this.hot;\n    let firstNonHiddenRow;\n    let firstNonHiddenColumn;\n    if (rowspan === 0) {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);\n    } else {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);\n    }\n    if (colspan === 0) {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);\n    } else {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);\n    }\n    const renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n    const renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n    return [renderableRow, renderableColumn];\n  }\n\n  /**\n   * The `modifyAutofillRange` hook callback.\n   *\n   * @param {Array} drag The drag area coordinates.\n   * @param {Array} select The selection information.\n   * @returns {Array} The new drag area.\n   */\n}\nfunction _onAfterInit() {\n  this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n  this.hot.render();\n}\nfunction _onAfterIsMultipleSelection(isMultiple) {\n  if (isMultiple) {\n    const mergedCells = this.mergedCellsCollection.mergedCells;\n    const selectionRange = this.hot.getSelectedRangeLast();\n    const topStartCoords = selectionRange.getTopStartCorner();\n    const bottomEndCoords = selectionRange.getBottomEndCorner();\n    for (let group = 0; group < mergedCells.length; group += 1) {\n      if (topStartCoords.row === mergedCells[group].row && topStartCoords.col === mergedCells[group].col && bottomEndCoords.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && bottomEndCoords.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n        return false;\n      }\n    }\n  }\n  return isMultiple;\n}\n/**\n * `modifyTransformFocus` hook callback.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformFocus(delta) {\n  _classPrivateFieldGet(_lastFocusDelta, this).row = delta.row;\n  _classPrivateFieldGet(_lastFocusDelta, this).col = delta.col;\n}\n/**\n * `modifyTransformStart` hook callback.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformStart(delta) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const {\n    highlight\n  } = selectedRange;\n  const {\n    columnIndexMapper,\n    rowIndexMapper\n  } = this.hot;\n  if (_classPrivateFieldGet(_lastSelectedFocus, this)) {\n    if (rowIndexMapper.getRenderableFromVisualIndex(_classPrivateFieldGet(_lastSelectedFocus, this).row) !== null) {\n      highlight.row = _classPrivateFieldGet(_lastSelectedFocus, this).row;\n    }\n    if (columnIndexMapper.getRenderableFromVisualIndex(_classPrivateFieldGet(_lastSelectedFocus, this).col) !== null) {\n      highlight.col = _classPrivateFieldGet(_lastSelectedFocus, this).col;\n    }\n    _classPrivateFieldSet(_lastSelectedFocus, this, null);\n  }\n  const mergedParent = this.mergedCellsCollection.get(highlight.row, highlight.col);\n  if (!mergedParent) {\n    return;\n  }\n  const visualColumnIndexStart = mergedParent.col;\n  const visualColumnIndexEnd = mergedParent.col + mergedParent.colspan - 1;\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n  const visualRowIndexStart = mergedParent.row;\n  const visualRowIndexEnd = mergedParent.row + mergedParent.rowspan - 1;\n  if (delta.row < 0) {\n    const nextRow = highlight.row >= visualRowIndexStart && highlight.row <= visualRowIndexEnd ? visualRowIndexStart - 1 : visualRowIndexEnd;\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, -1);\n    if (notHiddenRowIndex === null) {\n      // There are no visible rows anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous column (if autoWrapCol is enabled).\n      delta.row = -this.hot.view.countRenderableRowsInRange(0, highlight.row);\n    } else {\n      delta.row = -Math.max(this.hot.view.countRenderableRowsInRange(notHiddenRowIndex, highlight.row) - 1, 1);\n    }\n  } else if (delta.row > 0) {\n    const nextRow = highlight.row >= visualRowIndexStart && highlight.row <= visualRowIndexEnd ? visualRowIndexEnd + 1 : visualRowIndexStart;\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, 1);\n    if (notHiddenRowIndex === null) {\n      // There are no visible rows anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next column (if autoWrapCol is enabled).\n      delta.row = this.hot.view.countRenderableRowsInRange(highlight.row, this.hot.countRows());\n    } else {\n      delta.row = Math.max(this.hot.view.countRenderableRowsInRange(highlight.row, notHiddenRowIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook allows to modify the delta transformation object necessary for correct selection end transformations.\n * The logic here handles \"jumping over\" merged merged cells, while selecting.\n *\n * @param {{ row: number, col: number }} delta The transformation delta.\n */\nfunction _onModifyTransformEnd(delta) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const cloneRange = selectedRange.clone();\n  const {\n    to\n  } = selectedRange;\n  const {\n    columnIndexMapper,\n    rowIndexMapper\n  } = this.hot;\n  const expandCloneRange = (row, col) => {\n    cloneRange.expand(this.hot._createCellCoords(row, col));\n    for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n      cloneRange.expandByRange(this.mergedCellsCollection.mergedCells[i].getRange());\n    }\n  };\n  if (delta.col < 0) {\n    let nextColumn = this.mergedCellsCollection.getStartMostColumnIndex(selectedRange, to.col) + delta.col;\n    expandCloneRange(to.row, nextColumn);\n    if (selectedRange.getHorizontalDirection() === 'E-W' && cloneRange.getHorizontalDirection() === 'E-W') {\n      nextColumn = cloneRange.getTopStartCorner().col;\n    }\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex !== null) {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, to.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    let nextColumn = this.mergedCellsCollection.getEndMostColumnIndex(selectedRange, to.col) + delta.col;\n    expandCloneRange(to.row, nextColumn);\n    if (selectedRange.getHorizontalDirection() === 'W-E' && cloneRange.getHorizontalDirection() === 'W-E') {\n      nextColumn = cloneRange.getBottomEndCorner().col;\n    }\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex !== null) {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(to.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n  if (delta.row < 0) {\n    let nextRow = this.mergedCellsCollection.getTopMostRowIndex(selectedRange, to.row) + delta.row;\n    expandCloneRange(nextRow, to.col);\n    if (selectedRange.getVerticalDirection() === 'S-N' && cloneRange.getVerticalDirection() === 'S-N') {\n      nextRow = cloneRange.getTopStartCorner().row;\n    }\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, 1);\n    if (notHiddenRowIndex !== null) {\n      delta.row = -Math.max(this.hot.view.countRenderableRowsInRange(notHiddenRowIndex, to.row) - 1, 1);\n    }\n  } else if (delta.row > 0) {\n    let nextRow = this.mergedCellsCollection.getBottomMostRowIndex(selectedRange, to.row) + delta.row;\n    expandCloneRange(nextRow, to.col);\n    if (selectedRange.getVerticalDirection() === 'N-S' && cloneRange.getVerticalDirection() === 'N-S') {\n      nextRow = cloneRange.getBottomStartCorner().row;\n    }\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, -1);\n    if (notHiddenRowIndex !== null) {\n      delta.row = Math.max(this.hot.view.countRenderableRowsInRange(to.row, notHiddenRowIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook corrects the range (before drawing it) after the selection was made on the merged cells.\n * It expands the range to cover the entire area of the selected merged cells.\n */\nfunction _onBeforeSelectionHighlightSet() {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const {\n    highlight\n  } = selectedRange;\n  if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n    _classPrivateFieldSet(_lastSelectedFocus, this, highlight.clone());\n    return;\n  }\n  for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n    selectedRange.expandByRange(this.mergedCellsCollection.mergedCells[i].getRange(), false);\n  }\n  // TODO: This is a workaround for an issue with the selection not being extended properly.\n  // In some cases when the merge cells are defined in random order the selection is not\n  // extended in that way that it covers all overlapped merge cells.\n  for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n    selectedRange.expandByRange(this.mergedCellsCollection.mergedCells[i].getRange(), false);\n  }\n  const mergedParent = this.mergedCellsCollection.get(highlight.row, highlight.col);\n  _classPrivateFieldSet(_lastSelectedFocus, this, highlight.clone());\n  if (mergedParent) {\n    highlight.assign(mergedParent);\n  }\n}\n/**\n * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n *\n * @param {number} row Row index.\n * @param {number} column Visual column index.\n * @returns {Array|undefined} Visual coordinates of the merge.\n */\nfunction _onModifyGetCellCoords(row, column) {\n  if (row < 0 || column < 0) {\n    return;\n  }\n  const mergeParent = this.mergedCellsCollection.get(row, column);\n  if (!mergeParent) {\n    return;\n  }\n  const {\n    row: mergeRow,\n    col: mergeColumn,\n    colspan,\n    rowspan\n  } = mergeParent;\n  return [\n  // Most top-left merged cell coords.\n  mergeRow, mergeColumn,\n  // Most bottom-right merged cell coords.\n  mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n}\n/**\n * `afterContextMenuDefaultOptions` hook callback.\n *\n * @param {object} defaultOptions The default context menu options.\n */\nfunction _addMergeActionsToContextMenu(defaultOptions) {\n  defaultOptions.items.push({\n    name: '---------'\n  }, toggleMergeItem(this));\n}\n/**\n * Clears the last selected coordinates before setting a new selection range.\n */\nfunction _onBeforeSetRangeStart() {\n  _classPrivateFieldSet(_lastSelectedFocus, this, null);\n}\n/**\n * Detects if the last selected cell was a header cell if so update the order list active node for further\n * computations.\n */\nfunction _onBeforeSelectionFocusSet() {\n  if (_classPrivateFieldGet(_lastSelectedFocus, this).isCell()) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const verticalDir = selectedRange.getVerticalDirection();\n  const horizontalDir = selectedRange.getHorizontalDirection();\n  const focusCoords = _classPrivateFieldGet(_lastSelectedFocus, this).clone().normalize();\n  _classPrivateFieldGet(_focusOrder, this).setActiveNode(focusCoords.row, focusCoords.col);\n  if (_classPrivateFieldGet(_lastFocusDelta, this).row > 0 || _classPrivateFieldGet(_lastFocusDelta, this).col > 0) {\n    _classPrivateFieldGet(_focusOrder, this).setPrevNodeAsActive();\n  } else if (horizontalDir === 'E-W' && _classPrivateFieldGet(_lastFocusDelta, this).col < 0 || verticalDir === 'S-N' && _classPrivateFieldGet(_lastFocusDelta, this).row < 0) {\n    _classPrivateFieldGet(_focusOrder, this).setNextNodeAsActive();\n  }\n}\n/**\n * Changes the focus selection to the next or previous cell or merged cell position.\n *\n * @param {number} row The visual row index.\n * @param {number} column The visual column index.\n */\nfunction _onAfterSelectionFocusSet(row, column) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const {\n    columnIndexMapper,\n    rowIndexMapper\n  } = this.hot;\n  let notHiddenRowIndex = null;\n  let notHiddenColumnIndex = null;\n  if (_classPrivateFieldGet(_lastFocusDelta, this).col < 0) {\n    const {\n      rowEnd,\n      colEnd\n    } = _classPrivateFieldGet(_focusOrder, this).getPrevHorizontalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colEnd, -1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowEnd, -1);\n  } else if (_classPrivateFieldGet(_lastFocusDelta, this).col > 0) {\n    const {\n      rowStart,\n      colStart\n    } = _classPrivateFieldGet(_focusOrder, this).getNextHorizontalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colStart, 1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowStart, 1);\n  } else if (_classPrivateFieldGet(_lastFocusDelta, this).row < 0) {\n    const {\n      rowEnd,\n      colEnd\n    } = _classPrivateFieldGet(_focusOrder, this).getPrevVerticalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colEnd, -1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowEnd, -1);\n  } else if (_classPrivateFieldGet(_lastFocusDelta, this).row > 0) {\n    const {\n      rowStart,\n      colStart\n    } = _classPrivateFieldGet(_focusOrder, this).getNextVerticalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colStart, 1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowStart, 1);\n  }\n  if (notHiddenRowIndex !== null || notHiddenColumnIndex !== null) {\n    const coords = this.hot._createCellCoords(notHiddenRowIndex, notHiddenColumnIndex);\n    const mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n    row = coords.row;\n    column = coords.col;\n    if (mergeParent) {\n      selectedRange.highlight.assign({\n        row: this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1),\n        col: this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1)\n      });\n    } else {\n      selectedRange.highlight.assign(coords);\n    }\n    focusHighlight.clear();\n    focusHighlight.add(coords).commit();\n  }\n  _classPrivateFieldGet(_focusOrder, this).setActiveNode(row, column);\n  _classPrivateFieldSet(_lastFocusDelta, this, {\n    row: 0,\n    col: 0\n  });\n}\n/**\n * Creates the horizontal and vertical cells order matrix (linked lists) for focused cell.\n */\nfunction _onAfterSelectionEnd() {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection.isHeader()) {\n    _classPrivateFieldGet(_focusOrder, this).buildFocusOrder(this.hot.getSelectedRangeLast());\n  }\n}\n/**\n * The `afterGetCellMeta` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} col Column index.\n * @param {object} cellProperties The cell properties object.\n */\nfunction _onAfterGetCellMeta(row, col, cellProperties) {\n  const mergeParent = this.mergedCellsCollection.get(row, col);\n  if (mergeParent) {\n    if (mergeParent.row !== row || mergeParent.col !== col) {\n      cellProperties.copyable = false;\n    } else {\n      cellProperties.rowspan = mergeParent.rowspan;\n      cellProperties.colspan = mergeParent.colspan;\n    }\n  }\n}\n/**\n * `afterViewportRowCalculatorOverride` hook callback.\n *\n * @param {object} calc The row calculator object.\n */\nfunction _onAfterViewportRowCalculatorOverride(calc) {\n  const nrOfColumns = this.hot.countCols();\n  this.modifyViewportRowStart(calc, nrOfColumns);\n  this.modifyViewportRowEnd(calc, nrOfColumns);\n}\nfunction _onAfterViewportColumnCalculatorOverride(calc) {\n  const nrOfRows = this.hot.countRows();\n  this.modifyViewportColumnStart(calc, nrOfRows);\n  this.modifyViewportColumnEnd(calc, nrOfRows);\n}\nfunction _onModifyAutofillRange(drag, select) {\n  this.autofillCalculations.correctSelectionAreaSize(select);\n  const dragDirection = this.autofillCalculations.getDirection(select, drag);\n  let dragArea = drag;\n  if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n    dragArea = select;\n    return dragArea;\n  }\n  const from = this.hot._createCellCoords(select[0], select[1]);\n  const to = this.hot._createCellCoords(select[2], select[3]);\n  const range = this.hot._createCellRange(from, from, to);\n  const mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange(range);\n  if (mergedCellsWithinSelectionArea.length === 0) {\n    return dragArea;\n  }\n  dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n  return dragArea;\n}\n/**\n * `afterCreateCol` hook callback.\n *\n * @param {number} column Column index.\n * @param {number} count Number of created columns.\n */\nfunction _onAfterCreateCol(column, count) {\n  this.mergedCellsCollection.shiftCollections('right', column, count);\n}\n/**\n * `afterRemoveCol` hook callback.\n *\n * @param {number} column Column index.\n * @param {number} count Number of removed columns.\n */\nfunction _onAfterRemoveCol(column, count) {\n  this.mergedCellsCollection.shiftCollections('left', column, count);\n}\n/**\n * `afterCreateRow` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} count Number of created rows.\n * @param {string} source Source of change.\n */\nfunction _onAfterCreateRow(row, count, source) {\n  if (source === 'auto') {\n    return;\n  }\n  this.mergedCellsCollection.shiftCollections('down', row, count);\n}\n/**\n * `afterRemoveRow` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} count Number of removed rows.\n */\nfunction _onAfterRemoveRow(row, count) {\n  this.mergedCellsCollection.shiftCollections('up', row, count);\n}\n/**\n * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n *\n * @param {Array} changes The changes array.\n * @param {string} source Determines the source of the change.\n */\nfunction _onAfterChange(changes, source) {\n  if (source !== 'Autofill.fill') {\n    return;\n  }\n  this.autofillCalculations.recreateAfterDataPopulation(changes);\n}\n/**\n * `beforeDrawAreaBorders` hook callback.\n *\n * @param {Array} corners Visual coordinates of the area corners.\n * @param {string} className Class name for the area.\n */\nfunction _onBeforeDrawAreaBorders(corners, className) {\n  if (className && className === 'area') {\n    const selectedRange = this.hot.getSelectedRangeLast();\n    const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n    arrayEach(mergedCellsWithinRange, mergedCell => {\n      if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {\n        corners[2] = mergedCell.row;\n        corners[3] = mergedCell.col;\n      }\n    });\n  }\n}\n/**\n * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n *\n * @param {number} currentRow Visual row index of the currently processed cell.\n * @param {number} currentColumn Visual column index of the currently cell.\n * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow,\n *   endColumn]`.\n * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently\n *   processed cell.\n */\nfunction _onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n  // Nothing's selected (hook might be triggered by the custom borders)\n  if (!cornersOfSelection) {\n    return;\n  }\n  return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n}\n/**\n * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n *\n * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from\n *   all the cells in the table.\n */\nfunction _onBeforeRemoveCellClassNames() {\n  return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n}\n/**\n * Allows to prevent opening the editor while more than one merged cell is selected.\n *\n * @param {number} row Visual row index of the edited cell.\n * @param {number} column Visual column index of the edited cell.\n * @param {string | null} initialValue The initial editor value.\n * @param {MouseEvent | KeyboardEvent} event The event which was responsible for opening the editor.\n * @returns {boolean | undefined}\n */\nfunction _onBeforeBeginEditing(row, column, initialValue, event) {\n  if (!(event instanceof MouseEvent)) {\n    return;\n  }\n  const selection = this.hot.getSelectedRangeLast();\n  const mergeCell = this.mergedCellsCollection.getByRange(selection);\n  if (!mergeCell) {\n    return;\n  }\n  const from = this.hot._createCellCoords(mergeCell.row, mergeCell.col);\n  const to = this.hot._createCellCoords(mergeCell.row + mergeCell.rowspan - 1, mergeCell.col + mergeCell.colspan - 1);\n  return this.hot.selection.getLayerLevel() === 0 && selection.isEqual(this.hot._createCellRange(from, from, to));\n}\n/**\n * Hook used to modify the row height depends on the merged cells in the row.\n *\n * @param {number} height The row height value provided by the Core.\n * @param {number} row The visual row index.\n * @param {string} overlayType The overlay type that is currently rendered.\n * @returns {number}\n */\nfunction _onModifyRowHeightByOverlayName(height, row, overlayType) {\n  if (this.hot.getSettings().rowHeaders ||\n  // merged cells do not work with the bottom overlays\n  overlayType === 'bottom' || overlayType === 'bottom_inline_start_corner') {\n    return height;\n  }\n  let firstColumn;\n  let lastColumn;\n  if (overlayType === 'master') {\n    firstColumn = this.hot.view.getFirstRenderedVisibleColumn();\n    lastColumn = this.hot.view.getLastRenderedVisibleColumn();\n  } else {\n    const activeOverlay = this.hot.view.getOverlayByName(overlayType);\n    firstColumn = this.hot.columnIndexMapper.getVisualFromRenderableIndex(activeOverlay.clone.wtTable.getFirstRenderedColumn());\n    lastColumn = this.hot.columnIndexMapper.getVisualFromRenderableIndex(activeOverlay.clone.wtTable.getLastRenderedColumn());\n  }\n  const firstMergedCellInRow = this.mergedCellsCollection.get(row, firstColumn);\n  if (!firstMergedCellInRow) {\n    return height;\n  }\n  const from = this.hot._createCellCoords(row, firstColumn);\n  const to = this.hot._createCellCoords(row, lastColumn);\n  const viewportRange = this.hot._createCellRange(from, from, to);\n  const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(viewportRange);\n  const maxRowspan = mergedCellsWithinRange.reduce((acc, _ref) => {\n    let {\n      rowspan\n    } = _ref;\n    return Math.max(acc, rowspan);\n  }, 1);\n  let rowspanCorrection = 0;\n  if (mergedCellsWithinRange.length > 1 && mergedCellsWithinRange[0].rowspan < maxRowspan) {\n    rowspanCorrection = maxRowspan - mergedCellsWithinRange[0].rowspan;\n  }\n  mergedCellsWithinRange.forEach(_ref2 => {\n    var _height;\n    let {\n      rowspan\n    } = _ref2;\n    let rowspanAfterCorrection = 0;\n    if (overlayType === 'top' || overlayType === 'top_inline_start_corner') {\n      rowspanAfterCorrection = Math.min(maxRowspan, this.hot.view.countNotHiddenFixedRowsTop() - row);\n    } else {\n      rowspanAfterCorrection = rowspan - rowspanCorrection;\n    }\n    height = Math.max((_height = height) !== null && _height !== void 0 ? _height : 0, _assertClassBrand(_MergeCells_brand, this, _sumCellsHeights).call(this, row, rowspanAfterCorrection));\n  });\n  return height;\n}\n/**\n * Sums the heights of the all cells that the merge cell consists of.\n *\n * @param {number} row The visual row index of the merged cell.\n * @param {number} rowspan The rowspan value of the merged cell.\n * @returns {number}\n */\nfunction _sumCellsHeights(row, rowspan) {\n  const defaultHeight = this.hot.view._wt.wtSettings.getSettingPure('defaultRowHeight');\n  const autoRowSizePlugin = this.hot.getPlugin('autoRowSize');\n  let height = 0;\n  for (let i = row; i < row + rowspan; i++) {\n    if (!this.hot.rowIndexMapper.isHidden(i)) {\n      var _autoRowSizePlugin$ge;\n      height += (_autoRowSizePlugin$ge = autoRowSizePlugin === null || autoRowSizePlugin === void 0 ? void 0 : autoRowSizePlugin.getRowHeight(i)) !== null && _autoRowSizePlugin$ge !== void 0 ? _autoRowSizePlugin$ge : defaultHeight;\n    }\n  }\n  return height;\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldSet","s","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","BasePlugin","Hooks","MergedCellsCollection","MergedCellCoords","AutofillCalculations","SelectionCalculations","toggleMergeItem","arrayEach","isObject","warn","rangeEach","getStyle","isChrome","FocusOrder","createMergeCellRenderer","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","SHORTCUTS_GROUP","_lastSelectedFocus","WeakMap","_lastFocusDelta","_focusOrder","_cellRenderer","_MergeCells_brand","WeakSet","MergeCells","constructor","row","col","mergedCellsGetter","column","mergedCellsCollection","rowIndexMapper","hot","columnIndexMapper","isEnabled","getSettings","enablePlugin","_this","enabled","autofillCalculations","selectionCalculations","addHook","_len","args","Array","_key","_onAfterInit","_len2","_key2","_onModifyTransformFocus","_len3","_key3","_onModifyTransformStart","_len4","_key4","_onModifyTransformEnd","_len5","_key5","_onBeforeSelectionHighlightSet","_len6","_key6","_onBeforeSetRangeStart","_len7","_key7","_len8","_key8","_onBeforeSelectionFocusSet","_len9","_key9","_onAfterSelectionFocusSet","_len10","_key10","_onAfterSelectionEnd","_len11","_key11","_onModifyGetCellCoords","_len12","_key12","_onAfterIsMultipleSelection","after","_len13","_key13","_addMergeActionsToContextMenu","_len14","_key14","_onAfterGetCellMeta","_len15","_key15","_onAfterViewportRowCalculatorOverride","_len16","_key16","_onAfterViewportColumnCalculatorOverride","_len17","_key17","_onModifyAutofillRange","_len18","_key18","_onAfterCreateCol","_len19","_key19","_onAfterRemoveCol","_len20","_key20","_onAfterCreateRow","_len21","_key21","_onAfterRemoveRow","_len22","_key22","_onAfterChange","_len23","_key23","_onBeforeDrawAreaBorders","_len24","_key24","_onAfterDrawSelection","_len25","_key25","_onBeforeRemoveCellClassNames","_len26","_key26","_onBeforeBeginEditing","_len27","_key27","_onModifyRowHeightByOverlayName","action","source","registerShortcuts","disablePlugin","clearCollections","unregisterShortcuts","render","updatePlugin","settings","generateFromSettings","ifChromeForceRepaint","rowsToRefresh","rowIndexesToRefresh","mergedCells","forEach","mergedCell","rowspan","push","Set","rowIndex","renderableRowIndex","getRenderableFromVisualIndex","view","_wt","wtOverlays","getOverlays","map","overlay","name","clone","wtTable","wtTableRef","rowToRefresh","getRow","style","background","replace","_registerTimeout","rowElement","validateSetting","setting","containsNegativeValues","NEGATIVE_VALUES_WARNING","isOutOfBounds","countRows","countCols","IS_OUT_OF_BOUNDS_WARNING","isSingleCell","IS_SINGLE_CELL","containsZeroSpan","ZERO_SPAN_WARNING","isArray","validSettings","filter","mergeCellInfo","nonOverlappingSettings","filterOverlappingMergeCells","populatedNulls","colspan","from","_createCellCoords","to","mergeRange","_createCellRange","c","setDataAtCell","undefined","pluginName","clear","canMergeRange","newMergedCellInfo","auto","mergeSelection","cellRange","getSelectedRangeLast","setDirection","isRtl","unmergeRange","selectCell","unmergeSelection","preventPopulation","topStart","getTopStartCorner","bottomEnd","getBottomEndCorner","mergeParent","clearedData","populationInfo","runHooks","j","clearedValue","getSourceDataAtCell","toPhysicalRow","toPhysicalColumn","setCellMeta","mergedCellAdded","populateFromArray","getWithinRange","currentCollection","remove","removeCellMeta","toggleMerge","mergedCellCoversWholeRange","merge","startRow","startColumn","endRow","endColumn","start","end","unmerge","shortcutManager","getShortcutManager","gridContext","getContext","addShortcut","keys","callback","range","isSingleHeader","runOnlyIf","event","altKey","group","removeShortcutsByGroup","modifyViewportRowStart","calc","nrOfColumns","rowMapper","visualStartRow","getVisualFromRenderableIndex","visualColumnIndex","mergeParentForViewportStart","renderableIndexAtMergeStart","getNearestNotHiddenIndex","modifyViewportRowEnd","visualEndRow","mergeParentForViewportEnd","mergeEnd","renderableIndexAtMergeEnd","modifyViewportColumnStart","nrOfRows","columnMapper","visualStartCol","visualRowIndex","modifyViewportColumnEnd","visualEndCol","translateMergedCellToRenderable","parentRow","parentColumn","firstNonHiddenRow","firstNonHiddenColumn","renderableRow","renderableColumn","isMultiple","selectionRange","topStartCoords","bottomEndCoords","delta","selectedRange","highlight","mergedParent","visualColumnIndexStart","visualColumnIndexEnd","nextColumn","notHiddenColumnIndex","countRenderableColumnsInRange","Math","max","visualRowIndexStart","visualRowIndexEnd","nextRow","notHiddenRowIndex","countRenderableRowsInRange","cloneRange","expandCloneRange","expand","expandByRange","getRange","getStartMostColumnIndex","getHorizontalDirection","getEndMostColumnIndex","getTopMostRowIndex","getVerticalDirection","getBottomMostRowIndex","getBottomStartCorner","selection","isSelectedByColumnHeader","isSelectedByRowHeader","assign","mergeRow","mergeColumn","defaultOptions","items","isCell","verticalDir","horizontalDir","focusCoords","normalize","setActiveNode","setPrevNodeAsActive","setNextNodeAsActive","rowEnd","colEnd","getPrevHorizontalNode","rowStart","colStart","getNextHorizontalNode","getPrevVerticalNode","getNextVerticalNode","coords","focusHighlight","getFocus","commit","isHeader","buildFocusOrder","cellProperties","copyable","drag","select","correctSelectionAreaSize","dragDirection","getDirection","dragArea","dragAreaOverlapsCollections","mergedCellsWithinSelectionArea","snapDragArea","count","shiftCollections","changes","recreateAfterDataPopulation","corners","className","mergedCellsWithinRange","getLastRow","getLastColumn","currentRow","currentColumn","cornersOfSelection","layerLevel","getSelectedMergedCellClassName","getSelectedMergedCellClassNameToRemove","initialValue","MouseEvent","mergeCell","getByRange","getLayerLevel","isEqual","height","overlayType","rowHeaders","firstColumn","lastColumn","getFirstRenderedVisibleColumn","getLastRenderedVisibleColumn","activeOverlay","getOverlayByName","getFirstRenderedColumn","getLastRenderedColumn","firstMergedCellInRow","viewportRange","maxRowspan","reduce","acc","_ref","rowspanCorrection","_ref2","_height","rowspanAfterCorrection","min","countNotHiddenFixedRowsTop","_sumCellsHeights","defaultHeight","wtSettings","getSettingPure","autoRowSizePlugin","getPlugin","isHidden","_autoRowSizePlugin$ge","getRowHeight"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/mergeCells/mergeCells.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { getStyle } from \"../../helpers/dom/element.mjs\";\nimport { isChrome } from \"../../helpers/browser.mjs\";\nimport { FocusOrder } from \"./focusOrder.mjs\";\nimport { createMergeCellRenderer } from \"./renderer.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport const PLUGIN_KEY = 'mergeCells';\nexport const PLUGIN_PRIORITY = 150;\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin MergeCells\n * @class MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   // enable plugin\n *   mergeCells={[\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *   ]}\n * />\n * ```\n * :::\n */\nvar _lastSelectedFocus = /*#__PURE__*/new WeakMap();\nvar _lastFocusDelta = /*#__PURE__*/new WeakMap();\nvar _focusOrder = /*#__PURE__*/new WeakMap();\nvar _cellRenderer = /*#__PURE__*/new WeakMap();\nvar _MergeCells_brand = /*#__PURE__*/new WeakSet();\nexport class MergeCells extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _MergeCells_brand);\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n    _defineProperty(this, \"mergedCellsCollection\", null);\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n    _defineProperty(this, \"autofillCalculations\", null);\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n    _defineProperty(this, \"selectionCalculations\", null);\n    /**\n     * The holder for the last selected focus coordinates. This allows keeping the correct coordinates in cases after the\n     * focus is moved out of the merged cell.\n     *\n     * @type {CellCoords}\n     */\n    _classPrivateFieldInitSpec(this, _lastSelectedFocus, null);\n    /**\n     * The last used transformation delta.\n     *\n     * @type {{ row: number, col: number }}\n     */\n    _classPrivateFieldInitSpec(this, _lastFocusDelta, {\n      row: 0,\n      col: 0\n    });\n    /**\n     * The module responsible for providing the correct focus order (vertical and horizontal) within a selection that\n     * contains merged cells.\n     *\n     * @type {FocusOrder}\n     */\n    _classPrivateFieldInitSpec(this, _focusOrder, new FocusOrder({\n      mergedCellsGetter: (row, column) => this.mergedCellsCollection.get(row, column),\n      rowIndexMapper: this.hot.rowIndexMapper,\n      columnIndexMapper: this.hot.columnIndexMapper\n    }));\n    /**\n     * The cell renderer responsible for rendering the merged cells.\n     *\n     * @type {{before: Function, after: Function}}\n     */\n    _classPrivateFieldInitSpec(this, _cellRenderer, createMergeCellRenderer(this));\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.mergedCellsCollection = new MergedCellsCollection(this);\n    this.autofillCalculations = new AutofillCalculations(this);\n    this.selectionCalculations = new SelectionCalculations(this);\n    this.addHook('afterInit', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterInit).call(_this, ...args);\n    });\n    this.addHook('modifyTransformFocus', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyTransformFocus).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyTransformStart).call(_this, ...args);\n    });\n    this.addHook('modifyTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyTransformEnd).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSelectionHighlightSet).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStart', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSetRangeStart).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStartOnly', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSetRangeStart).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionFocusSet', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeSelectionFocusSet).call(_this, ...args);\n    });\n    this.addHook('afterSelectionFocusSet', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterSelectionFocusSet).call(_this, ...args);\n    });\n    this.addHook('afterSelectionEnd', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterSelectionEnd).call(_this, ...args);\n    });\n    this.addHook('modifyGetCellCoords', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyGetCellCoords).call(_this, ...args);\n    });\n    this.addHook('afterIsMultipleSelection', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterIsMultipleSelection).call(_this, ...args);\n    });\n    this.addHook('afterRenderer', function () {\n      return _classPrivateFieldGet(_cellRenderer, _this).after(...arguments);\n    });\n    this.addHook('afterContextMenuDefaultOptions', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _addMergeActionsToContextMenu).call(_this, ...args);\n    });\n    this.addHook('afterGetCellMeta', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterGetCellMeta).call(_this, ...args);\n    });\n    this.addHook('afterViewportRowCalculatorOverride', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterViewportRowCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterViewportColumnCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('modifyAutofillRange', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyAutofillRange).call(_this, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterCreateCol).call(_this, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterRemoveCol).call(_this, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterCreateRow).call(_this, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterRemoveRow).call(_this, ...args);\n    });\n    this.addHook('afterChange', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterChange).call(_this, ...args);\n    });\n    this.addHook('beforeDrawBorders', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeDrawAreaBorders).call(_this, ...args);\n    });\n    this.addHook('afterDrawSelection', function () {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onAfterDrawSelection).call(_this, ...args);\n    });\n    this.addHook('beforeRemoveCellClassNames', function () {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeRemoveCellClassNames).call(_this, ...args);\n    });\n    this.addHook('beforeBeginEditing', function () {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onBeforeBeginEditing).call(_this, ...args);\n    });\n    this.addHook('modifyRowHeightByOverlayName', function () {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return _assertClassBrand(_MergeCells_brand, _this, _onModifyRowHeightByOverlayName).call(_this, ...args);\n    });\n    this.addHook('beforeUndoStackChange', (action, source) => {\n      if (source === 'MergeCells') {\n        return false;\n      }\n    });\n    this.registerShortcuts();\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearCollections();\n    this.unregisterShortcuts();\n    this.hot.render();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the\n   * following configuration options:\n   *  - [`mergeCells`](@/api/options.md#mergecells)\n   */\n  updatePlugin() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    this.disablePlugin();\n    this.enablePlugin();\n    this.generateFromSettings(settings);\n    super.updatePlugin();\n  }\n\n  /**\n   * If the browser is recognized as Chrome, force an additional repaint to prevent showing the effects of a Chrome bug.\n   *\n   * Issue described in https://github.com/handsontable/dev-handsontable/issues/521.\n   *\n   * @private\n   */\n  ifChromeForceRepaint() {\n    if (!isChrome()) {\n      return;\n    }\n    const rowsToRefresh = [];\n    let rowIndexesToRefresh = [];\n    this.mergedCellsCollection.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        rowspan\n      } = mergedCell;\n      for (let r = row + 1; r < row + rowspan; r++) {\n        rowIndexesToRefresh.push(r);\n      }\n    });\n\n    // Remove duplicates\n    rowIndexesToRefresh = [...new Set(rowIndexesToRefresh)];\n    rowIndexesToRefresh.forEach(rowIndex => {\n      const renderableRowIndex = this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);\n      this.hot.view._wt.wtOverlays.getOverlays(true).map(overlay => (overlay === null || overlay === void 0 ? void 0 : overlay.name) === 'master' ? overlay : overlay.clone.wtTable).forEach(wtTableRef => {\n        const rowToRefresh = wtTableRef.getRow(renderableRowIndex);\n        if (rowToRefresh) {\n          // Modify the TR's `background` property to later modify it asynchronously.\n          // The background color is getting modified only with the alpha, so the change should not be visible (and is\n          // covered by the TDs' background color).\n          rowToRefresh.style.background = getStyle(rowToRefresh, 'backgroundColor').replace(')', ', 0.99)');\n          rowsToRefresh.push(rowToRefresh);\n        }\n      });\n    });\n\n    // Asynchronously revert the TRs' `background` property to force a fresh repaint.\n    this.hot._registerTimeout(() => {\n      rowsToRefresh.forEach(rowElement => {\n        rowElement.style.background = getStyle(rowElement, 'backgroundColor').replace(', 0.99)', ')');\n      });\n    }, 1);\n  }\n\n  /**\n   * Validates a single setting object, represented by a single merged cell information object.\n   *\n   * @private\n   * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  validateSetting(setting) {\n    if (!setting) {\n      return false;\n    }\n    if (MergedCellCoords.containsNegativeValues(setting)) {\n      warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n      return false;\n    }\n    if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n      warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n      return false;\n    }\n    if (MergedCellCoords.isSingleCell(setting)) {\n      warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n      return false;\n    }\n    if (MergedCellCoords.containsZeroSpan(setting)) {\n      warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Generates the merged cells from the settings provided to the plugin.\n   *\n   * @private\n   * @param {Array|boolean} settings The settings provided to the plugin.\n   */\n  generateFromSettings(settings) {\n    if (!Array.isArray(settings)) {\n      return;\n    }\n    const validSettings = settings.filter(mergeCellInfo => this.validateSetting(mergeCellInfo));\n    const nonOverlappingSettings = this.mergedCellsCollection.filterOverlappingMergeCells(validSettings);\n    const populatedNulls = [];\n    nonOverlappingSettings.forEach(mergeCellInfo => {\n      const {\n        row,\n        col,\n        rowspan,\n        colspan\n      } = mergeCellInfo;\n      const from = this.hot._createCellCoords(row, col);\n      const to = this.hot._createCellCoords(row + rowspan - 1, col + colspan - 1);\n      const mergeRange = this.hot._createCellRange(from, from, to);\n\n      // Merging without data population.\n      this.mergeRange(mergeRange, true, true);\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          // Not resetting a cell representing a merge area's value.\n          if (r !== row || c !== col) {\n            populatedNulls.push([r, c, null]);\n          }\n        }\n      }\n    });\n\n    // There are no merged cells. Thus, no data population is needed.\n    if (populatedNulls.length === 0) {\n      return;\n    }\n\n    // TODO: Change the `source` argument to a more meaningful value, e.g. `${this.pluginName}.clearCells`.\n    this.hot.setDataAtCell(populatedNulls, undefined, undefined, this.pluginName);\n  }\n\n  /**\n   * Clears the merged cells from the merged cell container.\n   */\n  clearCollections() {\n    this.mergedCellsCollection.clear();\n  }\n\n  /**\n   * Returns `true` if a range is mergeable.\n   *\n   * @private\n   * @param {object} newMergedCellInfo Merged cell information object to test.\n   * @param {boolean} [auto=false] `true` if triggered at initialization.\n   * @returns {boolean}\n   */\n  canMergeRange(newMergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return auto ? true : this.validateSetting(newMergedCellInfo);\n  }\n\n  /**\n   * Merges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  mergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    cellRange.setDirection(this.hot.isRtl() ? 'NE-SW' : 'NW-SE');\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.mergeRange(cellRange);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  unmergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Merges cells in the provided cell range.\n   *\n   * @private\n   * @param {CellRange} cellRange Cell range to merge.\n   * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\n   * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end,\n   *   but rather return its arguments.\n   * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to\n   *   true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  mergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const topStart = cellRange.getTopStartCorner();\n    const bottomEnd = cellRange.getBottomEndCorner();\n    const mergeParent = {\n      row: topStart.row,\n      col: topStart.col,\n      rowspan: bottomEnd.row - topStart.row + 1,\n      colspan: bottomEnd.col - topStart.col + 1\n    };\n    const clearedData = [];\n    let populationInfo = null;\n    if (!this.canMergeRange(mergeParent, auto)) {\n      return false;\n    }\n    this.hot.runHooks('beforeMergeCells', cellRange, auto);\n    rangeEach(0, mergeParent.rowspan - 1, i => {\n      rangeEach(0, mergeParent.colspan - 1, j => {\n        let clearedValue = null;\n        if (!clearedData[i]) {\n          clearedData[i] = [];\n        }\n        if (i === 0 && j === 0) {\n          clearedValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), this.hot.toPhysicalColumn(mergeParent.col));\n        } else {\n          this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n        }\n        clearedData[i][j] = clearedValue;\n      });\n    });\n    this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n    const mergedCellAdded = this.mergedCellsCollection.add(mergeParent, auto);\n    if (mergedCellAdded) {\n      if (preventPopulation) {\n        populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n      } else {\n        // TODO: Change the `source` argument to a more meaningful value, e.g. `${this.pluginName}.clearCells`.\n        this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, undefined, undefined, this.pluginName);\n      }\n      if (!auto) {\n        this.ifChromeForceRepaint();\n      }\n      this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n      return populationInfo;\n    }\n    return true;\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n   *\n   * @private\n   * @param {CellRange} cellRange Selection cell range.\n   * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n   *\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n    if (mergedCells.length === 0) {\n      return;\n    }\n    this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n    arrayEach(mergedCells, currentCollection => {\n      this.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n      rangeEach(0, currentCollection.rowspan - 1, i => {\n        rangeEach(0, currentCollection.colspan - 1, j => {\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'copyable');\n        });\n      });\n      this.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n    });\n    this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    this.hot.render();\n  }\n\n  /**\n   * Merges or unmerges, based on the cell range provided as `cellRange`.\n   *\n   * @private\n   * @param {CellRange} cellRange The cell range to merge or unmerged.\n   */\n  toggleMerge(cellRange) {\n    const mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n    const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n    if (mergedCellCoversWholeRange) {\n      this.unmergeRange(cellRange);\n    } else {\n      this.mergeSelection(cellRange);\n    }\n  }\n\n  /**\n   * Merges the specified range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  merge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.mergeRange(this.hot._createCellRange(start, start, end));\n  }\n\n  /**\n   * Unmerges the merged cell in the provided range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmerge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.unmergeRange(this.hot._createCellRange(start, start, end));\n  }\n  /**\n   * Register shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.addShortcut({\n      keys: [['Control', 'm']],\n      callback: () => {\n        const range = this.hot.getSelectedRangeLast();\n        if (range && !range.isSingleHeader()) {\n          this.toggleMerge(range);\n          this.hot.render();\n        }\n      },\n      runOnlyIf: event => !event.altKey,\n      // right ALT in some systems triggers ALT+CTRL\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n\n  /**\n   * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection`\n   * hook callback.\n   *\n   * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\n   * @returns {boolean}\n   */\n\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowStart(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startRow) {\n          // We extend viewport when some rows have been merged.\n          calc.startRow = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowEnd(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n        const renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endRow) {\n          // We extend the viewport when some rows have been merged.\n          calc.endRow = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   * `afterViewportColumnCalculatorOverride` hook callback.\n   *\n   * @param {object} calc The column calculator object.\n   */\n\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnStart(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startColumn) {\n          // We extend viewport when some columns have been merged.\n          calc.startColumn = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnEnd(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n        const renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endColumn) {\n          // We extend the viewport when some columns have been merged.\n          calc.endColumn = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   * Translates merged cell coordinates to renderable indexes.\n   *\n   * @private\n   * @param {number} parentRow Visual row index.\n   * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\n   *                         to calculate renderable index which points to the most bottom\n   *                         index position. Pass rowspan as `0` to calculate the most top\n   *                         index position.\n   * @param {number} parentColumn Visual column index.\n   * @param {number} colspan Colspan which describes shift which will be applied to parent column\n   *                         to calculate renderable index which points to the most right\n   *                         index position. Pass colspan as `0` to calculate the most left\n   *                         index position.\n   * @returns {number[]}\n   */\n  translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: columnMapper\n    } = this.hot;\n    let firstNonHiddenRow;\n    let firstNonHiddenColumn;\n    if (rowspan === 0) {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);\n    } else {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);\n    }\n    if (colspan === 0) {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);\n    } else {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);\n    }\n    const renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n    const renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n    return [renderableRow, renderableColumn];\n  }\n\n  /**\n   * The `modifyAutofillRange` hook callback.\n   *\n   * @param {Array} drag The drag area coordinates.\n   * @param {Array} select The selection information.\n   * @returns {Array} The new drag area.\n   */\n}\nfunction _onAfterInit() {\n  this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n  this.hot.render();\n}\nfunction _onAfterIsMultipleSelection(isMultiple) {\n  if (isMultiple) {\n    const mergedCells = this.mergedCellsCollection.mergedCells;\n    const selectionRange = this.hot.getSelectedRangeLast();\n    const topStartCoords = selectionRange.getTopStartCorner();\n    const bottomEndCoords = selectionRange.getBottomEndCorner();\n    for (let group = 0; group < mergedCells.length; group += 1) {\n      if (topStartCoords.row === mergedCells[group].row && topStartCoords.col === mergedCells[group].col && bottomEndCoords.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && bottomEndCoords.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n        return false;\n      }\n    }\n  }\n  return isMultiple;\n}\n/**\n * `modifyTransformFocus` hook callback.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformFocus(delta) {\n  _classPrivateFieldGet(_lastFocusDelta, this).row = delta.row;\n  _classPrivateFieldGet(_lastFocusDelta, this).col = delta.col;\n}\n/**\n * `modifyTransformStart` hook callback.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformStart(delta) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const {\n    highlight\n  } = selectedRange;\n  const {\n    columnIndexMapper,\n    rowIndexMapper\n  } = this.hot;\n  if (_classPrivateFieldGet(_lastSelectedFocus, this)) {\n    if (rowIndexMapper.getRenderableFromVisualIndex(_classPrivateFieldGet(_lastSelectedFocus, this).row) !== null) {\n      highlight.row = _classPrivateFieldGet(_lastSelectedFocus, this).row;\n    }\n    if (columnIndexMapper.getRenderableFromVisualIndex(_classPrivateFieldGet(_lastSelectedFocus, this).col) !== null) {\n      highlight.col = _classPrivateFieldGet(_lastSelectedFocus, this).col;\n    }\n    _classPrivateFieldSet(_lastSelectedFocus, this, null);\n  }\n  const mergedParent = this.mergedCellsCollection.get(highlight.row, highlight.col);\n  if (!mergedParent) {\n    return;\n  }\n  const visualColumnIndexStart = mergedParent.col;\n  const visualColumnIndexEnd = mergedParent.col + mergedParent.colspan - 1;\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n  const visualRowIndexStart = mergedParent.row;\n  const visualRowIndexEnd = mergedParent.row + mergedParent.rowspan - 1;\n  if (delta.row < 0) {\n    const nextRow = highlight.row >= visualRowIndexStart && highlight.row <= visualRowIndexEnd ? visualRowIndexStart - 1 : visualRowIndexEnd;\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, -1);\n    if (notHiddenRowIndex === null) {\n      // There are no visible rows anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous column (if autoWrapCol is enabled).\n      delta.row = -this.hot.view.countRenderableRowsInRange(0, highlight.row);\n    } else {\n      delta.row = -Math.max(this.hot.view.countRenderableRowsInRange(notHiddenRowIndex, highlight.row) - 1, 1);\n    }\n  } else if (delta.row > 0) {\n    const nextRow = highlight.row >= visualRowIndexStart && highlight.row <= visualRowIndexEnd ? visualRowIndexEnd + 1 : visualRowIndexStart;\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, 1);\n    if (notHiddenRowIndex === null) {\n      // There are no visible rows anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next column (if autoWrapCol is enabled).\n      delta.row = this.hot.view.countRenderableRowsInRange(highlight.row, this.hot.countRows());\n    } else {\n      delta.row = Math.max(this.hot.view.countRenderableRowsInRange(highlight.row, notHiddenRowIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook allows to modify the delta transformation object necessary for correct selection end transformations.\n * The logic here handles \"jumping over\" merged merged cells, while selecting.\n *\n * @param {{ row: number, col: number }} delta The transformation delta.\n */\nfunction _onModifyTransformEnd(delta) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const cloneRange = selectedRange.clone();\n  const {\n    to\n  } = selectedRange;\n  const {\n    columnIndexMapper,\n    rowIndexMapper\n  } = this.hot;\n  const expandCloneRange = (row, col) => {\n    cloneRange.expand(this.hot._createCellCoords(row, col));\n    for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n      cloneRange.expandByRange(this.mergedCellsCollection.mergedCells[i].getRange());\n    }\n  };\n  if (delta.col < 0) {\n    let nextColumn = this.mergedCellsCollection.getStartMostColumnIndex(selectedRange, to.col) + delta.col;\n    expandCloneRange(to.row, nextColumn);\n    if (selectedRange.getHorizontalDirection() === 'E-W' && cloneRange.getHorizontalDirection() === 'E-W') {\n      nextColumn = cloneRange.getTopStartCorner().col;\n    }\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex !== null) {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, to.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    let nextColumn = this.mergedCellsCollection.getEndMostColumnIndex(selectedRange, to.col) + delta.col;\n    expandCloneRange(to.row, nextColumn);\n    if (selectedRange.getHorizontalDirection() === 'W-E' && cloneRange.getHorizontalDirection() === 'W-E') {\n      nextColumn = cloneRange.getBottomEndCorner().col;\n    }\n    const notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex !== null) {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(to.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n  if (delta.row < 0) {\n    let nextRow = this.mergedCellsCollection.getTopMostRowIndex(selectedRange, to.row) + delta.row;\n    expandCloneRange(nextRow, to.col);\n    if (selectedRange.getVerticalDirection() === 'S-N' && cloneRange.getVerticalDirection() === 'S-N') {\n      nextRow = cloneRange.getTopStartCorner().row;\n    }\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, 1);\n    if (notHiddenRowIndex !== null) {\n      delta.row = -Math.max(this.hot.view.countRenderableRowsInRange(notHiddenRowIndex, to.row) - 1, 1);\n    }\n  } else if (delta.row > 0) {\n    let nextRow = this.mergedCellsCollection.getBottomMostRowIndex(selectedRange, to.row) + delta.row;\n    expandCloneRange(nextRow, to.col);\n    if (selectedRange.getVerticalDirection() === 'N-S' && cloneRange.getVerticalDirection() === 'N-S') {\n      nextRow = cloneRange.getBottomStartCorner().row;\n    }\n    const notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(nextRow, -1);\n    if (notHiddenRowIndex !== null) {\n      delta.row = Math.max(this.hot.view.countRenderableRowsInRange(to.row, notHiddenRowIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook corrects the range (before drawing it) after the selection was made on the merged cells.\n * It expands the range to cover the entire area of the selected merged cells.\n */\nfunction _onBeforeSelectionHighlightSet() {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const {\n    highlight\n  } = selectedRange;\n  if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n    _classPrivateFieldSet(_lastSelectedFocus, this, highlight.clone());\n    return;\n  }\n  for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n    selectedRange.expandByRange(this.mergedCellsCollection.mergedCells[i].getRange(), false);\n  }\n  // TODO: This is a workaround for an issue with the selection not being extended properly.\n  // In some cases when the merge cells are defined in random order the selection is not\n  // extended in that way that it covers all overlapped merge cells.\n  for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n    selectedRange.expandByRange(this.mergedCellsCollection.mergedCells[i].getRange(), false);\n  }\n  const mergedParent = this.mergedCellsCollection.get(highlight.row, highlight.col);\n  _classPrivateFieldSet(_lastSelectedFocus, this, highlight.clone());\n  if (mergedParent) {\n    highlight.assign(mergedParent);\n  }\n}\n/**\n * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n *\n * @param {number} row Row index.\n * @param {number} column Visual column index.\n * @returns {Array|undefined} Visual coordinates of the merge.\n */\nfunction _onModifyGetCellCoords(row, column) {\n  if (row < 0 || column < 0) {\n    return;\n  }\n  const mergeParent = this.mergedCellsCollection.get(row, column);\n  if (!mergeParent) {\n    return;\n  }\n  const {\n    row: mergeRow,\n    col: mergeColumn,\n    colspan,\n    rowspan\n  } = mergeParent;\n  return [\n  // Most top-left merged cell coords.\n  mergeRow, mergeColumn,\n  // Most bottom-right merged cell coords.\n  mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n}\n/**\n * `afterContextMenuDefaultOptions` hook callback.\n *\n * @param {object} defaultOptions The default context menu options.\n */\nfunction _addMergeActionsToContextMenu(defaultOptions) {\n  defaultOptions.items.push({\n    name: '---------'\n  }, toggleMergeItem(this));\n}\n/**\n * Clears the last selected coordinates before setting a new selection range.\n */\nfunction _onBeforeSetRangeStart() {\n  _classPrivateFieldSet(_lastSelectedFocus, this, null);\n}\n/**\n * Detects if the last selected cell was a header cell if so update the order list active node for further\n * computations.\n */\nfunction _onBeforeSelectionFocusSet() {\n  if (_classPrivateFieldGet(_lastSelectedFocus, this).isCell()) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const verticalDir = selectedRange.getVerticalDirection();\n  const horizontalDir = selectedRange.getHorizontalDirection();\n  const focusCoords = _classPrivateFieldGet(_lastSelectedFocus, this).clone().normalize();\n  _classPrivateFieldGet(_focusOrder, this).setActiveNode(focusCoords.row, focusCoords.col);\n  if (_classPrivateFieldGet(_lastFocusDelta, this).row > 0 || _classPrivateFieldGet(_lastFocusDelta, this).col > 0) {\n    _classPrivateFieldGet(_focusOrder, this).setPrevNodeAsActive();\n  } else if (horizontalDir === 'E-W' && _classPrivateFieldGet(_lastFocusDelta, this).col < 0 || verticalDir === 'S-N' && _classPrivateFieldGet(_lastFocusDelta, this).row < 0) {\n    _classPrivateFieldGet(_focusOrder, this).setNextNodeAsActive();\n  }\n}\n/**\n * Changes the focus selection to the next or previous cell or merged cell position.\n *\n * @param {number} row The visual row index.\n * @param {number} column The visual column index.\n */\nfunction _onAfterSelectionFocusSet(row, column) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const {\n    columnIndexMapper,\n    rowIndexMapper\n  } = this.hot;\n  let notHiddenRowIndex = null;\n  let notHiddenColumnIndex = null;\n  if (_classPrivateFieldGet(_lastFocusDelta, this).col < 0) {\n    const {\n      rowEnd,\n      colEnd\n    } = _classPrivateFieldGet(_focusOrder, this).getPrevHorizontalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colEnd, -1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowEnd, -1);\n  } else if (_classPrivateFieldGet(_lastFocusDelta, this).col > 0) {\n    const {\n      rowStart,\n      colStart\n    } = _classPrivateFieldGet(_focusOrder, this).getNextHorizontalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colStart, 1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowStart, 1);\n  } else if (_classPrivateFieldGet(_lastFocusDelta, this).row < 0) {\n    const {\n      rowEnd,\n      colEnd\n    } = _classPrivateFieldGet(_focusOrder, this).getPrevVerticalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colEnd, -1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowEnd, -1);\n  } else if (_classPrivateFieldGet(_lastFocusDelta, this).row > 0) {\n    const {\n      rowStart,\n      colStart\n    } = _classPrivateFieldGet(_focusOrder, this).getNextVerticalNode();\n    notHiddenColumnIndex = columnIndexMapper.getNearestNotHiddenIndex(colStart, 1);\n    notHiddenRowIndex = rowIndexMapper.getNearestNotHiddenIndex(rowStart, 1);\n  }\n  if (notHiddenRowIndex !== null || notHiddenColumnIndex !== null) {\n    const coords = this.hot._createCellCoords(notHiddenRowIndex, notHiddenColumnIndex);\n    const mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n    row = coords.row;\n    column = coords.col;\n    if (mergeParent) {\n      selectedRange.highlight.assign({\n        row: this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1),\n        col: this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1)\n      });\n    } else {\n      selectedRange.highlight.assign(coords);\n    }\n    focusHighlight.clear();\n    focusHighlight.add(coords).commit();\n  }\n  _classPrivateFieldGet(_focusOrder, this).setActiveNode(row, column);\n  _classPrivateFieldSet(_lastFocusDelta, this, {\n    row: 0,\n    col: 0\n  });\n}\n/**\n * Creates the horizontal and vertical cells order matrix (linked lists) for focused cell.\n */\nfunction _onAfterSelectionEnd() {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection.isHeader()) {\n    _classPrivateFieldGet(_focusOrder, this).buildFocusOrder(this.hot.getSelectedRangeLast());\n  }\n}\n/**\n * The `afterGetCellMeta` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} col Column index.\n * @param {object} cellProperties The cell properties object.\n */\nfunction _onAfterGetCellMeta(row, col, cellProperties) {\n  const mergeParent = this.mergedCellsCollection.get(row, col);\n  if (mergeParent) {\n    if (mergeParent.row !== row || mergeParent.col !== col) {\n      cellProperties.copyable = false;\n    } else {\n      cellProperties.rowspan = mergeParent.rowspan;\n      cellProperties.colspan = mergeParent.colspan;\n    }\n  }\n}\n/**\n * `afterViewportRowCalculatorOverride` hook callback.\n *\n * @param {object} calc The row calculator object.\n */\nfunction _onAfterViewportRowCalculatorOverride(calc) {\n  const nrOfColumns = this.hot.countCols();\n  this.modifyViewportRowStart(calc, nrOfColumns);\n  this.modifyViewportRowEnd(calc, nrOfColumns);\n}\nfunction _onAfterViewportColumnCalculatorOverride(calc) {\n  const nrOfRows = this.hot.countRows();\n  this.modifyViewportColumnStart(calc, nrOfRows);\n  this.modifyViewportColumnEnd(calc, nrOfRows);\n}\nfunction _onModifyAutofillRange(drag, select) {\n  this.autofillCalculations.correctSelectionAreaSize(select);\n  const dragDirection = this.autofillCalculations.getDirection(select, drag);\n  let dragArea = drag;\n  if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n    dragArea = select;\n    return dragArea;\n  }\n  const from = this.hot._createCellCoords(select[0], select[1]);\n  const to = this.hot._createCellCoords(select[2], select[3]);\n  const range = this.hot._createCellRange(from, from, to);\n  const mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange(range);\n  if (mergedCellsWithinSelectionArea.length === 0) {\n    return dragArea;\n  }\n  dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n  return dragArea;\n}\n/**\n * `afterCreateCol` hook callback.\n *\n * @param {number} column Column index.\n * @param {number} count Number of created columns.\n */\nfunction _onAfterCreateCol(column, count) {\n  this.mergedCellsCollection.shiftCollections('right', column, count);\n}\n/**\n * `afterRemoveCol` hook callback.\n *\n * @param {number} column Column index.\n * @param {number} count Number of removed columns.\n */\nfunction _onAfterRemoveCol(column, count) {\n  this.mergedCellsCollection.shiftCollections('left', column, count);\n}\n/**\n * `afterCreateRow` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} count Number of created rows.\n * @param {string} source Source of change.\n */\nfunction _onAfterCreateRow(row, count, source) {\n  if (source === 'auto') {\n    return;\n  }\n  this.mergedCellsCollection.shiftCollections('down', row, count);\n}\n/**\n * `afterRemoveRow` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} count Number of removed rows.\n */\nfunction _onAfterRemoveRow(row, count) {\n  this.mergedCellsCollection.shiftCollections('up', row, count);\n}\n/**\n * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n *\n * @param {Array} changes The changes array.\n * @param {string} source Determines the source of the change.\n */\nfunction _onAfterChange(changes, source) {\n  if (source !== 'Autofill.fill') {\n    return;\n  }\n  this.autofillCalculations.recreateAfterDataPopulation(changes);\n}\n/**\n * `beforeDrawAreaBorders` hook callback.\n *\n * @param {Array} corners Visual coordinates of the area corners.\n * @param {string} className Class name for the area.\n */\nfunction _onBeforeDrawAreaBorders(corners, className) {\n  if (className && className === 'area') {\n    const selectedRange = this.hot.getSelectedRangeLast();\n    const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n    arrayEach(mergedCellsWithinRange, mergedCell => {\n      if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {\n        corners[2] = mergedCell.row;\n        corners[3] = mergedCell.col;\n      }\n    });\n  }\n}\n/**\n * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n *\n * @param {number} currentRow Visual row index of the currently processed cell.\n * @param {number} currentColumn Visual column index of the currently cell.\n * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow,\n *   endColumn]`.\n * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently\n *   processed cell.\n */\nfunction _onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n  // Nothing's selected (hook might be triggered by the custom borders)\n  if (!cornersOfSelection) {\n    return;\n  }\n  return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n}\n/**\n * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n *\n * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from\n *   all the cells in the table.\n */\nfunction _onBeforeRemoveCellClassNames() {\n  return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n}\n/**\n * Allows to prevent opening the editor while more than one merged cell is selected.\n *\n * @param {number} row Visual row index of the edited cell.\n * @param {number} column Visual column index of the edited cell.\n * @param {string | null} initialValue The initial editor value.\n * @param {MouseEvent | KeyboardEvent} event The event which was responsible for opening the editor.\n * @returns {boolean | undefined}\n */\nfunction _onBeforeBeginEditing(row, column, initialValue, event) {\n  if (!(event instanceof MouseEvent)) {\n    return;\n  }\n  const selection = this.hot.getSelectedRangeLast();\n  const mergeCell = this.mergedCellsCollection.getByRange(selection);\n  if (!mergeCell) {\n    return;\n  }\n  const from = this.hot._createCellCoords(mergeCell.row, mergeCell.col);\n  const to = this.hot._createCellCoords(mergeCell.row + mergeCell.rowspan - 1, mergeCell.col + mergeCell.colspan - 1);\n  return this.hot.selection.getLayerLevel() === 0 && selection.isEqual(this.hot._createCellRange(from, from, to));\n}\n/**\n * Hook used to modify the row height depends on the merged cells in the row.\n *\n * @param {number} height The row height value provided by the Core.\n * @param {number} row The visual row index.\n * @param {string} overlayType The overlay type that is currently rendered.\n * @returns {number}\n */\nfunction _onModifyRowHeightByOverlayName(height, row, overlayType) {\n  if (this.hot.getSettings().rowHeaders ||\n  // merged cells do not work with the bottom overlays\n  overlayType === 'bottom' || overlayType === 'bottom_inline_start_corner') {\n    return height;\n  }\n  let firstColumn;\n  let lastColumn;\n  if (overlayType === 'master') {\n    firstColumn = this.hot.view.getFirstRenderedVisibleColumn();\n    lastColumn = this.hot.view.getLastRenderedVisibleColumn();\n  } else {\n    const activeOverlay = this.hot.view.getOverlayByName(overlayType);\n    firstColumn = this.hot.columnIndexMapper.getVisualFromRenderableIndex(activeOverlay.clone.wtTable.getFirstRenderedColumn());\n    lastColumn = this.hot.columnIndexMapper.getVisualFromRenderableIndex(activeOverlay.clone.wtTable.getLastRenderedColumn());\n  }\n  const firstMergedCellInRow = this.mergedCellsCollection.get(row, firstColumn);\n  if (!firstMergedCellInRow) {\n    return height;\n  }\n  const from = this.hot._createCellCoords(row, firstColumn);\n  const to = this.hot._createCellCoords(row, lastColumn);\n  const viewportRange = this.hot._createCellRange(from, from, to);\n  const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(viewportRange);\n  const maxRowspan = mergedCellsWithinRange.reduce((acc, _ref) => {\n    let {\n      rowspan\n    } = _ref;\n    return Math.max(acc, rowspan);\n  }, 1);\n  let rowspanCorrection = 0;\n  if (mergedCellsWithinRange.length > 1 && mergedCellsWithinRange[0].rowspan < maxRowspan) {\n    rowspanCorrection = maxRowspan - mergedCellsWithinRange[0].rowspan;\n  }\n  mergedCellsWithinRange.forEach(_ref2 => {\n    var _height;\n    let {\n      rowspan\n    } = _ref2;\n    let rowspanAfterCorrection = 0;\n    if (overlayType === 'top' || overlayType === 'top_inline_start_corner') {\n      rowspanAfterCorrection = Math.min(maxRowspan, this.hot.view.countNotHiddenFixedRowsTop() - row);\n    } else {\n      rowspanAfterCorrection = rowspan - rowspanCorrection;\n    }\n    height = Math.max((_height = height) !== null && _height !== void 0 ? _height : 0, _assertClassBrand(_MergeCells_brand, this, _sumCellsHeights).call(this, row, rowspanAfterCorrection));\n  });\n  return height;\n}\n/**\n * Sums the heights of the all cells that the merge cell consists of.\n *\n * @param {number} row The visual row index of the merged cell.\n * @param {number} rowspan The rowspan value of the merged cell.\n * @returns {number}\n */\nfunction _sumCellsHeights(row, rowspan) {\n  const defaultHeight = this.hot.view._wt.wtSettings.getSettingPure('defaultRowHeight');\n  const autoRowSizePlugin = this.hot.getPlugin('autoRowSize');\n  let height = 0;\n  for (let i = row; i < row + rowspan; i++) {\n    if (!this.hot.rowIndexMapper.isHidden(i)) {\n      var _autoRowSizePlugin$ge;\n      height += (_autoRowSizePlugin$ge = autoRowSizePlugin === null || autoRowSizePlugin === void 0 ? void 0 : autoRowSizePlugin.getRowHeight(i)) !== null && _autoRowSizePlugin$ge !== void 0 ? _autoRowSizePlugin$ge : defaultHeight;\n    }\n  }\n  return height;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}