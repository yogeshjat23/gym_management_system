{"ast":null,"code":"import { CellRange } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { arrayEach, arrayReduce } from \"./../helpers/array.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nexport const SELECTION_TYPE_UNRECOGNIZED = 0;\nexport const SELECTION_TYPE_EMPTY = 1;\nexport const SELECTION_TYPE_ARRAY = 2;\nexport const SELECTION_TYPE_OBJECT = 3;\nexport const SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nconst ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];\nconst rootCall = Symbol('root');\nconst childCall = Symbol('child');\n\n/**\n * Detect selection schema structure.\n *\n * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by\n * `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`\n * and `hot.getSelectedRangeLast()` methods.\n * @param {symbol} _callSymbol The symbol object which indicates source of the helper invocation.\n * @returns {number} Returns a number that specifies the type of detected selection schema. If selection schema type\n * is unrecognized than it returns `0`.\n */\nexport function detectSelectionType(selectionRanges) {\n  let _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;\n  if (_callSymbol !== rootCall && _callSymbol !== childCall) {\n    throw new Error('The second argument is used internally only and cannot be overwritten.');\n  }\n  const isArray = Array.isArray(selectionRanges);\n  const isRootCall = _callSymbol === rootCall;\n  let result = SELECTION_TYPE_UNRECOGNIZED;\n  if (isArray) {\n    const firstItem = selectionRanges[0];\n    if (selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } else if (isRootCall && firstItem instanceof CellRange) {\n      result = SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, childCall);\n    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {\n      const isArrayType = !selectionRanges.some((value, index) => !ARRAY_TYPE_PATTERN[index].includes(typeof value));\n      if (isArrayType) {\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Factory function designed for normalization data schema from different data structures of the selection ranges.\n *\n * @param {number} type Selection type which will be processed.\n * @param {object} options The normalization options.\n * @param {function(number, number): CellCoords} options.createCellCoords The factory function that returns an instance of the `CellCoords` class.\n * @param {function(CellCoords, CellCoords, CellCoords): CellRange} options.createCellRange The factory function that returns an instance of the `CellRange` class.\n * @param {boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the\n *                                                selected cells won't be changed. Otherwise, the selection will be\n *                                                normalized to values starting from top-left to bottom-right.\n * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column\n *                                       defined as props should be normalized to the numeric values.\n * @returns {number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).\n */\nexport function normalizeSelectionFactory(type) {\n  let {\n    createCellCoords,\n    createCellRange,\n    keepDirection = false,\n    propToCol\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!SELECTION_TYPES.includes(type)) {\n    throw new Error('Unsupported selection ranges schema type was provided.');\n  }\n  return function (selection) {\n    const isObjectType = type === SELECTION_TYPE_OBJECT;\n    let rowStart = isObjectType ? selection.from.row : selection[0];\n    let columnStart = isObjectType ? selection.from.col : selection[1];\n    let rowEnd = isObjectType ? selection.to.row : selection[2];\n    let columnEnd = isObjectType ? selection.to.col : selection[3];\n    if (typeof propToCol === 'function') {\n      if (typeof columnStart === 'string') {\n        columnStart = propToCol(columnStart);\n      }\n      if (typeof columnEnd === 'string') {\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n    if (isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n    if (isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n    if (!keepDirection) {\n      const origRowStart = rowStart;\n      const origColumnStart = columnStart;\n      const origRowEnd = rowEnd;\n      const origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n      rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = Math.max(origColumnStart, origColumnEnd);\n    }\n    const from = createCellCoords(rowStart, columnStart);\n    const to = createCellCoords(rowEnd, columnEnd);\n    return createCellRange(from, from, to);\n  };\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Core} hotInstance The Handsontable instance.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToColumnDistance(hotInstance) {\n  const selectionType = detectSelectionType(hotInstance.getSelected());\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n    createCellCoords: hotInstance._createCellCoords.bind(hotInstance),\n    createCellRange: hotInstance._createCellRange.bind(hotInstance)\n  });\n  const unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(hotInstance.getSelected(), selection => {\n    const {\n      from,\n      to\n    } = selectionSchemaNormalizer(selection);\n    const columnNonHeaderStart = Math.max(from.col, 0);\n    const amount = to.col - columnNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), (_, i) => columnNonHeaderStart + i), index => {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);\n  const normalizedColumnRanges = arrayReduce(orderedIndexes, (acc, visualColumnIndex, index, array) => {\n    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([visualColumnIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedColumnRanges;\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Core} hotInstance The Handsontable instance.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToRowDistance(hotInstance) {\n  const selectionType = detectSelectionType(hotInstance.getSelected());\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n    createCellCoords: hotInstance._createCellCoords.bind(hotInstance),\n    createCellRange: hotInstance._createCellRange.bind(hotInstance)\n  });\n  const unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(hotInstance.getSelected(), selection => {\n    const {\n      from,\n      to\n    } = selectionSchemaNormalizer(selection);\n    const rowNonHeaderStart = Math.max(from.row, 0);\n    const amount = to.row - rowNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), (_, i) => rowNonHeaderStart + i), index => {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);\n  const normalizedRowRanges = arrayReduce(orderedIndexes, (acc, rowIndex, index, array) => {\n    if (index !== 0 && rowIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedRowRanges;\n}","map":{"version":3,"names":["CellRange","arrayEach","arrayReduce","isUndefined","SELECTION_TYPE_UNRECOGNIZED","SELECTION_TYPE_EMPTY","SELECTION_TYPE_ARRAY","SELECTION_TYPE_OBJECT","SELECTION_TYPES","ARRAY_TYPE_PATTERN","rootCall","Symbol","childCall","detectSelectionType","selectionRanges","_callSymbol","arguments","length","undefined","Error","isArray","Array","isRootCall","result","firstItem","isArrayType","some","value","index","includes","normalizeSelectionFactory","type","createCellCoords","createCellRange","keepDirection","propToCol","selection","isObjectType","rowStart","from","row","columnStart","col","rowEnd","to","columnEnd","origRowStart","origColumnStart","origRowEnd","origColumnEnd","Math","min","max","transformSelectionToColumnDistance","hotInstance","selectionType","getSelected","selectionSchemaNormalizer","_createCellCoords","bind","_createCellRange","unorderedIndexes","Set","columnNonHeaderStart","amount","_","i","has","add","orderedIndexes","sort","a","b","normalizedColumnRanges","acc","visualColumnIndex","array","push","transformSelectionToRowDistance","rowNonHeaderStart","normalizedRowRanges","rowIndex"],"sources":["D:/gym-project/frontend/node_modules/handsontable/selection/utils.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { CellRange } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { arrayEach, arrayReduce } from \"./../helpers/array.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nexport const SELECTION_TYPE_UNRECOGNIZED = 0;\nexport const SELECTION_TYPE_EMPTY = 1;\nexport const SELECTION_TYPE_ARRAY = 2;\nexport const SELECTION_TYPE_OBJECT = 3;\nexport const SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nconst ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];\nconst rootCall = Symbol('root');\nconst childCall = Symbol('child');\n\n/**\n * Detect selection schema structure.\n *\n * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by\n * `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`\n * and `hot.getSelectedRangeLast()` methods.\n * @param {symbol} _callSymbol The symbol object which indicates source of the helper invocation.\n * @returns {number} Returns a number that specifies the type of detected selection schema. If selection schema type\n * is unrecognized than it returns `0`.\n */\nexport function detectSelectionType(selectionRanges) {\n  let _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;\n  if (_callSymbol !== rootCall && _callSymbol !== childCall) {\n    throw new Error('The second argument is used internally only and cannot be overwritten.');\n  }\n  const isArray = Array.isArray(selectionRanges);\n  const isRootCall = _callSymbol === rootCall;\n  let result = SELECTION_TYPE_UNRECOGNIZED;\n  if (isArray) {\n    const firstItem = selectionRanges[0];\n    if (selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } else if (isRootCall && firstItem instanceof CellRange) {\n      result = SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, childCall);\n    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {\n      const isArrayType = !selectionRanges.some((value, index) => !ARRAY_TYPE_PATTERN[index].includes(typeof value));\n      if (isArrayType) {\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Factory function designed for normalization data schema from different data structures of the selection ranges.\n *\n * @param {number} type Selection type which will be processed.\n * @param {object} options The normalization options.\n * @param {function(number, number): CellCoords} options.createCellCoords The factory function that returns an instance of the `CellCoords` class.\n * @param {function(CellCoords, CellCoords, CellCoords): CellRange} options.createCellRange The factory function that returns an instance of the `CellRange` class.\n * @param {boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the\n *                                                selected cells won't be changed. Otherwise, the selection will be\n *                                                normalized to values starting from top-left to bottom-right.\n * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column\n *                                       defined as props should be normalized to the numeric values.\n * @returns {number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).\n */\nexport function normalizeSelectionFactory(type) {\n  let {\n    createCellCoords,\n    createCellRange,\n    keepDirection = false,\n    propToCol\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!SELECTION_TYPES.includes(type)) {\n    throw new Error('Unsupported selection ranges schema type was provided.');\n  }\n  return function (selection) {\n    const isObjectType = type === SELECTION_TYPE_OBJECT;\n    let rowStart = isObjectType ? selection.from.row : selection[0];\n    let columnStart = isObjectType ? selection.from.col : selection[1];\n    let rowEnd = isObjectType ? selection.to.row : selection[2];\n    let columnEnd = isObjectType ? selection.to.col : selection[3];\n    if (typeof propToCol === 'function') {\n      if (typeof columnStart === 'string') {\n        columnStart = propToCol(columnStart);\n      }\n      if (typeof columnEnd === 'string') {\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n    if (isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n    if (isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n    if (!keepDirection) {\n      const origRowStart = rowStart;\n      const origColumnStart = columnStart;\n      const origRowEnd = rowEnd;\n      const origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n      rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = Math.max(origColumnStart, origColumnEnd);\n    }\n    const from = createCellCoords(rowStart, columnStart);\n    const to = createCellCoords(rowEnd, columnEnd);\n    return createCellRange(from, from, to);\n  };\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Core} hotInstance The Handsontable instance.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToColumnDistance(hotInstance) {\n  const selectionType = detectSelectionType(hotInstance.getSelected());\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n    createCellCoords: hotInstance._createCellCoords.bind(hotInstance),\n    createCellRange: hotInstance._createCellRange.bind(hotInstance)\n  });\n  const unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(hotInstance.getSelected(), selection => {\n    const {\n      from,\n      to\n    } = selectionSchemaNormalizer(selection);\n    const columnNonHeaderStart = Math.max(from.col, 0);\n    const amount = to.col - columnNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), (_, i) => columnNonHeaderStart + i), index => {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);\n  const normalizedColumnRanges = arrayReduce(orderedIndexes, (acc, visualColumnIndex, index, array) => {\n    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([visualColumnIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedColumnRanges;\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Core} hotInstance The Handsontable instance.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToRowDistance(hotInstance) {\n  const selectionType = detectSelectionType(hotInstance.getSelected());\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n    createCellCoords: hotInstance._createCellCoords.bind(hotInstance),\n    createCellRange: hotInstance._createCellRange.bind(hotInstance)\n  });\n  const unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(hotInstance.getSelected(), selection => {\n    const {\n      from,\n      to\n    } = selectionSchemaNormalizer(selection);\n    const rowNonHeaderStart = Math.max(from.row, 0);\n    const amount = to.row - rowNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), (_, i) => rowNonHeaderStart + i), index => {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);\n  const normalizedRowRanges = arrayReduce(orderedIndexes, (acc, rowIndex, index, array) => {\n    if (index !== 0 && rowIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedRowRanges;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}