{"ast":null,"code":"import { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function showColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\\x20\nthe last node, the show column modification can be applied.`);\n  }\n  const {\n    crossHiddenColumns\n  } = nodeToProcess.data;\n  if (!crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let isCollapsibleNode = false;\n  nodeToProcess.walkUp(node => {\n    const {\n      data: {\n        collapsible\n      }\n    } = node;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not show the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);\n    if (!data.isHidden && data.colspan < data.origColspan) {\n      data.colspan += 1;\n    }\n    data.isHidden = false;\n  });\n}","map":{"version":3,"names":["toSingleLine","showColumn","nodeToProcess","gridColumnIndex","Number","isInteger","Error","childs","length","crossHiddenColumns","data","includes","isCollapsibleNode","walkUp","node","collapsible","splice","indexOf","isHidden","colspan","origColspan"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/showColumn.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function showColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\\x20\nthe last node, the show column modification can be applied.`);\n  }\n  const {\n    crossHiddenColumns\n  } = nodeToProcess.data;\n  if (!crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let isCollapsibleNode = false;\n  nodeToProcess.walkUp(node => {\n    const {\n      data: {\n        collapsible\n      }\n    } = node;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not show the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);\n    if (!data.isHidden && data.colspan < data.origColspan) {\n      data.colspan += 1;\n    }\n    data.isHidden = false;\n  });\n}"],"mappings":"AACA,SAASA,YAAY,QAAQ,4CAA4C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,aAAa,EAAEC,eAAe,EAAE;EACzD,IAAI,CAACC,MAAM,CAACC,SAAS,CAACF,eAAe,CAAC,EAAE;IACtC,MAAM,IAAIG,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EACA,IAAIJ,aAAa,CAACK,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;IACnC,MAAM,IAAIF,KAAK,CAACN,YAAY;AAChC,4DAA4D,CAAC;EAC3D;EACA,MAAM;IACJS;EACF,CAAC,GAAGP,aAAa,CAACQ,IAAI;EACtB,IAAI,CAACD,kBAAkB,CAACE,QAAQ,CAACR,eAAe,CAAC,EAAE;IACjD;EACF;EACA,IAAIS,iBAAiB,GAAG,KAAK;EAC7BV,aAAa,CAACW,MAAM,CAACC,IAAI,IAAI;IAC3B,MAAM;MACJJ,IAAI,EAAE;QACJK;MACF;IACF,CAAC,GAAGD,IAAI;IACR,IAAIC,WAAW,EAAE;MACfH,iBAAiB,GAAG,IAAI;MACxB,OAAO,KAAK,CAAC,CAAC;IAChB;EACF,CAAC,CAAC;;EAEF;EACA;EACA,IAAIA,iBAAiB,EAAE;IACrB;EACF;EACAV,aAAa,CAACW,MAAM,CAACC,IAAI,IAAI;IAC3B,MAAM;MACJJ;IACF,CAAC,GAAGI,IAAI;IACRJ,IAAI,CAACD,kBAAkB,CAACO,MAAM,CAACN,IAAI,CAACD,kBAAkB,CAACQ,OAAO,CAACd,eAAe,CAAC,EAAE,CAAC,CAAC;IACnF,IAAI,CAACO,IAAI,CAACQ,QAAQ,IAAIR,IAAI,CAACS,OAAO,GAAGT,IAAI,CAACU,WAAW,EAAE;MACrDV,IAAI,CAACS,OAAO,IAAI,CAAC;IACnB;IACAT,IAAI,CAACQ,QAAQ,GAAG,KAAK;EACvB,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}