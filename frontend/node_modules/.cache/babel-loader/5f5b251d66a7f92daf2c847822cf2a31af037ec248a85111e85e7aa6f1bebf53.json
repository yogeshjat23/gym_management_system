{"ast":null,"code":"import Hooks from \"../../pluginHooks.mjs\";\nimport { arrayMap, arrayEach } from \"../../helpers/array.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { inherit, deepClone } from \"../../helpers/object.mjs\";\nimport { align } from \"../contextMenu/utils.mjs\";\nimport { getMoves } from \"../../helpers/moves.mjs\";\nconst SHORTCUTS_GROUP = 'undoRedo';\nexport const PLUGIN_KEY = 'undoRedo';\n\n/**\n * @description\n * Handsontable UndoRedo plugin allows to undo and redo certain actions done in the table.\n *\n * __Note__, that not all actions are currently undo-able. The UndoRedo plugin is enabled by default.\n * @example\n * ```js\n * undo: true\n * ```\n * @class UndoRedo\n * @plugin UndoRedo\n * @param {Core} instance The Handsontable instance.\n */\nfunction UndoRedo(instance) {\n  const plugin = this;\n  this.instance = instance;\n  this.doneActions = [];\n  this.undoneActions = [];\n  this.ignoreNewActions = false;\n  this.enabled = false;\n  instance.addHook('afterChange', function (changes, source) {\n    const changesLen = changes && changes.length;\n    if (!changesLen) {\n      return;\n    }\n    const hasDifferences = changes.find(change => {\n      const [,, oldValue, newValue] = change;\n      return oldValue !== newValue;\n    });\n    if (!hasDifferences) {\n      return;\n    }\n    const wrappedAction = () => {\n      const clonedChanges = changes.reduce((arr, change) => {\n        arr.push([...change]);\n        return arr;\n      }, []);\n      arrayEach(clonedChanges, change => {\n        change[1] = instance.propToCol(change[1]);\n      });\n      const selected = changesLen > 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];\n      return new UndoRedo.ChangeAction(clonedChanges, selected);\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateRow', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateRowAction(index, amount), source);\n  });\n  const getCellMetas = (fromRow, toRow, fromColumn, toColumn) => {\n    const genericKeys = ['visualRow', 'visualCol', 'row', 'col', 'prop'];\n    const genericKeysLength = genericKeys.length;\n    const cellMetas = [];\n    rangeEach(fromColumn, toColumn, columnIndex => {\n      rangeEach(fromRow, toRow, rowIndex => {\n        const cellMeta = instance.getCellMeta(rowIndex, columnIndex);\n        if (Object.keys(cellMeta).length !== genericKeysLength) {\n          const uniqueMeta = Object.fromEntries(Object.entries(cellMeta).filter(_ref => {\n            let [key] = _ref;\n            return genericKeys.includes(key) === false;\n          }));\n          cellMetas.push([cellMeta.visualRow, cellMeta.visualCol, uniqueMeta]);\n        }\n      });\n    });\n    return cellMetas;\n  };\n  instance.addHook('beforeRemoveRow', (index, amount, logicRows, source) => {\n    const wrappedAction = () => {\n      const physicalRowIndex = instance.toPhysicalRow(index);\n      const lastRowIndex = physicalRowIndex + amount - 1;\n      const removedData = deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex + amount - 1, plugin.instance.countSourceCols() - 1));\n      return new UndoRedo.RemoveRowAction(physicalRowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, instance.rowIndexMapper.getIndexesSequence(), getCellMetas(physicalRowIndex, lastRowIndex, 0, instance.countCols() - 1));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateCol', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateColumnAction(index, amount), source);\n  });\n  instance.addHook('beforeRemoveCol', (index, amount, logicColumns, source) => {\n    const wrappedAction = () => {\n      const originalData = plugin.instance.getSourceDataArray();\n      const columnIndex = (plugin.instance.countCols() + index) % plugin.instance.countCols();\n      const lastColumnIndex = columnIndex + amount - 1;\n      const removedData = [];\n      const headers = [];\n      const indexes = [];\n      rangeEach(originalData.length - 1, i => {\n        const column = [];\n        const origRow = originalData[i];\n        rangeEach(columnIndex, lastColumnIndex, j => {\n          column.push(origRow[instance.toPhysicalColumn(j)]);\n        });\n        removedData.push(column);\n      });\n      rangeEach(amount - 1, i => {\n        indexes.push(instance.toPhysicalColumn(columnIndex + i));\n      });\n      if (Array.isArray(instance.getSettings().colHeaders)) {\n        rangeEach(amount - 1, i => {\n          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);\n        });\n      }\n      const columnsMap = instance.columnIndexMapper.getIndexesSequence();\n      const rowsMap = instance.rowIndexMapper.getIndexesSequence();\n      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart, getCellMetas(0, instance.countRows(), columnIndex, lastColumnIndex));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('beforeCellAlignment', (stateBefore, range, type, alignment) => {\n    plugin.done(() => new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));\n  });\n  instance.addHook('beforeFilter', conditionsStack => {\n    plugin.done(() => new UndoRedo.FiltersAction(conditionsStack));\n  });\n  instance.addHook('beforeRowMove', (rows, finalIndex) => {\n    if (rows === false) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.RowMoveAction(rows, finalIndex));\n  });\n  instance.addHook('beforeColumnMove', (columns, finalIndex) => {\n    if (columns === false) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.ColumnMoveAction(columns, finalIndex));\n  });\n  instance.addHook('beforeMergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.MergeCellsAction(instance, cellRange));\n  });\n  instance.addHook('afterUnmergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.UnmergeCellsAction(instance, cellRange));\n  });\n  instance.addHook('beforeColumnSort', (currentSortConfig, destinationSortConfigs, sortPossible) => {\n    if (!sortPossible) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.ColumnSortAction(currentSortConfig, destinationSortConfigs));\n  });\n\n  // TODO: Why this callback is needed? One test doesn't pass after calling method right after plugin creation (outside the callback).\n  instance.addHook('afterInit', () => {\n    plugin.init();\n  });\n}\n\n/**\n * Stash information about performed actions.\n *\n * @function done\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @param {Function} wrappedAction The action descriptor wrapped in a closure.\n * @param {string} [source] Source of the action. It is defined just for more general actions (not related to plugins).\n */\nUndoRedo.prototype.done = function (wrappedAction, source) {\n  if (this.ignoreNewActions) {\n    return;\n  }\n  const isBlockedByDefault = source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n  if (isBlockedByDefault) {\n    return;\n  }\n  const doneActionsCopy = this.doneActions.slice();\n  const continueAction = this.instance.runHooks('beforeUndoStackChange', doneActionsCopy, source);\n  if (continueAction === false) {\n    return;\n  }\n  const newAction = wrappedAction();\n  const undoneActionsCopy = this.undoneActions.slice();\n  this.doneActions.push(newAction);\n  this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n  this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n  this.undoneActions.length = 0;\n  this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n};\n\n/**\n * Undo the last action performed to the table.\n *\n * @function undo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeUndo\n * @fires Hooks#afterUndo\n */\nUndoRedo.prototype.undo = function () {\n  if (this.isUndoAvailable()) {\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    const action = this.doneActions.pop();\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeUndo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    action.undo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.undoneActions.push(action);\n    });\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    this.instance.runHooks('afterUndo', actionClone);\n  }\n};\n\n/**\n * Redo the previous action performed to the table (used to reverse an undo).\n *\n * @function redo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeRedo\n * @fires Hooks#afterRedo\n */\nUndoRedo.prototype.redo = function () {\n  if (this.isRedoAvailable()) {\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    const action = this.undoneActions.pop();\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeRedo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    action.redo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.doneActions.push(action);\n    });\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    this.instance.runHooks('afterRedo', actionClone);\n  }\n};\n\n/**\n * Checks if undo action is available.\n *\n * @function isUndoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if undo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isUndoAvailable = function () {\n  return this.doneActions.length > 0;\n};\n\n/**\n * Checks if redo action is available.\n *\n * @function isRedoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if redo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isRedoAvailable = function () {\n  return this.undoneActions.length > 0;\n};\n\n/**\n * Clears undo history.\n *\n * @function clear\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.clear = function () {\n  this.doneActions.length = 0;\n  this.undoneActions.length = 0;\n};\n\n/**\n * Checks if the plugin is enabled.\n *\n * @function isEnabled\n * @memberof UndoRedo#\n * @returns {boolean}\n */\nUndoRedo.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\n * Enables the plugin.\n *\n * @function enable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.enable = function () {\n  if (this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = true;\n  exposeUndoRedoMethods(hot);\n  this.registerShortcuts();\n  hot.addHook('afterChange', onAfterChange);\n};\n\n/**\n * Disables the plugin.\n *\n * @function disable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.disable = function () {\n  if (!this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = false;\n  removeExposedUndoRedoMethods(hot);\n  this.unregisterShortcuts();\n  hot.removeHook('afterChange', onAfterChange);\n};\n\n/**\n * Destroys the instance.\n *\n * @function destroy\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.destroy = function () {\n  this.clear();\n  this.instance = null;\n  this.doneActions = null;\n  this.undoneActions = null;\n};\nUndoRedo.Action = function () {};\nUndoRedo.Action.prototype.undo = function () {};\nUndoRedo.Action.prototype.redo = function () {};\n\n/**\n * Change action.\n *\n * @private\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {number[]} selected The cell selection.\n */\nUndoRedo.ChangeAction = function (changes, selected) {\n  this.changes = changes;\n  this.selected = selected;\n  this.actionType = 'change';\n};\ninherit(UndoRedo.ChangeAction, UndoRedo.Action);\nUndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {\n  const data = deepClone(this.changes);\n  const emptyRowsAtTheEnd = instance.countEmptyRows(true);\n  const emptyColsAtTheEnd = instance.countEmptyCols(true);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(3, 1);\n  }\n  instance.addHookOnce('afterChange', undoneCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.undo');\n  for (let i = 0, len = data.length; i < len; i++) {\n    const [row, column] = data[i];\n    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {\n      instance.alter('remove_row', parseInt(row + 1, 10), instance.getSettings().minSpareRows);\n      instance.undoRedo.doneActions.pop();\n    }\n    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {\n      instance.alter('remove_col', parseInt(column + 1, 10), instance.getSettings().minSpareCols);\n      instance.undoRedo.doneActions.pop();\n    }\n  }\n  const selectedLast = instance.getSelectedLast();\n  if (selectedLast !== undefined) {\n    const [changedRow, changedColumn] = data[0];\n    const [selectedRow, selectedColumn] = selectedLast;\n    const firstFullyVisibleRow = instance.view.getFirstFullyVisibleRow();\n    const firstFullyVisibleColumn = instance.view.getFirstFullyVisibleColumn();\n    const isInVerticalViewPort = changedRow >= firstFullyVisibleRow;\n    const isInHorizontalViewPort = changedColumn >= firstFullyVisibleColumn;\n    const isInViewport = isInVerticalViewPort && isInHorizontalViewPort;\n    const isChangedSelection = selectedRow !== changedRow || selectedColumn !== changedColumn;\n\n    // Performing scroll only when selection has been changed right after editing a cell.\n    if (isInViewport === false && isChangedSelection === true) {\n      const scrollConfig = {\n        row: changedRow,\n        col: changedColumn\n      };\n      if (isInVerticalViewPort === false) {\n        scrollConfig.verticalSnap = 'top';\n      }\n      if (isInHorizontalViewPort === false) {\n        scrollConfig.horizontalSnap = 'start';\n      }\n      instance.scrollViewportTo(scrollConfig);\n    }\n  }\n  instance.selectCells(this.selected, false, false);\n};\nUndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {\n  const data = deepClone(this.changes);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(2, 1);\n  }\n  instance.addHookOnce('afterChange', onFinishCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.redo');\n  if (this.selected) {\n    instance.selectCells(this.selected, false, false);\n  }\n};\n\n/**\n * Create row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {number} amount The number of created rows.\n */\nUndoRedo.CreateRowAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_row';\n};\ninherit(UndoRedo.CreateRowAction, UndoRedo.Action);\nUndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {\n  const rowCount = instance.countRows();\n  const minSpareRows = instance.getSettings().minSpareRows;\n  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {\n    this.index -= minSpareRows; // work around the situation where the needed row was removed due to an 'undo' of a made change\n  }\n  instance.addHookOnce('afterRemoveRow', undoneCallback);\n  instance.alter('remove_row', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateRow', redoneCallback);\n  instance.alter('insert_row_above', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {Array} data The removed data.\n * @param {number} fixedRowsBottom Number of fixed rows on the bottom. Remove row action change it sometimes.\n * @param {number} fixedRowsTop Number of fixed rows on the top. Remove row action change it sometimes.\n * @param {Array} rowIndexesSequence Row index sequence taken from the row index mapper.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveRowAction = function (index, data, fixedRowsBottom, fixedRowsTop, rowIndexesSequence, removedCellMetas) {\n  this.index = index;\n  this.data = data;\n  this.actionType = 'remove_row';\n  this.fixedRowsBottom = fixedRowsBottom;\n  this.fixedRowsTop = fixedRowsTop;\n  this.rowIndexesSequence = rowIndexesSequence;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveRowAction, UndoRedo.Action);\nUndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n  const changes = [];\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedRowsBottom = this.fixedRowsBottom;\n  settings.fixedRowsTop = this.fixedRowsTop;\n\n  // Prepare the change list to fill the source data.\n  this.data.forEach((dataRow, rowIndexDelta) => {\n    Object.keys(dataRow).forEach(columnProp => {\n      const columnIndex = parseInt(columnProp, 10);\n      changes.push([this.index + rowIndexDelta, isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);\n    });\n  });\n  instance.alter('insert_row_above', this.index, this.data.length, 'UndoRedo.undo');\n  this.removedCellMetas.forEach(_ref2 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref2;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.setSourceDataAtCell(changes, null, null, 'UndoRedo.undo');\n  instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);\n};\nUndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveRow', redoneCallback);\n  instance.alter('remove_row', this.index, this.data.length, 'UndoRedo.redo');\n};\n\n/**\n * Create column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number} amount The number of created columns.\n */\nUndoRedo.CreateColumnAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_col';\n};\ninherit(UndoRedo.CreateColumnAction, UndoRedo.Action);\nUndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {\n  instance.addHookOnce('afterRemoveCol', undoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateCol', redoneCallback);\n  instance.alter('insert_col_start', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number[]} indexes The visual column indexes.\n * @param {Array} data The removed data.\n * @param {Array} headers The header values.\n * @param {number[]} columnPositions The column position.\n * @param {number[]} rowPositions The row position.\n * @param {number} fixedColumnsStart Number of fixed columns on the left. Remove column action change it sometimes.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveColumnAction = function (index, indexes, data, headers, columnPositions, rowPositions, fixedColumnsStart, removedCellMetas) {\n  // eslint-disable-line max-len\n  this.index = index;\n  this.indexes = indexes;\n  this.data = data;\n  this.amount = this.data[0].length;\n  this.headers = headers;\n  this.columnPositions = columnPositions.slice(0);\n  this.rowPositions = rowPositions.slice(0);\n  this.actionType = 'remove_col';\n  this.fixedColumnsStart = fixedColumnsStart;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);\nUndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedColumnsStart = this.fixedColumnsStart;\n  const ascendingIndexes = this.indexes.slice(0).sort();\n  const sortByIndexes = (elem, j, arr) => arr[this.indexes.indexOf(ascendingIndexes[j])];\n  const removedDataLength = this.data.length;\n  const sortedData = [];\n  for (let rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {\n    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));\n  }\n  const sortedHeaders = arrayMap(this.headers, sortByIndexes);\n  const changes = [];\n  instance.alter('insert_col_start', this.indexes[0], this.indexes.length, 'UndoRedo.undo');\n  arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {\n    arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {\n      rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];\n      changes.push([rowIndex, changedIndex, rowData[changedIndex]]);\n    });\n  });\n  instance.setSourceDataAtCell(changes, undefined, undefined, 'UndoRedo.undo');\n  if (typeof this.headers !== 'undefined') {\n    arrayEach(sortedHeaders, (headerData, columnIndex) => {\n      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;\n    });\n  }\n  this.removedCellMetas.forEach(_ref3 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref3;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.batchExecution(() => {\n    // Restore row sequence in a case when all columns are removed. the original\n    // row sequence is lost in that case.\n    instance.rowIndexMapper.setIndexesSequence(this.rowPositions);\n    instance.columnIndexMapper.setIndexesSequence(this.columnPositions);\n  }, true);\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveCol', redoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Cell alignment action.\n *\n * @private\n * @param {Array} stateBefore The previous state.\n * @param {object} range The cell range.\n * @param {string} type The type of the alignment (\"top\", \"left\", \"bottom\" or \"right\").\n * @param {string} alignment The alignment CSS class.\n */\nUndoRedo.CellAlignmentAction = function (stateBefore, range, type, alignment) {\n  this.stateBefore = stateBefore;\n  this.range = range;\n  this.type = type;\n  this.alignment = alignment;\n};\nUndoRedo.CellAlignmentAction.prototype.undo = function (instance, undoneCallback) {\n  arrayEach(this.range, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        instance.setCellMeta(row, col, 'className', this.stateBefore[row][col] || ' htLeft');\n      }\n    });\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.CellAlignmentAction.prototype.redo = function (instance, undoneCallback) {\n  align(this.range, this.type, this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, value) => instance.setCellMeta(row, col, key, value));\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\n\n/**\n * Filters action.\n *\n * @private\n * @param {Array} conditionsStack An array of the filter condition.\n */\nUndoRedo.FiltersAction = function (conditionsStack) {\n  this.conditionsStack = conditionsStack;\n  this.actionType = 'filter';\n};\ninherit(UndoRedo.FiltersAction, UndoRedo.Action);\nUndoRedo.FiltersAction.prototype.undo = function (instance, undoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));\n  filters.filter();\n};\nUndoRedo.FiltersAction.prototype.redo = function (instance, redoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack);\n  filters.filter();\n};\n\n/**\n * Merge Cells action.\n *\n * @util\n */\nclass MergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    const bottomEndCorner = this.cellRange.getBottomEndCorner();\n    this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, undefined, undefined, 'MergeCells');\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange);\n  }\n}\nUndoRedo.MergeCellsAction = MergeCellsAction;\n\n/**\n * Unmerge Cells action.\n *\n * @util\n */\nclass UnmergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange, true);\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    instance.render();\n  }\n}\nUndoRedo.UnmergeCellsAction = UnmergeCellsAction;\n\n/**\n * ManualRowMove action.\n *\n * @TODO removeRow undo should works on logical index\n * @private\n * @param {number[]} rows An array with moved rows.\n * @param {number} finalIndex The destination index.\n */\nUndoRedo.RowMoveAction = function (rows, finalIndex) {\n  this.rows = rows.slice();\n  this.finalRowIndex = finalIndex;\n  this.actionType = 'row_move';\n};\ninherit(UndoRedo.RowMoveAction, UndoRedo.Action);\nUndoRedo.RowMoveAction.prototype.undo = function (instance, undoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  const rowMoves = getMoves(this.rows, this.finalRowIndex, instance.rowIndexMapper.getNumberOfIndexes());\n  rowMoves.reverse().forEach(_ref4 => {\n    let {\n      from,\n      to\n    } = _ref4;\n    if (from < to) {\n      to -= 1;\n    }\n    manualRowMove.moveRow(to, from);\n  });\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);\n};\nUndoRedo.RowMoveAction.prototype.redo = function (instance, redoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  manualRowMove.moveRows(this.rows.slice(), this.finalRowIndex);\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.finalRowIndex, this.finalRowIndex + this.rows.length - 1);\n};\n\n/**\n * ManualColumnMove action.\n *\n * @private\n * @param {number[]} columns An array with moved columns.\n * @param {number} finalIndex The destination index.\n */\nUndoRedo.ColumnMoveAction = function (columns, finalIndex) {\n  this.columns = columns.slice();\n  this.finalColumnIndex = finalIndex;\n  this.actionType = 'col_move';\n};\ninherit(UndoRedo.ColumnMoveAction, UndoRedo.Action);\nUndoRedo.ColumnMoveAction.prototype.undo = function (instance, undoneCallback) {\n  const manualColumnMove = instance.getPlugin('manualColumnMove');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  const columnMoves = getMoves(this.columns, this.finalColumnIndex, instance.columnIndexMapper.getNumberOfIndexes());\n  columnMoves.reverse().forEach(_ref5 => {\n    let {\n      from,\n      to\n    } = _ref5;\n    if (from < to) {\n      to -= 1;\n    }\n    manualColumnMove.moveColumn(to, from);\n  });\n  instance.render();\n  instance.deselectCell();\n  instance.selectColumns(this.columns[0], this.columns[0] + this.columns.length - 1);\n};\nUndoRedo.ColumnMoveAction.prototype.redo = function (instance, redoneCallback) {\n  const manualColumnMove = instance.getPlugin('manualColumnMove');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  manualColumnMove.moveColumns(this.columns.slice(), this.finalColumnIndex);\n  instance.render();\n  instance.deselectCell();\n  instance.selectColumns(this.finalColumnIndex, this.finalColumnIndex + this.columns.length - 1);\n};\n\n/**\n * ColumnSort action.\n *\n * @private\n * @param {Array} currentSortState The current sort state.\n * @param {Array} newSortState The new sort state.\n */\nUndoRedo.ColumnSortAction = function (currentSortState, newSortState) {\n  this.previousSortState = currentSortState;\n  this.nextSortState = newSortState;\n};\ninherit(UndoRedo.ColumnSortAction, UndoRedo.Action);\nUndoRedo.ColumnSortAction.prototype.undo = function (instance, undoneCallback) {\n  const sortPlugin = instance.getPlugin('columnSorting');\n  const multiSortPlugin = instance.getPlugin('multiColumnSorting');\n  const enabledSortPlugin = multiSortPlugin.isEnabled() ? multiSortPlugin : sortPlugin;\n  if (this.previousSortState.length) {\n    enabledSortPlugin.sort(this.previousSortState);\n  } else {\n    enabledSortPlugin.clearSort();\n  }\n  undoneCallback();\n};\nUndoRedo.ColumnSortAction.prototype.redo = function (instance, redoneCallback) {\n  const sortPlugin = instance.getPlugin('columnSorting');\n  const multiSortPlugin = instance.getPlugin('multiColumnSorting');\n  const enabledSortPlugin = multiSortPlugin.isEnabled() ? multiSortPlugin : sortPlugin;\n  enabledSortPlugin.sort(this.nextSortState);\n  redoneCallback();\n};\n\n/**\n * Enabling and disabling plugin and attaching its to an instance.\n *\n * @private\n */\nUndoRedo.prototype.init = function () {\n  const settings = this.instance.getSettings().undo;\n  const pluginEnabled = typeof settings === 'undefined' || settings;\n  if (!this.instance.undoRedo) {\n    this.instance.undoRedo = this;\n  }\n  if (pluginEnabled) {\n    this.instance.undoRedo.enable();\n  } else {\n    this.instance.undoRedo.disable();\n  }\n};\n\n/**\n * Registers shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.registerShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  const runOnlyIf = event => {\n    return !event.altKey; // right ALT in some systems triggers ALT+CTR\n  };\n  const config = {\n    runOnlyIf,\n    group: SHORTCUTS_GROUP\n  };\n  gridContext.addShortcuts([{\n    keys: [['Control/Meta', 'z']],\n    callback: () => {\n      this.undo();\n    }\n  }, {\n    keys: [['Control/Meta', 'y'], ['Control/Meta', 'Shift', 'z']],\n    callback: () => {\n      this.redo();\n    }\n  }], config);\n};\n\n/**\n * Unregister shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.unregisterShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n};\n\n/**\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {string} source String that identifies source of hook call.\n * @returns {boolean}\n */\nfunction onAfterChange(changes, source) {\n  const instance = this;\n  if (source === 'loadData') {\n    return instance.undoRedo.clear();\n  }\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction exposeUndoRedoMethods(instance) {\n  /**\n   * {@link UndoRedo#undo}.\n   *\n   * @alias undo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.undo = function () {\n    return instance.undoRedo.undo();\n  };\n\n  /**\n   * {@link UndoRedo#redo}.\n   *\n   * @alias redo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.redo = function () {\n    return instance.undoRedo.redo();\n  };\n\n  /**\n   * {@link UndoRedo#isUndoAvailable}.\n   *\n   * @alias isUndoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isUndoAvailable = function () {\n    return instance.undoRedo.isUndoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#isRedoAvailable}.\n   *\n   * @alias isRedoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isRedoAvailable = function () {\n    return instance.undoRedo.isRedoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#clear}.\n   *\n   * @alias clearUndo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.clearUndo = function () {\n    return instance.undoRedo.clear();\n  };\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction removeExposedUndoRedoMethods(instance) {\n  delete instance.undo;\n  delete instance.redo;\n  delete instance.isUndoAvailable;\n  delete instance.isRedoAvailable;\n  delete instance.clearUndo;\n}\nconst hook = Hooks.getSingleton();\nhook.add('afterUpdateSettings', function () {\n  var _this$getPlugin;\n  (_this$getPlugin = this.getPlugin('undoRedo')) === null || _this$getPlugin === void 0 || _this$getPlugin.init();\n});\nhook.register('beforeUndo');\nhook.register('afterUndo');\nhook.register('beforeRedo');\nhook.register('afterRedo');\nUndoRedo.PLUGIN_KEY = PLUGIN_KEY;\nUndoRedo.SETTING_KEYS = true;\nexport default UndoRedo;","map":{"version":3,"names":["Hooks","arrayMap","arrayEach","rangeEach","inherit","deepClone","align","getMoves","SHORTCUTS_GROUP","PLUGIN_KEY","UndoRedo","instance","plugin","doneActions","undoneActions","ignoreNewActions","enabled","addHook","changes","source","changesLen","length","hasDifferences","find","change","oldValue","newValue","wrappedAction","clonedChanges","reduce","arr","push","propToCol","selected","getSelected","ChangeAction","done","index","amount","CreateRowAction","getCellMetas","fromRow","toRow","fromColumn","toColumn","genericKeys","genericKeysLength","cellMetas","columnIndex","rowIndex","cellMeta","getCellMeta","Object","keys","uniqueMeta","fromEntries","entries","filter","_ref","key","includes","visualRow","visualCol","logicRows","physicalRowIndex","toPhysicalRow","lastRowIndex","removedData","getSourceData","countSourceCols","RemoveRowAction","getSettings","fixedRowsBottom","fixedRowsTop","rowIndexMapper","getIndexesSequence","countCols","CreateColumnAction","logicColumns","originalData","getSourceDataArray","lastColumnIndex","headers","indexes","i","column","origRow","j","toPhysicalColumn","Array","isArray","colHeaders","columnsMap","columnIndexMapper","rowsMap","RemoveColumnAction","fixedColumnsStart","countRows","stateBefore","range","type","alignment","CellAlignmentAction","conditionsStack","FiltersAction","rows","finalIndex","RowMoveAction","columns","ColumnMoveAction","cellRange","auto","MergeCellsAction","UnmergeCellsAction","currentSortConfig","destinationSortConfigs","sortPossible","ColumnSortAction","init","prototype","isBlockedByDefault","doneActionsCopy","slice","continueAction","runHooks","newAction","undoneActionsCopy","undo","isUndoAvailable","action","pop","actionClone","that","redo","isRedoAvailable","clear","isEnabled","enable","hot","exposeUndoRedoMethods","registerShortcuts","onAfterChange","disable","removeExposedUndoRedoMethods","unregisterShortcuts","removeHook","destroy","Action","actionType","undoneCallback","data","emptyRowsAtTheEnd","countEmptyRows","emptyColsAtTheEnd","countEmptyCols","len","splice","addHookOnce","setDataAtCell","row","minSpareRows","alter","parseInt","undoRedo","minSpareCols","selectedLast","getSelectedLast","undefined","changedRow","changedColumn","selectedRow","selectedColumn","firstFullyVisibleRow","view","getFirstFullyVisibleRow","firstFullyVisibleColumn","getFirstFullyVisibleColumn","isInVerticalViewPort","isInHorizontalViewPort","isInViewport","isChangedSelection","scrollConfig","col","verticalSnap","horizontalSnap","scrollViewportTo","selectCells","onFinishCallback","rowCount","redoneCallback","rowIndexesSequence","removedCellMetas","settings","forEach","dataRow","rowIndexDelta","columnProp","isNaN","_ref2","setCellMetaObject","setSourceDataAtCell","setIndexesSequence","columnPositions","rowPositions","ascendingIndexes","sort","sortByIndexes","elem","indexOf","removedDataLength","sortedData","sortedHeaders","rowData","changedIndex","contiquesIndex","headerData","_ref3","batchExecution","render","forAll","setCellMeta","value","filters","getPlugin","conditionCollection","importAllConditions","constructor","topStartCorner","getTopStartCorner","bottomEndCorner","getBottomEndCorner","rangeData","getData","mergeCellsPlugin","unmergeRange","populateFromArray","mergeRange","finalRowIndex","manualRowMove","rowMoves","getNumberOfIndexes","reverse","_ref4","from","to","moveRow","deselectCell","selectRows","moveRows","finalColumnIndex","manualColumnMove","columnMoves","_ref5","moveColumn","selectColumns","moveColumns","currentSortState","newSortState","previousSortState","nextSortState","sortPlugin","multiSortPlugin","enabledSortPlugin","clearSort","pluginEnabled","shortcutManager","getShortcutManager","gridContext","getContext","runOnlyIf","event","altKey","config","group","addShortcuts","callback","removeShortcutsByGroup","clearUndo","hook","getSingleton","add","_this$getPlugin","register","SETTING_KEYS"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/undoRedo/undoRedo.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.from-entries.js\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayMap, arrayEach } from \"../../helpers/array.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { inherit, deepClone } from \"../../helpers/object.mjs\";\nimport { align } from \"../contextMenu/utils.mjs\";\nimport { getMoves } from \"../../helpers/moves.mjs\";\nconst SHORTCUTS_GROUP = 'undoRedo';\nexport const PLUGIN_KEY = 'undoRedo';\n\n/**\n * @description\n * Handsontable UndoRedo plugin allows to undo and redo certain actions done in the table.\n *\n * __Note__, that not all actions are currently undo-able. The UndoRedo plugin is enabled by default.\n * @example\n * ```js\n * undo: true\n * ```\n * @class UndoRedo\n * @plugin UndoRedo\n * @param {Core} instance The Handsontable instance.\n */\nfunction UndoRedo(instance) {\n  const plugin = this;\n  this.instance = instance;\n  this.doneActions = [];\n  this.undoneActions = [];\n  this.ignoreNewActions = false;\n  this.enabled = false;\n  instance.addHook('afterChange', function (changes, source) {\n    const changesLen = changes && changes.length;\n    if (!changesLen) {\n      return;\n    }\n    const hasDifferences = changes.find(change => {\n      const [,, oldValue, newValue] = change;\n      return oldValue !== newValue;\n    });\n    if (!hasDifferences) {\n      return;\n    }\n    const wrappedAction = () => {\n      const clonedChanges = changes.reduce((arr, change) => {\n        arr.push([...change]);\n        return arr;\n      }, []);\n      arrayEach(clonedChanges, change => {\n        change[1] = instance.propToCol(change[1]);\n      });\n      const selected = changesLen > 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];\n      return new UndoRedo.ChangeAction(clonedChanges, selected);\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateRow', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateRowAction(index, amount), source);\n  });\n  const getCellMetas = (fromRow, toRow, fromColumn, toColumn) => {\n    const genericKeys = ['visualRow', 'visualCol', 'row', 'col', 'prop'];\n    const genericKeysLength = genericKeys.length;\n    const cellMetas = [];\n    rangeEach(fromColumn, toColumn, columnIndex => {\n      rangeEach(fromRow, toRow, rowIndex => {\n        const cellMeta = instance.getCellMeta(rowIndex, columnIndex);\n        if (Object.keys(cellMeta).length !== genericKeysLength) {\n          const uniqueMeta = Object.fromEntries(Object.entries(cellMeta).filter(_ref => {\n            let [key] = _ref;\n            return genericKeys.includes(key) === false;\n          }));\n          cellMetas.push([cellMeta.visualRow, cellMeta.visualCol, uniqueMeta]);\n        }\n      });\n    });\n    return cellMetas;\n  };\n  instance.addHook('beforeRemoveRow', (index, amount, logicRows, source) => {\n    const wrappedAction = () => {\n      const physicalRowIndex = instance.toPhysicalRow(index);\n      const lastRowIndex = physicalRowIndex + amount - 1;\n      const removedData = deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex + amount - 1, plugin.instance.countSourceCols() - 1));\n      return new UndoRedo.RemoveRowAction(physicalRowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, instance.rowIndexMapper.getIndexesSequence(), getCellMetas(physicalRowIndex, lastRowIndex, 0, instance.countCols() - 1));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateCol', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateColumnAction(index, amount), source);\n  });\n  instance.addHook('beforeRemoveCol', (index, amount, logicColumns, source) => {\n    const wrappedAction = () => {\n      const originalData = plugin.instance.getSourceDataArray();\n      const columnIndex = (plugin.instance.countCols() + index) % plugin.instance.countCols();\n      const lastColumnIndex = columnIndex + amount - 1;\n      const removedData = [];\n      const headers = [];\n      const indexes = [];\n      rangeEach(originalData.length - 1, i => {\n        const column = [];\n        const origRow = originalData[i];\n        rangeEach(columnIndex, lastColumnIndex, j => {\n          column.push(origRow[instance.toPhysicalColumn(j)]);\n        });\n        removedData.push(column);\n      });\n      rangeEach(amount - 1, i => {\n        indexes.push(instance.toPhysicalColumn(columnIndex + i));\n      });\n      if (Array.isArray(instance.getSettings().colHeaders)) {\n        rangeEach(amount - 1, i => {\n          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);\n        });\n      }\n      const columnsMap = instance.columnIndexMapper.getIndexesSequence();\n      const rowsMap = instance.rowIndexMapper.getIndexesSequence();\n      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart, getCellMetas(0, instance.countRows(), columnIndex, lastColumnIndex));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('beforeCellAlignment', (stateBefore, range, type, alignment) => {\n    plugin.done(() => new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));\n  });\n  instance.addHook('beforeFilter', conditionsStack => {\n    plugin.done(() => new UndoRedo.FiltersAction(conditionsStack));\n  });\n  instance.addHook('beforeRowMove', (rows, finalIndex) => {\n    if (rows === false) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.RowMoveAction(rows, finalIndex));\n  });\n  instance.addHook('beforeColumnMove', (columns, finalIndex) => {\n    if (columns === false) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.ColumnMoveAction(columns, finalIndex));\n  });\n  instance.addHook('beforeMergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.MergeCellsAction(instance, cellRange));\n  });\n  instance.addHook('afterUnmergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.UnmergeCellsAction(instance, cellRange));\n  });\n  instance.addHook('beforeColumnSort', (currentSortConfig, destinationSortConfigs, sortPossible) => {\n    if (!sortPossible) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.ColumnSortAction(currentSortConfig, destinationSortConfigs));\n  });\n\n  // TODO: Why this callback is needed? One test doesn't pass after calling method right after plugin creation (outside the callback).\n  instance.addHook('afterInit', () => {\n    plugin.init();\n  });\n}\n\n/**\n * Stash information about performed actions.\n *\n * @function done\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @param {Function} wrappedAction The action descriptor wrapped in a closure.\n * @param {string} [source] Source of the action. It is defined just for more general actions (not related to plugins).\n */\nUndoRedo.prototype.done = function (wrappedAction, source) {\n  if (this.ignoreNewActions) {\n    return;\n  }\n  const isBlockedByDefault = source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n  if (isBlockedByDefault) {\n    return;\n  }\n  const doneActionsCopy = this.doneActions.slice();\n  const continueAction = this.instance.runHooks('beforeUndoStackChange', doneActionsCopy, source);\n  if (continueAction === false) {\n    return;\n  }\n  const newAction = wrappedAction();\n  const undoneActionsCopy = this.undoneActions.slice();\n  this.doneActions.push(newAction);\n  this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n  this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n  this.undoneActions.length = 0;\n  this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n};\n\n/**\n * Undo the last action performed to the table.\n *\n * @function undo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeUndo\n * @fires Hooks#afterUndo\n */\nUndoRedo.prototype.undo = function () {\n  if (this.isUndoAvailable()) {\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    const action = this.doneActions.pop();\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeUndo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    action.undo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.undoneActions.push(action);\n    });\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    this.instance.runHooks('afterUndo', actionClone);\n  }\n};\n\n/**\n * Redo the previous action performed to the table (used to reverse an undo).\n *\n * @function redo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeRedo\n * @fires Hooks#afterRedo\n */\nUndoRedo.prototype.redo = function () {\n  if (this.isRedoAvailable()) {\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    const action = this.undoneActions.pop();\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeRedo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    action.redo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.doneActions.push(action);\n    });\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    this.instance.runHooks('afterRedo', actionClone);\n  }\n};\n\n/**\n * Checks if undo action is available.\n *\n * @function isUndoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if undo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isUndoAvailable = function () {\n  return this.doneActions.length > 0;\n};\n\n/**\n * Checks if redo action is available.\n *\n * @function isRedoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if redo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isRedoAvailable = function () {\n  return this.undoneActions.length > 0;\n};\n\n/**\n * Clears undo history.\n *\n * @function clear\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.clear = function () {\n  this.doneActions.length = 0;\n  this.undoneActions.length = 0;\n};\n\n/**\n * Checks if the plugin is enabled.\n *\n * @function isEnabled\n * @memberof UndoRedo#\n * @returns {boolean}\n */\nUndoRedo.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\n * Enables the plugin.\n *\n * @function enable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.enable = function () {\n  if (this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = true;\n  exposeUndoRedoMethods(hot);\n  this.registerShortcuts();\n  hot.addHook('afterChange', onAfterChange);\n};\n\n/**\n * Disables the plugin.\n *\n * @function disable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.disable = function () {\n  if (!this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = false;\n  removeExposedUndoRedoMethods(hot);\n  this.unregisterShortcuts();\n  hot.removeHook('afterChange', onAfterChange);\n};\n\n/**\n * Destroys the instance.\n *\n * @function destroy\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.destroy = function () {\n  this.clear();\n  this.instance = null;\n  this.doneActions = null;\n  this.undoneActions = null;\n};\nUndoRedo.Action = function () {};\nUndoRedo.Action.prototype.undo = function () {};\nUndoRedo.Action.prototype.redo = function () {};\n\n/**\n * Change action.\n *\n * @private\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {number[]} selected The cell selection.\n */\nUndoRedo.ChangeAction = function (changes, selected) {\n  this.changes = changes;\n  this.selected = selected;\n  this.actionType = 'change';\n};\ninherit(UndoRedo.ChangeAction, UndoRedo.Action);\nUndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {\n  const data = deepClone(this.changes);\n  const emptyRowsAtTheEnd = instance.countEmptyRows(true);\n  const emptyColsAtTheEnd = instance.countEmptyCols(true);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(3, 1);\n  }\n  instance.addHookOnce('afterChange', undoneCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.undo');\n  for (let i = 0, len = data.length; i < len; i++) {\n    const [row, column] = data[i];\n    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {\n      instance.alter('remove_row', parseInt(row + 1, 10), instance.getSettings().minSpareRows);\n      instance.undoRedo.doneActions.pop();\n    }\n    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {\n      instance.alter('remove_col', parseInt(column + 1, 10), instance.getSettings().minSpareCols);\n      instance.undoRedo.doneActions.pop();\n    }\n  }\n  const selectedLast = instance.getSelectedLast();\n  if (selectedLast !== undefined) {\n    const [changedRow, changedColumn] = data[0];\n    const [selectedRow, selectedColumn] = selectedLast;\n    const firstFullyVisibleRow = instance.view.getFirstFullyVisibleRow();\n    const firstFullyVisibleColumn = instance.view.getFirstFullyVisibleColumn();\n    const isInVerticalViewPort = changedRow >= firstFullyVisibleRow;\n    const isInHorizontalViewPort = changedColumn >= firstFullyVisibleColumn;\n    const isInViewport = isInVerticalViewPort && isInHorizontalViewPort;\n    const isChangedSelection = selectedRow !== changedRow || selectedColumn !== changedColumn;\n\n    // Performing scroll only when selection has been changed right after editing a cell.\n    if (isInViewport === false && isChangedSelection === true) {\n      const scrollConfig = {\n        row: changedRow,\n        col: changedColumn\n      };\n      if (isInVerticalViewPort === false) {\n        scrollConfig.verticalSnap = 'top';\n      }\n      if (isInHorizontalViewPort === false) {\n        scrollConfig.horizontalSnap = 'start';\n      }\n      instance.scrollViewportTo(scrollConfig);\n    }\n  }\n  instance.selectCells(this.selected, false, false);\n};\nUndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {\n  const data = deepClone(this.changes);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(2, 1);\n  }\n  instance.addHookOnce('afterChange', onFinishCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.redo');\n  if (this.selected) {\n    instance.selectCells(this.selected, false, false);\n  }\n};\n\n/**\n * Create row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {number} amount The number of created rows.\n */\nUndoRedo.CreateRowAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_row';\n};\ninherit(UndoRedo.CreateRowAction, UndoRedo.Action);\nUndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {\n  const rowCount = instance.countRows();\n  const minSpareRows = instance.getSettings().minSpareRows;\n  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {\n    this.index -= minSpareRows; // work around the situation where the needed row was removed due to an 'undo' of a made change\n  }\n  instance.addHookOnce('afterRemoveRow', undoneCallback);\n  instance.alter('remove_row', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateRow', redoneCallback);\n  instance.alter('insert_row_above', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {Array} data The removed data.\n * @param {number} fixedRowsBottom Number of fixed rows on the bottom. Remove row action change it sometimes.\n * @param {number} fixedRowsTop Number of fixed rows on the top. Remove row action change it sometimes.\n * @param {Array} rowIndexesSequence Row index sequence taken from the row index mapper.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveRowAction = function (index, data, fixedRowsBottom, fixedRowsTop, rowIndexesSequence, removedCellMetas) {\n  this.index = index;\n  this.data = data;\n  this.actionType = 'remove_row';\n  this.fixedRowsBottom = fixedRowsBottom;\n  this.fixedRowsTop = fixedRowsTop;\n  this.rowIndexesSequence = rowIndexesSequence;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveRowAction, UndoRedo.Action);\nUndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n  const changes = [];\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedRowsBottom = this.fixedRowsBottom;\n  settings.fixedRowsTop = this.fixedRowsTop;\n\n  // Prepare the change list to fill the source data.\n  this.data.forEach((dataRow, rowIndexDelta) => {\n    Object.keys(dataRow).forEach(columnProp => {\n      const columnIndex = parseInt(columnProp, 10);\n      changes.push([this.index + rowIndexDelta, isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);\n    });\n  });\n  instance.alter('insert_row_above', this.index, this.data.length, 'UndoRedo.undo');\n  this.removedCellMetas.forEach(_ref2 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref2;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.setSourceDataAtCell(changes, null, null, 'UndoRedo.undo');\n  instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);\n};\nUndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveRow', redoneCallback);\n  instance.alter('remove_row', this.index, this.data.length, 'UndoRedo.redo');\n};\n\n/**\n * Create column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number} amount The number of created columns.\n */\nUndoRedo.CreateColumnAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_col';\n};\ninherit(UndoRedo.CreateColumnAction, UndoRedo.Action);\nUndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {\n  instance.addHookOnce('afterRemoveCol', undoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateCol', redoneCallback);\n  instance.alter('insert_col_start', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number[]} indexes The visual column indexes.\n * @param {Array} data The removed data.\n * @param {Array} headers The header values.\n * @param {number[]} columnPositions The column position.\n * @param {number[]} rowPositions The row position.\n * @param {number} fixedColumnsStart Number of fixed columns on the left. Remove column action change it sometimes.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveColumnAction = function (index, indexes, data, headers, columnPositions, rowPositions, fixedColumnsStart, removedCellMetas) {\n  // eslint-disable-line max-len\n  this.index = index;\n  this.indexes = indexes;\n  this.data = data;\n  this.amount = this.data[0].length;\n  this.headers = headers;\n  this.columnPositions = columnPositions.slice(0);\n  this.rowPositions = rowPositions.slice(0);\n  this.actionType = 'remove_col';\n  this.fixedColumnsStart = fixedColumnsStart;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);\nUndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedColumnsStart = this.fixedColumnsStart;\n  const ascendingIndexes = this.indexes.slice(0).sort();\n  const sortByIndexes = (elem, j, arr) => arr[this.indexes.indexOf(ascendingIndexes[j])];\n  const removedDataLength = this.data.length;\n  const sortedData = [];\n  for (let rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {\n    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));\n  }\n  const sortedHeaders = arrayMap(this.headers, sortByIndexes);\n  const changes = [];\n  instance.alter('insert_col_start', this.indexes[0], this.indexes.length, 'UndoRedo.undo');\n  arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {\n    arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {\n      rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];\n      changes.push([rowIndex, changedIndex, rowData[changedIndex]]);\n    });\n  });\n  instance.setSourceDataAtCell(changes, undefined, undefined, 'UndoRedo.undo');\n  if (typeof this.headers !== 'undefined') {\n    arrayEach(sortedHeaders, (headerData, columnIndex) => {\n      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;\n    });\n  }\n  this.removedCellMetas.forEach(_ref3 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref3;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.batchExecution(() => {\n    // Restore row sequence in a case when all columns are removed. the original\n    // row sequence is lost in that case.\n    instance.rowIndexMapper.setIndexesSequence(this.rowPositions);\n    instance.columnIndexMapper.setIndexesSequence(this.columnPositions);\n  }, true);\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveCol', redoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Cell alignment action.\n *\n * @private\n * @param {Array} stateBefore The previous state.\n * @param {object} range The cell range.\n * @param {string} type The type of the alignment (\"top\", \"left\", \"bottom\" or \"right\").\n * @param {string} alignment The alignment CSS class.\n */\nUndoRedo.CellAlignmentAction = function (stateBefore, range, type, alignment) {\n  this.stateBefore = stateBefore;\n  this.range = range;\n  this.type = type;\n  this.alignment = alignment;\n};\nUndoRedo.CellAlignmentAction.prototype.undo = function (instance, undoneCallback) {\n  arrayEach(this.range, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        instance.setCellMeta(row, col, 'className', this.stateBefore[row][col] || ' htLeft');\n      }\n    });\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.CellAlignmentAction.prototype.redo = function (instance, undoneCallback) {\n  align(this.range, this.type, this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, value) => instance.setCellMeta(row, col, key, value));\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\n\n/**\n * Filters action.\n *\n * @private\n * @param {Array} conditionsStack An array of the filter condition.\n */\nUndoRedo.FiltersAction = function (conditionsStack) {\n  this.conditionsStack = conditionsStack;\n  this.actionType = 'filter';\n};\ninherit(UndoRedo.FiltersAction, UndoRedo.Action);\nUndoRedo.FiltersAction.prototype.undo = function (instance, undoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));\n  filters.filter();\n};\nUndoRedo.FiltersAction.prototype.redo = function (instance, redoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack);\n  filters.filter();\n};\n\n/**\n * Merge Cells action.\n *\n * @util\n */\nclass MergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    const bottomEndCorner = this.cellRange.getBottomEndCorner();\n    this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, undefined, undefined, 'MergeCells');\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange);\n  }\n}\nUndoRedo.MergeCellsAction = MergeCellsAction;\n\n/**\n * Unmerge Cells action.\n *\n * @util\n */\nclass UnmergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange, true);\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    instance.render();\n  }\n}\nUndoRedo.UnmergeCellsAction = UnmergeCellsAction;\n\n/**\n * ManualRowMove action.\n *\n * @TODO removeRow undo should works on logical index\n * @private\n * @param {number[]} rows An array with moved rows.\n * @param {number} finalIndex The destination index.\n */\nUndoRedo.RowMoveAction = function (rows, finalIndex) {\n  this.rows = rows.slice();\n  this.finalRowIndex = finalIndex;\n  this.actionType = 'row_move';\n};\ninherit(UndoRedo.RowMoveAction, UndoRedo.Action);\nUndoRedo.RowMoveAction.prototype.undo = function (instance, undoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  const rowMoves = getMoves(this.rows, this.finalRowIndex, instance.rowIndexMapper.getNumberOfIndexes());\n  rowMoves.reverse().forEach(_ref4 => {\n    let {\n      from,\n      to\n    } = _ref4;\n    if (from < to) {\n      to -= 1;\n    }\n    manualRowMove.moveRow(to, from);\n  });\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);\n};\nUndoRedo.RowMoveAction.prototype.redo = function (instance, redoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  manualRowMove.moveRows(this.rows.slice(), this.finalRowIndex);\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.finalRowIndex, this.finalRowIndex + this.rows.length - 1);\n};\n\n/**\n * ManualColumnMove action.\n *\n * @private\n * @param {number[]} columns An array with moved columns.\n * @param {number} finalIndex The destination index.\n */\nUndoRedo.ColumnMoveAction = function (columns, finalIndex) {\n  this.columns = columns.slice();\n  this.finalColumnIndex = finalIndex;\n  this.actionType = 'col_move';\n};\ninherit(UndoRedo.ColumnMoveAction, UndoRedo.Action);\nUndoRedo.ColumnMoveAction.prototype.undo = function (instance, undoneCallback) {\n  const manualColumnMove = instance.getPlugin('manualColumnMove');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  const columnMoves = getMoves(this.columns, this.finalColumnIndex, instance.columnIndexMapper.getNumberOfIndexes());\n  columnMoves.reverse().forEach(_ref5 => {\n    let {\n      from,\n      to\n    } = _ref5;\n    if (from < to) {\n      to -= 1;\n    }\n    manualColumnMove.moveColumn(to, from);\n  });\n  instance.render();\n  instance.deselectCell();\n  instance.selectColumns(this.columns[0], this.columns[0] + this.columns.length - 1);\n};\nUndoRedo.ColumnMoveAction.prototype.redo = function (instance, redoneCallback) {\n  const manualColumnMove = instance.getPlugin('manualColumnMove');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  manualColumnMove.moveColumns(this.columns.slice(), this.finalColumnIndex);\n  instance.render();\n  instance.deselectCell();\n  instance.selectColumns(this.finalColumnIndex, this.finalColumnIndex + this.columns.length - 1);\n};\n\n/**\n * ColumnSort action.\n *\n * @private\n * @param {Array} currentSortState The current sort state.\n * @param {Array} newSortState The new sort state.\n */\nUndoRedo.ColumnSortAction = function (currentSortState, newSortState) {\n  this.previousSortState = currentSortState;\n  this.nextSortState = newSortState;\n};\ninherit(UndoRedo.ColumnSortAction, UndoRedo.Action);\nUndoRedo.ColumnSortAction.prototype.undo = function (instance, undoneCallback) {\n  const sortPlugin = instance.getPlugin('columnSorting');\n  const multiSortPlugin = instance.getPlugin('multiColumnSorting');\n  const enabledSortPlugin = multiSortPlugin.isEnabled() ? multiSortPlugin : sortPlugin;\n  if (this.previousSortState.length) {\n    enabledSortPlugin.sort(this.previousSortState);\n  } else {\n    enabledSortPlugin.clearSort();\n  }\n  undoneCallback();\n};\nUndoRedo.ColumnSortAction.prototype.redo = function (instance, redoneCallback) {\n  const sortPlugin = instance.getPlugin('columnSorting');\n  const multiSortPlugin = instance.getPlugin('multiColumnSorting');\n  const enabledSortPlugin = multiSortPlugin.isEnabled() ? multiSortPlugin : sortPlugin;\n  enabledSortPlugin.sort(this.nextSortState);\n  redoneCallback();\n};\n\n/**\n * Enabling and disabling plugin and attaching its to an instance.\n *\n * @private\n */\nUndoRedo.prototype.init = function () {\n  const settings = this.instance.getSettings().undo;\n  const pluginEnabled = typeof settings === 'undefined' || settings;\n  if (!this.instance.undoRedo) {\n    this.instance.undoRedo = this;\n  }\n  if (pluginEnabled) {\n    this.instance.undoRedo.enable();\n  } else {\n    this.instance.undoRedo.disable();\n  }\n};\n\n/**\n * Registers shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.registerShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  const runOnlyIf = event => {\n    return !event.altKey; // right ALT in some systems triggers ALT+CTR\n  };\n  const config = {\n    runOnlyIf,\n    group: SHORTCUTS_GROUP\n  };\n  gridContext.addShortcuts([{\n    keys: [['Control/Meta', 'z']],\n    callback: () => {\n      this.undo();\n    }\n  }, {\n    keys: [['Control/Meta', 'y'], ['Control/Meta', 'Shift', 'z']],\n    callback: () => {\n      this.redo();\n    }\n  }], config);\n};\n\n/**\n * Unregister shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.unregisterShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n};\n\n/**\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {string} source String that identifies source of hook call.\n * @returns {boolean}\n */\nfunction onAfterChange(changes, source) {\n  const instance = this;\n  if (source === 'loadData') {\n    return instance.undoRedo.clear();\n  }\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction exposeUndoRedoMethods(instance) {\n  /**\n   * {@link UndoRedo#undo}.\n   *\n   * @alias undo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.undo = function () {\n    return instance.undoRedo.undo();\n  };\n\n  /**\n   * {@link UndoRedo#redo}.\n   *\n   * @alias redo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.redo = function () {\n    return instance.undoRedo.redo();\n  };\n\n  /**\n   * {@link UndoRedo#isUndoAvailable}.\n   *\n   * @alias isUndoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isUndoAvailable = function () {\n    return instance.undoRedo.isUndoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#isRedoAvailable}.\n   *\n   * @alias isRedoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isRedoAvailable = function () {\n    return instance.undoRedo.isRedoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#clear}.\n   *\n   * @alias clearUndo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.clearUndo = function () {\n    return instance.undoRedo.clear();\n  };\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction removeExposedUndoRedoMethods(instance) {\n  delete instance.undo;\n  delete instance.redo;\n  delete instance.isUndoAvailable;\n  delete instance.isRedoAvailable;\n  delete instance.clearUndo;\n}\nconst hook = Hooks.getSingleton();\nhook.add('afterUpdateSettings', function () {\n  var _this$getPlugin;\n  (_this$getPlugin = this.getPlugin('undoRedo')) === null || _this$getPlugin === void 0 || _this$getPlugin.init();\n});\nhook.register('beforeUndo');\nhook.register('afterUndo');\nhook.register('beforeRedo');\nhook.register('afterRedo');\nUndoRedo.PLUGIN_KEY = PLUGIN_KEY;\nUndoRedo.SETTING_KEYS = true;\nexport default UndoRedo;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}