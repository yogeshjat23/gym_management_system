{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { hasClass, index, offset, removeTextNodes, overlayContainsElement, closest, outerHeight, outerWidth, innerHeight, isVisible, setAttribute } from \"../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER } from \"./overlay/index.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../helpers/a11y.mjs\";\n/**\n * @todo These mixes are never added to the class Table, however their members are used here.\n * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.\n * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.\n * @mixes stickyColumnsStart\n * @mixes stickyRowsBottom\n * @mixes stickyRowsTop\n * @mixes calculatedRows\n * @mixes calculatedColumns\n * @abstract\n */\nclass Table {\n  /**\n   *\n   * @abstract\n   * @param {TableDao} dataAccessObject The data access object.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.\n   */\n  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"TBODY\", null);\n    _defineProperty(this, \"THEAD\", null);\n    _defineProperty(this, \"COLGROUP\", null);\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableHeight\", true);\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableWidth\", true);\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isTableVisible\", false);\n    _defineProperty(this, \"tableOffset\", 0);\n    _defineProperty(this, \"holderOffset\", 0);\n    this.domBindings = domBindings;\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = name === 'master';\n    this.name = name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n\n    // legacy support\n    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.\n    this.wot = this.dataAccessObject.wot;\n    this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n\n    // TODO refactoring, to recognize the legitimacy of moving them into domBidings\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.correctHeaderWidth = false;\n    const origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');\n\n    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n    this.wtSettings.update('rowHeaderWidth', () => this._modifyRowHeaderWidth(origRowHeaderWidth));\n    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n\n    this.tableRenderer = new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wtSettings.getSettingPure('cellRenderer')\n    });\n  }\n\n  /**\n   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n  is(overlayTypeName) {\n    // todo refactoring: eliminate all protected and private usages\n    return this.name === overlayTypeName;\n  }\n\n  /**\n   *\n   */\n  fixTableDomTree() {\n    const rootDocument = this.domBindings.rootDocument;\n    this.TBODY = this.TABLE.querySelector('tbody');\n    if (!this.TBODY) {\n      this.TBODY = rootDocument.createElement('tbody');\n      this.TABLE.appendChild(this.TBODY);\n    }\n    this.THEAD = this.TABLE.querySelector('thead');\n    if (!this.THEAD) {\n      this.THEAD = rootDocument.createElement('thead');\n      this.TABLE.insertBefore(this.THEAD, this.TBODY);\n    }\n    this.COLGROUP = this.TABLE.querySelector('colgroup');\n    if (!this.COLGROUP) {\n      this.COLGROUP = rootDocument.createElement('colgroup');\n      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n    }\n  }\n\n  /**\n   * @param {HTMLTableElement} table An element to process.\n   * @returns {HTMLElement}\n   */\n  createSpreader(table) {\n    const parent = table.parentNode;\n    let spreader;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      spreader = this.domBindings.rootDocument.createElement('div');\n      spreader.className = 'wtSpreader';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(spreader, table);\n      }\n      spreader.appendChild(table);\n    }\n    spreader.style.position = 'relative';\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(spreader, [A11Y_PRESENTATION()]);\n    }\n    return spreader;\n  }\n\n  /**\n   * @param {HTMLElement} spreader An element to the hider element is injected.\n   * @returns {HTMLElement}\n   */\n  createHider(spreader) {\n    const parent = spreader.parentNode;\n    let hider;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      hider = this.domBindings.rootDocument.createElement('div');\n      hider.className = 'wtHider';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(hider, spreader);\n      }\n      hider.appendChild(spreader);\n    }\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(hider, [A11Y_PRESENTATION()]);\n    }\n    return hider;\n  }\n\n  /**\n   *\n   * @param {HTMLElement} hider An element to the holder element is injected.\n   * @returns {HTMLElement}\n   */\n  createHolder(hider) {\n    const parent = hider.parentNode;\n    let holder;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      holder = this.domBindings.rootDocument.createElement('div');\n      holder.style.position = 'relative';\n      holder.className = 'wtHolder';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(holder, hider);\n      }\n      if (this.isMaster) {\n        holder.parentNode.className += 'ht_master handsontable';\n        holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');\n        if (this.wtSettings.getSetting('ariaTags')) {\n          setAttribute(holder.parentNode, [A11Y_PRESENTATION()]);\n        }\n      }\n      holder.appendChild(hider);\n    }\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(holder, [A11Y_PRESENTATION()]);\n    }\n    return holder;\n  }\n\n  /**\n   * Redraws the table.\n   *\n   * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n   *                                   If FALSE or UNDEFINED, will perform a full redraw.\n   * @returns {Table}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtSettings\n    } = this;\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.dataAccessObject;\n    const totalRows = wtSettings.getSetting('totalRows');\n    const totalColumns = wtSettings.getSetting('totalColumns');\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const rowHeadersCount = rowHeaders.length;\n    const columnHeaders = wtSettings.getSetting('columnHeaders');\n    const columnHeadersCount = columnHeaders.length;\n    let runFastDraw = fastDraw;\n    if (this.isMaster) {\n      wtOverlays.beforeDraw();\n      this.holderOffset = offset(this.holder);\n      runFastDraw = wtViewport.createCalculators(runFastDraw);\n      if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {\n        const leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n        const previousState = this.correctHeaderWidth;\n        this.correctHeaderWidth = leftScrollPos !== 0;\n        if (previousState !== this.correctHeaderWidth) {\n          runFastDraw = false;\n        }\n      }\n    }\n    if (runFastDraw) {\n      if (this.isMaster) {\n        wtOverlays.refresh(true);\n      }\n    } else {\n      if (this.isMaster) {\n        this.tableOffset = offset(this.TABLE);\n      } else {\n        this.tableOffset = this.dataAccessObject.parentTableOffset;\n      }\n      const startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n      const startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n      this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n      this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n      let performRedraw = true;\n\n      // Only master table rendering can be skipped\n      if (this.isMaster) {\n        this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).\n        const skipRender = {};\n        this.wtSettings.getSetting('beforeDraw', true, skipRender);\n        performRedraw = skipRender.skipRender !== true;\n      }\n      if (performRedraw) {\n        this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n        if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {\n          // do NOT render headers on the bottom or bottom-left corner overlay\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n        }\n        this.resetOversizedRows();\n        this.tableRenderer.setActiveOverlayName(this.name).setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n        let workspaceWidth;\n        if (this.isMaster) {\n          workspaceWidth = this.dataAccessObject.workspaceWidth;\n          wtViewport.containerWidth = null;\n          this.markOversizedColumnHeaders();\n        }\n        this.adjustColumnHeaderHeights();\n        if (this.isMaster || this.is(CLONE_BOTTOM)) {\n          this.markOversizedRows();\n        }\n        if (this.isMaster) {\n          if (!this.wtSettings.getSetting('externalRowCalculator')) {\n            wtViewport.createVisibleCalculators();\n          }\n          wtOverlays.refresh(false);\n          wtOverlays.applyToDOM();\n          const hiderWidth = outerWidth(this.hider);\n          const tableWidth = outerWidth(this.TABLE);\n          if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n            // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n            this.columnUtils.calculateWidths();\n            this.tableRenderer.renderer.colGroup.render();\n          }\n          if (workspaceWidth !== wtViewport.getWorkspaceWidth()) {\n            // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n            wtViewport.containerWidth = null;\n            this.columnUtils.calculateWidths();\n            this.tableRenderer.renderer.colGroup.render();\n          }\n          this.wtSettings.getSetting('onDraw', true);\n        } else if (this.is(CLONE_BOTTOM)) {\n          this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n        }\n      }\n    }\n    let positionChanged = false;\n    if (this.isMaster) {\n      positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n      if (wtOverlays.bottomOverlay.clone) {\n        positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n      }\n      positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;\n      if (wtOverlays.topInlineStartCornerOverlay) {\n        wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n      }\n      if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n      }\n    }\n    if (positionChanged) {\n      // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n      // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens\n      // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n      wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method\n      wtOverlays.adjustElementsSize();\n    } else {\n      this.dataAccessObject.selectionManager.setActiveOverlay(this.facadeGetter()).render(runFastDraw);\n    }\n    if (this.isMaster) {\n      wtOverlays.afterDraw();\n    }\n    this.dataAccessObject.drawn = true;\n    return this;\n  }\n\n  /**\n   * @param {number} col The visual column index.\n   */\n  markIfOversizedColumnHeader(col) {\n    const sourceColIndex = this.columnFilter.renderedToSource(col);\n    let level = this.wtSettings.getSetting('columnHeaders').length;\n    const defaultRowHeight = this.wtSettings.getSetting('defaultRowHeight');\n    let previousColHeaderHeight;\n    let currentHeader;\n    let currentHeaderHeight;\n    const columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];\n    while (level) {\n      level -= 1;\n      previousColHeaderHeight = this.getColumnHeaderHeight(level);\n      currentHeader = this.getColumnHeader(sourceColIndex, level);\n      if (!currentHeader) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      currentHeaderHeight = innerHeight(currentHeader);\n      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n      }\n      if (Array.isArray(columnHeaderHeightSetting)) {\n        if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== undefined) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n        }\n      } else if (!isNaN(columnHeaderHeightSetting)) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n      }\n      if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n      }\n    }\n  }\n\n  /**\n   *\n   */\n  adjustColumnHeaderHeights() {\n    const {\n      wtSettings\n    } = this;\n    const children = this.THEAD.childNodes;\n    const oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n    const columnHeaders = wtSettings.getSetting('columnHeaders');\n    for (let i = 0, len = columnHeaders.length; i < len; i++) {\n      if (oversizedColumnHeaders[i]) {\n        if (!children[i] || children[i].childNodes.length === 0) {\n          return;\n        }\n        children[i].childNodes[0].style.height = `${oversizedColumnHeaders[i]}px`;\n      }\n    }\n  }\n\n  /**\n   * Resets cache of row heights. The cache should be cached for each render cycle in a case\n   * when new cell values have content which increases/decreases cell height.\n   */\n  resetOversizedRows() {\n    const {\n      wtSettings\n    } = this;\n    const {\n      wtViewport\n    } = this.dataAccessObject;\n    if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n      return;\n    }\n    if (!wtSettings.getSetting('externalRowCalculator')) {\n      const rowsToRender = this.getRenderedRowsCount();\n\n      // Reset the oversized row cache for rendered rows\n      for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n        const sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n        if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n          wtViewport.oversizedRows[sourceRow] = undefined;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get cell element at coords.\n   * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n   * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n   * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n   * outmost header element.\n   *\n   * In case an element for the coords is not rendered, the method returns an error code.\n   * To produce the error code, the input parameters are validated in the order in which they\n   * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n   * the method returns the error code for the row.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n   *  -1 row before viewport\n   *  -2 row after viewport\n   *  -3 column before viewport\n   *  -4 column after viewport.\n   */\n  getCell(coords) {\n    let row = coords.row;\n    let column = coords.col;\n    const hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column);\n    if (hookResult && Array.isArray(hookResult)) {\n      [row, column] = hookResult;\n    }\n    if (this.isRowBeforeRenderedRows(row)) {\n      // row before rendered rows\n      return -1;\n    } else if (this.isRowAfterRenderedRows(row)) {\n      // row after rendered rows\n      return -2;\n    } else if (this.isColumnBeforeRenderedColumns(column)) {\n      // column before rendered columns\n      return -3;\n    } else if (this.isColumnAfterRenderedColumns(column)) {\n      // column after rendered columns\n      return -4;\n    }\n    const TR = this.getRow(row);\n    if (!TR && row >= 0) {\n      throw new Error('TR was expected to be rendered but is not');\n    }\n    const TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n    if (!TD && column >= 0) {\n      throw new Error('TD or TH was expected to be rendered but is not');\n    }\n    return TD;\n  }\n\n  /**\n   * Get the DOM element of the row with the provided index.\n   *\n   * @param {number} rowIndex Row index.\n   * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided\n   * index doesn't exist.\n   */\n  getRow(rowIndex) {\n    let renderedRowIndex = null;\n    let parentElement = null;\n    if (rowIndex < 0) {\n      var _this$rowFilter;\n      renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n      parentElement = this.THEAD;\n    } else {\n      var _this$rowFilter2;\n      renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);\n      parentElement = this.TBODY;\n    }\n    if (renderedRowIndex !== undefined && parentElement !== undefined) {\n      if (parentElement.childNodes.length < renderedRowIndex + 1) {\n        return false;\n      } else {\n        return parentElement.childNodes[renderedRowIndex];\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * GetColumnHeader.\n   *\n   * @param {number} col Column index.\n   * @param {number} [level=0] Header level (0 = most distant to the table).\n   * @returns {object} HTMLElement on success or undefined on error.\n   */\n  getColumnHeader(col) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const TR = this.THEAD.childNodes[level];\n    return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n  }\n\n  /**\n   * Gets all columns headers (TH elements) from the table.\n   *\n   * @param {number} column A source column index.\n   * @returns {HTMLTableCellElement[]}\n   */\n  getColumnHeaders(column) {\n    const THs = [];\n    const visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n    this.THEAD.childNodes.forEach(TR => {\n      const TH = TR.childNodes[visibleColumn];\n      if (TH) {\n        THs.push(TH);\n      }\n    });\n    return THs;\n  }\n\n  /**\n   * GetRowHeader.\n   *\n   * @param {number} row Row index.\n   * @param {number} [level=0] Header level (0 = most distant to the table).\n   * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have\n   *   row headers`.\n   */\n  getRowHeader(row) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n    if (level >= rowHeadersCount) {\n      return;\n    }\n    const renderedRow = this.rowFilter.sourceToRendered(row);\n    const visibleRow = renderedRow < 0 ? this.rowFilter.sourceRowToVisibleColHeadedRow(row) : renderedRow;\n    const parentElement = renderedRow < 0 ? this.THEAD : this.TBODY;\n    const TR = parentElement.childNodes[visibleRow];\n    return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n  }\n\n  /**\n   * Gets all rows headers (TH elements) from the table.\n   *\n   * @param {number} row A source row index.\n   * @returns {HTMLTableCellElement[]}\n   */\n  getRowHeaders(row) {\n    const THs = [];\n    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n    for (let renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n      const TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      const TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n      if (TH) {\n        THs.push(TH);\n      }\n    }\n    return THs;\n  }\n\n  /**\n   * Returns cell coords object for a given TD (or a child element of a TD element).\n   *\n   * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n   * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the\n   *   provided element is not applicable.\n   */\n  getCoords(TD) {\n    let cellElement = TD;\n    if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n      cellElement = closest(cellElement, ['TD', 'TH']);\n    }\n    if (cellElement === null) {\n      return null;\n    }\n    const TR = cellElement.parentNode;\n    const CONTAINER = TR.parentNode;\n    let row = index(TR);\n    let col = cellElement.cellIndex;\n    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n      if (CONTAINER.nodeName === 'THEAD') {\n        row -= CONTAINER.childNodes.length;\n      }\n    } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n      const totalRows = this.wtSettings.getSetting('totalRows');\n      row = totalRows - CONTAINER.childNodes.length + row;\n    } else if (CONTAINER === this.THEAD) {\n      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n    } else {\n      row = this.rowFilter.renderedToSource(row);\n    }\n    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {\n      col = this.columnFilter.offsettedTH(col);\n    } else {\n      col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n    }\n    return this.wot.createCellCoords(row, col);\n  }\n\n  /**\n   * Check if any of the rendered rows is higher than expected, and if so, cache them.\n   */\n  markOversizedRows() {\n    if (this.wtSettings.getSetting('externalRowCalculator')) {\n      return;\n    }\n    let rowCount = this.TBODY.childNodes.length;\n    const expectedTableHeight = rowCount * this.wtSettings.getSetting('defaultRowHeight');\n    const actualTableHeight = innerHeight(this.TBODY) - 1;\n    let previousRowHeight;\n    let rowInnerHeight;\n    let sourceRowIndex;\n    let currentTr;\n    let rowHeader;\n    if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {\n      // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n      return;\n    }\n    while (rowCount) {\n      rowCount -= 1;\n      sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n      previousRowHeight = this.getRowHeight(sourceRowIndex);\n      currentTr = this.getTrForRow(sourceRowIndex);\n      rowHeader = currentTr.querySelector('th');\n      if (rowHeader) {\n        rowInnerHeight = innerHeight(rowHeader);\n      } else {\n        rowInnerHeight = innerHeight(currentTr) - 1;\n      }\n      if (!previousRowHeight && this.wtSettings.getSetting('defaultRowHeight') < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n        rowInnerHeight += 1;\n        this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n      }\n    }\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @returns {HTMLTableElement}\n   */\n  getTrForRow(row) {\n    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n  }\n\n  /**\n   * Checks if the column index (negative value from -1 to N) is rendered.\n   *\n   * @param {number} column The column index (negative value from -1 to N).\n   * @returns {boolean}\n   */\n  isColumnHeaderRendered(column) {\n    if (column >= 0) {\n      return false;\n    }\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    const rowHeadersCount = rowHeaders.length;\n    return Math.abs(column) <= rowHeadersCount;\n  }\n\n  /**\n   * Checks if the row index (negative value from -1 to N) is rendered.\n   *\n   * @param {number} row The row index (negative value from -1 to N).\n   * @returns {boolean}\n   */\n  isRowHeaderRendered(row) {\n    if (row >= 0) {\n      return false;\n    }\n    const columnHeaders = this.wtSettings.getSetting('columnHeaders');\n    const columnHeadersCount = columnHeaders.length;\n    return Math.abs(row) <= columnHeadersCount;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given row index is lower than the index of the first row that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * Negative row index is used to check the columns' headers.\n   *\n   *  Headers\n   *           +--------------+                                     │\n   *       -3  │    │    │    │                                     │\n   *           +--------------+                                     │\n   *       -2  │    │    │    │                                     │ TRUE\n   *           +--------------+                                     │\n   *       -1  │    │    │    │                                     │\n   *  Cells  +==================+                                   │\n   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n   *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n   *           +--------------+                                     │ FALSE\n   *        2  │ A3 │ B3 │ C3 │                                     │\n   *           +--------------+                                  ---+ last rendered row\n   *                                                                │\n   *                                                                │ FALSE\n   *\n   * @param {number} row The visual row index.\n   * @memberof Table#\n   * @function isRowBeforeRenderedRows\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isRowBeforeRenderedRows(row) {\n    const first = this.getFirstRenderedRow();\n\n    // Check the headers only in case when the first rendered row is -1 or 0.\n    // This is an indication that the overlay is placed on the most top position.\n    if (row < 0 && first <= 0) {\n      return !this.isRowHeaderRendered(row);\n    }\n    return row < first;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is greater than the index of the last column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * The negative row index is used to check the columns' headers. However,\n   * keep in mind that for negative indexes, the method always returns FALSE as\n   * it is not possible to render headers partially. The \"after\" index can not be\n   * lower than -1.\n   *\n   *  Headers\n   *           +--------------+                                     │\n   *       -3  │    │    │    │                                     │\n   *           +--------------+                                     │\n   *       -2  │    │    │    │                                     │ FALSE\n   *           +--------------+                                     │\n   *       -1  │    │    │    │                                     │\n   *  Cells  +==================+                                   │\n   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n   *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n   *           +--------------+                                     │ FALSE\n   *        2  │ A3 │ B3 │ C3 │                                     │\n   *           +--------------+                                  ---+ last rendered row\n   *                                                                │\n   *                                                                │ TRUE\n   *\n   * @param {number} row The visual row index.\n   * @memberof Table#\n   * @function isRowAfterRenderedRows\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isRowAfterRenderedRows(row) {\n    return row > this.getLastRenderedRow();\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is lower than the index of the first column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * Negative column index is used to check the rows' headers.\n   *\n   *                            For fixedColumnsStart: 1 the master overlay\n   *                            do not render this first columns.\n   *  Headers    -3   -2   -1    |\n   *           +----+----+----║┄ ┄ +------+------+\n   *           │    │    │    ║    │  B1  │  C1  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B2  │  C2  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B3  │  C3  │\n   *           +----+----+----║┄ ┄ +------+------+\n   *                               ╷             ╷\n   *      -------------------------+-------------+---------------->\n   *          TRUE             first    FALSE   last         FALSE\n   *                           rendered         rendered\n   *                           column           column\n   *\n   * @param {number} column The visual column index.\n   * @memberof Table#\n   * @function isColumnBeforeRenderedColumns\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isColumnBeforeRenderedColumns(column) {\n    const first = this.getFirstRenderedColumn();\n\n    // Check the headers only in case when the first rendered column is -1 or 0.\n    // This is an indication that the overlay is placed on the most left position.\n    if (column < 0 && first <= 0) {\n      return !this.isColumnHeaderRendered(column);\n    }\n    return column < first;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is greater than the index of the last column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * The negative column index is used to check the rows' headers. However,\n   * keep in mind that for negative indexes, the method always returns FALSE as\n   * it is not possible to render headers partially. The \"after\" index can not be\n   * lower than -1.\n   *\n   *                            For fixedColumnsStart: 1 the master overlay\n   *                            do not render this first columns.\n   *  Headers    -3   -2   -1    |\n   *           +----+----+----║┄ ┄ +------+------+\n   *           │    │    │    ║    │  B1  │  C1  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B2  │  C2  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B3  │  C3  │\n   *           +----+----+----║┄ ┄ +------+------+\n   *                               ╷             ╷\n   *      -------------------------+-------------+---------------->\n   *          FALSE             first    FALSE   last         TRUE\n   *                           rendered         rendered\n   *                           column           column\n   *\n   * @param {number} column The visual column index.\n   * @memberof Table#\n   * @function isColumnAfterRenderedColumns\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isColumnAfterRenderedColumns(column) {\n    return this.columnFilter && column > this.getLastRenderedColumn();\n  }\n  isColumnAfterViewport(column) {\n    return this.columnFilter && column > this.getLastVisibleColumn();\n  }\n  isRowAfterViewport(row) {\n    return this.rowFilter && row > this.getLastVisibleRow();\n  }\n  isColumnBeforeViewport(column) {\n    return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n  }\n  isLastRowFullyVisible() {\n    return this.getLastVisibleRow() === this.getLastRenderedRow();\n  }\n  isLastColumnFullyVisible() {\n    return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n  }\n  allRowsInViewport() {\n    return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();\n  }\n  allColumnsInViewport() {\n    return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();\n  }\n\n  /**\n   * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n   *\n   * @param {number} sourceRow The physical row index.\n   * @returns {number}\n   */\n  getRowHeight(sourceRow) {\n    return this.rowUtils.getHeight(sourceRow);\n  }\n\n  /**\n   * @param {number} level The column level.\n   * @returns {number}\n   */\n  getColumnHeaderHeight(level) {\n    return this.columnUtils.getHeaderHeight(level);\n  }\n\n  /**\n   * @param {number} sourceColumn The physical column index.\n   * @returns {number}\n   */\n  getColumnWidth(sourceColumn) {\n    return this.columnUtils.getWidth(sourceColumn);\n  }\n\n  /**\n   * @param {number} sourceColumn The physical column index.\n   * @returns {number}\n   */\n  getStretchedColumnWidth(sourceColumn) {\n    return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n  }\n\n  /**\n   * Checks if the table has defined size. It returns `true` when the table has width and height\n   * set bigger than `0px`.\n   *\n   * @returns {boolean}\n   */\n  hasDefinedSize() {\n    return this.hasTableHeight && this.hasTableWidth;\n  }\n\n  /**\n   * Gets table's width. The returned width is the width of the rendered cells that fit in the\n   * current viewport. The value may change depends on the viewport position (scroll position).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    return outerWidth(this.TABLE);\n  }\n\n  /**\n   * Gets table's height. The returned height is the height of the rendered cells that fit in the\n   * current viewport. The value may change depends on the viewport position (scroll position).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    return outerHeight(this.TABLE);\n  }\n\n  /**\n   * Gets table's total width. The returned width is the width of all rendered cells (including headers)\n   * that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  getTotalWidth() {\n    const width = outerWidth(this.hider);\n\n    // when the overlay's table does not have any cells the hider returns 0, get then width from the table element\n    return width !== 0 ? width : this.getWidth();\n  }\n\n  /**\n   * Gets table's total height. The returned height is the height of all rendered cells (including headers)\n   * that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  getTotalHeight() {\n    const height = outerHeight(this.hider);\n\n    // when the overlay's table does not have any cells the hider returns 0, get then height from the table element\n    return height !== 0 ? height : this.getHeight();\n  }\n\n  /**\n   * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n   * has CSS 'display' property different than 'none'.\n   *\n   * @returns {boolean}\n   */\n  isVisible() {\n    return isVisible(this.TABLE);\n  }\n\n  /**\n   * Modify row header widths provided by user in class contructor.\n   *\n   * @private\n   * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n   * @returns {number}\n   */\n  _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n    let widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n    if (Array.isArray(widths)) {\n      widths = [...widths];\n      widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n    } else {\n      widths = this._correctRowHeaderWidth(widths);\n    }\n    return widths;\n  }\n\n  /**\n   * Correct row header width if necessary.\n   *\n   * @private\n   * @param {number} width The width to process.\n   * @returns {number}\n   */\n  _correctRowHeaderWidth(width) {\n    let rowHeaderWidth = width;\n    if (typeof width !== 'number') {\n      rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    }\n    if (this.correctHeaderWidth) {\n      rowHeaderWidth += 1;\n    }\n    return rowHeaderWidth;\n  }\n}\nexport default Table;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","hasClass","index","offset","removeTextNodes","overlayContainsElement","closest","outerHeight","outerWidth","innerHeight","isVisible","setAttribute","isFunction","ColumnFilter","RowFilter","Renderer","ColumnUtils","RowUtils","CLONE_TOP","CLONE_BOTTOM","CLONE_INLINE_START","CLONE_TOP_INLINE_START_CORNER","CLONE_BOTTOM_INLINE_START_CORNER","A11Y_PRESENTATION","Table","constructor","dataAccessObject","facadeGetter","domBindings","wtSettings","name","isMaster","instance","wot","TABLE","rootTable","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","getSettingPure","update","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","THEAD","COLGROUP","TBODY","cellRenderer","is","overlayTypeName","rootDocument","querySelector","createElement","appendChild","insertBefore","table","parent","nodeType","Node","ELEMENT_NODE","className","style","position","getSetting","draw","fastDraw","arguments","length","undefined","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","runFastDraw","beforeDraw","holderOffset","createCalculators","leftScrollPos","inlineStartOverlay","getScrollPosition","previousState","refresh","tableOffset","parentTableOffset","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","resetOversizedRows","setActiveOverlayName","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","createVisibleCalculators","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","getWorkspaceWidth","cloneSource","adjustElementsSize","positionChanged","topOverlay","resetFixedPosition","bottomOverlay","clone","topInlineStartCornerOverlay","bottomInlineStartCornerOverlay","refreshAll","selectionManager","setActiveOverlay","afterDraw","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","Array","isArray","isNaN","children","childNodes","len","height","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","getCell","coords","row","column","hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","TR","getRow","Error","TD","sourceColumnToVisibleRowHeadedColumn","rowIndex","renderedRowIndex","parentElement","_this$rowFilter","sourceRowToVisibleColHeadedRow","_this$rowFilter2","sourceToRendered","getColumnHeaders","THs","visibleColumn","forEach","TH","push","getRowHeader","renderedRow","visibleRow","getRowHeaders","getCoords","cellElement","nodeName","CONTAINER","cellIndex","visibleColHeadedRowToSourceRow","offsettedTH","visibleRowHeadedColumnToSourceColumn","createCellCoords","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderRendered","Math","abs","isRowHeaderRendered","first","getLastRenderedRow","getLastRenderedColumn","isColumnAfterViewport","getLastVisibleColumn","isRowAfterViewport","getLastVisibleRow","isColumnBeforeViewport","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","hasTableHeight","hasTableWidth","getTotalWidth","width","getTotalHeight","rowHeaderWidthFactory","widths","_correctRowHeaderWidth","rowHeaderWidth"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/table.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { hasClass, index, offset, removeTextNodes, overlayContainsElement, closest, outerHeight, outerWidth, innerHeight, isVisible, setAttribute } from \"../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER } from \"./overlay/index.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../helpers/a11y.mjs\";\n/**\n * @todo These mixes are never added to the class Table, however their members are used here.\n * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.\n * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.\n * @mixes stickyColumnsStart\n * @mixes stickyRowsBottom\n * @mixes stickyRowsTop\n * @mixes calculatedRows\n * @mixes calculatedColumns\n * @abstract\n */\nclass Table {\n  /**\n   *\n   * @abstract\n   * @param {TableDao} dataAccessObject The data access object.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.\n   */\n  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"TBODY\", null);\n    _defineProperty(this, \"THEAD\", null);\n    _defineProperty(this, \"COLGROUP\", null);\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableHeight\", true);\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableWidth\", true);\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isTableVisible\", false);\n    _defineProperty(this, \"tableOffset\", 0);\n    _defineProperty(this, \"holderOffset\", 0);\n    this.domBindings = domBindings;\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = name === 'master';\n    this.name = name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n\n    // legacy support\n    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.\n    this.wot = this.dataAccessObject.wot;\n    this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n\n    // TODO refactoring, to recognize the legitimacy of moving them into domBidings\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.correctHeaderWidth = false;\n    const origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');\n\n    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n    this.wtSettings.update('rowHeaderWidth', () => this._modifyRowHeaderWidth(origRowHeaderWidth));\n    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n\n    this.tableRenderer = new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wtSettings.getSettingPure('cellRenderer')\n    });\n  }\n\n  /**\n   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n  is(overlayTypeName) {\n    // todo refactoring: eliminate all protected and private usages\n    return this.name === overlayTypeName;\n  }\n\n  /**\n   *\n   */\n  fixTableDomTree() {\n    const rootDocument = this.domBindings.rootDocument;\n    this.TBODY = this.TABLE.querySelector('tbody');\n    if (!this.TBODY) {\n      this.TBODY = rootDocument.createElement('tbody');\n      this.TABLE.appendChild(this.TBODY);\n    }\n    this.THEAD = this.TABLE.querySelector('thead');\n    if (!this.THEAD) {\n      this.THEAD = rootDocument.createElement('thead');\n      this.TABLE.insertBefore(this.THEAD, this.TBODY);\n    }\n    this.COLGROUP = this.TABLE.querySelector('colgroup');\n    if (!this.COLGROUP) {\n      this.COLGROUP = rootDocument.createElement('colgroup');\n      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n    }\n  }\n\n  /**\n   * @param {HTMLTableElement} table An element to process.\n   * @returns {HTMLElement}\n   */\n  createSpreader(table) {\n    const parent = table.parentNode;\n    let spreader;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      spreader = this.domBindings.rootDocument.createElement('div');\n      spreader.className = 'wtSpreader';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(spreader, table);\n      }\n      spreader.appendChild(table);\n    }\n    spreader.style.position = 'relative';\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(spreader, [A11Y_PRESENTATION()]);\n    }\n    return spreader;\n  }\n\n  /**\n   * @param {HTMLElement} spreader An element to the hider element is injected.\n   * @returns {HTMLElement}\n   */\n  createHider(spreader) {\n    const parent = spreader.parentNode;\n    let hider;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      hider = this.domBindings.rootDocument.createElement('div');\n      hider.className = 'wtHider';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(hider, spreader);\n      }\n      hider.appendChild(spreader);\n    }\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(hider, [A11Y_PRESENTATION()]);\n    }\n    return hider;\n  }\n\n  /**\n   *\n   * @param {HTMLElement} hider An element to the holder element is injected.\n   * @returns {HTMLElement}\n   */\n  createHolder(hider) {\n    const parent = hider.parentNode;\n    let holder;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      holder = this.domBindings.rootDocument.createElement('div');\n      holder.style.position = 'relative';\n      holder.className = 'wtHolder';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(holder, hider);\n      }\n      if (this.isMaster) {\n        holder.parentNode.className += 'ht_master handsontable';\n        holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');\n        if (this.wtSettings.getSetting('ariaTags')) {\n          setAttribute(holder.parentNode, [A11Y_PRESENTATION()]);\n        }\n      }\n      holder.appendChild(hider);\n    }\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(holder, [A11Y_PRESENTATION()]);\n    }\n    return holder;\n  }\n\n  /**\n   * Redraws the table.\n   *\n   * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n   *                                   If FALSE or UNDEFINED, will perform a full redraw.\n   * @returns {Table}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtSettings\n    } = this;\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.dataAccessObject;\n    const totalRows = wtSettings.getSetting('totalRows');\n    const totalColumns = wtSettings.getSetting('totalColumns');\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const rowHeadersCount = rowHeaders.length;\n    const columnHeaders = wtSettings.getSetting('columnHeaders');\n    const columnHeadersCount = columnHeaders.length;\n    let runFastDraw = fastDraw;\n    if (this.isMaster) {\n      wtOverlays.beforeDraw();\n      this.holderOffset = offset(this.holder);\n      runFastDraw = wtViewport.createCalculators(runFastDraw);\n      if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {\n        const leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n        const previousState = this.correctHeaderWidth;\n        this.correctHeaderWidth = leftScrollPos !== 0;\n        if (previousState !== this.correctHeaderWidth) {\n          runFastDraw = false;\n        }\n      }\n    }\n    if (runFastDraw) {\n      if (this.isMaster) {\n        wtOverlays.refresh(true);\n      }\n    } else {\n      if (this.isMaster) {\n        this.tableOffset = offset(this.TABLE);\n      } else {\n        this.tableOffset = this.dataAccessObject.parentTableOffset;\n      }\n      const startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n      const startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n      this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n      this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n      let performRedraw = true;\n\n      // Only master table rendering can be skipped\n      if (this.isMaster) {\n        this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).\n        const skipRender = {};\n        this.wtSettings.getSetting('beforeDraw', true, skipRender);\n        performRedraw = skipRender.skipRender !== true;\n      }\n      if (performRedraw) {\n        this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n        if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {\n          // do NOT render headers on the bottom or bottom-left corner overlay\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n        }\n        this.resetOversizedRows();\n        this.tableRenderer.setActiveOverlayName(this.name).setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n        let workspaceWidth;\n        if (this.isMaster) {\n          workspaceWidth = this.dataAccessObject.workspaceWidth;\n          wtViewport.containerWidth = null;\n          this.markOversizedColumnHeaders();\n        }\n        this.adjustColumnHeaderHeights();\n        if (this.isMaster || this.is(CLONE_BOTTOM)) {\n          this.markOversizedRows();\n        }\n        if (this.isMaster) {\n          if (!this.wtSettings.getSetting('externalRowCalculator')) {\n            wtViewport.createVisibleCalculators();\n          }\n          wtOverlays.refresh(false);\n          wtOverlays.applyToDOM();\n          const hiderWidth = outerWidth(this.hider);\n          const tableWidth = outerWidth(this.TABLE);\n          if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n            // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n            this.columnUtils.calculateWidths();\n            this.tableRenderer.renderer.colGroup.render();\n          }\n          if (workspaceWidth !== wtViewport.getWorkspaceWidth()) {\n            // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n            wtViewport.containerWidth = null;\n            this.columnUtils.calculateWidths();\n            this.tableRenderer.renderer.colGroup.render();\n          }\n          this.wtSettings.getSetting('onDraw', true);\n        } else if (this.is(CLONE_BOTTOM)) {\n          this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n        }\n      }\n    }\n    let positionChanged = false;\n    if (this.isMaster) {\n      positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n      if (wtOverlays.bottomOverlay.clone) {\n        positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n      }\n      positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;\n      if (wtOverlays.topInlineStartCornerOverlay) {\n        wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n      }\n      if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n      }\n    }\n    if (positionChanged) {\n      // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n      // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens\n      // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n      wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method\n      wtOverlays.adjustElementsSize();\n    } else {\n      this.dataAccessObject.selectionManager.setActiveOverlay(this.facadeGetter()).render(runFastDraw);\n    }\n    if (this.isMaster) {\n      wtOverlays.afterDraw();\n    }\n    this.dataAccessObject.drawn = true;\n    return this;\n  }\n\n  /**\n   * @param {number} col The visual column index.\n   */\n  markIfOversizedColumnHeader(col) {\n    const sourceColIndex = this.columnFilter.renderedToSource(col);\n    let level = this.wtSettings.getSetting('columnHeaders').length;\n    const defaultRowHeight = this.wtSettings.getSetting('defaultRowHeight');\n    let previousColHeaderHeight;\n    let currentHeader;\n    let currentHeaderHeight;\n    const columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];\n    while (level) {\n      level -= 1;\n      previousColHeaderHeight = this.getColumnHeaderHeight(level);\n      currentHeader = this.getColumnHeader(sourceColIndex, level);\n      if (!currentHeader) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      currentHeaderHeight = innerHeight(currentHeader);\n      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n      }\n      if (Array.isArray(columnHeaderHeightSetting)) {\n        if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== undefined) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n        }\n      } else if (!isNaN(columnHeaderHeightSetting)) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n      }\n      if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n      }\n    }\n  }\n\n  /**\n   *\n   */\n  adjustColumnHeaderHeights() {\n    const {\n      wtSettings\n    } = this;\n    const children = this.THEAD.childNodes;\n    const oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n    const columnHeaders = wtSettings.getSetting('columnHeaders');\n    for (let i = 0, len = columnHeaders.length; i < len; i++) {\n      if (oversizedColumnHeaders[i]) {\n        if (!children[i] || children[i].childNodes.length === 0) {\n          return;\n        }\n        children[i].childNodes[0].style.height = `${oversizedColumnHeaders[i]}px`;\n      }\n    }\n  }\n\n  /**\n   * Resets cache of row heights. The cache should be cached for each render cycle in a case\n   * when new cell values have content which increases/decreases cell height.\n   */\n  resetOversizedRows() {\n    const {\n      wtSettings\n    } = this;\n    const {\n      wtViewport\n    } = this.dataAccessObject;\n    if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n      return;\n    }\n    if (!wtSettings.getSetting('externalRowCalculator')) {\n      const rowsToRender = this.getRenderedRowsCount();\n\n      // Reset the oversized row cache for rendered rows\n      for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n        const sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n        if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n          wtViewport.oversizedRows[sourceRow] = undefined;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get cell element at coords.\n   * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n   * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n   * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n   * outmost header element.\n   *\n   * In case an element for the coords is not rendered, the method returns an error code.\n   * To produce the error code, the input parameters are validated in the order in which they\n   * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n   * the method returns the error code for the row.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n   *  -1 row before viewport\n   *  -2 row after viewport\n   *  -3 column before viewport\n   *  -4 column after viewport.\n   */\n  getCell(coords) {\n    let row = coords.row;\n    let column = coords.col;\n    const hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column);\n    if (hookResult && Array.isArray(hookResult)) {\n      [row, column] = hookResult;\n    }\n    if (this.isRowBeforeRenderedRows(row)) {\n      // row before rendered rows\n      return -1;\n    } else if (this.isRowAfterRenderedRows(row)) {\n      // row after rendered rows\n      return -2;\n    } else if (this.isColumnBeforeRenderedColumns(column)) {\n      // column before rendered columns\n      return -3;\n    } else if (this.isColumnAfterRenderedColumns(column)) {\n      // column after rendered columns\n      return -4;\n    }\n    const TR = this.getRow(row);\n    if (!TR && row >= 0) {\n      throw new Error('TR was expected to be rendered but is not');\n    }\n    const TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n    if (!TD && column >= 0) {\n      throw new Error('TD or TH was expected to be rendered but is not');\n    }\n    return TD;\n  }\n\n  /**\n   * Get the DOM element of the row with the provided index.\n   *\n   * @param {number} rowIndex Row index.\n   * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided\n   * index doesn't exist.\n   */\n  getRow(rowIndex) {\n    let renderedRowIndex = null;\n    let parentElement = null;\n    if (rowIndex < 0) {\n      var _this$rowFilter;\n      renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n      parentElement = this.THEAD;\n    } else {\n      var _this$rowFilter2;\n      renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);\n      parentElement = this.TBODY;\n    }\n    if (renderedRowIndex !== undefined && parentElement !== undefined) {\n      if (parentElement.childNodes.length < renderedRowIndex + 1) {\n        return false;\n      } else {\n        return parentElement.childNodes[renderedRowIndex];\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * GetColumnHeader.\n   *\n   * @param {number} col Column index.\n   * @param {number} [level=0] Header level (0 = most distant to the table).\n   * @returns {object} HTMLElement on success or undefined on error.\n   */\n  getColumnHeader(col) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const TR = this.THEAD.childNodes[level];\n    return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n  }\n\n  /**\n   * Gets all columns headers (TH elements) from the table.\n   *\n   * @param {number} column A source column index.\n   * @returns {HTMLTableCellElement[]}\n   */\n  getColumnHeaders(column) {\n    const THs = [];\n    const visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n    this.THEAD.childNodes.forEach(TR => {\n      const TH = TR.childNodes[visibleColumn];\n      if (TH) {\n        THs.push(TH);\n      }\n    });\n    return THs;\n  }\n\n  /**\n   * GetRowHeader.\n   *\n   * @param {number} row Row index.\n   * @param {number} [level=0] Header level (0 = most distant to the table).\n   * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have\n   *   row headers`.\n   */\n  getRowHeader(row) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n    if (level >= rowHeadersCount) {\n      return;\n    }\n    const renderedRow = this.rowFilter.sourceToRendered(row);\n    const visibleRow = renderedRow < 0 ? this.rowFilter.sourceRowToVisibleColHeadedRow(row) : renderedRow;\n    const parentElement = renderedRow < 0 ? this.THEAD : this.TBODY;\n    const TR = parentElement.childNodes[visibleRow];\n    return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n  }\n\n  /**\n   * Gets all rows headers (TH elements) from the table.\n   *\n   * @param {number} row A source row index.\n   * @returns {HTMLTableCellElement[]}\n   */\n  getRowHeaders(row) {\n    const THs = [];\n    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n    for (let renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n      const TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      const TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n      if (TH) {\n        THs.push(TH);\n      }\n    }\n    return THs;\n  }\n\n  /**\n   * Returns cell coords object for a given TD (or a child element of a TD element).\n   *\n   * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n   * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the\n   *   provided element is not applicable.\n   */\n  getCoords(TD) {\n    let cellElement = TD;\n    if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n      cellElement = closest(cellElement, ['TD', 'TH']);\n    }\n    if (cellElement === null) {\n      return null;\n    }\n    const TR = cellElement.parentNode;\n    const CONTAINER = TR.parentNode;\n    let row = index(TR);\n    let col = cellElement.cellIndex;\n    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n      if (CONTAINER.nodeName === 'THEAD') {\n        row -= CONTAINER.childNodes.length;\n      }\n    } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n      const totalRows = this.wtSettings.getSetting('totalRows');\n      row = totalRows - CONTAINER.childNodes.length + row;\n    } else if (CONTAINER === this.THEAD) {\n      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n    } else {\n      row = this.rowFilter.renderedToSource(row);\n    }\n    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {\n      col = this.columnFilter.offsettedTH(col);\n    } else {\n      col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n    }\n    return this.wot.createCellCoords(row, col);\n  }\n\n  /**\n   * Check if any of the rendered rows is higher than expected, and if so, cache them.\n   */\n  markOversizedRows() {\n    if (this.wtSettings.getSetting('externalRowCalculator')) {\n      return;\n    }\n    let rowCount = this.TBODY.childNodes.length;\n    const expectedTableHeight = rowCount * this.wtSettings.getSetting('defaultRowHeight');\n    const actualTableHeight = innerHeight(this.TBODY) - 1;\n    let previousRowHeight;\n    let rowInnerHeight;\n    let sourceRowIndex;\n    let currentTr;\n    let rowHeader;\n    if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {\n      // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n      return;\n    }\n    while (rowCount) {\n      rowCount -= 1;\n      sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n      previousRowHeight = this.getRowHeight(sourceRowIndex);\n      currentTr = this.getTrForRow(sourceRowIndex);\n      rowHeader = currentTr.querySelector('th');\n      if (rowHeader) {\n        rowInnerHeight = innerHeight(rowHeader);\n      } else {\n        rowInnerHeight = innerHeight(currentTr) - 1;\n      }\n      if (!previousRowHeight && this.wtSettings.getSetting('defaultRowHeight') < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n        rowInnerHeight += 1;\n        this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n      }\n    }\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @returns {HTMLTableElement}\n   */\n  getTrForRow(row) {\n    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n  }\n\n  /**\n   * Checks if the column index (negative value from -1 to N) is rendered.\n   *\n   * @param {number} column The column index (negative value from -1 to N).\n   * @returns {boolean}\n   */\n  isColumnHeaderRendered(column) {\n    if (column >= 0) {\n      return false;\n    }\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    const rowHeadersCount = rowHeaders.length;\n    return Math.abs(column) <= rowHeadersCount;\n  }\n\n  /**\n   * Checks if the row index (negative value from -1 to N) is rendered.\n   *\n   * @param {number} row The row index (negative value from -1 to N).\n   * @returns {boolean}\n   */\n  isRowHeaderRendered(row) {\n    if (row >= 0) {\n      return false;\n    }\n    const columnHeaders = this.wtSettings.getSetting('columnHeaders');\n    const columnHeadersCount = columnHeaders.length;\n    return Math.abs(row) <= columnHeadersCount;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given row index is lower than the index of the first row that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * Negative row index is used to check the columns' headers.\n   *\n   *  Headers\n   *           +--------------+                                     │\n   *       -3  │    │    │    │                                     │\n   *           +--------------+                                     │\n   *       -2  │    │    │    │                                     │ TRUE\n   *           +--------------+                                     │\n   *       -1  │    │    │    │                                     │\n   *  Cells  +==================+                                   │\n   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n   *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n   *           +--------------+                                     │ FALSE\n   *        2  │ A3 │ B3 │ C3 │                                     │\n   *           +--------------+                                  ---+ last rendered row\n   *                                                                │\n   *                                                                │ FALSE\n   *\n   * @param {number} row The visual row index.\n   * @memberof Table#\n   * @function isRowBeforeRenderedRows\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isRowBeforeRenderedRows(row) {\n    const first = this.getFirstRenderedRow();\n\n    // Check the headers only in case when the first rendered row is -1 or 0.\n    // This is an indication that the overlay is placed on the most top position.\n    if (row < 0 && first <= 0) {\n      return !this.isRowHeaderRendered(row);\n    }\n    return row < first;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is greater than the index of the last column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * The negative row index is used to check the columns' headers. However,\n   * keep in mind that for negative indexes, the method always returns FALSE as\n   * it is not possible to render headers partially. The \"after\" index can not be\n   * lower than -1.\n   *\n   *  Headers\n   *           +--------------+                                     │\n   *       -3  │    │    │    │                                     │\n   *           +--------------+                                     │\n   *       -2  │    │    │    │                                     │ FALSE\n   *           +--------------+                                     │\n   *       -1  │    │    │    │                                     │\n   *  Cells  +==================+                                   │\n   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n   *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n   *           +--------------+                                     │ FALSE\n   *        2  │ A3 │ B3 │ C3 │                                     │\n   *           +--------------+                                  ---+ last rendered row\n   *                                                                │\n   *                                                                │ TRUE\n   *\n   * @param {number} row The visual row index.\n   * @memberof Table#\n   * @function isRowAfterRenderedRows\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isRowAfterRenderedRows(row) {\n    return row > this.getLastRenderedRow();\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is lower than the index of the first column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * Negative column index is used to check the rows' headers.\n   *\n   *                            For fixedColumnsStart: 1 the master overlay\n   *                            do not render this first columns.\n   *  Headers    -3   -2   -1    |\n   *           +----+----+----║┄ ┄ +------+------+\n   *           │    │    │    ║    │  B1  │  C1  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B2  │  C2  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B3  │  C3  │\n   *           +----+----+----║┄ ┄ +------+------+\n   *                               ╷             ╷\n   *      -------------------------+-------------+---------------->\n   *          TRUE             first    FALSE   last         FALSE\n   *                           rendered         rendered\n   *                           column           column\n   *\n   * @param {number} column The visual column index.\n   * @memberof Table#\n   * @function isColumnBeforeRenderedColumns\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isColumnBeforeRenderedColumns(column) {\n    const first = this.getFirstRenderedColumn();\n\n    // Check the headers only in case when the first rendered column is -1 or 0.\n    // This is an indication that the overlay is placed on the most left position.\n    if (column < 0 && first <= 0) {\n      return !this.isColumnHeaderRendered(column);\n    }\n    return column < first;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is greater than the index of the last column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * The negative column index is used to check the rows' headers. However,\n   * keep in mind that for negative indexes, the method always returns FALSE as\n   * it is not possible to render headers partially. The \"after\" index can not be\n   * lower than -1.\n   *\n   *                            For fixedColumnsStart: 1 the master overlay\n   *                            do not render this first columns.\n   *  Headers    -3   -2   -1    |\n   *           +----+----+----║┄ ┄ +------+------+\n   *           │    │    │    ║    │  B1  │  C1  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B2  │  C2  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B3  │  C3  │\n   *           +----+----+----║┄ ┄ +------+------+\n   *                               ╷             ╷\n   *      -------------------------+-------------+---------------->\n   *          FALSE             first    FALSE   last         TRUE\n   *                           rendered         rendered\n   *                           column           column\n   *\n   * @param {number} column The visual column index.\n   * @memberof Table#\n   * @function isColumnAfterRenderedColumns\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isColumnAfterRenderedColumns(column) {\n    return this.columnFilter && column > this.getLastRenderedColumn();\n  }\n  isColumnAfterViewport(column) {\n    return this.columnFilter && column > this.getLastVisibleColumn();\n  }\n  isRowAfterViewport(row) {\n    return this.rowFilter && row > this.getLastVisibleRow();\n  }\n  isColumnBeforeViewport(column) {\n    return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n  }\n  isLastRowFullyVisible() {\n    return this.getLastVisibleRow() === this.getLastRenderedRow();\n  }\n  isLastColumnFullyVisible() {\n    return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n  }\n  allRowsInViewport() {\n    return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();\n  }\n  allColumnsInViewport() {\n    return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();\n  }\n\n  /**\n   * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n   *\n   * @param {number} sourceRow The physical row index.\n   * @returns {number}\n   */\n  getRowHeight(sourceRow) {\n    return this.rowUtils.getHeight(sourceRow);\n  }\n\n  /**\n   * @param {number} level The column level.\n   * @returns {number}\n   */\n  getColumnHeaderHeight(level) {\n    return this.columnUtils.getHeaderHeight(level);\n  }\n\n  /**\n   * @param {number} sourceColumn The physical column index.\n   * @returns {number}\n   */\n  getColumnWidth(sourceColumn) {\n    return this.columnUtils.getWidth(sourceColumn);\n  }\n\n  /**\n   * @param {number} sourceColumn The physical column index.\n   * @returns {number}\n   */\n  getStretchedColumnWidth(sourceColumn) {\n    return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n  }\n\n  /**\n   * Checks if the table has defined size. It returns `true` when the table has width and height\n   * set bigger than `0px`.\n   *\n   * @returns {boolean}\n   */\n  hasDefinedSize() {\n    return this.hasTableHeight && this.hasTableWidth;\n  }\n\n  /**\n   * Gets table's width. The returned width is the width of the rendered cells that fit in the\n   * current viewport. The value may change depends on the viewport position (scroll position).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    return outerWidth(this.TABLE);\n  }\n\n  /**\n   * Gets table's height. The returned height is the height of the rendered cells that fit in the\n   * current viewport. The value may change depends on the viewport position (scroll position).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    return outerHeight(this.TABLE);\n  }\n\n  /**\n   * Gets table's total width. The returned width is the width of all rendered cells (including headers)\n   * that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  getTotalWidth() {\n    const width = outerWidth(this.hider);\n\n    // when the overlay's table does not have any cells the hider returns 0, get then width from the table element\n    return width !== 0 ? width : this.getWidth();\n  }\n\n  /**\n   * Gets table's total height. The returned height is the height of all rendered cells (including headers)\n   * that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  getTotalHeight() {\n    const height = outerHeight(this.hider);\n\n    // when the overlay's table does not have any cells the hider returns 0, get then height from the table element\n    return height !== 0 ? height : this.getHeight();\n  }\n\n  /**\n   * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n   * has CSS 'display' property different than 'none'.\n   *\n   * @returns {boolean}\n   */\n  isVisible() {\n    return isVisible(this.TABLE);\n  }\n\n  /**\n   * Modify row header widths provided by user in class contructor.\n   *\n   * @private\n   * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n   * @returns {number}\n   */\n  _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n    let widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n    if (Array.isArray(widths)) {\n      widths = [...widths];\n      widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n    } else {\n      widths = this._correctRowHeaderWidth(widths);\n    }\n    return widths;\n  }\n\n  /**\n   * Correct row header width if necessary.\n   *\n   * @private\n   * @param {number} width The width to process.\n   * @returns {number}\n   */\n  _correctRowHeaderWidth(width) {\n    let rowHeaderWidth = width;\n    if (typeof width !== 'number') {\n      rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    }\n    if (this.correctHeaderWidth) {\n      rowHeaderWidth += 1;\n    }\n    return rowHeaderWidth;\n  }\n}\nexport default Table;"],"mappings":"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GD,UAAU,CAACN,MAAM;IACzC,OAAOyI,IAAI,CAACC,GAAG,CAACjD,MAAM,CAAC,IAAIlF,eAAe;EAC5C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEoI,mBAAmBA,CAACnD,GAAG,EAAE;IACvB,IAAIA,GAAG,IAAI,CAAC,EAAE;MACZ,OAAO,KAAK;IACd;IACA,MAAMhF,aAAa,GAAG,IAAI,CAAC1D,UAAU,CAAC8C,UAAU,CAAC,eAAe,CAAC;IACjE,MAAMa,kBAAkB,GAAGD,aAAa,CAACR,MAAM;IAC/C,OAAOyI,IAAI,CAACC,GAAG,CAAClD,GAAG,CAAC,IAAI/E,kBAAkB;EAC5C;;EAEA;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;EACAkF,uBAAuBA,CAACH,GAAG,EAAE;IAC3B,MAAMoD,KAAK,GAAG,IAAI,CAACtH,mBAAmB,CAAC,CAAC;;IAExC;IACA;IACA,IAAIkE,GAAG,GAAG,CAAC,IAAIoD,KAAK,IAAI,CAAC,EAAE;MACzB,OAAO,CAAC,IAAI,CAACD,mBAAmB,CAACnD,GAAG,CAAC;IACvC;IACA,OAAOA,GAAG,GAAGoD,KAAK;EACpB;;EAEA;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;EACAhD,sBAAsBA,CAACJ,GAAG,EAAE;IAC1B,OAAOA,GAAG,GAAG,IAAI,CAACqD,kBAAkB,CAAC,CAAC;EACxC;;EAEA;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;EACAhD,6BAA6BA,CAACJ,MAAM,EAAE;IACpC,M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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}