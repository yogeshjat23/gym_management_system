{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { WORKING_SPACE_TOP, WORKING_SPACE_BOTTOM } from \"./constants.mjs\";\nimport ViewSizeSet from \"./viewSizeSet.mjs\";\n/**\n * Executive model for each table renderer. It's responsible for injecting DOM nodes in a\n * specified order and adjusting the number of elements in the root node.\n *\n * Only this class have rights to juggling DOM elements within the root node (see render method).\n *\n * @class {OrderView}\n */\nexport default class OrderView {\n  constructor(rootNode, nodesPool, childNodeType) {\n    /**\n     * The root node to manage with.\n     *\n     * @type {HTMLElement}\n     */\n    _defineProperty(this, \"rootNode\", void 0);\n    /**\n     * Factory for newly created DOM elements.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"nodesPool\", void 0);\n    /**\n     * Holder for sizing and positioning of the view.\n     *\n     * @type {ViewSizeSet}\n     */\n    _defineProperty(this, \"sizeSet\", new ViewSizeSet());\n    /**\n     * Node type which the order view will manage while rendering the DOM elements.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"childNodeType\", void 0);\n    /**\n     * The visual index of currently processed row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"visualIndex\", 0);\n    /**\n     * The list of DOM elements which are rendered for this render cycle.\n     *\n     * @type {HTMLElement[]}\n     */\n    _defineProperty(this, \"collectedNodes\", []);\n    this.rootNode = rootNode;\n    this.nodesPool = nodesPool;\n    this.childNodeType = childNodeType.toUpperCase();\n  }\n\n  /**\n   * Sets the size for rendered elements. It can be a size for rows, cells or size for row\n   * headers etc. It depends for what table renderer this instance was created.\n   *\n   * @param {number} size The size.\n   * @returns {OrderView}\n   */\n  setSize(size) {\n    this.sizeSet.setSize(size);\n    return this;\n  }\n\n  /**\n   * Sets the offset for rendered elements. The offset describes the shift between 0 and\n   * the first rendered element according to the scroll position.\n   *\n   * @param {number} offset The offset.\n   * @returns {OrderView}\n   */\n  setOffset(offset) {\n    this.sizeSet.setOffset(offset);\n    return this;\n  }\n\n  /**\n   * Checks if this instance of the view shares the root node with another instance. This happens only once when\n   * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection\n   * algorithm is performed to achieve consistent order.\n   *\n   * @returns {boolean}\n   */\n  isSharedViewSet() {\n    return this.sizeSet.isShared();\n  }\n\n  /**\n   * Returns rendered DOM element based on visual index.\n   *\n   * @param {number} visualIndex The visual index.\n   * @returns {HTMLElement}\n   */\n  getNode(visualIndex) {\n    return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;\n  }\n\n  /**\n   * Returns currently processed DOM element.\n   *\n   * @returns {HTMLElement}\n   */\n  getCurrentNode() {\n    const length = this.collectedNodes.length;\n    return length > 0 ? this.collectedNodes[length - 1] : null;\n  }\n\n  /**\n   * Returns rendered child count for this instance.\n   *\n   * @returns {number}\n   */\n  getRenderedChildCount() {\n    const {\n      rootNode,\n      sizeSet\n    } = this;\n    let childElementCount = 0;\n    if (this.isSharedViewSet()) {\n      let element = rootNode.firstElementChild;\n      while (element) {\n        if (element.tagName === this.childNodeType) {\n          childElementCount += 1;\n        } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {\n          break;\n        }\n        element = element.nextElementSibling;\n      }\n    } else {\n      childElementCount = rootNode.childElementCount;\n    }\n    return childElementCount;\n  }\n\n  /**\n   * Setups and prepares all necessary properties and start the rendering process.\n   * This method has to be called only once (at the start) for the render cycle.\n   */\n  start() {\n    this.collectedNodes.length = 0;\n    this.visualIndex = 0;\n    const {\n      rootNode,\n      sizeSet\n    } = this;\n    const isShared = this.isSharedViewSet();\n    const {\n      nextSize\n    } = sizeSet.getViewSize();\n    let childElementCount = this.getRenderedChildCount();\n    while (childElementCount < nextSize) {\n      const newNode = this.nodesPool();\n      if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n        rootNode.appendChild(newNode);\n      } else {\n        rootNode.insertBefore(newNode, rootNode.firstChild);\n      }\n      childElementCount += 1;\n    }\n    const isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);\n    while (childElementCount > nextSize) {\n      rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);\n      childElementCount -= 1;\n    }\n  }\n\n  /**\n   * Renders the DOM element based on visual index (which is calculated internally).\n   * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).\n   */\n  render() {\n    const {\n      rootNode,\n      sizeSet\n    } = this;\n    let visualIndex = this.visualIndex;\n    if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n      visualIndex += sizeSet.sharedSize.nextSize;\n    }\n    let node = rootNode.childNodes[visualIndex];\n    if (node.tagName !== this.childNodeType) {\n      const newNode = this.nodesPool();\n      rootNode.replaceChild(newNode, node);\n      node = newNode;\n    }\n    this.collectedNodes.push(node);\n    this.visualIndex += 1;\n  }\n\n  /**\n   * Ends the render process.\n   * This method has to be called only once (at the end) for the render cycle.\n   */\n  end() {}\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","WORKING_SPACE_TOP","WORKING_SPACE_BOTTOM","ViewSizeSet","OrderView","constructor","rootNode","nodesPool","childNodeType","toUpperCase","setSize","size","sizeSet","setOffset","offset","isSharedViewSet","isShared","getNode","visualIndex","collectedNodes","length","getCurrentNode","getRenderedChildCount","childElementCount","element","firstElementChild","tagName","isPlaceOn","nextElementSibling","start","nextSize","getViewSize","newNode","appendChild","insertBefore","firstChild","isSharedPlacedOnTop","removeChild","lastChild","render","sharedSize","node","childNodes","replaceChild","push","end"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/view.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { WORKING_SPACE_TOP, WORKING_SPACE_BOTTOM } from \"./constants.mjs\";\nimport ViewSizeSet from \"./viewSizeSet.mjs\";\n/**\n * Executive model for each table renderer. It's responsible for injecting DOM nodes in a\n * specified order and adjusting the number of elements in the root node.\n *\n * Only this class have rights to juggling DOM elements within the root node (see render method).\n *\n * @class {OrderView}\n */\nexport default class OrderView {\n  constructor(rootNode, nodesPool, childNodeType) {\n    /**\n     * The root node to manage with.\n     *\n     * @type {HTMLElement}\n     */\n    _defineProperty(this, \"rootNode\", void 0);\n    /**\n     * Factory for newly created DOM elements.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"nodesPool\", void 0);\n    /**\n     * Holder for sizing and positioning of the view.\n     *\n     * @type {ViewSizeSet}\n     */\n    _defineProperty(this, \"sizeSet\", new ViewSizeSet());\n    /**\n     * Node type which the order view will manage while rendering the DOM elements.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"childNodeType\", void 0);\n    /**\n     * The visual index of currently processed row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"visualIndex\", 0);\n    /**\n     * The list of DOM elements which are rendered for this render cycle.\n     *\n     * @type {HTMLElement[]}\n     */\n    _defineProperty(this, \"collectedNodes\", []);\n    this.rootNode = rootNode;\n    this.nodesPool = nodesPool;\n    this.childNodeType = childNodeType.toUpperCase();\n  }\n\n  /**\n   * Sets the size for rendered elements. It can be a size for rows, cells or size for row\n   * headers etc. It depends for what table renderer this instance was created.\n   *\n   * @param {number} size The size.\n   * @returns {OrderView}\n   */\n  setSize(size) {\n    this.sizeSet.setSize(size);\n    return this;\n  }\n\n  /**\n   * Sets the offset for rendered elements. The offset describes the shift between 0 and\n   * the first rendered element according to the scroll position.\n   *\n   * @param {number} offset The offset.\n   * @returns {OrderView}\n   */\n  setOffset(offset) {\n    this.sizeSet.setOffset(offset);\n    return this;\n  }\n\n  /**\n   * Checks if this instance of the view shares the root node with another instance. This happens only once when\n   * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection\n   * algorithm is performed to achieve consistent order.\n   *\n   * @returns {boolean}\n   */\n  isSharedViewSet() {\n    return this.sizeSet.isShared();\n  }\n\n  /**\n   * Returns rendered DOM element based on visual index.\n   *\n   * @param {number} visualIndex The visual index.\n   * @returns {HTMLElement}\n   */\n  getNode(visualIndex) {\n    return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;\n  }\n\n  /**\n   * Returns currently processed DOM element.\n   *\n   * @returns {HTMLElement}\n   */\n  getCurrentNode() {\n    const length = this.collectedNodes.length;\n    return length > 0 ? this.collectedNodes[length - 1] : null;\n  }\n\n  /**\n   * Returns rendered child count for this instance.\n   *\n   * @returns {number}\n   */\n  getRenderedChildCount() {\n    const {\n      rootNode,\n      sizeSet\n    } = this;\n    let childElementCount = 0;\n    if (this.isSharedViewSet()) {\n      let element = rootNode.firstElementChild;\n      while (element) {\n        if (element.tagName === this.childNodeType) {\n          childElementCount += 1;\n        } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {\n          break;\n        }\n        element = element.nextElementSibling;\n      }\n    } else {\n      childElementCount = rootNode.childElementCount;\n    }\n    return childElementCount;\n  }\n\n  /**\n   * Setups and prepares all necessary properties and start the rendering process.\n   * This method has to be called only once (at the start) for the render cycle.\n   */\n  start() {\n    this.collectedNodes.length = 0;\n    this.visualIndex = 0;\n    const {\n      rootNode,\n      sizeSet\n    } = this;\n    const isShared = this.isSharedViewSet();\n    const {\n      nextSize\n    } = sizeSet.getViewSize();\n    let childElementCount = this.getRenderedChildCount();\n    while (childElementCount < nextSize) {\n      const newNode = this.nodesPool();\n      if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n        rootNode.appendChild(newNode);\n      } else {\n        rootNode.insertBefore(newNode, rootNode.firstChild);\n      }\n      childElementCount += 1;\n    }\n    const isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);\n    while (childElementCount > nextSize) {\n      rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);\n      childElementCount -= 1;\n    }\n  }\n\n  /**\n   * Renders the DOM element based on visual index (which is calculated internally).\n   * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).\n   */\n  render() {\n    const {\n      rootNode,\n      sizeSet\n    } = this;\n    let visualIndex = this.visualIndex;\n    if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n      visualIndex += sizeSet.sharedSize.nextSize;\n    }\n    let node = rootNode.childNodes[visualIndex];\n    if (node.tagName !== this.childNodeType) {\n      const newNode = this.nodesPool();\n      rootNode.replaceChild(newNode, node);\n      node = newNode;\n    }\n    this.collectedNodes.push(node);\n    this.visualIndex += 1;\n  }\n\n  /**\n   * Ends the render process.\n   * This method has to be called only once (at the end) for the render cycle.\n   */\n  end() {}\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}