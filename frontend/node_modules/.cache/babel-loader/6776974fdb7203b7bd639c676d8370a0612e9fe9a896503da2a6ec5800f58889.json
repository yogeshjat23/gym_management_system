{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { offset, outerHeight, outerWidth } from \"../../helpers/dom/element.mjs\";\nimport { arrayEach, arrayMap } from \"../../helpers/array.mjs\";\nimport { isEmpty } from \"../../helpers/mixed.mjs\";\nimport { getDragDirectionAndRange, DIRECTIONS, getMappedFillHandleSetting } from \"./utils.mjs\";\nHooks.getSingleton().register('modifyAutofillRange');\nHooks.getSingleton().register('beforeAutofill');\nHooks.getSingleton().register('afterAutofill');\nexport const PLUGIN_KEY = 'autofill';\nexport const PLUGIN_PRIORITY = 20;\nconst SETTING_KEYS = ['fillHandle'];\nconst INSERT_ROW_ALTER_ACTION_NAME = 'insert_row_below';\nconst INTERVAL_FOR_ADDING_ROW = 200;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated using the small square in the right\n * bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring cells when you drag the small\n * square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells below when you double click the small square.\n *\n * @class Autofill\n * @plugin Autofill\n */\nvar _Autofill_brand = /*#__PURE__*/new WeakSet();\nexport class Autofill extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On cell corner double click callback.\n     *\n     * @private\n     */\n    _classPrivateMethodInitSpec(this, _Autofill_brand);\n    /**\n     * Specifies if adding new row started.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"addingStarted\", false);\n    /**\n     * Specifies if there was mouse down on the cell corner.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDownOnCellCorner\", false);\n    /**\n     * Specifies if mouse was dragged outside Handsontable.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDragOutside\", false);\n    /**\n     * Specifies how many cell levels were dragged using the handle.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"handleDraggedCells\", 0);\n    /**\n     * Specifies allowed directions of drag (`'horizontal'` or '`vertical`').\n     *\n     * @private\n     * @type {string[]}\n     */\n    _defineProperty(this, \"directions\", []);\n    /**\n     * Specifies if can insert new rows if needed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"autoInsertRow\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * Checks if the plugin is enabled in the Handsontable settings.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings().fillHandle;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.mapSettings();\n    this.registerEvents();\n    this.addHook('afterOnCellCornerMouseDown', event => _assertClassBrand(_Autofill_brand, this, _onAfterCellCornerMouseDown).call(this, event));\n    this.addHook('afterOnCellCornerDblClick', event => _assertClassBrand(_Autofill_brand, this, _onCellCornerDblClick).call(this, event));\n    this.addHook('beforeOnCellMouseOver', (_, coords) => _assertClassBrand(_Autofill_brand, this, _onBeforeCellMouseOver).call(this, coords));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - `autofill`\n   *  - [`fillHandle`](@/api/options.md#fillhandle)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearMappedSettings();\n    super.disablePlugin();\n  }\n\n  /**\n   * Gets selection data.\n   *\n   * @private\n   * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   */\n  getSelectionData() {\n    const selection = this.hot.getSelectedRangeLast();\n    const {\n      row: startRow,\n      col: startCol\n    } = selection.getTopStartCorner();\n    const {\n      row: endRow,\n      col: endCol\n    } = selection.getBottomEndCorner();\n    const copyableRanges = this.hot.runHooks('modifyCopyableRange', [{\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    }]);\n    const copyableRows = [];\n    const copyableColumns = [];\n    const data = [];\n    arrayEach(copyableRanges, range => {\n      for (let visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {\n        if (copyableRows.indexOf(visualRow) === -1) {\n          copyableRows.push(visualRow);\n        }\n      }\n      for (let visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {\n        if (copyableColumns.indexOf(visualColumn) === -1) {\n          copyableColumns.push(visualColumn);\n        }\n      }\n    });\n    arrayEach(copyableRows, row => {\n      const rowSet = [];\n      arrayEach(copyableColumns, column => {\n        rowSet.push(this.hot.getCopyableData(row, column));\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Try to apply fill values to the area in fill border, omitting the selection border.\n   *\n   * @private\n   * @returns {boolean} Reports if fill was applied.\n   *\n   * @fires Hooks#modifyAutofillRange\n   * @fires Hooks#beforeAutofill\n   * @fires Hooks#afterAutofill\n   */\n  fillIn() {\n    if (this.hot.selection.highlight.getFill().isEmpty()) {\n      return false;\n    }\n\n    // Fill area may starts or ends with invisible cell. There won't be any information about it as highlighted\n    // selection store just renderable indexes (It's part of Walkontable). I extrapolate where the start or/and\n    // the end is.\n    const [fillStartRow, fillStartColumn, fillEndRow, fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();\n    const selectionRangeLast = this.hot.getSelectedRangeLast();\n    const topStartCorner = selectionRangeLast.getTopStartCorner();\n    const bottomEndCorner = selectionRangeLast.getBottomEndCorner();\n    this.resetSelectionOfDraggedArea();\n    const cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];\n    const cornersOfSelectionAndDragAreas = this.hot.runHooks('modifyAutofillRange', [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);\n    const {\n      directionOfDrag,\n      startOfDragCoords,\n      endOfDragCoords\n    } = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, (row, column) => this.hot._createCellCoords(row, column));\n    if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n      const selectionData = this.getSelectionData();\n      const sourceRange = selectionRangeLast.clone();\n      const targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);\n      const beforeAutofillHookResult = this.hot.runHooks('beforeAutofill', selectionData, sourceRange, targetRange, directionOfDrag);\n      if (beforeAutofillHookResult === false) {\n        this.hot.selection.highlight.getFill().clear();\n        this.hot.render();\n        return false;\n      }\n      let fillData = beforeAutofillHookResult;\n      const res = beforeAutofillHookResult;\n      if (['up', 'left'].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {\n        fillData = [];\n        if (directionOfDrag === 'up') {\n          const dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;\n          const fillOffset = dragLength % res.length;\n          for (let i = 0; i < dragLength; i++) {\n            fillData.push(res[(i + (res.length - fillOffset)) % res.length]);\n          }\n        } else {\n          const dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;\n          const fillOffset = dragLength % res[0].length;\n          for (let i = 0; i < res.length; i++) {\n            fillData.push([]);\n            for (let j = 0; j < dragLength; j++) {\n              fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % res[i].length]);\n            }\n          }\n        }\n      }\n      this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, `${this.pluginName}.fill`, null);\n      this.setSelection(cornersOfSelectionAndDragAreas);\n      this.hot.runHooks('afterAutofill', fillData, sourceRange, targetRange, directionOfDrag);\n      this.hot.render();\n    } else {\n      // reset to avoid some range bug\n      this.hot.view.render();\n    }\n    return true;\n  }\n\n  /**\n   * Reduces the selection area if the handle was dragged outside of the table or on headers.\n   *\n   * @private\n   * @param {CellCoords} coords Indexes of selection corners.\n   * @returns {CellCoords}\n   */\n  reduceSelectionAreaIfNeeded(coords) {\n    if (coords.row < 0) {\n      coords.row = 0;\n    }\n    if (coords.col < 0) {\n      coords.col = 0;\n    }\n    return coords;\n  }\n\n  /**\n   * Gets the coordinates of the drag & drop borders.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   * @returns {CellCoords}\n   */\n  getCoordsOfDragAndDropBorders(coordsOfSelection) {\n    const currentSelection = this.hot.getSelectedRangeLast();\n    const bottomRightCorner = currentSelection.getBottomEndCorner();\n    let coords = coordsOfSelection;\n    if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {\n      const topStartCorner = currentSelection.getTopStartCorner();\n      if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {\n        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n      }\n      if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {\n        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n      }\n    } else if (this.directions.includes(DIRECTIONS.vertical)) {\n      coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n    } else if (this.directions.includes(DIRECTIONS.horizontal)) {\n      coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n    } else {\n      // wrong direction\n      return;\n    }\n    return this.reduceSelectionAreaIfNeeded(coords);\n  }\n\n  /**\n   * Show the fill border.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   */\n  showBorder(coordsOfSelection) {\n    const coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n    if (coordsOfDragAndDropBorders) {\n      this.redrawBorders(coordsOfDragAndDropBorders);\n    }\n  }\n\n  /**\n   * Add new row.\n   *\n   * @private\n   */\n  addRow() {\n    this.hot._registerTimeout(() => {\n      this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, undefined, 1, `${this.pluginName}.fill`);\n      this.addingStarted = false;\n    }, INTERVAL_FOR_ADDING_ROW);\n  }\n\n  /**\n   * Add new rows if they are needed to continue auto-filling values.\n   *\n   * @private\n   */\n  addNewRowIfNeeded() {\n    if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {\n      const cornersOfSelectedCells = this.hot.getSelectedLast();\n      const cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();\n      const nrOfTableRows = this.hot.countRows();\n      if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n        this.addingStarted = true;\n        this.addRow();\n      }\n    }\n  }\n\n  /**\n   * Get index of last adjacent filled in row.\n   *\n   * @private\n   * @param {Array} cornersOfSelectedCells Indexes of selection corners.\n   * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.\n   *                   Or -1 when selection adjacent can't be applied.\n   */\n  getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n    const data = this.hot.getData();\n    const nrOfTableRows = this.hot.countRows();\n    let lastFilledInRowIndex;\n    for (let rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {\n      for (let columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {\n        const dataInCell = data[rowIndex][columnIndex];\n        if (!isEmpty(dataInCell)) {\n          return -1;\n        }\n      }\n      const dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];\n      const dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];\n      if (!isEmpty(dataInNextLeftCell) || !isEmpty(dataInNextRightCell)) {\n        lastFilledInRowIndex = rowIndex;\n      }\n    }\n    return lastFilledInRowIndex;\n  }\n\n  /**\n   * Adds a selection from the start area to the specific row index.\n   *\n   * @private\n   * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.\n   * @param {number} rowIndex The row index into the selection will be added.\n   */\n  addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();\n  }\n\n  /**\n   * Sets selection based on passed corners.\n   *\n   * @private\n   * @param {Array} cornersOfArea An array witch defines selection.\n   */\n  setSelection(cornersOfArea) {\n    this.hot.selectCell(...arrayMap(cornersOfArea, index => Math.max(index, 0)), false, false);\n  }\n\n  /**\n   * Try to select cells down to the last row in the left column and then returns if selection was applied.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  selectAdjacent() {\n    const cornersOfSelectedCells = this.hot.getSelectedLast();\n    const lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n    if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === undefined) {\n      return false;\n    }\n    this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);\n    return true;\n  }\n\n  /**\n   * Resets selection of dragged area.\n   *\n   * @private\n   */\n  resetSelectionOfDraggedArea() {\n    this.handleDraggedCells = 0;\n    this.hot.selection.highlight.getFill().clear();\n  }\n\n  /**\n   * Redraws borders.\n   *\n   * @private\n   * @param {CellCoords} coords `CellCoords` coord object.\n   */\n  redrawBorders(coords) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();\n    this.hot.view.render();\n  }\n\n  /**\n   * Get if mouse was dragged outside.\n   *\n   * @private\n   * @param {MouseEvent} event `mousemove` event properties.\n   * @returns {boolean}\n   */\n  getIfMouseWasDraggedOutside(event) {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    const tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);\n    const tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);\n    return event.clientY > tableBottom && event.clientX <= tableRight;\n  }\n\n  /**\n   * Bind the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _assertClassBrand(_Autofill_brand, this, _onMouseUp).call(this));\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _assertClassBrand(_Autofill_brand, this, _onMouseMove).call(this, event));\n  }\n  /**\n   * Clears mapped settings.\n   *\n   * @private\n   */\n  clearMappedSettings() {\n    this.directions.length = 0;\n    this.autoInsertRow = false;\n  }\n\n  /**\n   * Map settings.\n   *\n   * @private\n   */\n  mapSettings() {\n    const mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n    this.directions = mappedSettings.directions;\n    this.autoInsertRow = mappedSettings.autoInsertRow;\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onCellCornerDblClick() {\n  const selectionApplied = this.selectAdjacent();\n  if (selectionApplied) {\n    this.fillIn();\n  }\n}\n/**\n * On after cell corner mouse down listener.\n */\nfunction _onAfterCellCornerMouseDown() {\n  this.handleDraggedCells = 1;\n  this.mouseDownOnCellCorner = true;\n}\n/**\n * On before cell mouse over listener.\n *\n * @param {CellCoords} coords `CellCoords` coord object.\n */\nfunction _onBeforeCellMouseOver(coords) {\n  if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {\n    this.handleDraggedCells += 1;\n    this.showBorder(coords);\n    this.addNewRowIfNeeded();\n  }\n}\n/**\n * On mouse up listener.\n */\nfunction _onMouseUp() {\n  if (this.handleDraggedCells) {\n    if (this.handleDraggedCells > 1) {\n      this.fillIn();\n    }\n    this.handleDraggedCells = 0;\n    this.mouseDownOnCellCorner = false;\n  }\n}\n/**\n * On mouse move listener.\n *\n * @param {MouseEvent} event `mousemove` event properties.\n */\nfunction _onMouseMove(event) {\n  const mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);\n  if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n    this.mouseDragOutside = true;\n    this.addingStarted = true;\n  } else {\n    this.mouseDragOutside = false;\n  }\n  if (this.mouseDragOutside && this.autoInsertRow) {\n    this.addRow();\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","t","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_assertClassBrand","n","arguments","length","BasePlugin","Hooks","offset","outerHeight","outerWidth","arrayEach","arrayMap","isEmpty","getDragDirectionAndRange","DIRECTIONS","getMappedFillHandleSetting","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","SETTING_KEYS","INSERT_ROW_ALTER_ACTION_NAME","INTERVAL_FOR_ADDING_ROW","_Autofill_brand","WeakSet","Autofill","constructor","isEnabled","hot","getSettings","fillHandle","enablePlugin","enabled","mapSettings","registerEvents","addHook","event","_onAfterCellCornerMouseDown","_onCellCornerDblClick","_","coords","_onBeforeCellMouseOver","updatePlugin","disablePlugin","clearMappedSettings","getSelectionData","selection","getSelectedRangeLast","row","startRow","col","startCol","getTopStartCorner","endRow","endCol","getBottomEndCorner","copyableRanges","runHooks","copyableRows","copyableColumns","data","range","visualRow","indexOf","push","visualColumn","rowSet","column","getCopyableData","fillIn","highlight","getFill","fillStartRow","fillStartColumn","fillEndRow","fillEndColumn","getVisualCorners","selectionRangeLast","topStartCorner","bottomEndCorner","resetSelectionOfDraggedArea","cornersOfSelectedCells","cornersOfSelectionAndDragAreas","Math","min","max","directionOfDrag","startOfDragCoords","endOfDragCoords","_createCellCoords","selectionData","sourceRange","clone","targetRange","_createCellRange","beforeAutofillHookResult","clear","render","fillData","res","dragLength","fillOffset","j","populateFromArray","pluginName","setSelection","view","reduceSelectionAreaIfNeeded","getCoordsOfDragAndDropBorders","coordsOfSelection","currentSelection","bottomRightCorner","directions","includes","vertical","horizontal","showBorder","coordsOfDragAndDropBorders","redrawBorders","addRow","_registerTimeout","alter","undefined","addingStarted","addNewRowIfNeeded","autoInsertRow","getSelectedLast","cornersOfSelectedDragArea","nrOfTableRows","countRows","getIndexOfLastAdjacentFilledInRow","getData","lastFilledInRowIndex","rowIndex","columnIndex","dataInCell","dataInNextLeftCell","dataInNextRightCell","addSelectionFromStartAreaToSpecificRowIndex","selectStartArea","commit","cornersOfArea","selectCell","index","selectAdjacent","handleDraggedCells","from","to","getIfMouseWasDraggedOutside","documentElement","rootDocument","tableBottom","table","top","rootWindow","pageYOffset","scrollTop","tableRight","left","pageXOffset","scrollLeft","clientY","clientX","eventManager","addEventListener","_onMouseUp","_onMouseMove","mappedSettings","destroy","selectionApplied","mouseDownOnCellCorner","isMouseDown","mouseWasDraggedOutside","mouseDragOutside"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/autofill/autofill.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { offset, outerHeight, outerWidth } from \"../../helpers/dom/element.mjs\";\nimport { arrayEach, arrayMap } from \"../../helpers/array.mjs\";\nimport { isEmpty } from \"../../helpers/mixed.mjs\";\nimport { getDragDirectionAndRange, DIRECTIONS, getMappedFillHandleSetting } from \"./utils.mjs\";\nHooks.getSingleton().register('modifyAutofillRange');\nHooks.getSingleton().register('beforeAutofill');\nHooks.getSingleton().register('afterAutofill');\nexport const PLUGIN_KEY = 'autofill';\nexport const PLUGIN_PRIORITY = 20;\nconst SETTING_KEYS = ['fillHandle'];\nconst INSERT_ROW_ALTER_ACTION_NAME = 'insert_row_below';\nconst INTERVAL_FOR_ADDING_ROW = 200;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated using the small square in the right\n * bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring cells when you drag the small\n * square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells below when you double click the small square.\n *\n * @class Autofill\n * @plugin Autofill\n */\nvar _Autofill_brand = /*#__PURE__*/new WeakSet();\nexport class Autofill extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On cell corner double click callback.\n     *\n     * @private\n     */\n    _classPrivateMethodInitSpec(this, _Autofill_brand);\n    /**\n     * Specifies if adding new row started.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"addingStarted\", false);\n    /**\n     * Specifies if there was mouse down on the cell corner.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDownOnCellCorner\", false);\n    /**\n     * Specifies if mouse was dragged outside Handsontable.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDragOutside\", false);\n    /**\n     * Specifies how many cell levels were dragged using the handle.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"handleDraggedCells\", 0);\n    /**\n     * Specifies allowed directions of drag (`'horizontal'` or '`vertical`').\n     *\n     * @private\n     * @type {string[]}\n     */\n    _defineProperty(this, \"directions\", []);\n    /**\n     * Specifies if can insert new rows if needed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"autoInsertRow\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * Checks if the plugin is enabled in the Handsontable settings.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings().fillHandle;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.mapSettings();\n    this.registerEvents();\n    this.addHook('afterOnCellCornerMouseDown', event => _assertClassBrand(_Autofill_brand, this, _onAfterCellCornerMouseDown).call(this, event));\n    this.addHook('afterOnCellCornerDblClick', event => _assertClassBrand(_Autofill_brand, this, _onCellCornerDblClick).call(this, event));\n    this.addHook('beforeOnCellMouseOver', (_, coords) => _assertClassBrand(_Autofill_brand, this, _onBeforeCellMouseOver).call(this, coords));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - `autofill`\n   *  - [`fillHandle`](@/api/options.md#fillhandle)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearMappedSettings();\n    super.disablePlugin();\n  }\n\n  /**\n   * Gets selection data.\n   *\n   * @private\n   * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   */\n  getSelectionData() {\n    const selection = this.hot.getSelectedRangeLast();\n    const {\n      row: startRow,\n      col: startCol\n    } = selection.getTopStartCorner();\n    const {\n      row: endRow,\n      col: endCol\n    } = selection.getBottomEndCorner();\n    const copyableRanges = this.hot.runHooks('modifyCopyableRange', [{\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    }]);\n    const copyableRows = [];\n    const copyableColumns = [];\n    const data = [];\n    arrayEach(copyableRanges, range => {\n      for (let visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {\n        if (copyableRows.indexOf(visualRow) === -1) {\n          copyableRows.push(visualRow);\n        }\n      }\n      for (let visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {\n        if (copyableColumns.indexOf(visualColumn) === -1) {\n          copyableColumns.push(visualColumn);\n        }\n      }\n    });\n    arrayEach(copyableRows, row => {\n      const rowSet = [];\n      arrayEach(copyableColumns, column => {\n        rowSet.push(this.hot.getCopyableData(row, column));\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Try to apply fill values to the area in fill border, omitting the selection border.\n   *\n   * @private\n   * @returns {boolean} Reports if fill was applied.\n   *\n   * @fires Hooks#modifyAutofillRange\n   * @fires Hooks#beforeAutofill\n   * @fires Hooks#afterAutofill\n   */\n  fillIn() {\n    if (this.hot.selection.highlight.getFill().isEmpty()) {\n      return false;\n    }\n\n    // Fill area may starts or ends with invisible cell. There won't be any information about it as highlighted\n    // selection store just renderable indexes (It's part of Walkontable). I extrapolate where the start or/and\n    // the end is.\n    const [fillStartRow, fillStartColumn, fillEndRow, fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();\n    const selectionRangeLast = this.hot.getSelectedRangeLast();\n    const topStartCorner = selectionRangeLast.getTopStartCorner();\n    const bottomEndCorner = selectionRangeLast.getBottomEndCorner();\n    this.resetSelectionOfDraggedArea();\n    const cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];\n    const cornersOfSelectionAndDragAreas = this.hot.runHooks('modifyAutofillRange', [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);\n    const {\n      directionOfDrag,\n      startOfDragCoords,\n      endOfDragCoords\n    } = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, (row, column) => this.hot._createCellCoords(row, column));\n    if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n      const selectionData = this.getSelectionData();\n      const sourceRange = selectionRangeLast.clone();\n      const targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);\n      const beforeAutofillHookResult = this.hot.runHooks('beforeAutofill', selectionData, sourceRange, targetRange, directionOfDrag);\n      if (beforeAutofillHookResult === false) {\n        this.hot.selection.highlight.getFill().clear();\n        this.hot.render();\n        return false;\n      }\n      let fillData = beforeAutofillHookResult;\n      const res = beforeAutofillHookResult;\n      if (['up', 'left'].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {\n        fillData = [];\n        if (directionOfDrag === 'up') {\n          const dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;\n          const fillOffset = dragLength % res.length;\n          for (let i = 0; i < dragLength; i++) {\n            fillData.push(res[(i + (res.length - fillOffset)) % res.length]);\n          }\n        } else {\n          const dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;\n          const fillOffset = dragLength % res[0].length;\n          for (let i = 0; i < res.length; i++) {\n            fillData.push([]);\n            for (let j = 0; j < dragLength; j++) {\n              fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % res[i].length]);\n            }\n          }\n        }\n      }\n      this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, `${this.pluginName}.fill`, null);\n      this.setSelection(cornersOfSelectionAndDragAreas);\n      this.hot.runHooks('afterAutofill', fillData, sourceRange, targetRange, directionOfDrag);\n      this.hot.render();\n    } else {\n      // reset to avoid some range bug\n      this.hot.view.render();\n    }\n    return true;\n  }\n\n  /**\n   * Reduces the selection area if the handle was dragged outside of the table or on headers.\n   *\n   * @private\n   * @param {CellCoords} coords Indexes of selection corners.\n   * @returns {CellCoords}\n   */\n  reduceSelectionAreaIfNeeded(coords) {\n    if (coords.row < 0) {\n      coords.row = 0;\n    }\n    if (coords.col < 0) {\n      coords.col = 0;\n    }\n    return coords;\n  }\n\n  /**\n   * Gets the coordinates of the drag & drop borders.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   * @returns {CellCoords}\n   */\n  getCoordsOfDragAndDropBorders(coordsOfSelection) {\n    const currentSelection = this.hot.getSelectedRangeLast();\n    const bottomRightCorner = currentSelection.getBottomEndCorner();\n    let coords = coordsOfSelection;\n    if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {\n      const topStartCorner = currentSelection.getTopStartCorner();\n      if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {\n        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n      }\n      if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {\n        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n      }\n    } else if (this.directions.includes(DIRECTIONS.vertical)) {\n      coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n    } else if (this.directions.includes(DIRECTIONS.horizontal)) {\n      coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n    } else {\n      // wrong direction\n      return;\n    }\n    return this.reduceSelectionAreaIfNeeded(coords);\n  }\n\n  /**\n   * Show the fill border.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   */\n  showBorder(coordsOfSelection) {\n    const coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n    if (coordsOfDragAndDropBorders) {\n      this.redrawBorders(coordsOfDragAndDropBorders);\n    }\n  }\n\n  /**\n   * Add new row.\n   *\n   * @private\n   */\n  addRow() {\n    this.hot._registerTimeout(() => {\n      this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, undefined, 1, `${this.pluginName}.fill`);\n      this.addingStarted = false;\n    }, INTERVAL_FOR_ADDING_ROW);\n  }\n\n  /**\n   * Add new rows if they are needed to continue auto-filling values.\n   *\n   * @private\n   */\n  addNewRowIfNeeded() {\n    if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {\n      const cornersOfSelectedCells = this.hot.getSelectedLast();\n      const cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();\n      const nrOfTableRows = this.hot.countRows();\n      if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n        this.addingStarted = true;\n        this.addRow();\n      }\n    }\n  }\n\n  /**\n   * Get index of last adjacent filled in row.\n   *\n   * @private\n   * @param {Array} cornersOfSelectedCells Indexes of selection corners.\n   * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.\n   *                   Or -1 when selection adjacent can't be applied.\n   */\n  getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n    const data = this.hot.getData();\n    const nrOfTableRows = this.hot.countRows();\n    let lastFilledInRowIndex;\n    for (let rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {\n      for (let columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {\n        const dataInCell = data[rowIndex][columnIndex];\n        if (!isEmpty(dataInCell)) {\n          return -1;\n        }\n      }\n      const dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];\n      const dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];\n      if (!isEmpty(dataInNextLeftCell) || !isEmpty(dataInNextRightCell)) {\n        lastFilledInRowIndex = rowIndex;\n      }\n    }\n    return lastFilledInRowIndex;\n  }\n\n  /**\n   * Adds a selection from the start area to the specific row index.\n   *\n   * @private\n   * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.\n   * @param {number} rowIndex The row index into the selection will be added.\n   */\n  addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();\n  }\n\n  /**\n   * Sets selection based on passed corners.\n   *\n   * @private\n   * @param {Array} cornersOfArea An array witch defines selection.\n   */\n  setSelection(cornersOfArea) {\n    this.hot.selectCell(...arrayMap(cornersOfArea, index => Math.max(index, 0)), false, false);\n  }\n\n  /**\n   * Try to select cells down to the last row in the left column and then returns if selection was applied.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  selectAdjacent() {\n    const cornersOfSelectedCells = this.hot.getSelectedLast();\n    const lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n    if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === undefined) {\n      return false;\n    }\n    this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);\n    return true;\n  }\n\n  /**\n   * Resets selection of dragged area.\n   *\n   * @private\n   */\n  resetSelectionOfDraggedArea() {\n    this.handleDraggedCells = 0;\n    this.hot.selection.highlight.getFill().clear();\n  }\n\n  /**\n   * Redraws borders.\n   *\n   * @private\n   * @param {CellCoords} coords `CellCoords` coord object.\n   */\n  redrawBorders(coords) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();\n    this.hot.view.render();\n  }\n\n  /**\n   * Get if mouse was dragged outside.\n   *\n   * @private\n   * @param {MouseEvent} event `mousemove` event properties.\n   * @returns {boolean}\n   */\n  getIfMouseWasDraggedOutside(event) {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    const tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);\n    const tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);\n    return event.clientY > tableBottom && event.clientX <= tableRight;\n  }\n\n  /**\n   * Bind the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _assertClassBrand(_Autofill_brand, this, _onMouseUp).call(this));\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _assertClassBrand(_Autofill_brand, this, _onMouseMove).call(this, event));\n  }\n  /**\n   * Clears mapped settings.\n   *\n   * @private\n   */\n  clearMappedSettings() {\n    this.directions.length = 0;\n    this.autoInsertRow = false;\n  }\n\n  /**\n   * Map settings.\n   *\n   * @private\n   */\n  mapSettings() {\n    const mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n    this.directions = mappedSettings.directions;\n    this.autoInsertRow = mappedSettings.autoInsertRow;\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onCellCornerDblClick() {\n  const selectionApplied = this.selectAdjacent();\n  if (selectionApplied) {\n    this.fillIn();\n  }\n}\n/**\n * On after cell corner mouse down listener.\n */\nfunction _onAfterCellCornerMouseDown() {\n  this.handleDraggedCells = 1;\n  this.mouseDownOnCellCorner = true;\n}\n/**\n * On before cell mouse over listener.\n *\n * @param {CellCoords} coords `CellCoords` coord object.\n */\nfunction _onBeforeCellMouseOver(coords) {\n  if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {\n    this.handleDraggedCells += 1;\n    this.showBorder(coords);\n    this.addNewRowIfNeeded();\n  }\n}\n/**\n * On mouse up listener.\n */\nfunction _onMouseUp() {\n  if (this.handleDraggedCells) {\n    if (this.handleDraggedCells > 1) {\n      this.fillIn();\n    }\n    this.handleDraggedCells = 0;\n    this.mouseDownOnCellCorner = false;\n  }\n}\n/**\n * On mouse move listener.\n *\n * @param {MouseEvent} event `mousemove` event properties.\n */\nfunction _onMouseMove(event) {\n  const mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);\n  if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n    this.mouseDragOutside = true;\n    this.addingStarted = true;\n  } else {\n    this.mouseDragOutside = false;\n  }\n  if (this.mouseDragOutside && this.autoInsertRow) {\n    this.addRow();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}