{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\n/* eslint-disable no-continue */\nimport { addClass } from \"../../../../helpers/dom/element.mjs\";\n/**\n * Selection scanner module scans the rendered cells and headers and if it finds an intersection with\n * the coordinates of the Selection class (highlight) it returns the DOM elements.\n *\n * @private\n */\nvar _selection = /*#__PURE__*/new WeakMap();\nvar _activeOverlaysWot = /*#__PURE__*/new WeakMap();\nvar _SelectionScanner_brand = /*#__PURE__*/new WeakSet();\nexport class SelectionScanner {\n  constructor() {\n    /**\n     * The method triggers a callback for each rendered cell.\n     *\n     * @param {function(number, number): void} callback The callback function to trigger.\n     */\n    _classPrivateMethodInitSpec(this, _SelectionScanner_brand);\n    /**\n     * Active Selection instance to process.\n     *\n     * @type {Selection}\n     */\n    _classPrivateFieldInitSpec(this, _selection, void 0);\n    /**\n     * The Walkontable instance that the scans depends on.\n     *\n     * @type {Walkontable}\n     */\n    _classPrivateFieldInitSpec(this, _activeOverlaysWot, void 0);\n  }\n  /**\n   * Sets the Walkontable instance that will be taking into account while scanning the table.\n   *\n   * @param {Walkontable} activeOverlaysWot The Walkontable instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveOverlay(activeOverlaysWot) {\n    _classPrivateFieldSet(_activeOverlaysWot, this, activeOverlaysWot);\n    return this;\n  }\n\n  /**\n   * Sets the Selection instance to process.\n   *\n   * @param {Selection} selection The Selection instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveSelection(selection) {\n    _classPrivateFieldSet(_selection, this, selection);\n    return this;\n  }\n\n  /**\n   * Scans the rendered table with selection and returns elements that intersects\n   * with selection coordinates.\n   *\n   * @returns {HTMLTableElement[]}\n   */\n  scan() {\n    const selectionType = _classPrivateFieldGet(_selection, this).settings.selectionType;\n    const elements = new Set();\n\n    // TODO(improvement): use heuristics from coords to detect what type of scan\n    // the Selection needs instead of using `selectionType` property.\n    if (selectionType === 'active-header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'area') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'focus') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'fill') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'row') {\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanRowsInCellsRange(element => elements.add(element));\n    } else if (selectionType === 'column') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanColumnsInCellsRange(element => elements.add(element));\n    }\n    return elements;\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all column headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n    const columnHeadersCount = wtTable.getColumnHeadersCount();\n    let cursor = 0;\n    for (let column = -wtTable.getRowHeadersCount(); column < renderedColumnsCount; column++) {\n      const sourceColumn = wtTable.columnFilter.renderedToSource(column);\n      if (sourceColumn < topColumn || sourceColumn > bottomColumn) {\n        continue;\n      }\n      for (let headerLevel = -columnHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topRow || headerLevel > bottomRow) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + columnHeadersCount;\n        let TH = wtTable.getColumnHeader(sourceColumn, positiveBasedHeaderLevel);\n        const newSourceCol = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeHighlightingColumnHeader', sourceColumn, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(_selection, this).settings.selectionType,\n          columnCursor: cursor,\n          selectionWidth: bottomColumn - topColumn + 1\n        });\n        if (newSourceCol === null) {\n          continue;\n        }\n        if (newSourceCol !== sourceColumn) {\n          TH = wtTable.getColumnHeader(newSourceCol, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all row headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    const renderedRowsCount = wtTable.getRenderedRowsCount();\n    const rowHeadersCount = wtTable.getRowHeadersCount();\n    let cursor = 0;\n    for (let row = -wtTable.getColumnHeadersCount(); row < renderedRowsCount; row++) {\n      const sourceRow = wtTable.rowFilter.renderedToSource(row);\n      if (sourceRow < topRow || sourceRow > bottomRow) {\n        continue;\n      }\n      for (let headerLevel = -rowHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topColumn || headerLevel > bottomColumn) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + rowHeadersCount;\n        let TH = wtTable.getRowHeader(sourceRow, positiveBasedHeaderLevel);\n        const newSourceRow = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeHighlightingRowHeader', sourceRow, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(_selection, this).settings.selectionType,\n          rowCursor: cursor,\n          selectionHeight: bottomRow - topRow + 1\n        });\n        if (newSourceRow === null) {\n          continue;\n        }\n        if (newSourceRow !== sourceRow) {\n          TH = wtTable.getRowHeader(newSourceRow, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collect all cells (TR) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanCellsRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow && sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));\n\n        // support for old API\n        const additionalSelectionClass = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onAfterDrawSelection', sourceRow, sourceColumn, _classPrivateFieldGet(_selection, this).settings.layerLevel);\n        if (typeof additionalSelectionClass === 'string') {\n          addClass(cell, additionalSelectionClass);\n        }\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the X axis (rows).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInCellsRange(callback) {\n    // eslint-disable-next-line comma-spacing\n    const [topRow,, bottomRow] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the Y axis (columns).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInCellsRange(callback) {\n    const [, topColumn,, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {\n      if (sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n}\nfunction _scanCellsRange(callback) {\n  const {\n    wtTable\n  } = _classPrivateFieldGet(_activeOverlaysWot, this);\n  const renderedRowsCount = wtTable.getRenderedRowsCount();\n  const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n  for (let row = 0; row < renderedRowsCount; row += 1) {\n    const sourceRow = wtTable.rowFilter.renderedToSource(row);\n    for (let column = 0; column < renderedColumnsCount; column += 1) {\n      callback(sourceRow, wtTable.columnFilter.renderedToSource(column));\n    }\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","addClass","_selection","WeakMap","_activeOverlaysWot","_SelectionScanner_brand","WeakSet","SelectionScanner","constructor","setActiveOverlay","activeOverlaysWot","setActiveSelection","selection","scan","selectionType","settings","elements","Set","scanColumnsInHeadersRange","element","scanRowsInHeadersRange","scanCellsRange","scanRowsInCellsRange","scanColumnsInCellsRange","callback","topRow","topColumn","bottomRow","bottomColumn","getCorners","wtTable","renderedColumnsCount","getRenderedColumnsCount","columnHeadersCount","getColumnHeadersCount","cursor","column","getRowHeadersCount","sourceColumn","columnFilter","renderedToSource","headerLevel","positiveBasedHeaderLevel","TH","getColumnHeader","newSourceCol","getSetting","columnCursor","selectionWidth","renderedRowsCount","getRenderedRowsCount","rowHeadersCount","row","sourceRow","rowFilter","getRowHeader","newSourceRow","rowCursor","selectionHeight","_scanCellsRange","call","cell","getCell","createCellCoords","additionalSelectionClass","layerLevel"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/selection/scanner.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n/* eslint-disable no-continue */\nimport { addClass } from \"../../../../helpers/dom/element.mjs\";\n/**\n * Selection scanner module scans the rendered cells and headers and if it finds an intersection with\n * the coordinates of the Selection class (highlight) it returns the DOM elements.\n *\n * @private\n */\nvar _selection = /*#__PURE__*/new WeakMap();\nvar _activeOverlaysWot = /*#__PURE__*/new WeakMap();\nvar _SelectionScanner_brand = /*#__PURE__*/new WeakSet();\nexport class SelectionScanner {\n  constructor() {\n    /**\n     * The method triggers a callback for each rendered cell.\n     *\n     * @param {function(number, number): void} callback The callback function to trigger.\n     */\n    _classPrivateMethodInitSpec(this, _SelectionScanner_brand);\n    /**\n     * Active Selection instance to process.\n     *\n     * @type {Selection}\n     */\n    _classPrivateFieldInitSpec(this, _selection, void 0);\n    /**\n     * The Walkontable instance that the scans depends on.\n     *\n     * @type {Walkontable}\n     */\n    _classPrivateFieldInitSpec(this, _activeOverlaysWot, void 0);\n  }\n  /**\n   * Sets the Walkontable instance that will be taking into account while scanning the table.\n   *\n   * @param {Walkontable} activeOverlaysWot The Walkontable instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveOverlay(activeOverlaysWot) {\n    _classPrivateFieldSet(_activeOverlaysWot, this, activeOverlaysWot);\n    return this;\n  }\n\n  /**\n   * Sets the Selection instance to process.\n   *\n   * @param {Selection} selection The Selection instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveSelection(selection) {\n    _classPrivateFieldSet(_selection, this, selection);\n    return this;\n  }\n\n  /**\n   * Scans the rendered table with selection and returns elements that intersects\n   * with selection coordinates.\n   *\n   * @returns {HTMLTableElement[]}\n   */\n  scan() {\n    const selectionType = _classPrivateFieldGet(_selection, this).settings.selectionType;\n    const elements = new Set();\n\n    // TODO(improvement): use heuristics from coords to detect what type of scan\n    // the Selection needs instead of using `selectionType` property.\n    if (selectionType === 'active-header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'area') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'focus') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'fill') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'row') {\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanRowsInCellsRange(element => elements.add(element));\n    } else if (selectionType === 'column') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanColumnsInCellsRange(element => elements.add(element));\n    }\n    return elements;\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all column headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n    const columnHeadersCount = wtTable.getColumnHeadersCount();\n    let cursor = 0;\n    for (let column = -wtTable.getRowHeadersCount(); column < renderedColumnsCount; column++) {\n      const sourceColumn = wtTable.columnFilter.renderedToSource(column);\n      if (sourceColumn < topColumn || sourceColumn > bottomColumn) {\n        continue;\n      }\n      for (let headerLevel = -columnHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topRow || headerLevel > bottomRow) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + columnHeadersCount;\n        let TH = wtTable.getColumnHeader(sourceColumn, positiveBasedHeaderLevel);\n        const newSourceCol = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeHighlightingColumnHeader', sourceColumn, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(_selection, this).settings.selectionType,\n          columnCursor: cursor,\n          selectionWidth: bottomColumn - topColumn + 1\n        });\n        if (newSourceCol === null) {\n          continue;\n        }\n        if (newSourceCol !== sourceColumn) {\n          TH = wtTable.getColumnHeader(newSourceCol, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all row headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    const renderedRowsCount = wtTable.getRenderedRowsCount();\n    const rowHeadersCount = wtTable.getRowHeadersCount();\n    let cursor = 0;\n    for (let row = -wtTable.getColumnHeadersCount(); row < renderedRowsCount; row++) {\n      const sourceRow = wtTable.rowFilter.renderedToSource(row);\n      if (sourceRow < topRow || sourceRow > bottomRow) {\n        continue;\n      }\n      for (let headerLevel = -rowHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topColumn || headerLevel > bottomColumn) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + rowHeadersCount;\n        let TH = wtTable.getRowHeader(sourceRow, positiveBasedHeaderLevel);\n        const newSourceRow = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeHighlightingRowHeader', sourceRow, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(_selection, this).settings.selectionType,\n          rowCursor: cursor,\n          selectionHeight: bottomRow - topRow + 1\n        });\n        if (newSourceRow === null) {\n          continue;\n        }\n        if (newSourceRow !== sourceRow) {\n          TH = wtTable.getRowHeader(newSourceRow, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collect all cells (TR) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanCellsRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow && sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));\n\n        // support for old API\n        const additionalSelectionClass = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onAfterDrawSelection', sourceRow, sourceColumn, _classPrivateFieldGet(_selection, this).settings.layerLevel);\n        if (typeof additionalSelectionClass === 'string') {\n          addClass(cell, additionalSelectionClass);\n        }\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the X axis (rows).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInCellsRange(callback) {\n    // eslint-disable-next-line comma-spacing\n    const [topRow,, bottomRow] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the Y axis (columns).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInCellsRange(callback) {\n    const [, topColumn,, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(_activeOverlaysWot, this);\n    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {\n      if (sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n}\nfunction _scanCellsRange(callback) {\n  const {\n    wtTable\n  } = _classPrivateFieldGet(_activeOverlaysWot, this);\n  const renderedRowsCount = wtTable.getRenderedRowsCount();\n  const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n  for (let row = 0; row < renderedRowsCount; row += 1) {\n    const sourceRow = wtTable.rowFilter.renderedToSource(row);\n    for (let column = 0; column < renderedColumnsCount; column += 1) {\n      callback(sourceRow, wtTable.columnFilter.renderedToSource(column));\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}