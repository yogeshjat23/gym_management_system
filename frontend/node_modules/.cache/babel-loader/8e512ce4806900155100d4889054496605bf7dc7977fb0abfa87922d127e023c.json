{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { hasOwnProperty } from \"../../helpers/object.mjs\";\n/**\n * Command executor for ContextMenu.\n *\n * @private\n * @class CommandExecutor\n */\nexport class CommandExecutor {\n  constructor(hotInstance) {\n    /**\n     * @type {Core}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * @type {object}\n     */\n    _defineProperty(this, \"commands\", {});\n    /**\n     * @type {Function}\n     */\n    _defineProperty(this, \"commonCallback\", null);\n    this.hot = hotInstance;\n  }\n\n  /**\n   * Register command.\n   *\n   * @param {string} name Command name.\n   * @param {object} commandDescriptor Command descriptor object with properties like `key` (command id),\n   *                                   `callback` (task to execute), `name` (command name), `disabled` (command availability).\n   */\n  registerCommand(name, commandDescriptor) {\n    this.commands[name] = commandDescriptor;\n  }\n\n  /**\n   * Set common callback which will be trigger on every executed command.\n   *\n   * @param {Function} callback Function which will be fired on every command execute.\n   */\n  setCommonCallback(callback) {\n    this.commonCallback = callback;\n  }\n\n  /**\n   * Execute command by its name.\n   *\n   * @param {string} commandName Command id.\n   * @param {*} params Arguments passed to command task.\n   */\n  execute(commandName) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    const commandSplit = commandName.split(':');\n    const commandNamePrimary = commandSplit[0];\n    const subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;\n    let command = this.commands[commandNamePrimary];\n    if (!command) {\n      throw new Error(`Menu command '${commandNamePrimary}' not exists.`);\n    }\n    if (subCommandName && command.submenu) {\n      command = findSubCommand(subCommandName, command.submenu.items);\n    }\n    if (command.disabled === true) {\n      return;\n    }\n    if (typeof command.disabled === 'function' && command.disabled.call(this.hot) === true) {\n      return;\n    }\n    if (hasOwnProperty(command, 'submenu')) {\n      return;\n    }\n    const callbacks = [];\n    if (typeof command.callback === 'function') {\n      callbacks.push(command.callback);\n    }\n    if (typeof this.commonCallback === 'function') {\n      callbacks.push(this.commonCallback);\n    }\n    params.unshift(commandSplit.join(':'));\n    arrayEach(callbacks, callback => callback.apply(this.hot, params));\n  }\n}\n\n/**\n * @param {string} subCommandName The subcommand name.\n * @param {string[]} subCommands The collection of the commands.\n * @returns {boolean}\n */\nfunction findSubCommand(subCommandName, subCommands) {\n  let command;\n  arrayEach(subCommands, cmd => {\n    const cmds = cmd.key ? cmd.key.split(':') : null;\n    if (Array.isArray(cmds) && cmds[1] === subCommandName) {\n      command = cmd;\n      return false;\n    }\n  });\n  return command;\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","arrayEach","hasOwnProperty","CommandExecutor","constructor","hotInstance","hot","registerCommand","name","commandDescriptor","commands","setCommonCallback","callback","commonCallback","execute","commandName","_len","arguments","length","params","Array","_key","commandSplit","split","commandNamePrimary","subCommandName","command","Error","submenu","findSubCommand","items","disabled","callbacks","push","unshift","join","apply","subCommands","cmd","cmds","key","isArray"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/contextMenu/commandExecutor.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { hasOwnProperty } from \"../../helpers/object.mjs\";\n/**\n * Command executor for ContextMenu.\n *\n * @private\n * @class CommandExecutor\n */\nexport class CommandExecutor {\n  constructor(hotInstance) {\n    /**\n     * @type {Core}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * @type {object}\n     */\n    _defineProperty(this, \"commands\", {});\n    /**\n     * @type {Function}\n     */\n    _defineProperty(this, \"commonCallback\", null);\n    this.hot = hotInstance;\n  }\n\n  /**\n   * Register command.\n   *\n   * @param {string} name Command name.\n   * @param {object} commandDescriptor Command descriptor object with properties like `key` (command id),\n   *                                   `callback` (task to execute), `name` (command name), `disabled` (command availability).\n   */\n  registerCommand(name, commandDescriptor) {\n    this.commands[name] = commandDescriptor;\n  }\n\n  /**\n   * Set common callback which will be trigger on every executed command.\n   *\n   * @param {Function} callback Function which will be fired on every command execute.\n   */\n  setCommonCallback(callback) {\n    this.commonCallback = callback;\n  }\n\n  /**\n   * Execute command by its name.\n   *\n   * @param {string} commandName Command id.\n   * @param {*} params Arguments passed to command task.\n   */\n  execute(commandName) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    const commandSplit = commandName.split(':');\n    const commandNamePrimary = commandSplit[0];\n    const subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;\n    let command = this.commands[commandNamePrimary];\n    if (!command) {\n      throw new Error(`Menu command '${commandNamePrimary}' not exists.`);\n    }\n    if (subCommandName && command.submenu) {\n      command = findSubCommand(subCommandName, command.submenu.items);\n    }\n    if (command.disabled === true) {\n      return;\n    }\n    if (typeof command.disabled === 'function' && command.disabled.call(this.hot) === true) {\n      return;\n    }\n    if (hasOwnProperty(command, 'submenu')) {\n      return;\n    }\n    const callbacks = [];\n    if (typeof command.callback === 'function') {\n      callbacks.push(command.callback);\n    }\n    if (typeof this.commonCallback === 'function') {\n      callbacks.push(this.commonCallback);\n    }\n    params.unshift(commandSplit.join(':'));\n    arrayEach(callbacks, callback => callback.apply(this.hot, params));\n  }\n}\n\n/**\n * @param {string} subCommandName The subcommand name.\n * @param {string[]} subCommands The collection of the commands.\n * @returns {boolean}\n */\nfunction findSubCommand(subCommandName, subCommands) {\n  let command;\n  arrayEach(subCommands, cmd => {\n    const cmds = cmd.key ? cmd.key.split(':') : null;\n    if (Array.isArray(cmds) && cmds[1] === subCommandName) {\n      command = cmd;\n      return false;\n    }\n  });\n  return command;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}