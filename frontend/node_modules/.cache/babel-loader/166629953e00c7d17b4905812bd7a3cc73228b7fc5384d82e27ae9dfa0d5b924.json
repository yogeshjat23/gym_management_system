{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\nimport { addClass, removeClass, offset, getTrimmingContainer } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport BacklightUI from \"./ui/backlight.mjs\";\nimport GuidelineUI from \"./ui/guideline.mjs\";\nHooks.getSingleton().register('beforeRowMove');\nHooks.getSingleton().register('afterRowMove');\nexport const PLUGIN_KEY = 'manualRowMove';\nexport const PLUGIN_PRIORITY = 140;\nconst CSS_PLUGIN = 'ht__manualRowMove';\nconst CSS_SHOW_UI = 'show-ui';\nconst CSS_ON_MOVING = 'on-moving--rows';\nconst CSS_AFTER_SELECTION = 'after-selection--rows';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualRowMove\n * @class ManualRowMove\n *\n * @description\n * This plugin allows to change rows order. To make rows order persistent the {@link Options#persistentState}\n * plugin should be enabled.\n *\n * API:\n * - `moveRow` - move single row to the new position.\n * - `moveRows` - move many rows (as an array of indexes) to the new position.\n * - `dragRow` - drag single row to the new position.\n * - `dragRows` - drag many rows (as an array of indexes) to the new position.\n *\n * [Documentation](@/guides/rows/row-moving/row-moving.md) explain differences between drag and move actions. Please keep in mind that if you want apply visual changes,\n * you have to call manually the `render` method on the instance of Handsontable.\n *\n * The plugin creates additional components to make moving possibly using user interface:\n * - backlight - highlight of selected rows.\n * - guideline - line which shows where rows has been moved.\n *\n * @class ManualRowMove\n * @plugin ManualRowMove\n */\nvar _backlight = /*#__PURE__*/new WeakMap();\nvar _guideline = /*#__PURE__*/new WeakMap();\nvar _rowsToMove = /*#__PURE__*/new WeakMap();\nvar _pressed = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _cachedDropIndex = /*#__PURE__*/new WeakMap();\nvar _ManualRowMove_brand = /*#__PURE__*/new WeakSet();\nexport class ManualRowMove extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Change the behavior of selection / dragging.\n     *\n     * @param {MouseEvent} event `mousedown` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _ManualRowMove_brand);\n    /**\n     * Backlight UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _backlight, new BacklightUI(this.hot));\n    /**\n     * Guideline UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _guideline, new GuidelineUI(this.hot));\n    /**\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _rowsToMove, []);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _pressed, void 0);\n    /**\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _target, {});\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _cachedDropIndex, void 0);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualRowMove#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_ManualRowMove_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_ManualRowMove_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('afterScrollHorizontally', () => _assertClassBrand(_ManualRowMove_brand, this, _onAfterScrollHorizontally).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_ManualRowMove_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.buildPluginUI();\n    this.registerEvents();\n\n    // TODO: move adding plugin classname to BasePlugin.\n    addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualRowMove`](@/api/options.md#manualrowmove)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    this.unregisterEvents();\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.disablePlugin();\n  }\n\n  /**\n   * Moves a single row.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {number} row Visual row index to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRow(row, finalIndex) {\n    return this.moveRows([row], finalIndex);\n  }\n\n  /**\n   * Moves multiple rows.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRows(rows, finalIndex) {\n    const dropIndex = _classPrivateFieldGet(_cachedDropIndex, this);\n    const movePossible = this.isMovePossible(rows, finalIndex);\n    const beforeMoveHook = this.hot.runHooks('beforeRowMove', rows, finalIndex, dropIndex, movePossible);\n    _classPrivateFieldSet(_cachedDropIndex, this, undefined);\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if (movePossible) {\n      this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);\n    }\n    const movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n\n  /**\n   * Drag a single row to drop index position.\n   *\n   * @param {number} row Visual row index to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRow(row, dropIndex) {\n    return this.dragRows([row], dropIndex);\n  }\n\n  /**\n   * Drag multiple rows to drop index position.\n   *\n   * @param {Array} rows Array of visual row indexes to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRows(rows, dropIndex) {\n    const finalIndex = this.countFinalIndex(rows, dropIndex);\n    _classPrivateFieldSet(_cachedDropIndex, this, dropIndex);\n    return this.moveRows(rows, finalIndex);\n  }\n\n  /**\n   * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You can’t move more than one element to the last position.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedRows, finalIndex) {\n    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();\n\n    // An attempt to transfer more rows to start destination than is possible (only when moving from the top to the bottom).\n    const tooHighDestinationIndex = movedRows.length + finalIndex > length;\n    const tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedRowIndex = movedRows.some(movedRow => movedRow < 0);\n    const tooHighMovedRowIndex = movedRows.some(movedRow => movedRow >= length);\n    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n\n  /**\n   * Count the final row index from the drop index.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows.\n   * @returns {number} Visual row index, being a start index for the moved rows.\n   */\n  countFinalIndex(movedRows, dropIndex) {\n    const numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, currentRowIndex) => {\n      if (currentRowIndex < dropIndex) {\n        numberOfRows += 1;\n      }\n      return numberOfRows;\n    }, 0);\n    return dropIndex - numberOfRowsLowerThanDropIndex;\n  }\n\n  /**\n   * Gets the sum of the heights of rows in the provided range.\n   *\n   * @private\n   * @param {number} fromRow Visual row index.\n   * @param {number} toRow Visual row index.\n   * @returns {number}\n   */\n  getRowsHeight(fromRow, toRow) {\n    const rowMapper = this.hot.rowIndexMapper;\n    let rowsHeight = 0;\n    for (let visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {\n      const renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);\n      if (renderableIndex !== null) {\n        rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;\n      }\n    }\n    return rowsHeight;\n  }\n\n  /**\n   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.\n   *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(pluginSettings)) {\n      this.moveRows(pluginSettings, 0);\n    } else if (pluginSettings !== undefined) {\n      const persistentState = this.persistentStateLoad();\n      if (persistentState.length) {\n        this.moveRows(persistentState, 0);\n      }\n    }\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsTop section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowTop(row) {\n    return row < this.hot.getSettings().fixedRowsTop;\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsBottom section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowBottom(row) {\n    return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;\n  }\n\n  /**\n   * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    // The `PersistentState` plugin should be refactored.\n    this.hot.runHooks('persistentStateSave', 'manualRowMove', this.hot.rowIndexMapper.getIndexesSequence());\n  }\n\n  /**\n   * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   */\n  persistentStateLoad() {\n    const storedState = {};\n    this.hot.runHooks('persistentStateLoad', 'manualRowMove', storedState);\n    return storedState.value ? storedState.value : [];\n  }\n\n  /**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * @private\n   * @returns {Array}\n   */\n  prepareRowsToMoving() {\n    const selection = this.hot.getSelectedRangeLast();\n    const selectedRows = [];\n    if (!selection) {\n      return selectedRows;\n    }\n    const {\n      from,\n      to\n    } = selection;\n    const start = Math.min(from.row, to.row);\n    const end = Math.max(from.row, to.row);\n    rangeEach(start, end, i => {\n      selectedRows.push(i);\n    });\n    return selectedRows;\n  }\n\n  /**\n   * Update the UI visual position.\n   *\n   * @private\n   */\n  refreshPositions() {\n    const coords = _classPrivateFieldGet(_target, this).coords;\n    const firstVisible = this.hot.view.getFirstFullyVisibleRow();\n    const lastVisible = this.hot.view.getLastFullyVisibleRow();\n    const countRows = this.hot.countRows();\n    if (this.isFixedRowTop(coords.row) && firstVisible > 0) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));\n    }\n    if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), undefined, true);\n    }\n    const wtTable = this.hot.view._wt.wtTable;\n    const TD = _classPrivateFieldGet(_target, this).TD;\n    const rootElement = this.hot.rootElement;\n    const rootElementOffset = offset(rootElement);\n    const trimmingContainer = getTrimmingContainer(rootElement);\n    const tableScroll = wtTable.holder.scrollTop;\n    const trimmingContainerScroll = this.hot.rootWindow !== trimmingContainer ? trimmingContainer.scrollTop : 0;\n    const pixelsAbove = rootElementOffset.top - trimmingContainerScroll;\n    const pixelsRelToTableStart = _classPrivateFieldGet(_target, this).eventPageY - pixelsAbove + tableScroll;\n    const hiderHeight = wtTable.hider.offsetHeight;\n    const tbodyOffsetTop = wtTable.TBODY.offsetTop;\n    const backlightElemMarginTop = _classPrivateFieldGet(_backlight, this).getOffset().top;\n    const backlightElemHeight = _classPrivateFieldGet(_backlight, this).getSize().height;\n    const tdMiddle = TD.offsetHeight / 2;\n    const tdHeight = TD.offsetHeight;\n    let tdStartPixel = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);\n    const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;\n    if (this.isFixedRowTop(coords.row)) {\n      tdStartPixel += this.hot.view._wt.wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (coords.row < 0) {\n      // if hover on colHeader\n      _classPrivateFieldGet(_target, this).row = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n    } else if (isBelowTable) {\n      // if hover on lower part of TD\n      _classPrivateFieldGet(_target, this).row = coords.row + 1;\n      // unfortunately first row is bigger than rest\n      tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;\n    } else {\n      // elsewhere on table\n      _classPrivateFieldGet(_target, this).row = coords.row;\n    }\n    let backlightTop = pixelsRelToTableStart;\n    let guidelineTop = tdStartPixel;\n    if (pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {\n      // prevent display backlight below table\n      backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;\n    } else if (pixelsRelToTableStart + backlightElemMarginTop < tbodyOffsetTop) {\n      // prevent display above below table\n      backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);\n    }\n    if (tdStartPixel >= hiderHeight - 1) {\n      // prevent display guideline below table\n      guidelineTop = hiderHeight - 1;\n    }\n    _classPrivateFieldGet(_backlight, this).setPosition(backlightTop);\n    _classPrivateFieldGet(_guideline, this).setPosition(guidelineTop);\n  }\n\n  /**\n   * Binds the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _assertClassBrand(_ManualRowMove_brand, this, _onMouseMove).call(this, event));\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _assertClassBrand(_ManualRowMove_brand, this, _onMouseUp).call(this));\n  }\n\n  /**\n   * Unbinds the events used by the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    this.eventManager.clear();\n  }\n  /**\n   * Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    _classPrivateFieldGet(_backlight, this).build();\n    _classPrivateFieldGet(_guideline, this).build();\n  }\n\n  /**\n   * Callback for the `afterLoadData` hook.\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.destroy();\n  }\n}\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const {\n    wtTable,\n    wtViewport\n  } = this.hot.view._wt;\n  const isHeaderSelection = this.hot.selection.isSelectedByRowHeader();\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection || !isHeaderSelection || _classPrivateFieldGet(_pressed, this) || event.button !== 0) {\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_rowsToMove, this).length = 0;\n    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);\n    return;\n  }\n  const guidelineIsNotReady = _classPrivateFieldGet(_guideline, this).isBuilt() && !_classPrivateFieldGet(_guideline, this).isAppended();\n  const backlightIsNotReady = _classPrivateFieldGet(_backlight, this).isBuilt() && !_classPrivateFieldGet(_backlight, this).isAppended();\n  if (guidelineIsNotReady && backlightIsNotReady) {\n    _classPrivateFieldGet(_guideline, this).appendTo(wtTable.hider);\n    _classPrivateFieldGet(_backlight, this).appendTo(wtTable.hider);\n  }\n  const {\n    from,\n    to\n  } = selection;\n  const start = Math.min(from.row, to.row);\n  const end = Math.max(from.row, to.row);\n  if (coords.col < 0 && coords.row >= start && coords.row <= end) {\n    controller.row = true;\n    _classPrivateFieldSet(_pressed, this, true);\n    _classPrivateFieldGet(_target, this).eventPageY = event.pageY;\n    _classPrivateFieldGet(_target, this).coords = coords;\n    _classPrivateFieldGet(_target, this).TD = TD;\n    _classPrivateFieldSet(_rowsToMove, this, this.prepareRowsToMoving());\n    const leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();\n    const topOffset = this.getRowsHeight(start, coords.row - 1) + event.offsetY;\n    _classPrivateFieldGet(_backlight, this).setPosition(null, leftPos);\n    _classPrivateFieldGet(_backlight, this).setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));\n    _classPrivateFieldGet(_backlight, this).setOffset(-topOffset, null);\n    addClass(this.hot.rootElement, CSS_ON_MOVING);\n    this.refreshPositions();\n  } else {\n    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_rowsToMove, this).length = 0;\n  }\n}\n/**\n * 'mouseMove' event callback. Fired when pointer move on document.documentElement.\n *\n * @param {MouseEvent} event `mousemove` event properties.\n */\nfunction _onMouseMove(event) {\n  if (!_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  _classPrivateFieldGet(_target, this).eventPageY = event.pageY;\n  this.refreshPositions();\n}\n/**\n * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.\n *\n * @param {MouseEvent} event `mouseover` event properties.\n * @param {CellCoords} coords Visual cell coordinates where was fired event.\n * @param {HTMLElement} TD Cell represented as HTMLElement.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  if (!selectedRange || !_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  if (_classPrivateFieldGet(_rowsToMove, this).indexOf(coords.row) > -1) {\n    removeClass(this.hot.rootElement, CSS_SHOW_UI);\n  } else {\n    addClass(this.hot.rootElement, CSS_SHOW_UI);\n  }\n  controller.row = true;\n  controller.column = true;\n  controller.cell = true;\n  _classPrivateFieldGet(_target, this).coords = coords;\n  _classPrivateFieldGet(_target, this).TD = TD;\n}\n/**\n * `onMouseUp` hook callback.\n */\nfunction _onMouseUp() {\n  const target = _classPrivateFieldGet(_target, this).row;\n  const rowsLen = _classPrivateFieldGet(_rowsToMove, this).length;\n  _classPrivateFieldSet(_pressed, this, false);\n  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);\n  if (this.hot.selection.isSelectedByRowHeader()) {\n    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n  }\n  if (rowsLen < 1 || target === undefined) {\n    return;\n  }\n  const firstMovedVisualRow = _classPrivateFieldGet(_rowsToMove, this)[0];\n  const firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);\n  const movePerformed = this.dragRows(_classPrivateFieldGet(_rowsToMove, this), target);\n  _classPrivateFieldGet(_rowsToMove, this).length = 0;\n  if (movePerformed === true) {\n    this.persistentStateSave();\n    this.hot.render();\n    this.hot.view.adjustElementsSize();\n    const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);\n    const selectionEnd = selectionStart + rowsLen - 1;\n    this.hot.selectRows(selectionStart, selectionEnd);\n  }\n}\n/**\n * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.\n */\nfunction _onAfterScrollHorizontally() {\n  const wtTable = this.hot.view._wt.wtTable;\n  const headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();\n  const scrollLeft = wtTable.holder.scrollLeft;\n  const posLeft = headerWidth + scrollLeft;\n  _classPrivateFieldGet(_backlight, this).setPosition(null, posLeft);\n  _classPrivateFieldGet(_backlight, this).setSize(wtTable.hider.offsetWidth - posLeft);\n}\nfunction _onAfterLoadData() {\n  this.moveBySettingsOrLoad();\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldSet","s","r","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","BasePlugin","Hooks","arrayReduce","addClass","removeClass","offset","getTrimmingContainer","rangeEach","BacklightUI","GuidelineUI","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","CSS_PLUGIN","CSS_SHOW_UI","CSS_ON_MOVING","CSS_AFTER_SELECTION","_backlight","WeakMap","_guideline","_rowsToMove","_pressed","_target","_cachedDropIndex","_ManualRowMove_brand","WeakSet","ManualRowMove","constructor","hot","isEnabled","getSettings","enablePlugin","_this","enabled","addHook","_len","args","Array","_key","_onBeforeOnCellMouseDown","call","_len2","_key2","_onBeforeOnCellMouseOver","_onAfterScrollHorizontally","_len3","_key3","_onAfterLoadData","buildPluginUI","registerEvents","rootElement","updatePlugin","disablePlugin","moveBySettingsOrLoad","unregisterEvents","destroy","moveRow","row","finalIndex","moveRows","rows","dropIndex","movePossible","isMovePossible","beforeMoveHook","runHooks","undefined","rowIndexMapper","moveIndexes","movePerformed","isRowOrderChanged","dragRow","dragRows","countFinalIndex","movedRows","getNotTrimmedIndexesLength","tooHighDestinationIndex","tooLowDestinationIndex","tooLowMovedRowIndex","some","movedRow","tooHighMovedRowIndex","nrOfMovedElement","numberOfRowsLowerThanDropIndex","numberOfRows","currentRowIndex","getRowsHeight","fromRow","toRow","rowMapper","rowsHeight","visualRowIndex","renderableIndex","getRenderableFromVisualIndex","view","_wt","wtTable","getRowHeight","pluginSettings","isArray","persistentState","persistentStateLoad","isFixedRowTop","fixedRowsTop","isFixedRowBottom","countRows","fixedRowsBottom","persistentStateSave","getIndexesSequence","storedState","value","prepareRowsToMoving","selection","getSelectedRangeLast","selectedRows","from","to","start","Math","min","end","max","i","push","refreshPositions","coords","firstVisible","getFirstFullyVisibleRow","lastVisible","getLastFullyVisibleRow","scrollViewportTo","getNearestNotHiddenIndex","TD","rootElementOffset","trimmingContainer","tableScroll","holder","scrollTop","trimmingContainerScroll","rootWindow","pixelsAbove","top","pixelsRelToTableStart","eventPageY","hiderHeight","hider","offsetHeight","tbodyOffsetTop","TBODY","offsetTop","backlightElemMarginTop","getOffset","backlightElemHeight","getSize","height","tdMiddle","tdHeight","tdStartPixel","THEAD","isBelowTable","wtOverlays","topOverlay","getOverlayOffset","backlightTop","guidelineTop","abs","setPosition","documentElement","rootDocument","eventManager","addEventListener","event","_onMouseMove","_onMouseUp","clear","build","controller","wtViewport","isHeaderSelection","isSelectedByRowHeader","button","guidelineIsNotReady","isBuilt","isAppended","backlightIsNotReady","appendTo","col","pageY","leftPos","scrollLeft","getRowHeaderWidth","topOffset","offsetY","setSize","offsetWidth","setOffset","selectedRange","indexOf","column","cell","target","rowsLen","firstMovedVisualRow","firstMovedPhysicalRow","toPhysicalRow","render","adjustElementsSize","selectionStart","toVisualRow","selectionEnd","selectRows","headerWidth","posLeft"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/manualRowMove/manualRowMove.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\nimport { addClass, removeClass, offset, getTrimmingContainer } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport BacklightUI from \"./ui/backlight.mjs\";\nimport GuidelineUI from \"./ui/guideline.mjs\";\nHooks.getSingleton().register('beforeRowMove');\nHooks.getSingleton().register('afterRowMove');\nexport const PLUGIN_KEY = 'manualRowMove';\nexport const PLUGIN_PRIORITY = 140;\nconst CSS_PLUGIN = 'ht__manualRowMove';\nconst CSS_SHOW_UI = 'show-ui';\nconst CSS_ON_MOVING = 'on-moving--rows';\nconst CSS_AFTER_SELECTION = 'after-selection--rows';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualRowMove\n * @class ManualRowMove\n *\n * @description\n * This plugin allows to change rows order. To make rows order persistent the {@link Options#persistentState}\n * plugin should be enabled.\n *\n * API:\n * - `moveRow` - move single row to the new position.\n * - `moveRows` - move many rows (as an array of indexes) to the new position.\n * - `dragRow` - drag single row to the new position.\n * - `dragRows` - drag many rows (as an array of indexes) to the new position.\n *\n * [Documentation](@/guides/rows/row-moving/row-moving.md) explain differences between drag and move actions. Please keep in mind that if you want apply visual changes,\n * you have to call manually the `render` method on the instance of Handsontable.\n *\n * The plugin creates additional components to make moving possibly using user interface:\n * - backlight - highlight of selected rows.\n * - guideline - line which shows where rows has been moved.\n *\n * @class ManualRowMove\n * @plugin ManualRowMove\n */\nvar _backlight = /*#__PURE__*/new WeakMap();\nvar _guideline = /*#__PURE__*/new WeakMap();\nvar _rowsToMove = /*#__PURE__*/new WeakMap();\nvar _pressed = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _cachedDropIndex = /*#__PURE__*/new WeakMap();\nvar _ManualRowMove_brand = /*#__PURE__*/new WeakSet();\nexport class ManualRowMove extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Change the behavior of selection / dragging.\n     *\n     * @param {MouseEvent} event `mousedown` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _ManualRowMove_brand);\n    /**\n     * Backlight UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _backlight, new BacklightUI(this.hot));\n    /**\n     * Guideline UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _guideline, new GuidelineUI(this.hot));\n    /**\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _rowsToMove, []);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _pressed, void 0);\n    /**\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _target, {});\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _cachedDropIndex, void 0);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualRowMove#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_ManualRowMove_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_ManualRowMove_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('afterScrollHorizontally', () => _assertClassBrand(_ManualRowMove_brand, this, _onAfterScrollHorizontally).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_ManualRowMove_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.buildPluginUI();\n    this.registerEvents();\n\n    // TODO: move adding plugin classname to BasePlugin.\n    addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualRowMove`](@/api/options.md#manualrowmove)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    this.unregisterEvents();\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.disablePlugin();\n  }\n\n  /**\n   * Moves a single row.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {number} row Visual row index to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRow(row, finalIndex) {\n    return this.moveRows([row], finalIndex);\n  }\n\n  /**\n   * Moves multiple rows.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRows(rows, finalIndex) {\n    const dropIndex = _classPrivateFieldGet(_cachedDropIndex, this);\n    const movePossible = this.isMovePossible(rows, finalIndex);\n    const beforeMoveHook = this.hot.runHooks('beforeRowMove', rows, finalIndex, dropIndex, movePossible);\n    _classPrivateFieldSet(_cachedDropIndex, this, undefined);\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if (movePossible) {\n      this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);\n    }\n    const movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n\n  /**\n   * Drag a single row to drop index position.\n   *\n   * @param {number} row Visual row index to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRow(row, dropIndex) {\n    return this.dragRows([row], dropIndex);\n  }\n\n  /**\n   * Drag multiple rows to drop index position.\n   *\n   * @param {Array} rows Array of visual row indexes to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRows(rows, dropIndex) {\n    const finalIndex = this.countFinalIndex(rows, dropIndex);\n    _classPrivateFieldSet(_cachedDropIndex, this, dropIndex);\n    return this.moveRows(rows, finalIndex);\n  }\n\n  /**\n   * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You can’t move more than one element to the last position.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedRows, finalIndex) {\n    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();\n\n    // An attempt to transfer more rows to start destination than is possible (only when moving from the top to the bottom).\n    const tooHighDestinationIndex = movedRows.length + finalIndex > length;\n    const tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedRowIndex = movedRows.some(movedRow => movedRow < 0);\n    const tooHighMovedRowIndex = movedRows.some(movedRow => movedRow >= length);\n    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n\n  /**\n   * Count the final row index from the drop index.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows.\n   * @returns {number} Visual row index, being a start index for the moved rows.\n   */\n  countFinalIndex(movedRows, dropIndex) {\n    const numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, currentRowIndex) => {\n      if (currentRowIndex < dropIndex) {\n        numberOfRows += 1;\n      }\n      return numberOfRows;\n    }, 0);\n    return dropIndex - numberOfRowsLowerThanDropIndex;\n  }\n\n  /**\n   * Gets the sum of the heights of rows in the provided range.\n   *\n   * @private\n   * @param {number} fromRow Visual row index.\n   * @param {number} toRow Visual row index.\n   * @returns {number}\n   */\n  getRowsHeight(fromRow, toRow) {\n    const rowMapper = this.hot.rowIndexMapper;\n    let rowsHeight = 0;\n    for (let visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {\n      const renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);\n      if (renderableIndex !== null) {\n        rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;\n      }\n    }\n    return rowsHeight;\n  }\n\n  /**\n   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.\n   *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(pluginSettings)) {\n      this.moveRows(pluginSettings, 0);\n    } else if (pluginSettings !== undefined) {\n      const persistentState = this.persistentStateLoad();\n      if (persistentState.length) {\n        this.moveRows(persistentState, 0);\n      }\n    }\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsTop section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowTop(row) {\n    return row < this.hot.getSettings().fixedRowsTop;\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsBottom section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowBottom(row) {\n    return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;\n  }\n\n  /**\n   * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    // The `PersistentState` plugin should be refactored.\n    this.hot.runHooks('persistentStateSave', 'manualRowMove', this.hot.rowIndexMapper.getIndexesSequence());\n  }\n\n  /**\n   * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   */\n  persistentStateLoad() {\n    const storedState = {};\n    this.hot.runHooks('persistentStateLoad', 'manualRowMove', storedState);\n    return storedState.value ? storedState.value : [];\n  }\n\n  /**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * @private\n   * @returns {Array}\n   */\n  prepareRowsToMoving() {\n    const selection = this.hot.getSelectedRangeLast();\n    const selectedRows = [];\n    if (!selection) {\n      return selectedRows;\n    }\n    const {\n      from,\n      to\n    } = selection;\n    const start = Math.min(from.row, to.row);\n    const end = Math.max(from.row, to.row);\n    rangeEach(start, end, i => {\n      selectedRows.push(i);\n    });\n    return selectedRows;\n  }\n\n  /**\n   * Update the UI visual position.\n   *\n   * @private\n   */\n  refreshPositions() {\n    const coords = _classPrivateFieldGet(_target, this).coords;\n    const firstVisible = this.hot.view.getFirstFullyVisibleRow();\n    const lastVisible = this.hot.view.getLastFullyVisibleRow();\n    const countRows = this.hot.countRows();\n    if (this.isFixedRowTop(coords.row) && firstVisible > 0) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));\n    }\n    if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), undefined, true);\n    }\n    const wtTable = this.hot.view._wt.wtTable;\n    const TD = _classPrivateFieldGet(_target, this).TD;\n    const rootElement = this.hot.rootElement;\n    const rootElementOffset = offset(rootElement);\n    const trimmingContainer = getTrimmingContainer(rootElement);\n    const tableScroll = wtTable.holder.scrollTop;\n    const trimmingContainerScroll = this.hot.rootWindow !== trimmingContainer ? trimmingContainer.scrollTop : 0;\n    const pixelsAbove = rootElementOffset.top - trimmingContainerScroll;\n    const pixelsRelToTableStart = _classPrivateFieldGet(_target, this).eventPageY - pixelsAbove + tableScroll;\n    const hiderHeight = wtTable.hider.offsetHeight;\n    const tbodyOffsetTop = wtTable.TBODY.offsetTop;\n    const backlightElemMarginTop = _classPrivateFieldGet(_backlight, this).getOffset().top;\n    const backlightElemHeight = _classPrivateFieldGet(_backlight, this).getSize().height;\n    const tdMiddle = TD.offsetHeight / 2;\n    const tdHeight = TD.offsetHeight;\n    let tdStartPixel = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);\n    const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;\n    if (this.isFixedRowTop(coords.row)) {\n      tdStartPixel += this.hot.view._wt.wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (coords.row < 0) {\n      // if hover on colHeader\n      _classPrivateFieldGet(_target, this).row = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n    } else if (isBelowTable) {\n      // if hover on lower part of TD\n      _classPrivateFieldGet(_target, this).row = coords.row + 1;\n      // unfortunately first row is bigger than rest\n      tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;\n    } else {\n      // elsewhere on table\n      _classPrivateFieldGet(_target, this).row = coords.row;\n    }\n    let backlightTop = pixelsRelToTableStart;\n    let guidelineTop = tdStartPixel;\n    if (pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {\n      // prevent display backlight below table\n      backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;\n    } else if (pixelsRelToTableStart + backlightElemMarginTop < tbodyOffsetTop) {\n      // prevent display above below table\n      backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);\n    }\n    if (tdStartPixel >= hiderHeight - 1) {\n      // prevent display guideline below table\n      guidelineTop = hiderHeight - 1;\n    }\n    _classPrivateFieldGet(_backlight, this).setPosition(backlightTop);\n    _classPrivateFieldGet(_guideline, this).setPosition(guidelineTop);\n  }\n\n  /**\n   * Binds the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _assertClassBrand(_ManualRowMove_brand, this, _onMouseMove).call(this, event));\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _assertClassBrand(_ManualRowMove_brand, this, _onMouseUp).call(this));\n  }\n\n  /**\n   * Unbinds the events used by the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    this.eventManager.clear();\n  }\n  /**\n   * Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    _classPrivateFieldGet(_backlight, this).build();\n    _classPrivateFieldGet(_guideline, this).build();\n  }\n\n  /**\n   * Callback for the `afterLoadData` hook.\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.destroy();\n  }\n}\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const {\n    wtTable,\n    wtViewport\n  } = this.hot.view._wt;\n  const isHeaderSelection = this.hot.selection.isSelectedByRowHeader();\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection || !isHeaderSelection || _classPrivateFieldGet(_pressed, this) || event.button !== 0) {\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_rowsToMove, this).length = 0;\n    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);\n    return;\n  }\n  const guidelineIsNotReady = _classPrivateFieldGet(_guideline, this).isBuilt() && !_classPrivateFieldGet(_guideline, this).isAppended();\n  const backlightIsNotReady = _classPrivateFieldGet(_backlight, this).isBuilt() && !_classPrivateFieldGet(_backlight, this).isAppended();\n  if (guidelineIsNotReady && backlightIsNotReady) {\n    _classPrivateFieldGet(_guideline, this).appendTo(wtTable.hider);\n    _classPrivateFieldGet(_backlight, this).appendTo(wtTable.hider);\n  }\n  const {\n    from,\n    to\n  } = selection;\n  const start = Math.min(from.row, to.row);\n  const end = Math.max(from.row, to.row);\n  if (coords.col < 0 && coords.row >= start && coords.row <= end) {\n    controller.row = true;\n    _classPrivateFieldSet(_pressed, this, true);\n    _classPrivateFieldGet(_target, this).eventPageY = event.pageY;\n    _classPrivateFieldGet(_target, this).coords = coords;\n    _classPrivateFieldGet(_target, this).TD = TD;\n    _classPrivateFieldSet(_rowsToMove, this, this.prepareRowsToMoving());\n    const leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();\n    const topOffset = this.getRowsHeight(start, coords.row - 1) + event.offsetY;\n    _classPrivateFieldGet(_backlight, this).setPosition(null, leftPos);\n    _classPrivateFieldGet(_backlight, this).setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));\n    _classPrivateFieldGet(_backlight, this).setOffset(-topOffset, null);\n    addClass(this.hot.rootElement, CSS_ON_MOVING);\n    this.refreshPositions();\n  } else {\n    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_rowsToMove, this).length = 0;\n  }\n}\n/**\n * 'mouseMove' event callback. Fired when pointer move on document.documentElement.\n *\n * @param {MouseEvent} event `mousemove` event properties.\n */\nfunction _onMouseMove(event) {\n  if (!_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  _classPrivateFieldGet(_target, this).eventPageY = event.pageY;\n  this.refreshPositions();\n}\n/**\n * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.\n *\n * @param {MouseEvent} event `mouseover` event properties.\n * @param {CellCoords} coords Visual cell coordinates where was fired event.\n * @param {HTMLElement} TD Cell represented as HTMLElement.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  if (!selectedRange || !_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  if (_classPrivateFieldGet(_rowsToMove, this).indexOf(coords.row) > -1) {\n    removeClass(this.hot.rootElement, CSS_SHOW_UI);\n  } else {\n    addClass(this.hot.rootElement, CSS_SHOW_UI);\n  }\n  controller.row = true;\n  controller.column = true;\n  controller.cell = true;\n  _classPrivateFieldGet(_target, this).coords = coords;\n  _classPrivateFieldGet(_target, this).TD = TD;\n}\n/**\n * `onMouseUp` hook callback.\n */\nfunction _onMouseUp() {\n  const target = _classPrivateFieldGet(_target, this).row;\n  const rowsLen = _classPrivateFieldGet(_rowsToMove, this).length;\n  _classPrivateFieldSet(_pressed, this, false);\n  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);\n  if (this.hot.selection.isSelectedByRowHeader()) {\n    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n  }\n  if (rowsLen < 1 || target === undefined) {\n    return;\n  }\n  const firstMovedVisualRow = _classPrivateFieldGet(_rowsToMove, this)[0];\n  const firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);\n  const movePerformed = this.dragRows(_classPrivateFieldGet(_rowsToMove, this), target);\n  _classPrivateFieldGet(_rowsToMove, this).length = 0;\n  if (movePerformed === true) {\n    this.persistentStateSave();\n    this.hot.render();\n    this.hot.view.adjustElementsSize();\n    const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);\n    const selectionEnd = selectionStart + rowsLen - 1;\n    this.hot.selectRows(selectionStart, selectionEnd);\n  }\n}\n/**\n * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.\n */\nfunction _onAfterScrollHorizontally() {\n  const wtTable = this.hot.view._wt.wtTable;\n  const headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();\n  const scrollLeft = wtTable.holder.scrollLeft;\n  const posLeft = headerWidth + scrollLeft;\n  _classPrivateFieldGet(_backlight, this).setPosition(null, posLeft);\n  _classPrivateFieldGet(_backlight, this).setSize(wtTable.hider.offsetWidth - posLeft);\n}\nfunction _onAfterLoadData() {\n  this.moveBySettingsOrLoad();\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}