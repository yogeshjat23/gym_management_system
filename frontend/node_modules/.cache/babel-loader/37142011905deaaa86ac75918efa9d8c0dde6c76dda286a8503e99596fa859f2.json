{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { DEFAULT_COLUMN_WIDTH } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nHooks.getSingleton().register('modifyAutoColumnSizeSeed');\nexport const PLUGIN_KEY = 'autoColumnSize';\nexport const PLUGIN_PRIORITY = 10;\nconst COLUMN_SIZE_MAP_NAME = 'autoColumnSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoColumnSize\n * @class AutoColumnSize\n *\n * @description\n * This plugin allows to set column widths based on their widest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it enabled (same as if it was declared as `true`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the widths of all cells to\n * resize the columns accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the column widths manually.\n *\n * Column width calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of columns) or a percentage value to a config object:\n *\n * ```js\n * // as a number (300 columns in sync, rest async)\n * autoColumnSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoColumnSize: {syncLimit: '40%'},\n * ```\n *\n * The plugin uses {@link GhostTable} and {@link SamplesGenerator} for calculations.\n * First, {@link SamplesGenerator} prepares samples of data with its coordinates.\n * Next {@link GhostTable} uses coordinates to get cells' renderers and append all to the DOM through DocumentFragment.\n *\n * Sampling accepts additional options:\n * - *samplingRatio* - Defines how many samples for the same length will be used to calculate. Default is `3`.\n *\n * ```js\n *   autoColumnSize: {\n *     samplingRatio: 10,\n *   }\n * ```\n *\n * - *allowSampleDuplicates* - Defines if duplicated values might be used in sampling. Default is `false`.\n *\n * ```js\n *   autoColumnSize: {\n *     allowSampleDuplicates: true,\n *   }\n * ```\n *\n * To configure this plugin see {@link Options#autoColumnSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoColumnSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoColumnSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _cachedColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _visualColumnsToRefresh = /*#__PURE__*/new WeakMap();\nvar _AutoColumnSize_brand = /*#__PURE__*/new WeakSet();\nexport class AutoColumnSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 50;\n  }\n\n  /**\n   * Instance of {@link GhostTable} for rows and columns size calculations.\n   *\n   * @private\n   * @type {GhostTable}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * Calculates specific columns width (overwrite cache values).\n     *\n     * @param {number[]} visualColumns List of visual columns to calculate.\n     */\n    _classPrivateMethodInitSpec(this, _AutoColumnSize_brand);\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for columns width calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     * @fires Hooks#modifyAutoColumnSizeSeed\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      const physicalRow = this.hot.toPhysicalRow(row);\n      const physicalColumn = this.hot.toPhysicalColumn(column);\n      if (this.hot.rowIndexMapper.isHidden(physicalRow) || this.hot.columnIndexMapper.isHidden(physicalColumn)) {\n        return false;\n      }\n      const cellMeta = this.hot.getCellMeta(row, column);\n      let cellValue = '';\n      if (!cellMeta.spanned) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      }\n      let bundleSeed = '';\n      if (this.hot.hasHook('modifyAutoColumnSizeSeed')) {\n        bundleSeed = this.hot.runHooks('modifyAutoColumnSizeSeed', bundleSeed, cellMeta, cellValue);\n      }\n      return {\n        value: cellValue,\n        bundleSeed\n      };\n    }));\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured columns (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredColumns\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track widths for physical column indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"columnWidthsMap\", new IndexToValueMap());\n    /**\n     * Cached column header names. It is used to diff current column headers with previous state and detect which\n     * columns width should be updated.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _cachedColumnHeaders, []);\n    /**\n     * An array of column indexes whose width will be recalculated.\n     *\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _visualColumnsToRefresh, []);\n    this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, this.columnWidthsMap);\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _assertClassBrand(_AutoColumnSize_brand, this, _onBeforeColumnResize).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link #enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings()[PLUGIN_KEY] !== false && !this.hot.getSettings().colWidths;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    if (setting && setting.useHeaders !== null && setting.useHeaders !== undefined) {\n      this.ghostTable.setSetting('useHeaders', setting.useHeaders);\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_AutoColumnSize_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_AutoColumnSize_brand, _this, _onBeforeChange).call(_this, ...args);\n    });\n    this.addHook('afterFormulasValuesUpdate', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_AutoColumnSize_brand, _this, _onAfterFormulasValuesUpdate).call(_this, ...args);\n    });\n    this.addHook('beforeRender', () => _assertClassBrand(_AutoColumnSize_brand, this, _onBeforeRender).call(this));\n    this.addHook('modifyColWidth', (width, col) => this.getColumnWidth(col, width));\n    this.addHook('init', () => _assertClassBrand(_AutoColumnSize_brand, this, _onInit).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.\n   */\n  updatePlugin() {\n    _classPrivateFieldSet(_visualColumnsToRefresh, this, this.findColumnsWhereHeaderWasChanged());\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _assertClassBrand(_AutoColumnSize_brand, this, _onBeforeColumnResize).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Calculates widths for visible columns in the viewport only.\n   */\n  calculateVisibleColumnsWidth() {\n    // Keep last column widths unchanged for situation when all rows was deleted or trimmed (pro #6)\n    if (!this.hot.countRows()) {\n      return;\n    }\n    const firstVisibleColumn = this.getFirstVisibleColumn();\n    const lastVisibleColumn = this.getLastVisibleColumn();\n    if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {\n      return;\n    }\n    const overwriteCache = this.hot.renderCall;\n    this.calculateColumnsWidth({\n      from: firstVisibleColumn,\n      to: lastVisibleColumn\n    }, undefined, overwriteCache);\n  }\n\n  /**\n   * Calculates a columns width.\n   *\n   * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.\n   * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.\n   * @param {boolean} [overwriteCache=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateColumnsWidth() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let rowRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let overwriteCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    rangeEach(columnsRange.from, columnsRange.to, visualColumn => {\n      let physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      if (physicalColumn === null) {\n        physicalColumn = visualColumn;\n      }\n      if (overwriteCache || this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !this.hot._getColWidthFromSettings(physicalColumn)) {\n        const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n        samples.forEach((sample, column) => this.ghostTable.addColumn(column, sample));\n      }\n    });\n    if (this.ghostTable.columns.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getWidths((visualColumn, width) => {\n          const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n          this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n        });\n      }, true);\n      this.measuredColumns = columnsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.\n   * To retrieve width for specified column use {@link AutoColumnSize#getColumnWidth} method.\n   *\n   * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.\n   * @param {boolean} [overwriteCache] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateAllColumnsWidth() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let overwriteCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let current = 0;\n    const length = this.hot.countCols() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateColumnsWidth({\n        from: current,\n        to: Math.min(current + AutoColumnSize.CALCULATION_STEP, length)\n      }, rowRange, overwriteCache);\n      current = current + AutoColumnSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize();\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (syncLimit >= 0) {\n      this.calculateColumnsWidth({\n        from: 0,\n        to: syncLimit\n      }, rowRange, overwriteCache);\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n    }\n  }\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all columns width (overwrite cache values).\n   */\n  recalculateAllColumnsWidth() {\n    if (this.hot.view.isVisible()) {\n      this.calculateAllColumnsWidth({\n        from: 0,\n        to: this.hot.countRows() - 1\n      }, true);\n    }\n  }\n\n  /**\n   * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoColumnSize.SYNC_CALCULATION_LIMIT;\n    const colsLimit = this.hot.countCols() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(colsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, colsLimit);\n  }\n\n  /**\n   * Gets the calculated column width.\n   *\n   * @param {number} column Visual column index.\n   * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.\n   * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).\n   * @returns {number}\n   */\n  getColumnWidth(column, defaultWidth) {\n    let keepMinimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let width = defaultWidth;\n    if (width === undefined) {\n      width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));\n      if (keepMinimum && typeof width === 'number') {\n        width = Math.max(width, DEFAULT_COLUMN_WIDTH);\n      }\n    }\n    return width;\n  }\n\n  /**\n   * Gets the first visible column.\n   *\n   * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.\n   */\n  getFirstVisibleColumn() {\n    var _this$hot$view$getFir;\n    return (_this$hot$view$getFir = this.hot.view.getFirstRenderedVisibleColumn()) !== null && _this$hot$view$getFir !== void 0 ? _this$hot$view$getFir : -1;\n  }\n\n  /**\n   * Gets the last visible column.\n   *\n   * @returns {number} Returns visual column index or -1 if table is not rendered.\n   */\n  getLastVisibleColumn() {\n    var _this$hot$view$getLas;\n    return (_this$hot$view$getLas = this.hot.view.getLastRenderedVisibleColumn()) !== null && _this$hot$view$getLas !== void 0 ? _this$hot$view$getLas : -1;\n  }\n\n  /**\n   * Collects all columns which titles has been changed in comparison to the previous state.\n   *\n   * @private\n   * @returns {Array} It returns an array of visual column indexes.\n   */\n  findColumnsWhereHeaderWasChanged() {\n    const columnHeaders = this.hot.getColHeader();\n    const changedColumns = columnHeaders.reduce((acc, columnTitle, physicalColumn) => {\n      const cachedColumnsLength = _classPrivateFieldGet(_cachedColumnHeaders, this).length;\n      if (cachedColumnsLength - 1 < physicalColumn || _classPrivateFieldGet(_cachedColumnHeaders, this)[physicalColumn] !== columnTitle) {\n        acc.push(this.hot.toVisualColumn(physicalColumn));\n      }\n      if (cachedColumnsLength - 1 < physicalColumn) {\n        _classPrivateFieldGet(_cachedColumnHeaders, this).push(columnTitle);\n      } else {\n        _classPrivateFieldGet(_cachedColumnHeaders, this)[physicalColumn] = columnTitle;\n      }\n      return acc;\n    }, []);\n    return changedColumns;\n  }\n\n  /**\n   * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.\n   * Otherwise whole cache will be cleared.\n   *\n   * @param {number[]} [physicalColumns] List of physical column indexes to clear.\n   */\n  clearCache(physicalColumns) {\n    if (Array.isArray(physicalColumns)) {\n      this.hot.batchExecution(() => {\n        physicalColumns.forEach(physicalIndex => {\n          this.columnWidthsMap.setValueAtIndex(physicalIndex, null);\n        });\n      }, true);\n    } else {\n      this.columnWidthsMap.clear();\n    }\n  }\n\n  /**\n   * Checks if all widths were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!this.columnWidthsMap.getValues().slice(0, this.measuredColumns).filter(item => item === null).length;\n  }\n\n  /**\n   * On before view render listener.\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _calculateSpecificColumnsWidth(visualColumns) {\n  const rowsRange = {\n    from: 0,\n    to: this.hot.countRows() - 1\n  };\n  visualColumns.forEach(visualColumn => {\n    const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n    if (physicalColumn === null) {\n      return;\n    }\n    if (!this.hot._getColWidthFromSettings(physicalColumn)) {\n      const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n      samples.forEach((sample, column) => this.ghostTable.addColumn(column, sample));\n    }\n  });\n  if (this.ghostTable.columns.length) {\n    this.hot.batchExecution(() => {\n      this.ghostTable.getWidths((visualColumn, width) => {\n        const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n        this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n      });\n    }, true);\n    this.ghostTable.clean();\n  }\n}\nfunction _onBeforeRender() {\n  this.calculateVisibleColumnsWidth();\n  if (!this.inProgress) {\n    _assertClassBrand(_AutoColumnSize_brand, this, _calculateSpecificColumnsWidth).call(this, _classPrivateFieldGet(_visualColumnsToRefresh, this));\n    _classPrivateFieldSet(_visualColumnsToRefresh, this, []);\n  }\n}\n/**\n * On after load data listener.\n *\n * @param {Array} sourceData Source data.\n * @param {boolean} isFirstLoad `true` if this is the first load.\n */\nfunction _onAfterLoadData(sourceData, isFirstLoad) {\n  if (!isFirstLoad) {\n    this.recalculateAllColumnsWidth();\n  }\n}\n/**\n * On before change listener.\n *\n * @param {Array} changes An array of modified data.\n */\nfunction _onBeforeChange(changes) {\n  const changedColumns = changes.reduce((acc, _ref) => {\n    let [, columnProperty] = _ref;\n    const visualColumn = this.hot.propToCol(columnProperty);\n    if (Number.isInteger(visualColumn) && acc.indexOf(visualColumn) === -1) {\n      acc.push(visualColumn);\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualColumnsToRefresh, this).push(...changedColumns);\n}\n/**\n * On before column resize listener.\n *\n * @param {number} size Calculated new column width.\n * @param {number} column Visual index of the resized column.\n * @param {boolean} isDblClick  Flag that determines whether there was a double-click.\n * @returns {number}\n */\nfunction _onBeforeColumnResize(size, column, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateColumnsWidth(column, undefined, true);\n    newSize = this.getColumnWidth(column, undefined, false);\n  }\n  return newSize;\n}\n/**\n * On after Handsontable init fill plugin with all necessary values.\n */\nfunction _onInit() {\n  _classPrivateFieldSet(_cachedColumnHeaders, this, this.hot.getColHeader());\n  this.recalculateAllColumnsWidth();\n}\n/**\n * After formulas values updated listener.\n *\n * @param {Array} changes An array of modified data.\n */\nfunction _onAfterFormulasValuesUpdate(changes) {\n  const changedColumns = changes.reduce((acc, change) => {\n    var _change$address;\n    const physicalColumn = (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col;\n    if (Number.isInteger(physicalColumn)) {\n      const visualColumn = this.hot.toVisualColumn(physicalColumn);\n      if (acc.indexOf(visualColumn) === -1) {\n        acc.push(visualColumn);\n      }\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualColumnsToRefresh, this).push(...changedColumns);\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","n","arguments","length","BasePlugin","cancelAnimationFrame","requestAnimationFrame","GhostTable","Hooks","isObject","hasOwnProperty","valueAccordingPercent","rangeEach","SamplesGenerator","isPercentValue","DEFAULT_COLUMN_WIDTH","PhysicalIndexToValueMap","IndexToValueMap","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","COLUMN_SIZE_MAP_NAME","_cachedColumnHeaders","WeakMap","_visualColumnsToRefresh","_AutoColumnSize_brand","WeakSet","AutoColumnSize","SETTING_KEYS","CALCULATION_STEP","SYNC_CALCULATION_LIMIT","constructor","hotInstance","hot","row","column","physicalRow","toPhysicalRow","physicalColumn","toPhysicalColumn","rowIndexMapper","isHidden","columnIndexMapper","cellMeta","getCellMeta","cellValue","spanned","getDataAtCell","bundleSeed","hasHook","runHooks","registerMap","columnWidthsMap","addHook","size","isDblClick","_onBeforeColumnResize","isEnabled","getSettings","colWidths","enablePlugin","_this","enabled","setting","useHeaders","undefined","ghostTable","setSetting","setSamplingOptions","_len","args","Array","_key","_onAfterLoadData","_len2","_key2","_onBeforeChange","_len3","_key3","_onAfterFormulasValuesUpdate","_onBeforeRender","width","col","getColumnWidth","_onInit","updatePlugin","findColumnsWhereHeaderWasChanged","disablePlugin","calculateVisibleColumnsWidth","countRows","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","overwriteCache","renderCall","calculateColumnsWidth","from","to","colRange","countCols","rowRange","columnsRange","rowsRange","visualColumn","getValueAtIndex","_getColWidthFromSettings","samples","samplesGenerator","generateColumnSamples","forEach","sample","addColumn","columns","batchExecution","getWidths","setValueAtIndex","measuredColumns","clean","calculateAllColumnsWidth","current","timer","inProgress","loop","Math","min","view","adjustElementsSize","syncLimit","getSyncCalculationLimit","samplingRatio","allowSampleDuplicates","isNaN","setSampleCount","parseInt","setAllowDuplicates","recalculateAllColumnsWidth","isVisible","settings","limit","colsLimit","defaultWidth","keepMinimum","max","_this$hot$view$getFir","getFirstRenderedVisibleColumn","_this$hot$view$getLas","getLastRenderedVisibleColumn","columnHeaders","getColHeader","changedColumns","reduce","acc","columnTitle","cachedColumnsLength","push","toVisualColumn","clearCache","physicalColumns","isArray","physicalIndex","clear","isNeedRecalculate","getValues","slice","filter","item","destroy","_calculateSpecificColumnsWidth","visualColumns","sourceData","isFirstLoad","changes","_ref","columnProperty","propToCol","isInteger","indexOf","newSize","change","_change$address","address"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/autoColumnSize/autoColumnSize.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { DEFAULT_COLUMN_WIDTH } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nHooks.getSingleton().register('modifyAutoColumnSizeSeed');\nexport const PLUGIN_KEY = 'autoColumnSize';\nexport const PLUGIN_PRIORITY = 10;\nconst COLUMN_SIZE_MAP_NAME = 'autoColumnSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoColumnSize\n * @class AutoColumnSize\n *\n * @description\n * This plugin allows to set column widths based on their widest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it enabled (same as if it was declared as `true`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the widths of all cells to\n * resize the columns accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the column widths manually.\n *\n * Column width calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of columns) or a percentage value to a config object:\n *\n * ```js\n * // as a number (300 columns in sync, rest async)\n * autoColumnSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoColumnSize: {syncLimit: '40%'},\n * ```\n *\n * The plugin uses {@link GhostTable} and {@link SamplesGenerator} for calculations.\n * First, {@link SamplesGenerator} prepares samples of data with its coordinates.\n * Next {@link GhostTable} uses coordinates to get cells' renderers and append all to the DOM through DocumentFragment.\n *\n * Sampling accepts additional options:\n * - *samplingRatio* - Defines how many samples for the same length will be used to calculate. Default is `3`.\n *\n * ```js\n *   autoColumnSize: {\n *     samplingRatio: 10,\n *   }\n * ```\n *\n * - *allowSampleDuplicates* - Defines if duplicated values might be used in sampling. Default is `false`.\n *\n * ```js\n *   autoColumnSize: {\n *     allowSampleDuplicates: true,\n *   }\n * ```\n *\n * To configure this plugin see {@link Options#autoColumnSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoColumnSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoColumnSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _cachedColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _visualColumnsToRefresh = /*#__PURE__*/new WeakMap();\nvar _AutoColumnSize_brand = /*#__PURE__*/new WeakSet();\nexport class AutoColumnSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 50;\n  }\n\n  /**\n   * Instance of {@link GhostTable} for rows and columns size calculations.\n   *\n   * @private\n   * @type {GhostTable}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * Calculates specific columns width (overwrite cache values).\n     *\n     * @param {number[]} visualColumns List of visual columns to calculate.\n     */\n    _classPrivateMethodInitSpec(this, _AutoColumnSize_brand);\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for columns width calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     * @fires Hooks#modifyAutoColumnSizeSeed\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      const physicalRow = this.hot.toPhysicalRow(row);\n      const physicalColumn = this.hot.toPhysicalColumn(column);\n      if (this.hot.rowIndexMapper.isHidden(physicalRow) || this.hot.columnIndexMapper.isHidden(physicalColumn)) {\n        return false;\n      }\n      const cellMeta = this.hot.getCellMeta(row, column);\n      let cellValue = '';\n      if (!cellMeta.spanned) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      }\n      let bundleSeed = '';\n      if (this.hot.hasHook('modifyAutoColumnSizeSeed')) {\n        bundleSeed = this.hot.runHooks('modifyAutoColumnSizeSeed', bundleSeed, cellMeta, cellValue);\n      }\n      return {\n        value: cellValue,\n        bundleSeed\n      };\n    }));\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured columns (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredColumns\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track widths for physical column indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"columnWidthsMap\", new IndexToValueMap());\n    /**\n     * Cached column header names. It is used to diff current column headers with previous state and detect which\n     * columns width should be updated.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _cachedColumnHeaders, []);\n    /**\n     * An array of column indexes whose width will be recalculated.\n     *\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _visualColumnsToRefresh, []);\n    this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, this.columnWidthsMap);\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _assertClassBrand(_AutoColumnSize_brand, this, _onBeforeColumnResize).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link #enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings()[PLUGIN_KEY] !== false && !this.hot.getSettings().colWidths;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    if (setting && setting.useHeaders !== null && setting.useHeaders !== undefined) {\n      this.ghostTable.setSetting('useHeaders', setting.useHeaders);\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_AutoColumnSize_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_AutoColumnSize_brand, _this, _onBeforeChange).call(_this, ...args);\n    });\n    this.addHook('afterFormulasValuesUpdate', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_AutoColumnSize_brand, _this, _onAfterFormulasValuesUpdate).call(_this, ...args);\n    });\n    this.addHook('beforeRender', () => _assertClassBrand(_AutoColumnSize_brand, this, _onBeforeRender).call(this));\n    this.addHook('modifyColWidth', (width, col) => this.getColumnWidth(col, width));\n    this.addHook('init', () => _assertClassBrand(_AutoColumnSize_brand, this, _onInit).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.\n   */\n  updatePlugin() {\n    _classPrivateFieldSet(_visualColumnsToRefresh, this, this.findColumnsWhereHeaderWasChanged());\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _assertClassBrand(_AutoColumnSize_brand, this, _onBeforeColumnResize).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Calculates widths for visible columns in the viewport only.\n   */\n  calculateVisibleColumnsWidth() {\n    // Keep last column widths unchanged for situation when all rows was deleted or trimmed (pro #6)\n    if (!this.hot.countRows()) {\n      return;\n    }\n    const firstVisibleColumn = this.getFirstVisibleColumn();\n    const lastVisibleColumn = this.getLastVisibleColumn();\n    if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {\n      return;\n    }\n    const overwriteCache = this.hot.renderCall;\n    this.calculateColumnsWidth({\n      from: firstVisibleColumn,\n      to: lastVisibleColumn\n    }, undefined, overwriteCache);\n  }\n\n  /**\n   * Calculates a columns width.\n   *\n   * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.\n   * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.\n   * @param {boolean} [overwriteCache=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateColumnsWidth() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let rowRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let overwriteCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    rangeEach(columnsRange.from, columnsRange.to, visualColumn => {\n      let physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      if (physicalColumn === null) {\n        physicalColumn = visualColumn;\n      }\n      if (overwriteCache || this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !this.hot._getColWidthFromSettings(physicalColumn)) {\n        const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n        samples.forEach((sample, column) => this.ghostTable.addColumn(column, sample));\n      }\n    });\n    if (this.ghostTable.columns.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getWidths((visualColumn, width) => {\n          const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n          this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n        });\n      }, true);\n      this.measuredColumns = columnsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.\n   * To retrieve width for specified column use {@link AutoColumnSize#getColumnWidth} method.\n   *\n   * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.\n   * @param {boolean} [overwriteCache] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateAllColumnsWidth() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let overwriteCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let current = 0;\n    const length = this.hot.countCols() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateColumnsWidth({\n        from: current,\n        to: Math.min(current + AutoColumnSize.CALCULATION_STEP, length)\n      }, rowRange, overwriteCache);\n      current = current + AutoColumnSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize();\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (syncLimit >= 0) {\n      this.calculateColumnsWidth({\n        from: 0,\n        to: syncLimit\n      }, rowRange, overwriteCache);\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n    }\n  }\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all columns width (overwrite cache values).\n   */\n  recalculateAllColumnsWidth() {\n    if (this.hot.view.isVisible()) {\n      this.calculateAllColumnsWidth({\n        from: 0,\n        to: this.hot.countRows() - 1\n      }, true);\n    }\n  }\n\n  /**\n   * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoColumnSize.SYNC_CALCULATION_LIMIT;\n    const colsLimit = this.hot.countCols() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(colsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, colsLimit);\n  }\n\n  /**\n   * Gets the calculated column width.\n   *\n   * @param {number} column Visual column index.\n   * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.\n   * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).\n   * @returns {number}\n   */\n  getColumnWidth(column, defaultWidth) {\n    let keepMinimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let width = defaultWidth;\n    if (width === undefined) {\n      width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));\n      if (keepMinimum && typeof width === 'number') {\n        width = Math.max(width, DEFAULT_COLUMN_WIDTH);\n      }\n    }\n    return width;\n  }\n\n  /**\n   * Gets the first visible column.\n   *\n   * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.\n   */\n  getFirstVisibleColumn() {\n    var _this$hot$view$getFir;\n    return (_this$hot$view$getFir = this.hot.view.getFirstRenderedVisibleColumn()) !== null && _this$hot$view$getFir !== void 0 ? _this$hot$view$getFir : -1;\n  }\n\n  /**\n   * Gets the last visible column.\n   *\n   * @returns {number} Returns visual column index or -1 if table is not rendered.\n   */\n  getLastVisibleColumn() {\n    var _this$hot$view$getLas;\n    return (_this$hot$view$getLas = this.hot.view.getLastRenderedVisibleColumn()) !== null && _this$hot$view$getLas !== void 0 ? _this$hot$view$getLas : -1;\n  }\n\n  /**\n   * Collects all columns which titles has been changed in comparison to the previous state.\n   *\n   * @private\n   * @returns {Array} It returns an array of visual column indexes.\n   */\n  findColumnsWhereHeaderWasChanged() {\n    const columnHeaders = this.hot.getColHeader();\n    const changedColumns = columnHeaders.reduce((acc, columnTitle, physicalColumn) => {\n      const cachedColumnsLength = _classPrivateFieldGet(_cachedColumnHeaders, this).length;\n      if (cachedColumnsLength - 1 < physicalColumn || _classPrivateFieldGet(_cachedColumnHeaders, this)[physicalColumn] !== columnTitle) {\n        acc.push(this.hot.toVisualColumn(physicalColumn));\n      }\n      if (cachedColumnsLength - 1 < physicalColumn) {\n        _classPrivateFieldGet(_cachedColumnHeaders, this).push(columnTitle);\n      } else {\n        _classPrivateFieldGet(_cachedColumnHeaders, this)[physicalColumn] = columnTitle;\n      }\n      return acc;\n    }, []);\n    return changedColumns;\n  }\n\n  /**\n   * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.\n   * Otherwise whole cache will be cleared.\n   *\n   * @param {number[]} [physicalColumns] List of physical column indexes to clear.\n   */\n  clearCache(physicalColumns) {\n    if (Array.isArray(physicalColumns)) {\n      this.hot.batchExecution(() => {\n        physicalColumns.forEach(physicalIndex => {\n          this.columnWidthsMap.setValueAtIndex(physicalIndex, null);\n        });\n      }, true);\n    } else {\n      this.columnWidthsMap.clear();\n    }\n  }\n\n  /**\n   * Checks if all widths were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!this.columnWidthsMap.getValues().slice(0, this.measuredColumns).filter(item => item === null).length;\n  }\n\n  /**\n   * On before view render listener.\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _calculateSpecificColumnsWidth(visualColumns) {\n  const rowsRange = {\n    from: 0,\n    to: this.hot.countRows() - 1\n  };\n  visualColumns.forEach(visualColumn => {\n    const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n    if (physicalColumn === null) {\n      return;\n    }\n    if (!this.hot._getColWidthFromSettings(physicalColumn)) {\n      const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n      samples.forEach((sample, column) => this.ghostTable.addColumn(column, sample));\n    }\n  });\n  if (this.ghostTable.columns.length) {\n    this.hot.batchExecution(() => {\n      this.ghostTable.getWidths((visualColumn, width) => {\n        const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n        this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n      });\n    }, true);\n    this.ghostTable.clean();\n  }\n}\nfunction _onBeforeRender() {\n  this.calculateVisibleColumnsWidth();\n  if (!this.inProgress) {\n    _assertClassBrand(_AutoColumnSize_brand, this, _calculateSpecificColumnsWidth).call(this, _classPrivateFieldGet(_visualColumnsToRefresh, this));\n    _classPrivateFieldSet(_visualColumnsToRefresh, this, []);\n  }\n}\n/**\n * On after load data listener.\n *\n * @param {Array} sourceData Source data.\n * @param {boolean} isFirstLoad `true` if this is the first load.\n */\nfunction _onAfterLoadData(sourceData, isFirstLoad) {\n  if (!isFirstLoad) {\n    this.recalculateAllColumnsWidth();\n  }\n}\n/**\n * On before change listener.\n *\n * @param {Array} changes An array of modified data.\n */\nfunction _onBeforeChange(changes) {\n  const changedColumns = changes.reduce((acc, _ref) => {\n    let [, columnProperty] = _ref;\n    const visualColumn = this.hot.propToCol(columnProperty);\n    if (Number.isInteger(visualColumn) && acc.indexOf(visualColumn) === -1) {\n      acc.push(visualColumn);\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualColumnsToRefresh, this).push(...changedColumns);\n}\n/**\n * On before column resize listener.\n *\n * @param {number} size Calculated new column width.\n * @param {number} column Visual index of the resized column.\n * @param {boolean} isDblClick  Flag that determines whether there was a double-click.\n * @returns {number}\n */\nfunction _onBeforeColumnResize(size, column, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateColumnsWidth(column, undefined, true);\n    newSize = this.getColumnWidth(column, undefined, false);\n  }\n  return newSize;\n}\n/**\n * On after Handsontable init fill plugin with all necessary values.\n */\nfunction _onInit() {\n  _classPrivateFieldSet(_cachedColumnHeaders, this, this.hot.getColHeader());\n  this.recalculateAllColumnsWidth();\n}\n/**\n * After formulas values updated listener.\n *\n * @param {Array} changes An array of modified data.\n */\nfunction _onAfterFormulasValuesUpdate(changes) {\n  const changedColumns = changes.reduce((acc, change) => {\n    var _change$address;\n    const physicalColumn = (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col;\n    if (Number.isInteger(physicalColumn)) {\n      const visualColumn = this.hot.toVisualColumn(physicalColumn);\n      if (acc.indexOf(visualColumn) === -1) {\n        acc.push(visualColumn);\n      }\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualColumnsToRefresh, this).push(...changedColumns);\n}"],"mappings":"AAEA,SAASA,2BAA2BA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAAEC,0BAA0B,CAACF,CAAC,EAAEC,CAAC,CAAC,EAAEA,CAAC,CAACE,GAAG,CAACH,CAAC,CAAC;AAAE;AACzF,SAASI,0BAA0BA,CAACJ,CAAC,EAAEK,CAAC,EAAEJ,CAAC,EAAE;EAAEC,0BAA0B,CAACF,CAAC,EAAEK,CAAC,CAAC,EAAEA,CAAC,CAACC,GAAG,CAACN,CAAC,EAAEC,CAAC,CAAC;AAAE;AAC9F,SAASC,0BAA0BA,CAACF,CAAC,EAAEK,CAAC,EAAE;EAAE,IAAIA,CAAC,CAACE,GAAG,CAACP,CAAC,CAAC,EAAE,MAAM,IAAIQ,SAAS,CAAC,gEAAgE,CAAC;AAAE;AACjJ,SAASC,eAAeA,CAACT,CAAC,EAAEU,CAAC,EAAEL,CAAC,EAAE;EAAE,OAAO,CAACK,CAAC,GAAGC,cAAc,CAACD,CAAC,CAAC,KAAKV,CAAC,GAAGY,MAAM,CAACC,cAAc,CAACb,CAAC,EAAEU,CAAC,EAAE;IAAEI,KAAK,EAAET,CAAC;IAAEU,UAAU,EAAE,CAAC,CAAC;IAAEC,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGjB,CAAC,CAACU,CAAC,CAAC,GAAGL,CAAC,EAAEL,CAAC;AAAE;AACnL,SAASW,cAAcA,CAACN,CAAC,EAAE;EAAE,IAAIa,CAAC,GAAGC,YAAY,CAACd,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOa,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAACd,CAAC,EAAEK,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOL,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIL,CAAC,GAAGK,CAAC,CAACe,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKrB,CAAC,EAAE;IAAE,IAAIkB,CAAC,GAAGlB,CAAC,CAACsB,IAAI,CAACjB,CAAC,EAAEK,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOQ,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIV,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKE,CAAC,GAAGa,MAAM,GAAGC,MAAM,EAAEnB,CAAC,CAAC;AAAE;AACvT,SAASoB,qBAAqBA,CAACC,CAAC,EAAEzB,CAAC,EAAE;EAAE,OAAOyB,CAAC,CAACC,GAAG,CAACC,iBAAiB,CAACF,CAAC,EAAEzB,CAAC,CAAC,CAAC;AAAE;AAC9E,SAAS4B,qBAAqBA,CAACH,CAAC,EAAEzB,CAAC,EAAES,CAAC,EAAE;EAAE,OAAOgB,CAAC,CAACpB,GAAG,CAACsB,iBAAiB,CAACF,CAAC,EAAEzB,CAAC,CAAC,EAAES,CAAC,CAAC,EAAEA,CAAC;AAAE;AACvF,SAASkB,iBAAiBA,CAAC5B,CAAC,EAAEK,CAAC,EAAEyB,CAAC,EAAE;EAAE,IAAI,UAAU,IAAI,OAAO9B,CAAC,GAAGA,CAAC,KAAKK,CAAC,GAAGL,CAAC,CAACO,GAAG,CAACF,CAAC,CAAC,EAAE,OAAO0B,SAAS,CAACC,MAAM,GAAG,CAAC,GAAG3B,CAAC,GAAGyB,CAAC;EAAE,MAAM,IAAItB,SAAS,CAAC,+CAA+C,CAAC;AAAE;AAClM,SAASyB,UAAU,QAAQ,mBAAmB;AAC9C,SAASC,oBAAoB,EAAEC,qBAAqB,QAAQ,2BAA2B;AACvF,OAAOC,UAAU,MAAM,4BAA4B;AACnD,OAAOC,KAAK,MAAM,uBAAuB;AACzC,SAASC,QAAQ,EAAEC,cAAc,QAAQ,0BAA0B;AACnE,SAASC,qBAAqB,EAAEC,SAAS,QAAQ,0BAA0B;AAC3E,OAAOC,gBAAgB,MAAM,kCAAkC;AAC/D,SAASC,cAAc,QAAQ,0BAA0B;AACzD,SAASC,oBAAoB,QAAQ,0CAA0C;AAC/E,SAASC,uBAAuB,IAAIC,eAAe,QAAQ,8BAA8B;AACzFT,KAAK,CAACU,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,0BAA0B,CAAC;AACzD,OAAO,MAAMC,UAAU,GAAG,gBAAgB;AAC1C,OAAO,MAAMC,eAAe,GAAG,EAAE;AACjC,MAAMC,oBAAoB,GAAG,gBAAgB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,oBAAoB,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AACrD,IAAIC,uBAAuB,GAAG,aAAa,IAAID,OAAO,CAAC,CAAC;AACxD,IAAIE,qBAAqB,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AACtD,OAAO,MAAMC,cAAc,SAASxB,UAAU,CAAC;EAC7C,WAAWgB,UAAUA,CAAA,EAAG;IACtB,OAAOA,UAAU;EACnB;EACA,WAAWC,eAAeA,CAAA,EAAG;IAC3B,OAAOA,eAAe;EACxB;EACA,WAAWQ,YAAYA,CAAA,EAAG;IACxB,OAAO,IAAI;EACb;EACA,WAAWC,gBAAgBA,CAAA,EAAG;IAC5B,OAAO,EAAE;EACX;EACA,WAAWC,sBAAsBA,CAAA,EAAG;IAClC,OAAO,EAAE;EACX;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEEC,WAAWA,CAACC,WAAW,EAAE;IACvB,KAAK,CAACA,WAAW,CAAC;IAClB;AACJ;AACA;AACA;AACA;IACI/D,2BAA2B,CAAC,IAAI,EAAEwD,qBAAqB,CAAC;IACxD9C,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,IAAI2B,UAAU,CAAC,IAAI,CAAC2B,GAAG,CAAC,CAAC;IAC7D;AACJ;AACA;AACA;AACA;AACA;AACA;IACIt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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}