{"ast":null,"code":"import { sanitize } from \"../string.mjs\";\nimport { A11Y_HIDDEN } from \"../a11y.mjs\";\n/**\n * Get the parent of the specified node in the DOM tree.\n *\n * @param {HTMLElement} element Element from which traversing is started.\n * @param {number} [level=0] Traversing deep level.\n * @returns {HTMLElement|null}\n */\nexport function getParent(element) {\n  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let iteration = -1;\n  let parent = null;\n  let elementToCheck = element;\n  while (elementToCheck !== null) {\n    if (iteration === level) {\n      parent = elementToCheck;\n      break;\n    }\n    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = elementToCheck.host;\n    } else {\n      iteration += 1;\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  return parent;\n}\n\n/**\n * Check if the provided element is a child of the provided Handsontable container.\n *\n * @param {HTMLElement} element Element to be analyzed.\n * @param {HTMLElement} thisHotContainer The Handsontable container.\n * @returns {boolean}\n */\nexport function isThisHotChild(element, thisHotContainer) {\n  const closestHandsontableContainer = element.closest('.handsontable');\n  return !!closestHandsontableContainer && (closestHandsontableContainer.parentNode === thisHotContainer || closestHandsontableContainer === thisHotContainer);\n}\n\n/**\n * Gets `frameElement` of the specified frame. Returns null if it is a top frame or if script has no access to read property.\n *\n * @param {Window} frame Frame from which should be get frameElement in safe way.\n * @returns {HTMLIFrameElement|null}\n */\nexport function getFrameElement(frame) {\n  return Object.getPrototypeOf(frame.parent) && frame.frameElement;\n}\n\n/**\n * Gets parent frame of the specified frame. Returns null if it is a top frame or if script has no access to read property.\n *\n * @param {Window} frame Frame from which should get frameElement in a safe way.\n * @returns {Window|null}\n */\nexport function getParentWindow(frame) {\n  return getFrameElement(frame) && frame.parent;\n}\n\n/**\n * Checks if script has access to read from parent frame of specified frame.\n *\n * @param {Window} frame Frame from which should get frameElement in a safe way.\n * @returns {boolean}\n */\nexport function hasAccessToParentWindow(frame) {\n  return !!Object.getPrototypeOf(frame.parent);\n}\n\n/**\n * Goes up the DOM tree (including given element) until it finds an parent element that matches the nodes or nodes name.\n * This method goes up through web components.\n *\n * @param {Node} element Element from which traversing is started.\n * @param {Array<string|Node>} [nodes] Array of elements or Array of elements name (in uppercase form).\n * @param {Node} [until] The element until the traversing ends.\n * @returns {Node|null}\n */\nexport function closest(element) {\n  let nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let until = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    ELEMENT_NODE,\n    DOCUMENT_FRAGMENT_NODE\n  } = Node;\n  let elementToCheck = element;\n  while (elementToCheck !== null && elementToCheck !== undefined && elementToCheck !== until) {\n    const {\n      nodeType,\n      nodeName\n    } = elementToCheck;\n    if (nodeType === ELEMENT_NODE && (nodes.includes(nodeName) || nodes.includes(elementToCheck))) {\n      return elementToCheck;\n    }\n    const {\n      host\n    } = elementToCheck;\n    if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = host;\n    } else {\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  return null;\n}\n\n/**\n * Goes \"down\" the DOM tree (including given element) until it finds an element that matches the nodes or nodes name.\n *\n * @param {HTMLElement} element Element from which traversing is started.\n * @param {Array} nodes Array of elements or Array of elements name.\n * @param {HTMLElement} [until] The list of elements until the traversing ends.\n * @returns {HTMLElement|null}\n */\nexport function closestDown(element, nodes, until) {\n  const matched = [];\n  let elementToCheck = element;\n  while (elementToCheck) {\n    elementToCheck = closest(elementToCheck, nodes, until);\n    if (!elementToCheck || until && !until.contains(elementToCheck)) {\n      break;\n    }\n    matched.push(elementToCheck);\n    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = elementToCheck.host;\n    } else {\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  const length = matched.length;\n  return length ? matched[length - 1] : null;\n}\n\n/**\n * Goes up the DOM tree and checks if element is child of another element.\n *\n * @param {HTMLElement} child Child element An element to check.\n * @param {object|string} parent Parent element OR selector of the parent element.\n *                               If string provided, function returns `true` for the first occurrence of element with that class.\n * @returns {boolean}\n */\nexport function isChildOf(child, parent) {\n  let node = child.parentNode;\n  let queriedParents = [];\n  if (typeof parent === 'string') {\n    if (child.defaultView) {\n      queriedParents = Array.prototype.slice.call(child.querySelectorAll(parent), 0);\n    } else {\n      queriedParents = Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent), 0);\n    }\n  } else {\n    queriedParents.push(parent);\n  }\n  while (node !== null) {\n    if (queriedParents.indexOf(node) > -1) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n\n/**\n * Counts index of element within its parent.\n * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true\n * for Walkotnable, otherwise would need to check for nodeType or use previousElementSibling.\n *\n * @see http://jsperf.com/sibling-index/10\n * @param {Element} element The element to check.\n * @returns {number}\n */\nexport function index(element) {\n  let i = 0;\n  let elementToCheck = element;\n  if (elementToCheck.previousSibling) {\n    /* eslint-disable no-cond-assign */\n    while (elementToCheck = elementToCheck.previousSibling) {\n      i += 1;\n    }\n  }\n  return i;\n}\n\n/**\n * Check if the provided overlay contains the provided element.\n *\n * @param {string} overlayType The type of the overlay.\n * @param {HTMLElement} element An element to check.\n * @param {HTMLElement} root The root element.\n * @returns {boolean}\n */\nexport function overlayContainsElement(overlayType, element, root) {\n  const overlayElement = root.parentElement.querySelector(`.ht_clone_${overlayType}`);\n  return overlayElement ? overlayElement.contains(element) : null;\n}\n\n/**\n * @param {string[]} classNames The element \"class\" attribute string.\n * @returns {string[]}\n */\nfunction filterEmptyClassNames(classNames) {\n  if (!classNames || !classNames.length) {\n    return [];\n  }\n  return classNames.filter(x => !!x);\n}\n\n/**\n * Filter out the RegExp entries from an array.\n *\n * @param {(string|RegExp)[]} list Array of either strings, Regexes or a mix of both.\n * @param {boolean} [returnBoth] If `true`, both the array without regexes and an array of regexes will be returned.\n * @returns {string[]|{regexFree: string[], regexes: RegExp[]}}\n */\nfunction filterRegexes(list, returnBoth) {\n  if (!list || !list.length) {\n    return returnBoth ? {\n      regexFree: [],\n      regexes: []\n    } : [];\n  }\n  const regexes = [];\n  const regexFree = [];\n  regexFree.push(...list.filter(entry => {\n    const isRegex = entry instanceof RegExp;\n    if (isRegex && returnBoth) {\n      regexes.push(entry);\n    }\n    return !isRegex;\n  }));\n  return returnBoth ? {\n    regexFree,\n    regexes\n  } : regexFree;\n}\n\n/**\n * Checks if element has class name.\n *\n * @param {HTMLElement} element An element to check.\n * @param {string} className Class name to check.\n * @returns {boolean}\n */\nexport function hasClass(element, className) {\n  if (element.classList === undefined || typeof className !== 'string' || className === '') {\n    return false;\n  }\n  return element.classList.contains(className);\n}\n\n/**\n * Add class name to an element.\n *\n * @param {HTMLElement} element An element to process.\n * @param {string|Array} className Class name as string or array of strings.\n */\nexport function addClass(element, className) {\n  if (typeof className === 'string') {\n    className = className.split(' ');\n  }\n  className = filterEmptyClassNames(className);\n  if (className.length > 0) {\n    element.classList.add(...className);\n  }\n}\n\n/**\n * Remove class name from an element.\n *\n * @param {HTMLElement} element An element to process.\n * @param {string|Array<string|RegExp>} className Class name as string or array of strings.\n */\nexport function removeClass(element, className) {\n  if (typeof className === 'string') {\n    className = className.split(' ');\n  } else if (className instanceof RegExp) {\n    className = [className];\n  }\n  let {\n    regexFree: stringClasses,\n    // eslint-disable-next-line prefer-const\n    regexes: regexClasses\n  } = filterRegexes(className, true);\n  stringClasses = filterEmptyClassNames(stringClasses);\n  if (stringClasses.length > 0) {\n    element.classList.remove(...stringClasses);\n  }\n  regexClasses.forEach(regexClassName => {\n    element.classList.forEach(currentClassName => {\n      if (regexClassName.test(currentClassName)) {\n        element.classList.remove(currentClassName);\n      }\n    });\n  });\n}\n\n/**\n * Set a single attribute or multiple attributes at once.\n *\n * @param {HTMLElement} domElement The HTML element to be modified.\n * @param {Array[]|string} attributes If setting multiple attributes at once, `attributes` holds an array containing the\n * attributes to be added. Each element of the array should be an array in a form of `[attributeName,\n * attributeValue]`. If setting a single attribute, `attributes` holds the name of the attribute.\n * @param {string|number|undefined} [attributeValue] If setting a single attribute, `attributeValue` holds the attribute\n * value.\n */\nexport function setAttribute(domElement) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let attributeValue = arguments.length > 2 ? arguments[2] : undefined;\n  if (!Array.isArray(attributes)) {\n    attributes = [[attributes, attributeValue]];\n  }\n  attributes.forEach(attributeInfo => {\n    if (Array.isArray(attributeInfo) && attributeInfo[0] !== '') {\n      domElement.setAttribute(...attributeInfo);\n    }\n  });\n}\n\n/**\n * Remove a single attribute or multiple attributes from the provided element at once.\n *\n * @param {HTMLElement} domElement The HTML element to be processed.\n * @param {Array<string|RegExp>|string} attributesToRemove If removing multiple attributes, `attributesToRemove`\n * holds an array of attribute names to be removed from the provided element. If removing a single attribute, it\n * holds the attribute name.\n */\nexport function removeAttribute(domElement) {\n  let attributesToRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (typeof attributesToRemove === 'string') {\n    attributesToRemove = attributesToRemove.split(' ');\n  } else if (attributesToRemove instanceof RegExp) {\n    attributesToRemove = [attributesToRemove];\n  }\n  const {\n    regexFree: stringAttributes,\n    regexes: regexAttributes\n  } = filterRegexes(attributesToRemove, true);\n  stringAttributes.forEach(attributeNameToRemove => {\n    if (attributeNameToRemove !== '') {\n      domElement.removeAttribute(attributeNameToRemove);\n    }\n  });\n  regexAttributes.forEach(attributeRegex => {\n    domElement.getAttributeNames().forEach(attributeName => {\n      if (attributeRegex.test(attributeName)) {\n        domElement.removeAttribute(attributeName);\n      }\n    });\n  });\n}\n\n/**\n * @param {HTMLElement} element An element from the text is removed.\n */\nexport function removeTextNodes(element) {\n  if (element.nodeType === 3) {\n    element.parentNode.removeChild(element); // bye text nodes!\n  } else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(element.nodeName) > -1) {\n    const childs = element.childNodes;\n    for (let i = childs.length - 1; i >= 0; i--) {\n      removeTextNodes(childs[i]);\n    }\n  }\n}\n\n/**\n * Remove children function\n * WARNING - this doesn't unload events and data attached by jQuery\n * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9\n * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method.\n *\n * @param {HTMLElement} element An element to clear.\n */\nexport function empty(element) {\n  let child;\n\n  /* eslint-disable no-cond-assign */\n  while (child = element.lastChild) {\n    element.removeChild(child);\n  }\n}\nexport const HTML_CHARACTERS = /(<(.*)>|&(.*);)/;\n\n/**\n * Insert content into element trying to avoid innerHTML method.\n *\n * @param {HTMLElement} element An element to write into.\n * @param {string} content The text to write.\n * @param {boolean} [sanitizeContent=true] If `true`, the content will be sanitized before writing to the element.\n */\nexport function fastInnerHTML(element, content) {\n  let sanitizeContent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (HTML_CHARACTERS.test(content)) {\n    element.innerHTML = sanitizeContent ? sanitize(content) : content;\n  } else {\n    fastInnerText(element, content);\n  }\n}\n\n/**\n * Insert text content into element.\n *\n * @param {HTMLElement} element An element to write into.\n * @param {string} content The text to write.\n */\nexport function fastInnerText(element, content) {\n  const child = element.firstChild;\n  if (child && child.nodeType === 3 && child.nextSibling === null) {\n    // fast lane - replace existing text node\n    child.textContent = content;\n  } else {\n    // slow lane - empty element and insert a text node\n    empty(element);\n    element.appendChild(element.ownerDocument.createTextNode(content));\n  }\n}\n\n/**\n * Returns true if element is attached to the DOM and visible, false otherwise.\n *\n * @param {HTMLElement} element An element to check.\n * @returns {boolean}\n */\nexport function isVisible(element) {\n  const documentElement = element.ownerDocument.documentElement;\n  let next = element;\n  while (next !== documentElement) {\n    // until <html> reached\n    if (next === null) {\n      // parent detached from DOM\n      return false;\n    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      if (next.host) {\n        // this is Web Components Shadow DOM\n        // see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation\n        // according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet\n        if (next.host.impl) {\n          // Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled\n          return isVisible(next.host.impl);\n        } else if (next.host) {\n          // Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled\n          return isVisible(next.host);\n        }\n        throw new Error('Lost in Web Components world');\n      } else {\n        return false; // this is a node detached from document in IE8\n      }\n    } else if (getComputedStyle(next).display === 'none') {\n      return false;\n    }\n    next = next.parentNode;\n  }\n  return true;\n}\n\n/**\n * Returns elements top and left offset relative to the document. Function is not compatible with jQuery offset.\n *\n * @param {HTMLElement} element An element to get the offset position from.\n * @returns {object} Returns object with `top` and `left` props.\n */\nexport function offset(element) {\n  const rootDocument = element.ownerDocument;\n  const rootWindow = rootDocument.defaultView;\n  const documentElement = rootDocument.documentElement;\n  let elementToCheck = element;\n  let offsetLeft;\n  let offsetTop;\n  let lastElem;\n  offsetLeft = elementToCheck.offsetLeft;\n  offsetTop = elementToCheck.offsetTop;\n  lastElem = elementToCheck;\n\n  /* eslint-disable no-cond-assign */\n  while (elementToCheck = elementToCheck.offsetParent) {\n    // from my observation, document.body always has scrollLeft/scrollTop == 0\n    if (elementToCheck === rootDocument.body) {\n      break;\n    }\n    // If the element is inside an SVG context, the `offsetParent` can be\n    // a <foreignObject> that does not have properties `offsetLeft` and `offsetTop` defined.\n    if (!('offsetLeft' in elementToCheck)) {\n      break;\n    }\n    offsetLeft += elementToCheck.offsetLeft;\n    offsetTop += elementToCheck.offsetTop;\n    lastElem = elementToCheck;\n  }\n\n  // slow - http://jsperf.com/offset-vs-getboundingclientrect/6\n  if (lastElem && lastElem.style.position === 'fixed') {\n    // if(lastElem !== document.body) { //faster but does gives false positive in Firefox\n    offsetLeft += rootWindow.pageXOffset || documentElement.scrollLeft;\n    offsetTop += rootWindow.pageYOffset || documentElement.scrollTop;\n  }\n  return {\n    left: offsetLeft,\n    top: offsetTop\n  };\n}\n\n/**\n * Returns the document's scrollTop property.\n *\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getWindowScrollTop() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  return rootWindow.scrollY;\n}\n\n/**\n * Returns the document's scrollLeft property.\n *\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getWindowScrollLeft() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  return rootWindow.scrollX;\n}\n\n/**\n * Returns the provided element's scrollTop property.\n *\n * @param {HTMLElement} element An element to get the scroll top position from.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getScrollTop(element) {\n  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  if (element === rootWindow) {\n    return getWindowScrollTop(rootWindow);\n  }\n  return element.scrollTop;\n}\n\n/**\n * Returns the provided element's scrollLeft property.\n *\n * @param {HTMLElement} element An element to get the scroll left position from.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getScrollLeft(element) {\n  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  if (element === rootWindow) {\n    return getWindowScrollLeft(rootWindow);\n  }\n  return element.scrollLeft;\n}\n\n/**\n * Returns a DOM element responsible for scrolling of the provided element.\n *\n * @param {HTMLElement} element An element to get the scrollable element from.\n * @returns {HTMLElement} Element's scrollable parent.\n */\nexport function getScrollableElement(element) {\n  let rootDocument = element.ownerDocument;\n  let rootWindow = rootDocument ? rootDocument.defaultView : undefined;\n  if (!rootDocument) {\n    rootDocument = element.document ? element.document : element;\n    rootWindow = rootDocument.defaultView;\n  }\n  const props = ['auto', 'scroll'];\n  let el = element.parentNode;\n  while (el && el.style && rootDocument.body !== el) {\n    let {\n      overflow,\n      overflowX,\n      overflowY\n    } = el.style;\n    if ([overflow, overflowX, overflowY].includes('scroll')) {\n      return el;\n    } else {\n      ({\n        overflow,\n        overflowX,\n        overflowY\n      } = rootWindow.getComputedStyle(el));\n      if (props.includes(overflow) || props.includes(overflowX) || props.includes(overflowY)) {\n        return el;\n      }\n    }\n\n    // The '+ 1' after the scrollHeight/scrollWidth is to prevent problems with zoomed out Chrome.\n    if (el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || props.includes(overflow))) {\n      return el;\n    }\n    if (el.clientWidth <= el.scrollWidth + 1 && (props.includes(overflowX) || props.includes(overflow))) {\n      return el;\n    }\n    el = el.parentNode;\n  }\n  return rootWindow;\n}\n\n/**\n * Get the maximum available `scrollTop` value for the provided element.\n *\n * @param {HTMLElement} element The element to get the maximum scroll top value from.\n * @returns {number} The maximum scroll top value.\n */\nexport function getMaximumScrollTop(element) {\n  return element.scrollHeight - element.clientHeight;\n}\n\n/**\n * Get the maximum available `scrollLeft` value for the provided element.\n *\n * @param {HTMLElement} element The element to get the maximum scroll left value from.\n * @returns {number} The maximum scroll left value.\n */\nexport function getMaximumScrollLeft(element) {\n  return element.scrollWidth - element.clientWidth;\n}\n\n/**\n * Returns a DOM element responsible for trimming the provided element.\n *\n * @param {HTMLElement} base Base element.\n * @returns {HTMLElement} Base element's trimming parent.\n */\nexport function getTrimmingContainer(base) {\n  const rootDocument = base.ownerDocument;\n  const rootWindow = rootDocument.defaultView;\n  let el = base.parentNode;\n  while (el && el.style && rootDocument.body !== el) {\n    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {\n      return el;\n    }\n    const computedStyle = getComputedStyle(el, rootWindow);\n    const allowedProperties = ['scroll', 'hidden', 'auto'];\n    const property = computedStyle.getPropertyValue('overflow');\n    const propertyY = computedStyle.getPropertyValue('overflow-y');\n    const propertyX = computedStyle.getPropertyValue('overflow-x');\n    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {\n      return el;\n    }\n    el = el.parentNode;\n  }\n  return rootWindow;\n}\n\n/**\n * Returns a style property for the provided element. (Be it an inline or external style).\n *\n * @param {HTMLElement} element An element to get the style from.\n * @param {string} prop Wanted property.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {string|undefined} Element's style property.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getStyle(element, prop) {\n  let rootWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n  if (!element) {\n    return;\n  } else if (element === rootWindow) {\n    if (prop === 'width') {\n      return `${rootWindow.innerWidth}px`;\n    } else if (prop === 'height') {\n      return `${rootWindow.innerHeight}px`;\n    }\n    return;\n  }\n  const styleProp = element.style[prop];\n  if (styleProp !== '' && styleProp !== undefined) {\n    return styleProp;\n  }\n  const computedStyle = getComputedStyle(element, rootWindow);\n  if (computedStyle[prop] !== '' && computedStyle[prop] !== undefined) {\n    return computedStyle[prop];\n  }\n}\n\n/**\n * Verifies if element fit to provided CSSRule.\n *\n * @param {Element} element Element to verify with selector text.\n * @param {CSSRule} rule Selector text from CSSRule.\n * @returns {boolean}\n */\nexport function matchesCSSRules(element, rule) {\n  const {\n    selectorText\n  } = rule;\n  let result = false;\n  if (rule.type === CSSRule.STYLE_RULE && selectorText) {\n    if (element.msMatchesSelector) {\n      result = element.msMatchesSelector(selectorText);\n    } else if (element.matches) {\n      result = element.matches(selectorText);\n    }\n  }\n  return result;\n}\n\n/**\n * Returns a computed style object for the provided element. (Needed if style is declared in external stylesheet).\n *\n * @param {HTMLElement} element An element to get style from.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {IEElementStyle|CssStyle} Elements computed style object.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getComputedStyle(element) {\n  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  return element.currentStyle || rootWindow.getComputedStyle(element);\n}\n\n/**\n * Returns the element's outer width.\n *\n * @param {HTMLElement} element An element to get the width from.\n * @returns {number} Element's outer width.\n */\nexport function outerWidth(element) {\n  return element.offsetWidth;\n}\n\n/**\n * Returns the element's outer height.\n *\n * @param {HTMLElement} element An element to get the height from.\n * @returns {number} Element's outer height.\n */\nexport function outerHeight(element) {\n  return element.offsetHeight;\n}\n\n/**\n * Returns the element's inner height.\n *\n * @param {HTMLElement} element An element to get the height from.\n * @returns {number} Element's inner height.\n */\nexport function innerHeight(element) {\n  return element.clientHeight || element.innerHeight;\n}\n\n/**\n * Returns the element's inner width.\n *\n * @param {HTMLElement} element An element to get the width from.\n * @returns {number} Element's inner width.\n */\nexport function innerWidth(element) {\n  return element.clientWidth || element.innerWidth;\n}\n\n/**\n * @param {HTMLElement} element An element to which the event is added.\n * @param {string} event The event name.\n * @param {Function} callback The callback to add.\n */\nexport function addEvent(element, event, callback) {\n  element.addEventListener(event, callback, false);\n}\n\n/**\n * @param {HTMLElement} element An element from which the event is removed.\n * @param {string} event The event name.\n * @param {Function} callback The function reference to remove.\n */\nexport function removeEvent(element, event, callback) {\n  element.removeEventListener(event, callback, false);\n}\n\n/**\n * Returns caret position in text input.\n *\n * @author https://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea\n * @param {HTMLElement} el An element to check.\n * @returns {number}\n */\nexport function getCaretPosition(el) {\n  if (el.selectionStart) {\n    return el.selectionStart;\n  }\n  return 0;\n}\n\n/**\n * Returns end of the selection in text input.\n *\n * @param {HTMLElement} el An element to check.\n * @returns {number}\n */\nexport function getSelectionEndPosition(el) {\n  if (el.selectionEnd) {\n    return el.selectionEnd;\n  }\n  return 0;\n}\n\n/**\n * Returns text under selection.\n *\n * @param {Window} [rootWindow] The document window owner.\n * @returns {string}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getSelectionText() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  const rootDocument = rootWindow.document;\n  let text = '';\n  if (rootWindow.getSelection) {\n    text = rootWindow.getSelection().toString();\n  } else if (rootDocument.selection && rootDocument.selection.type !== 'Control') {\n    text = rootDocument.selection.createRange().text;\n  }\n  return text;\n}\n\n/**\n * Cross-platform helper to clear text selection.\n *\n * @param {Window} [rootWindow] The document window owner.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function clearTextSelection() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  // http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\n  if (rootWindow.getSelection) {\n    if (rootWindow.getSelection().empty) {\n      // Chrome\n      rootWindow.getSelection().empty();\n    } else if (rootWindow.getSelection().removeAllRanges) {\n      // Firefox\n      rootWindow.getSelection().removeAllRanges();\n    }\n  }\n}\n\n/**\n * Sets caret position in text input.\n *\n * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/\n * @param {Element} element An element to process.\n * @param {number} pos The selection start position.\n * @param {number} endPos The selection end position.\n */\nexport function setCaretPosition(element, pos, endPos) {\n  if (endPos === undefined) {\n    endPos = pos;\n  }\n  if (element.setSelectionRange) {\n    element.focus();\n    try {\n      element.setSelectionRange(pos, endPos);\n    } catch (err) {\n      const elementParent = element.parentNode;\n      const parentDisplayValue = elementParent.style.display;\n      elementParent.style.display = 'block';\n      element.setSelectionRange(pos, endPos);\n      elementParent.style.display = parentDisplayValue;\n    }\n  }\n}\nlet cachedScrollbarWidth;\n\n/**\n * Helper to calculate scrollbar width.\n * Source: https://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes.\n *\n * @private\n * @param {Document} rootDocument The onwer of the document.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nfunction walkontableCalculateScrollbarWidth() {\n  let rootDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  const inner = rootDocument.createElement('div');\n  inner.style.height = '200px';\n  inner.style.width = '100%';\n  const outer = rootDocument.createElement('div');\n  outer.style.boxSizing = 'content-box';\n  outer.style.height = '150px';\n  outer.style.left = '0px';\n  outer.style.overflow = 'hidden';\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.width = '200px';\n  outer.style.visibility = 'hidden';\n  outer.appendChild(inner);\n  (rootDocument.body || rootDocument.documentElement).appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  (rootDocument.body || rootDocument.documentElement).removeChild(outer);\n  return w1 - w2;\n}\n\n/**\n * Returns the computed width of the native browser scroll bar.\n *\n * @param {Document} [rootDocument] The owner of the document.\n * @returns {number} Width.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getScrollbarWidth() {\n  let rootDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  if (cachedScrollbarWidth === undefined) {\n    cachedScrollbarWidth = walkontableCalculateScrollbarWidth(rootDocument);\n  }\n  return cachedScrollbarWidth;\n}\n\n/**\n * Checks if the provided element has a vertical scrollbar.\n *\n * @param {HTMLElement} element An element to check.\n * @returns {boolean}\n */\nexport function hasVerticalScrollbar(element) {\n  return element.offsetWidth !== element.clientWidth;\n}\n\n/**\n * Checks if the provided element has a vertical scrollbar.\n *\n * @param {HTMLElement} element An element to check.\n * @returns {boolean}\n */\nexport function hasHorizontalScrollbar(element) {\n  return element.offsetHeight !== element.clientHeight;\n}\n\n/**\n * Sets overlay position depending on it's type and used browser.\n *\n * @param {HTMLElement} overlayElem An element to process.\n * @param {number|string} left The left position of the overlay.\n * @param {number|string} top The top position of the overlay.\n */\nexport function setOverlayPosition(overlayElem, left, top) {\n  overlayElem.style.transform = `translate3d(${left},${top},0)`;\n}\n\n/**\n * @param {HTMLElement} element An element to process.\n * @returns {number|Array}\n */\nexport function getCssTransform(element) {\n  let transform;\n  if (element.style.transform && (transform = element.style.transform) !== '') {\n    return ['transform', transform];\n  }\n  return -1;\n}\n\n/**\n * @param {HTMLElement} element An element to process.\n */\nexport function resetCssTransform(element) {\n  if (element.style.transform && element.style.transform !== '') {\n    element.style.transform = '';\n  }\n}\n\n/**\n * Determines if the given DOM element is an input field.\n * Notice: By 'input' we mean input, textarea and select nodes.\n *\n * @param {HTMLElement} element - DOM element.\n * @returns {boolean}\n */\nexport function isInput(element) {\n  const inputs = ['INPUT', 'SELECT', 'TEXTAREA'];\n  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === 'true');\n}\n\n/**\n * Determines if the given DOM element is an input field placed OUTSIDE of HOT.\n * Notice: By 'input' we mean input, textarea and select nodes which have defined 'data-hot-input' attribute.\n *\n * @param {HTMLElement} element - DOM element.\n * @returns {boolean}\n */\nexport function isOutsideInput(element) {\n  return isInput(element) && element.hasAttribute('data-hot-input') === false;\n}\n\n/**\n * Check if the given DOM element can be focused (by using \"select\" method).\n *\n * @param {HTMLElement} element - DOM element.\n */\nexport function selectElementIfAllowed(element) {\n  const activeElement = element.ownerDocument.activeElement;\n  if (!isOutsideInput(activeElement)) {\n    element.select();\n  }\n}\n\n/**\n * Check if the provided element is detached from DOM.\n *\n * @param {HTMLElement} element HTML element to be checked.\n * @returns {boolean} `true` if the element is detached, `false` otherwise.\n */\nexport function isDetached(element) {\n  return !element.parentNode;\n}\n\n/**\n * Set up an observer to recognize when the provided element first becomes visible and trigger a callback when it\n * happens.\n *\n * @param {HTMLElement} elementToBeObserved Element to be observed.\n * @param {Function} callback The callback function.\n */\nexport function observeVisibilityChangeOnce(elementToBeObserved, callback) {\n  const visibilityObserver = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting && elementToBeObserved.offsetParent !== null) {\n        callback();\n        observer.unobserve(elementToBeObserved);\n      }\n    });\n  }, {\n    root: elementToBeObserved.ownerDocument.body\n  });\n  visibilityObserver.observe(elementToBeObserved);\n}\n\n/**\n * Add a `contenteditable` attribute, select the contents and optionally add the `invisibleSelection`\n * class to the provided element.\n *\n * @param {HTMLElement} element Element to be processed.\n * @param {boolean} [invisibleSelection=true] `true` if the class should be added to the element.\n * @param {boolean} [ariaHidden=true] `true` if the `aria-hidden` attribute should be added to the processed element.\n */\nexport function makeElementContentEditableAndSelectItsContent(element) {\n  let invisibleSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let ariaHidden = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ownerDocument = element.ownerDocument;\n  const range = ownerDocument.createRange();\n  const sel = ownerDocument.defaultView.getSelection();\n  setAttribute(element, 'contenteditable', true);\n  if (ariaHidden) {\n    setAttribute(element, ...A11Y_HIDDEN());\n  }\n  if (invisibleSelection) {\n    addClass(element, 'invisibleSelection');\n  }\n  range.selectNodeContents(element);\n  sel.removeAllRanges();\n  sel.addRange(range);\n}\n\n/**\n * Remove the `contenteditable` attribute, deselect the contents and optionally remove the `invisibleSelection`\n * class from the provided element.\n *\n * @param {HTMLElement} selectedElement The element to be deselected.\n * @param {boolean} [removeInvisibleSelectionClass=true] `true` if the class should be removed from the element.\n */\nexport function removeContentEditableFromElementAndDeselect(selectedElement) {\n  let removeInvisibleSelectionClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const sel = selectedElement.ownerDocument.defaultView.getSelection();\n  if (selectedElement.hasAttribute('aria-hidden')) {\n    selectedElement.removeAttribute('aria-hidden');\n  }\n  sel.removeAllRanges();\n  if (removeInvisibleSelectionClass) {\n    removeClass(selectedElement, 'invisibleSelection');\n  }\n  selectedElement.removeAttribute('contenteditable');\n}\n\n/**\n * Run the provided callback while the provided element is selected and modified to have the `contenteditable`\n * attribute added. Optionally, the selection can be configured to be invisible.\n *\n * @param {HTMLElement} element Element to be selected.\n * @param {Function} callback Callback to be called.\n * @param {boolean} [invisibleSelection=true] `true` if the selection should be invisible.\n */\nexport function runWithSelectedContendEditableElement(element, callback) {\n  let invisibleSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  makeElementContentEditableAndSelectItsContent(element, invisibleSelection);\n  callback();\n  removeContentEditableFromElementAndDeselect(element, invisibleSelection);\n}","map":{"version":3,"names":["sanitize","A11Y_HIDDEN","getParent","element","level","arguments","length","undefined","iteration","parent","elementToCheck","host","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","isThisHotChild","thisHotContainer","closestHandsontableContainer","closest","getFrameElement","frame","Object","getPrototypeOf","frameElement","getParentWindow","hasAccessToParentWindow","nodes","until","ELEMENT_NODE","nodeName","includes","closestDown","matched","contains","push","isChildOf","child","node","queriedParents","defaultView","Array","prototype","slice","call","querySelectorAll","ownerDocument","indexOf","index","i","previousSibling","overlayContainsElement","overlayType","root","overlayElement","parentElement","querySelector","filterEmptyClassNames","classNames","filter","x","filterRegexes","list","returnBoth","regexFree","regexes","entry","isRegex","RegExp","hasClass","className","classList","addClass","split","add","removeClass","stringClasses","regexClasses","remove","forEach","regexClassName","currentClassName","test","setAttribute","domElement","attributes","attributeValue","isArray","attributeInfo","removeAttribute","attributesToRemove","stringAttributes","regexAttributes","attributeNameToRemove","attributeRegex","getAttributeNames","attributeName","removeTextNodes","removeChild","childs","childNodes","empty","lastChild","HTML_CHARACTERS","fastInnerHTML","content","sanitizeContent","innerHTML","fastInnerText","firstChild","nextSibling","textContent","appendChild","createTextNode","isVisible","documentElement","next","impl","Error","getComputedStyle","display","offset","rootDocument","rootWindow","offsetLeft","offsetTop","lastElem","offsetParent","body","style","position","pageXOffset","scrollLeft","pageYOffset","scrollTop","left","top","getWindowScrollTop","window","scrollY","getWindowScrollLeft","scrollX","getScrollTop","getScrollLeft","getScrollableElement","document","props","el","overflow","overflowX","overflowY","clientHeight","scrollHeight","clientWidth","scrollWidth","getMaximumScrollTop","getMaximumScrollLeft","getTrimmingContainer","base","computedStyle","allowedProperties","property","getPropertyValue","propertyY","propertyX","getStyle","prop","innerWidth","innerHeight","styleProp","matchesCSSRules","rule","selectorText","result","type","CSSRule","STYLE_RULE","msMatchesSelector","matches","currentStyle","outerWidth","offsetWidth","outerHeight","offsetHeight","addEvent","event","callback","addEventListener","removeEvent","removeEventListener","getCaretPosition","selectionStart","getSelectionEndPosition","selectionEnd","getSelectionText","text","getSelection","toString","selection","createRange","clearTextSelection","removeAllRanges","setCaretPosition","pos","endPos","setSelectionRange","focus","err","elementParent","parentDisplayValue","cachedScrollbarWidth","walkontableCalculateScrollbarWidth","inner","createElement","height","width","outer","boxSizing","visibility","w1","w2","getScrollbarWidth","hasVerticalScrollbar","hasHorizontalScrollbar","setOverlayPosition","overlayElem","transform","getCssTransform","resetCssTransform","isInput","inputs","contentEditable","isOutsideInput","hasAttribute","selectElementIfAllowed","activeElement","select","isDetached","observeVisibilityChangeOnce","elementToBeObserved","visibilityObserver","IntersectionObserver","entries","observer","isIntersecting","unobserve","observe","makeElementContentEditableAndSelectItsContent","invisibleSelection","ariaHidden","range","sel","selectNodeContents","addRange","removeContentEditableFromElementAndDeselect","selectedElement","removeInvisibleSelectionClass","runWithSelectedContendEditableElement"],"sources":["D:/gym-project/frontend/node_modules/handsontable/helpers/dom/element.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { sanitize } from \"../string.mjs\";\nimport { A11Y_HIDDEN } from \"../a11y.mjs\";\n/**\n * Get the parent of the specified node in the DOM tree.\n *\n * @param {HTMLElement} element Element from which traversing is started.\n * @param {number} [level=0] Traversing deep level.\n * @returns {HTMLElement|null}\n */\nexport function getParent(element) {\n  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let iteration = -1;\n  let parent = null;\n  let elementToCheck = element;\n  while (elementToCheck !== null) {\n    if (iteration === level) {\n      parent = elementToCheck;\n      break;\n    }\n    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = elementToCheck.host;\n    } else {\n      iteration += 1;\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  return parent;\n}\n\n/**\n * Check if the provided element is a child of the provided Handsontable container.\n *\n * @param {HTMLElement} element Element to be analyzed.\n * @param {HTMLElement} thisHotContainer The Handsontable container.\n * @returns {boolean}\n */\nexport function isThisHotChild(element, thisHotContainer) {\n  const closestHandsontableContainer = element.closest('.handsontable');\n  return !!closestHandsontableContainer && (closestHandsontableContainer.parentNode === thisHotContainer || closestHandsontableContainer === thisHotContainer);\n}\n\n/**\n * Gets `frameElement` of the specified frame. Returns null if it is a top frame or if script has no access to read property.\n *\n * @param {Window} frame Frame from which should be get frameElement in safe way.\n * @returns {HTMLIFrameElement|null}\n */\nexport function getFrameElement(frame) {\n  return Object.getPrototypeOf(frame.parent) && frame.frameElement;\n}\n\n/**\n * Gets parent frame of the specified frame. Returns null if it is a top frame or if script has no access to read property.\n *\n * @param {Window} frame Frame from which should get frameElement in a safe way.\n * @returns {Window|null}\n */\nexport function getParentWindow(frame) {\n  return getFrameElement(frame) && frame.parent;\n}\n\n/**\n * Checks if script has access to read from parent frame of specified frame.\n *\n * @param {Window} frame Frame from which should get frameElement in a safe way.\n * @returns {boolean}\n */\nexport function hasAccessToParentWindow(frame) {\n  return !!Object.getPrototypeOf(frame.parent);\n}\n\n/**\n * Goes up the DOM tree (including given element) until it finds an parent element that matches the nodes or nodes name.\n * This method goes up through web components.\n *\n * @param {Node} element Element from which traversing is started.\n * @param {Array<string|Node>} [nodes] Array of elements or Array of elements name (in uppercase form).\n * @param {Node} [until] The element until the traversing ends.\n * @returns {Node|null}\n */\nexport function closest(element) {\n  let nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let until = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    ELEMENT_NODE,\n    DOCUMENT_FRAGMENT_NODE\n  } = Node;\n  let elementToCheck = element;\n  while (elementToCheck !== null && elementToCheck !== undefined && elementToCheck !== until) {\n    const {\n      nodeType,\n      nodeName\n    } = elementToCheck;\n    if (nodeType === ELEMENT_NODE && (nodes.includes(nodeName) || nodes.includes(elementToCheck))) {\n      return elementToCheck;\n    }\n    const {\n      host\n    } = elementToCheck;\n    if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = host;\n    } else {\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  return null;\n}\n\n/**\n * Goes \"down\" the DOM tree (including given element) until it finds an element that matches the nodes or nodes name.\n *\n * @param {HTMLElement} element Element from which traversing is started.\n * @param {Array} nodes Array of elements or Array of elements name.\n * @param {HTMLElement} [until] The list of elements until the traversing ends.\n * @returns {HTMLElement|null}\n */\nexport function closestDown(element, nodes, until) {\n  const matched = [];\n  let elementToCheck = element;\n  while (elementToCheck) {\n    elementToCheck = closest(elementToCheck, nodes, until);\n    if (!elementToCheck || until && !until.contains(elementToCheck)) {\n      break;\n    }\n    matched.push(elementToCheck);\n    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = elementToCheck.host;\n    } else {\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  const length = matched.length;\n  return length ? matched[length - 1] : null;\n}\n\n/**\n * Goes up the DOM tree and checks if element is child of another element.\n *\n * @param {HTMLElement} child Child element An element to check.\n * @param {object|string} parent Parent element OR selector of the parent element.\n *                               If string provided, function returns `true` for the first occurrence of element with that class.\n * @returns {boolean}\n */\nexport function isChildOf(child, parent) {\n  let node = child.parentNode;\n  let queriedParents = [];\n  if (typeof parent === 'string') {\n    if (child.defaultView) {\n      queriedParents = Array.prototype.slice.call(child.querySelectorAll(parent), 0);\n    } else {\n      queriedParents = Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent), 0);\n    }\n  } else {\n    queriedParents.push(parent);\n  }\n  while (node !== null) {\n    if (queriedParents.indexOf(node) > -1) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n\n/**\n * Counts index of element within its parent.\n * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true\n * for Walkotnable, otherwise would need to check for nodeType or use previousElementSibling.\n *\n * @see http://jsperf.com/sibling-index/10\n * @param {Element} element The element to check.\n * @returns {number}\n */\nexport function index(element) {\n  let i = 0;\n  let elementToCheck = element;\n  if (elementToCheck.previousSibling) {\n    /* eslint-disable no-cond-assign */\n    while (elementToCheck = elementToCheck.previousSibling) {\n      i += 1;\n    }\n  }\n  return i;\n}\n\n/**\n * Check if the provided overlay contains the provided element.\n *\n * @param {string} overlayType The type of the overlay.\n * @param {HTMLElement} element An element to check.\n * @param {HTMLElement} root The root element.\n * @returns {boolean}\n */\nexport function overlayContainsElement(overlayType, element, root) {\n  const overlayElement = root.parentElement.querySelector(`.ht_clone_${overlayType}`);\n  return overlayElement ? overlayElement.contains(element) : null;\n}\n\n/**\n * @param {string[]} classNames The element \"class\" attribute string.\n * @returns {string[]}\n */\nfunction filterEmptyClassNames(classNames) {\n  if (!classNames || !classNames.length) {\n    return [];\n  }\n  return classNames.filter(x => !!x);\n}\n\n/**\n * Filter out the RegExp entries from an array.\n *\n * @param {(string|RegExp)[]} list Array of either strings, Regexes or a mix of both.\n * @param {boolean} [returnBoth] If `true`, both the array without regexes and an array of regexes will be returned.\n * @returns {string[]|{regexFree: string[], regexes: RegExp[]}}\n */\nfunction filterRegexes(list, returnBoth) {\n  if (!list || !list.length) {\n    return returnBoth ? {\n      regexFree: [],\n      regexes: []\n    } : [];\n  }\n  const regexes = [];\n  const regexFree = [];\n  regexFree.push(...list.filter(entry => {\n    const isRegex = entry instanceof RegExp;\n    if (isRegex && returnBoth) {\n      regexes.push(entry);\n    }\n    return !isRegex;\n  }));\n  return returnBoth ? {\n    regexFree,\n    regexes\n  } : regexFree;\n}\n\n/**\n * Checks if element has class name.\n *\n * @param {HTMLElement} element An element to check.\n * @param {string} className Class name to check.\n * @returns {boolean}\n */\nexport function hasClass(element, className) {\n  if (element.classList === undefined || typeof className !== 'string' || className === '') {\n    return false;\n  }\n  return element.classList.contains(className);\n}\n\n/**\n * Add class name to an element.\n *\n * @param {HTMLElement} element An element to process.\n * @param {string|Array} className Class name as string or array of strings.\n */\nexport function addClass(element, className) {\n  if (typeof className === 'string') {\n    className = className.split(' ');\n  }\n  className = filterEmptyClassNames(className);\n  if (className.length > 0) {\n    element.classList.add(...className);\n  }\n}\n\n/**\n * Remove class name from an element.\n *\n * @param {HTMLElement} element An element to process.\n * @param {string|Array<string|RegExp>} className Class name as string or array of strings.\n */\nexport function removeClass(element, className) {\n  if (typeof className === 'string') {\n    className = className.split(' ');\n  } else if (className instanceof RegExp) {\n    className = [className];\n  }\n  let {\n    regexFree: stringClasses,\n    // eslint-disable-next-line prefer-const\n    regexes: regexClasses\n  } = filterRegexes(className, true);\n  stringClasses = filterEmptyClassNames(stringClasses);\n  if (stringClasses.length > 0) {\n    element.classList.remove(...stringClasses);\n  }\n  regexClasses.forEach(regexClassName => {\n    element.classList.forEach(currentClassName => {\n      if (regexClassName.test(currentClassName)) {\n        element.classList.remove(currentClassName);\n      }\n    });\n  });\n}\n\n/**\n * Set a single attribute or multiple attributes at once.\n *\n * @param {HTMLElement} domElement The HTML element to be modified.\n * @param {Array[]|string} attributes If setting multiple attributes at once, `attributes` holds an array containing the\n * attributes to be added. Each element of the array should be an array in a form of `[attributeName,\n * attributeValue]`. If setting a single attribute, `attributes` holds the name of the attribute.\n * @param {string|number|undefined} [attributeValue] If setting a single attribute, `attributeValue` holds the attribute\n * value.\n */\nexport function setAttribute(domElement) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let attributeValue = arguments.length > 2 ? arguments[2] : undefined;\n  if (!Array.isArray(attributes)) {\n    attributes = [[attributes, attributeValue]];\n  }\n  attributes.forEach(attributeInfo => {\n    if (Array.isArray(attributeInfo) && attributeInfo[0] !== '') {\n      domElement.setAttribute(...attributeInfo);\n    }\n  });\n}\n\n/**\n * Remove a single attribute or multiple attributes from the provided element at once.\n *\n * @param {HTMLElement} domElement The HTML element to be processed.\n * @param {Array<string|RegExp>|string} attributesToRemove If removing multiple attributes, `attributesToRemove`\n * holds an array of attribute names to be removed from the provided element. If removing a single attribute, it\n * holds the attribute name.\n */\nexport function removeAttribute(domElement) {\n  let attributesToRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (typeof attributesToRemove === 'string') {\n    attributesToRemove = attributesToRemove.split(' ');\n  } else if (attributesToRemove instanceof RegExp) {\n    attributesToRemove = [attributesToRemove];\n  }\n  const {\n    regexFree: stringAttributes,\n    regexes: regexAttributes\n  } = filterRegexes(attributesToRemove, true);\n  stringAttributes.forEach(attributeNameToRemove => {\n    if (attributeNameToRemove !== '') {\n      domElement.removeAttribute(attributeNameToRemove);\n    }\n  });\n  regexAttributes.forEach(attributeRegex => {\n    domElement.getAttributeNames().forEach(attributeName => {\n      if (attributeRegex.test(attributeName)) {\n        domElement.removeAttribute(attributeName);\n      }\n    });\n  });\n}\n\n/**\n * @param {HTMLElement} element An element from the text is removed.\n */\nexport function removeTextNodes(element) {\n  if (element.nodeType === 3) {\n    element.parentNode.removeChild(element); // bye text nodes!\n  } else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(element.nodeName) > -1) {\n    const childs = element.childNodes;\n    for (let i = childs.length - 1; i >= 0; i--) {\n      removeTextNodes(childs[i]);\n    }\n  }\n}\n\n/**\n * Remove children function\n * WARNING - this doesn't unload events and data attached by jQuery\n * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9\n * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method.\n *\n * @param {HTMLElement} element An element to clear.\n */\nexport function empty(element) {\n  let child;\n\n  /* eslint-disable no-cond-assign */\n  while (child = element.lastChild) {\n    element.removeChild(child);\n  }\n}\nexport const HTML_CHARACTERS = /(<(.*)>|&(.*);)/;\n\n/**\n * Insert content into element trying to avoid innerHTML method.\n *\n * @param {HTMLElement} element An element to write into.\n * @param {string} content The text to write.\n * @param {boolean} [sanitizeContent=true] If `true`, the content will be sanitized before writing to the element.\n */\nexport function fastInnerHTML(element, content) {\n  let sanitizeContent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (HTML_CHARACTERS.test(content)) {\n    element.innerHTML = sanitizeContent ? sanitize(content) : content;\n  } else {\n    fastInnerText(element, content);\n  }\n}\n\n/**\n * Insert text content into element.\n *\n * @param {HTMLElement} element An element to write into.\n * @param {string} content The text to write.\n */\nexport function fastInnerText(element, content) {\n  const child = element.firstChild;\n  if (child && child.nodeType === 3 && child.nextSibling === null) {\n    // fast lane - replace existing text node\n    child.textContent = content;\n  } else {\n    // slow lane - empty element and insert a text node\n    empty(element);\n    element.appendChild(element.ownerDocument.createTextNode(content));\n  }\n}\n\n/**\n * Returns true if element is attached to the DOM and visible, false otherwise.\n *\n * @param {HTMLElement} element An element to check.\n * @returns {boolean}\n */\nexport function isVisible(element) {\n  const documentElement = element.ownerDocument.documentElement;\n  let next = element;\n  while (next !== documentElement) {\n    // until <html> reached\n    if (next === null) {\n      // parent detached from DOM\n      return false;\n    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      if (next.host) {\n        // this is Web Components Shadow DOM\n        // see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation\n        // according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet\n        if (next.host.impl) {\n          // Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled\n          return isVisible(next.host.impl);\n        } else if (next.host) {\n          // Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled\n          return isVisible(next.host);\n        }\n        throw new Error('Lost in Web Components world');\n      } else {\n        return false; // this is a node detached from document in IE8\n      }\n    } else if (getComputedStyle(next).display === 'none') {\n      return false;\n    }\n    next = next.parentNode;\n  }\n  return true;\n}\n\n/**\n * Returns elements top and left offset relative to the document. Function is not compatible with jQuery offset.\n *\n * @param {HTMLElement} element An element to get the offset position from.\n * @returns {object} Returns object with `top` and `left` props.\n */\nexport function offset(element) {\n  const rootDocument = element.ownerDocument;\n  const rootWindow = rootDocument.defaultView;\n  const documentElement = rootDocument.documentElement;\n  let elementToCheck = element;\n  let offsetLeft;\n  let offsetTop;\n  let lastElem;\n  offsetLeft = elementToCheck.offsetLeft;\n  offsetTop = elementToCheck.offsetTop;\n  lastElem = elementToCheck;\n\n  /* eslint-disable no-cond-assign */\n  while (elementToCheck = elementToCheck.offsetParent) {\n    // from my observation, document.body always has scrollLeft/scrollTop == 0\n    if (elementToCheck === rootDocument.body) {\n      break;\n    }\n    // If the element is inside an SVG context, the `offsetParent` can be\n    // a <foreignObject> that does not have properties `offsetLeft` and `offsetTop` defined.\n    if (!('offsetLeft' in elementToCheck)) {\n      break;\n    }\n    offsetLeft += elementToCheck.offsetLeft;\n    offsetTop += elementToCheck.offsetTop;\n    lastElem = elementToCheck;\n  }\n\n  // slow - http://jsperf.com/offset-vs-getboundingclientrect/6\n  if (lastElem && lastElem.style.position === 'fixed') {\n    // if(lastElem !== document.body) { //faster but does gives false positive in Firefox\n    offsetLeft += rootWindow.pageXOffset || documentElement.scrollLeft;\n    offsetTop += rootWindow.pageYOffset || documentElement.scrollTop;\n  }\n  return {\n    left: offsetLeft,\n    top: offsetTop\n  };\n}\n\n/**\n * Returns the document's scrollTop property.\n *\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getWindowScrollTop() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  return rootWindow.scrollY;\n}\n\n/**\n * Returns the document's scrollLeft property.\n *\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getWindowScrollLeft() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  return rootWindow.scrollX;\n}\n\n/**\n * Returns the provided element's scrollTop property.\n *\n * @param {HTMLElement} element An element to get the scroll top position from.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getScrollTop(element) {\n  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  if (element === rootWindow) {\n    return getWindowScrollTop(rootWindow);\n  }\n  return element.scrollTop;\n}\n\n/**\n * Returns the provided element's scrollLeft property.\n *\n * @param {HTMLElement} element An element to get the scroll left position from.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getScrollLeft(element) {\n  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  if (element === rootWindow) {\n    return getWindowScrollLeft(rootWindow);\n  }\n  return element.scrollLeft;\n}\n\n/**\n * Returns a DOM element responsible for scrolling of the provided element.\n *\n * @param {HTMLElement} element An element to get the scrollable element from.\n * @returns {HTMLElement} Element's scrollable parent.\n */\nexport function getScrollableElement(element) {\n  let rootDocument = element.ownerDocument;\n  let rootWindow = rootDocument ? rootDocument.defaultView : undefined;\n  if (!rootDocument) {\n    rootDocument = element.document ? element.document : element;\n    rootWindow = rootDocument.defaultView;\n  }\n  const props = ['auto', 'scroll'];\n  let el = element.parentNode;\n  while (el && el.style && rootDocument.body !== el) {\n    let {\n      overflow,\n      overflowX,\n      overflowY\n    } = el.style;\n    if ([overflow, overflowX, overflowY].includes('scroll')) {\n      return el;\n    } else {\n      ({\n        overflow,\n        overflowX,\n        overflowY\n      } = rootWindow.getComputedStyle(el));\n      if (props.includes(overflow) || props.includes(overflowX) || props.includes(overflowY)) {\n        return el;\n      }\n    }\n\n    // The '+ 1' after the scrollHeight/scrollWidth is to prevent problems with zoomed out Chrome.\n    if (el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || props.includes(overflow))) {\n      return el;\n    }\n    if (el.clientWidth <= el.scrollWidth + 1 && (props.includes(overflowX) || props.includes(overflow))) {\n      return el;\n    }\n    el = el.parentNode;\n  }\n  return rootWindow;\n}\n\n/**\n * Get the maximum available `scrollTop` value for the provided element.\n *\n * @param {HTMLElement} element The element to get the maximum scroll top value from.\n * @returns {number} The maximum scroll top value.\n */\nexport function getMaximumScrollTop(element) {\n  return element.scrollHeight - element.clientHeight;\n}\n\n/**\n * Get the maximum available `scrollLeft` value for the provided element.\n *\n * @param {HTMLElement} element The element to get the maximum scroll left value from.\n * @returns {number} The maximum scroll left value.\n */\nexport function getMaximumScrollLeft(element) {\n  return element.scrollWidth - element.clientWidth;\n}\n\n/**\n * Returns a DOM element responsible for trimming the provided element.\n *\n * @param {HTMLElement} base Base element.\n * @returns {HTMLElement} Base element's trimming parent.\n */\nexport function getTrimmingContainer(base) {\n  const rootDocument = base.ownerDocument;\n  const rootWindow = rootDocument.defaultView;\n  let el = base.parentNode;\n  while (el && el.style && rootDocument.body !== el) {\n    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {\n      return el;\n    }\n    const computedStyle = getComputedStyle(el, rootWindow);\n    const allowedProperties = ['scroll', 'hidden', 'auto'];\n    const property = computedStyle.getPropertyValue('overflow');\n    const propertyY = computedStyle.getPropertyValue('overflow-y');\n    const propertyX = computedStyle.getPropertyValue('overflow-x');\n    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {\n      return el;\n    }\n    el = el.parentNode;\n  }\n  return rootWindow;\n}\n\n/**\n * Returns a style property for the provided element. (Be it an inline or external style).\n *\n * @param {HTMLElement} element An element to get the style from.\n * @param {string} prop Wanted property.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {string|undefined} Element's style property.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getStyle(element, prop) {\n  let rootWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n  if (!element) {\n    return;\n  } else if (element === rootWindow) {\n    if (prop === 'width') {\n      return `${rootWindow.innerWidth}px`;\n    } else if (prop === 'height') {\n      return `${rootWindow.innerHeight}px`;\n    }\n    return;\n  }\n  const styleProp = element.style[prop];\n  if (styleProp !== '' && styleProp !== undefined) {\n    return styleProp;\n  }\n  const computedStyle = getComputedStyle(element, rootWindow);\n  if (computedStyle[prop] !== '' && computedStyle[prop] !== undefined) {\n    return computedStyle[prop];\n  }\n}\n\n/**\n * Verifies if element fit to provided CSSRule.\n *\n * @param {Element} element Element to verify with selector text.\n * @param {CSSRule} rule Selector text from CSSRule.\n * @returns {boolean}\n */\nexport function matchesCSSRules(element, rule) {\n  const {\n    selectorText\n  } = rule;\n  let result = false;\n  if (rule.type === CSSRule.STYLE_RULE && selectorText) {\n    if (element.msMatchesSelector) {\n      result = element.msMatchesSelector(selectorText);\n    } else if (element.matches) {\n      result = element.matches(selectorText);\n    }\n  }\n  return result;\n}\n\n/**\n * Returns a computed style object for the provided element. (Needed if style is declared in external stylesheet).\n *\n * @param {HTMLElement} element An element to get style from.\n * @param {Window} [rootWindow] The document window owner.\n * @returns {IEElementStyle|CssStyle} Elements computed style object.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getComputedStyle(element) {\n  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  return element.currentStyle || rootWindow.getComputedStyle(element);\n}\n\n/**\n * Returns the element's outer width.\n *\n * @param {HTMLElement} element An element to get the width from.\n * @returns {number} Element's outer width.\n */\nexport function outerWidth(element) {\n  return element.offsetWidth;\n}\n\n/**\n * Returns the element's outer height.\n *\n * @param {HTMLElement} element An element to get the height from.\n * @returns {number} Element's outer height.\n */\nexport function outerHeight(element) {\n  return element.offsetHeight;\n}\n\n/**\n * Returns the element's inner height.\n *\n * @param {HTMLElement} element An element to get the height from.\n * @returns {number} Element's inner height.\n */\nexport function innerHeight(element) {\n  return element.clientHeight || element.innerHeight;\n}\n\n/**\n * Returns the element's inner width.\n *\n * @param {HTMLElement} element An element to get the width from.\n * @returns {number} Element's inner width.\n */\nexport function innerWidth(element) {\n  return element.clientWidth || element.innerWidth;\n}\n\n/**\n * @param {HTMLElement} element An element to which the event is added.\n * @param {string} event The event name.\n * @param {Function} callback The callback to add.\n */\nexport function addEvent(element, event, callback) {\n  element.addEventListener(event, callback, false);\n}\n\n/**\n * @param {HTMLElement} element An element from which the event is removed.\n * @param {string} event The event name.\n * @param {Function} callback The function reference to remove.\n */\nexport function removeEvent(element, event, callback) {\n  element.removeEventListener(event, callback, false);\n}\n\n/**\n * Returns caret position in text input.\n *\n * @author https://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea\n * @param {HTMLElement} el An element to check.\n * @returns {number}\n */\nexport function getCaretPosition(el) {\n  if (el.selectionStart) {\n    return el.selectionStart;\n  }\n  return 0;\n}\n\n/**\n * Returns end of the selection in text input.\n *\n * @param {HTMLElement} el An element to check.\n * @returns {number}\n */\nexport function getSelectionEndPosition(el) {\n  if (el.selectionEnd) {\n    return el.selectionEnd;\n  }\n  return 0;\n}\n\n/**\n * Returns text under selection.\n *\n * @param {Window} [rootWindow] The document window owner.\n * @returns {string}\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getSelectionText() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  const rootDocument = rootWindow.document;\n  let text = '';\n  if (rootWindow.getSelection) {\n    text = rootWindow.getSelection().toString();\n  } else if (rootDocument.selection && rootDocument.selection.type !== 'Control') {\n    text = rootDocument.selection.createRange().text;\n  }\n  return text;\n}\n\n/**\n * Cross-platform helper to clear text selection.\n *\n * @param {Window} [rootWindow] The document window owner.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function clearTextSelection() {\n  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  // http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\n  if (rootWindow.getSelection) {\n    if (rootWindow.getSelection().empty) {\n      // Chrome\n      rootWindow.getSelection().empty();\n    } else if (rootWindow.getSelection().removeAllRanges) {\n      // Firefox\n      rootWindow.getSelection().removeAllRanges();\n    }\n  }\n}\n\n/**\n * Sets caret position in text input.\n *\n * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/\n * @param {Element} element An element to process.\n * @param {number} pos The selection start position.\n * @param {number} endPos The selection end position.\n */\nexport function setCaretPosition(element, pos, endPos) {\n  if (endPos === undefined) {\n    endPos = pos;\n  }\n  if (element.setSelectionRange) {\n    element.focus();\n    try {\n      element.setSelectionRange(pos, endPos);\n    } catch (err) {\n      const elementParent = element.parentNode;\n      const parentDisplayValue = elementParent.style.display;\n      elementParent.style.display = 'block';\n      element.setSelectionRange(pos, endPos);\n      elementParent.style.display = parentDisplayValue;\n    }\n  }\n}\nlet cachedScrollbarWidth;\n\n/**\n * Helper to calculate scrollbar width.\n * Source: https://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes.\n *\n * @private\n * @param {Document} rootDocument The onwer of the document.\n * @returns {number}\n */\n// eslint-disable-next-line no-restricted-globals\nfunction walkontableCalculateScrollbarWidth() {\n  let rootDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  const inner = rootDocument.createElement('div');\n  inner.style.height = '200px';\n  inner.style.width = '100%';\n  const outer = rootDocument.createElement('div');\n  outer.style.boxSizing = 'content-box';\n  outer.style.height = '150px';\n  outer.style.left = '0px';\n  outer.style.overflow = 'hidden';\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.width = '200px';\n  outer.style.visibility = 'hidden';\n  outer.appendChild(inner);\n  (rootDocument.body || rootDocument.documentElement).appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  (rootDocument.body || rootDocument.documentElement).removeChild(outer);\n  return w1 - w2;\n}\n\n/**\n * Returns the computed width of the native browser scroll bar.\n *\n * @param {Document} [rootDocument] The owner of the document.\n * @returns {number} Width.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function getScrollbarWidth() {\n  let rootDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  if (cachedScrollbarWidth === undefined) {\n    cachedScrollbarWidth = walkontableCalculateScrollbarWidth(rootDocument);\n  }\n  return cachedScrollbarWidth;\n}\n\n/**\n * Checks if the provided element has a vertical scrollbar.\n *\n * @param {HTMLElement} element An element to check.\n * @returns {boolean}\n */\nexport function hasVerticalScrollbar(element) {\n  return element.offsetWidth !== element.clientWidth;\n}\n\n/**\n * Checks if the provided element has a vertical scrollbar.\n *\n * @param {HTMLElement} element An element to check.\n * @returns {boolean}\n */\nexport function hasHorizontalScrollbar(element) {\n  return element.offsetHeight !== element.clientHeight;\n}\n\n/**\n * Sets overlay position depending on it's type and used browser.\n *\n * @param {HTMLElement} overlayElem An element to process.\n * @param {number|string} left The left position of the overlay.\n * @param {number|string} top The top position of the overlay.\n */\nexport function setOverlayPosition(overlayElem, left, top) {\n  overlayElem.style.transform = `translate3d(${left},${top},0)`;\n}\n\n/**\n * @param {HTMLElement} element An element to process.\n * @returns {number|Array}\n */\nexport function getCssTransform(element) {\n  let transform;\n  if (element.style.transform && (transform = element.style.transform) !== '') {\n    return ['transform', transform];\n  }\n  return -1;\n}\n\n/**\n * @param {HTMLElement} element An element to process.\n */\nexport function resetCssTransform(element) {\n  if (element.style.transform && element.style.transform !== '') {\n    element.style.transform = '';\n  }\n}\n\n/**\n * Determines if the given DOM element is an input field.\n * Notice: By 'input' we mean input, textarea and select nodes.\n *\n * @param {HTMLElement} element - DOM element.\n * @returns {boolean}\n */\nexport function isInput(element) {\n  const inputs = ['INPUT', 'SELECT', 'TEXTAREA'];\n  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === 'true');\n}\n\n/**\n * Determines if the given DOM element is an input field placed OUTSIDE of HOT.\n * Notice: By 'input' we mean input, textarea and select nodes which have defined 'data-hot-input' attribute.\n *\n * @param {HTMLElement} element - DOM element.\n * @returns {boolean}\n */\nexport function isOutsideInput(element) {\n  return isInput(element) && element.hasAttribute('data-hot-input') === false;\n}\n\n/**\n * Check if the given DOM element can be focused (by using \"select\" method).\n *\n * @param {HTMLElement} element - DOM element.\n */\nexport function selectElementIfAllowed(element) {\n  const activeElement = element.ownerDocument.activeElement;\n  if (!isOutsideInput(activeElement)) {\n    element.select();\n  }\n}\n\n/**\n * Check if the provided element is detached from DOM.\n *\n * @param {HTMLElement} element HTML element to be checked.\n * @returns {boolean} `true` if the element is detached, `false` otherwise.\n */\nexport function isDetached(element) {\n  return !element.parentNode;\n}\n\n/**\n * Set up an observer to recognize when the provided element first becomes visible and trigger a callback when it\n * happens.\n *\n * @param {HTMLElement} elementToBeObserved Element to be observed.\n * @param {Function} callback The callback function.\n */\nexport function observeVisibilityChangeOnce(elementToBeObserved, callback) {\n  const visibilityObserver = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting && elementToBeObserved.offsetParent !== null) {\n        callback();\n        observer.unobserve(elementToBeObserved);\n      }\n    });\n  }, {\n    root: elementToBeObserved.ownerDocument.body\n  });\n  visibilityObserver.observe(elementToBeObserved);\n}\n\n/**\n * Add a `contenteditable` attribute, select the contents and optionally add the `invisibleSelection`\n * class to the provided element.\n *\n * @param {HTMLElement} element Element to be processed.\n * @param {boolean} [invisibleSelection=true] `true` if the class should be added to the element.\n * @param {boolean} [ariaHidden=true] `true` if the `aria-hidden` attribute should be added to the processed element.\n */\nexport function makeElementContentEditableAndSelectItsContent(element) {\n  let invisibleSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let ariaHidden = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ownerDocument = element.ownerDocument;\n  const range = ownerDocument.createRange();\n  const sel = ownerDocument.defaultView.getSelection();\n  setAttribute(element, 'contenteditable', true);\n  if (ariaHidden) {\n    setAttribute(element, ...A11Y_HIDDEN());\n  }\n  if (invisibleSelection) {\n    addClass(element, 'invisibleSelection');\n  }\n  range.selectNodeContents(element);\n  sel.removeAllRanges();\n  sel.addRange(range);\n}\n\n/**\n * Remove the `contenteditable` attribute, deselect the contents and optionally remove the `invisibleSelection`\n * class from the provided element.\n *\n * @param {HTMLElement} selectedElement The element to be deselected.\n * @param {boolean} [removeInvisibleSelectionClass=true] `true` if the class should be removed from the element.\n */\nexport function removeContentEditableFromElementAndDeselect(selectedElement) {\n  let removeInvisibleSelectionClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const sel = selectedElement.ownerDocument.defaultView.getSelection();\n  if (selectedElement.hasAttribute('aria-hidden')) {\n    selectedElement.removeAttribute('aria-hidden');\n  }\n  sel.removeAllRanges();\n  if (removeInvisibleSelectionClass) {\n    removeClass(selectedElement, 'invisibleSelection');\n  }\n  selectedElement.removeAttribute('contenteditable');\n}\n\n/**\n * Run the provided callback while the provided element is selected and modified to have the `contenteditable`\n * attribute added. Optionally, the selection can be configured to be invisible.\n *\n * @param {HTMLElement} element Element to be selected.\n * @param {Function} callback Callback to be called.\n * @param {boolean} [invisibleSelection=true] `true` if the selection should be invisible.\n */\nexport function runWithSelectedContendEditableElement(element, callback) {\n  let invisibleSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  makeElementContentEditableAndSelectItsContent(element, invisibleSelection);\n  callback();\n  removeContentEditableFromElementAndDeselect(element, invisibleSelection);\n}"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,eAAe;AACxC,SAASC,WAAW,QAAQ,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,OAAO,EAAE;EACjC,IAAIC,KAAK,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;EACjF,IAAIG,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIC,cAAc,GAAGP,OAAO;EAC5B,OAAOO,cAAc,KAAK,IAAI,EAAE;IAC9B,IAAIF,SAAS,KAAKJ,KAAK,EAAE;MACvBK,MAAM,GAAGC,cAAc;MACvB;IACF;IACA,IAAIA,cAAc,CAACC,IAAI,IAAID,cAAc,CAACE,QAAQ,KAAKC,IAAI,CAACC,sBAAsB,EAAE;MAClFJ,cAAc,GAAGA,cAAc,CAACC,IAAI;IACtC,CAAC,MAAM;MACLH,SAAS,IAAI,CAAC;MACdE,cAAc,GAAGA,cAAc,CAACK,UAAU;IAC5C;EACF;EACA,OAAON,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,cAAcA,CAACb,OAAO,EAAEc,gBAAgB,EAAE;EACxD,MAAMC,4BAA4B,GAAGf,OAAO,CAACgB,OAAO,CAAC,eAAe,CAAC;EACrE,OAAO,CAAC,CAACD,4BAA4B,KAAKA,4BAA4B,CAACH,UAAU,KAAKE,gBAAgB,IAAIC,4BAA4B,KAAKD,gBAAgB,CAAC;AAC9J;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,eAAeA,CAACC,KAAK,EAAE;EACrC,OAAOC,MAAM,CAACC,cAAc,CAACF,KAAK,CAACZ,MAAM,CAAC,IAAIY,KAAK,CAACG,YAAY;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACJ,KAAK,EAAE;EACrC,OAAOD,eAAe,CAACC,KAAK,CAAC,IAAIA,KAAK,CAACZ,MAAM;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiB,uBAAuBA,CAACL,KAAK,EAAE;EAC7C,OAAO,CAAC,CAACC,MAAM,CAACC,cAAc,CAACF,KAAK,CAACZ,MAAM,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,OAAOA,CAAChB,OAAO,EAAE;EAC/B,IAAIwB,KAAK,GAAGtB,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EAClF,IAAIuB,KAAK,GAAGvB,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGE,SAAS;EAC3D,MAAM;IACJsB,YAAY;IACZf;EACF,CAAC,GAAGD,IAAI;EACR,IAAIH,cAAc,GAAGP,OAAO;EAC5B,OAAOO,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAKH,SAAS,IAAIG,cAAc,KAAKkB,KAAK,EAAE;IAC1F,MAAM;MACJhB,QAAQ;MACRkB;IACF,CAAC,GAAGpB,cAAc;IAClB,IAAIE,QAAQ,KAAKiB,YAAY,KAAKF,KAAK,CAACI,QAAQ,CAACD,QAAQ,CAAC,IAAIH,KAAK,CAACI,QAAQ,CAACrB,cAAc,CAAC,CAAC,EAAE;MAC7F,OAAOA,cAAc;IACvB;IACA,MAAM;MACJC;IACF,CAAC,GAAGD,cAAc;IAClB,IAAIC,IAAI,IAAIC,QAAQ,KAAKE,sBAAsB,EAAE;MAC/CJ,cAAc,GAAGC,IAAI;IACvB,CAAC,MAAM;MACLD,cAAc,GAAGA,cAAc,CAACK,UAAU;IAC5C;EACF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiB,WAAWA,CAAC7B,OAAO,EAAEwB,KAAK,EAAEC,KAAK,EAAE;EACjD,MAAMK,OAAO,GAAG,EAAE;EAClB,IAAIvB,cAAc,GAAGP,OAAO;EAC5B,OAAOO,cAAc,EAAE;IACrBA,cAAc,GAAGS,OAAO,CAACT,cAAc,EAAEiB,KAAK,EAAEC,KAAK,CAAC;IACtD,IAAI,CAAClB,cAAc,IAAIkB,KAAK,IAAI,CAACA,KAAK,CAACM,QAAQ,CAACxB,cAAc,CAAC,EAAE;MAC/D;IACF;IACAuB,OAAO,CAACE,IAAI,CAACzB,cAAc,CAAC;IAC5B,IAAIA,cAAc,CAACC,IAAI,IAAID,cAAc,CAACE,QAAQ,KAAKC,IAAI,CAACC,sBAAsB,EAAE;MAClFJ,cAAc,GAAGA,cAAc,CAACC,IAAI;IACtC,CAAC,MAAM;MACLD,cAAc,GAAGA,cAAc,CAACK,UAAU;IAC5C;EACF;EACA,MAAMT,MAAM,GAAG2B,OAAO,CAAC3B,MAAM;EAC7B,OAAOA,MAAM,GAAG2B,OAAO,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8B,SAASA,CAACC,KAAK,EAAE5B,MAAM,EAAE;EACvC,IAAI6B,IAAI,GAAGD,KAAK,CAACtB,UAAU;EAC3B,IAAIwB,cAAc,GAAG,EAAE;EACvB,IAAI,OAAO9B,MAAM,KAAK,QAAQ,EAAE;IAC9B,IAAI4B,KAAK,CAACG,WAAW,EAAE;MACrBD,cAAc,GAAGE,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACP,KAAK,CAACQ,gBAAgB,CAACpC,MAAM,CAAC,EAAE,CAAC,CAAC;IAChF,CAAC,MAAM;MACL8B,cAAc,GAAGE,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACP,KAAK,CAACS,aAAa,CAACD,gBAAgB,CAACpC,MAAM,CAAC,EAAE,CAAC,CAAC;IAC9F;EACF,CAAC,MAAM;IACL8B,cAAc,CAACJ,IAAI,CAAC1B,MAAM,CAAC;EAC7B;EACA,OAAO6B,IAAI,KAAK,IAAI,EAAE;IACpB,IAAIC,cAAc,CAACQ,OAAO,CAACT,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;MACrC,OAAO,IAAI;IACb;IACAA,IAAI,GAAGA,IAAI,CAACvB,UAAU;EACxB;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiC,KAAKA,CAAC7C,OAAO,EAAE;EAC7B,IAAI8C,CAAC,GAAG,CAAC;EACT,IAAIvC,cAAc,GAAGP,OAAO;EAC5B,IAAIO,cAAc,CAACwC,eAAe,EAAE;IAClC;IACA,OAAOxC,cAAc,GAAGA,cAAc,CAACwC,eAAe,EAAE;MACtDD,CAAC,IAAI,CAAC;IACR;EACF;EACA,OAAOA,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,sBAAsBA,CAACC,WAAW,EAAEjD,OAAO,EAAEkD,IAAI,EAAE;EACjE,MAAMC,cAAc,GAAGD,IAAI,CAACE,aAAa,CAACC,aAAa,CAAC,aAAaJ,WAAW,EAAE,CAAC;EACnF,OAAOE,cAAc,GAAGA,cAAc,CAACpB,QAAQ,CAAC/B,OAAO,CAAC,GAAG,IAAI;AACjE;;AAEA;AACA;AACA;AACA;AACA,SAASsD,qBAAqBA,CAACC,UAAU,EAAE;EACzC,IAAI,CAACA,UAAU,IAAI,CAACA,UAAU,CAACpD,MAAM,EAAE;IACrC,OAAO,EAAE;EACX;EACA,OAAOoD,UAAU,CAACC,MAAM,CAACC,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,IAAI,EAAEC,UAAU,EAAE;EACvC,IAAI,CAACD,IAAI,IAAI,CAACA,IAAI,CAACxD,MAAM,EAAE;IACzB,OAAOyD,UAAU,GAAG;MAClBC,SAAS,EAAE,EAAE;MACbC,OAAO,EAAE;IACX,CAAC,GAAG,EAAE;EACR;EACA,MAAMA,OAAO,GAAG,EAAE;EAClB,MAAMD,SAAS,GAAG,EAAE;EACpBA,SAAS,CAAC7B,IAAI,CAAC,GAAG2B,IAAI,CAACH,MAAM,CAACO,KAAK,IAAI;IACrC,MAAMC,OAAO,GAAGD,KAAK,YAAYE,MAAM;IACvC,IAAID,OAAO,IAAIJ,UAAU,EAAE;MACzBE,OAAO,CAAC9B,IAAI,CAAC+B,KAAK,CAAC;IACrB;IACA,OAAO,CAACC,OAAO;EACjB,CAAC,CAAC,CAAC;EACH,OAAOJ,UAAU,GAAG;IAClBC,SAAS;IACTC;EACF,CAAC,GAAGD,SAAS;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,QAAQA,CAAClE,OAAO,EAAEmE,SAAS,EAAE;EAC3C,IAAInE,OAAO,CAACoE,SAAS,KAAKhE,SAAS,IAAI,OAAO+D,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,EAAE,EAAE;IACxF,OAAO,KAAK;EACd;EACA,OAAOnE,OAAO,CAACoE,SAAS,CAACrC,QAAQ,CAACoC,SAAS,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,QAAQA,CAACrE,OAAO,EAAEmE,SAAS,EAAE;EAC3C,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;IACjCA,SAAS,GAAGA,SAAS,CAACG,KAAK,CAAC,GAAG,CAAC;EAClC;EACAH,SAAS,GAAGb,qBAAqB,CAACa,SAAS,CAAC;EAC5C,IAAIA,SAAS,CAAChE,MAAM,GAAG,CAAC,EAAE;IACxBH,OAAO,CAACoE,SAAS,CAACG,GAAG,CAAC,GAAGJ,SAAS,CAAC;EACrC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,WAAWA,CAACxE,OAAO,EAAEmE,SAAS,EAAE;EAC9C,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;IACjCA,SAAS,GAAGA,SAAS,CAACG,KAAK,CAAC,GAAG,CAAC;EAClC,CAAC,MAAM,IAAIH,SAAS,YAAYF,MAAM,EAAE;IACtCE,SAAS,GAAG,CAACA,SAAS,CAAC;EACzB;EACA,IAAI;IACFN,SAAS,EAAEY,aAAa;IACxB;IACAX,OAAO,EAAEY;EACX,CAAC,GAAGhB,aAAa,CAACS,SAAS,EAAE,IAAI,CAAC;EAClCM,aAAa,GAAGnB,qBAAqB,CAACmB,aAAa,CAAC;EACpD,IAAIA,aAAa,CAACtE,MAAM,GAAG,CAAC,EAAE;IAC5BH,OAAO,CAACoE,SAAS,CAACO,MAAM,CAAC,GAAGF,aAAa,CAAC;EAC5C;EACAC,YAAY,CAACE,OAAO,CAACC,cAAc,IAAI;IACrC7E,OAAO,CAACoE,SAAS,CAACQ,OAAO,CAACE,gBAAgB,IAAI;MAC5C,IAAID,cAAc,CAACE,IAAI,CAACD,gBAAgB,CAAC,EAAE;QACzC9E,OAAO,CAACoE,SAAS,CAACO,MAAM,CAACG,gBAAgB,CAAC;MAC5C;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,YAAYA,CAACC,UAAU,EAAE;EACvC,IAAIC,UAAU,GAAGhF,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EACvF,IAAIiF,cAAc,GAAGjF,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGE,SAAS;EACpE,IAAI,CAACkC,KAAK,CAAC8C,OAAO,CAACF,UAAU,CAAC,EAAE;IAC9BA,UAAU,GAAG,CAAC,CAACA,UAAU,EAAEC,cAAc,CAAC,CAAC;EAC7C;EACAD,UAAU,CAACN,OAAO,CAACS,aAAa,IAAI;IAClC,IAAI/C,KAAK,CAAC8C,OAAO,CAACC,aAAa,CAAC,IAAIA,aAAa,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;MAC3DJ,UAAU,CAACD,YAAY,CAAC,GAAGK,aAAa,CAAC;IAC3C;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACL,UAAU,EAAE;EAC1C,IAAIM,kBAAkB,GAAGrF,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EAC/F,IAAI,OAAOqF,kBAAkB,KAAK,QAAQ,EAAE;IAC1CA,kBAAkB,GAAGA,kBAAkB,CAACjB,KAAK,CAAC,GAAG,CAAC;EACpD,CAAC,MAAM,IAAIiB,kBAAkB,YAAYtB,MAAM,EAAE;IAC/CsB,kBAAkB,GAAG,CAACA,kBAAkB,CAAC;EAC3C;EACA,MAAM;IACJ1B,SAAS,EAAE2B,gBAAgB;IAC3B1B,OAAO,EAAE2B;EACX,CAAC,GAAG/B,aAAa,CAAC6B,kBAAkB,EAAE,IAAI,CAAC;EAC3CC,gBAAgB,CAACZ,OAAO,CAACc,qBAAqB,IAAI;IAChD,IAAIA,qBAAqB,KAAK,EAAE,EAAE;MAChCT,UAAU,CAACK,eAAe,CAACI,qBAAqB,CAAC;IACnD;EACF,CAAC,CAAC;EACFD,eAAe,CAACb,OAAO,CAACe,cAAc,IAAI;IACxCV,UAAU,CAACW,iBAAiB,CAAC,CAAC,CAAChB,OAAO,CAACiB,aAAa,IAAI;MACtD,IAAIF,cAAc,CAACZ,IAAI,CAACc,aAAa,CAAC,EAAE;QACtCZ,UAAU,CAACK,eAAe,CAACO,aAAa,CAAC;MAC3C;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAAC9F,OAAO,EAAE;EACvC,IAAIA,OAAO,CAACS,QAAQ,KAAK,CAAC,EAAE;IAC1BT,OAAO,CAACY,UAAU,CAACmF,WAAW,CAAC/F,OAAO,CAAC,CAAC,CAAC;EAC3C,CAAC,MAAM,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC4C,OAAO,CAAC5C,OAAO,CAAC2B,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;IACpF,MAAMqE,MAAM,GAAGhG,OAAO,CAACiG,UAAU;IACjC,KAAK,IAAInD,CAAC,GAAGkD,MAAM,CAAC7F,MAAM,GAAG,CAAC,EAAE2C,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3CgD,eAAe,CAACE,MAAM,CAAClD,CAAC,CAAC,CAAC;IAC5B;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoD,KAAKA,CAAClG,OAAO,EAAE;EAC7B,IAAIkC,KAAK;;EAET;EACA,OAAOA,KAAK,GAAGlC,OAAO,CAACmG,SAAS,EAAE;IAChCnG,OAAO,CAAC+F,WAAW,CAAC7D,KAAK,CAAC;EAC5B;AACF;AACA,OAAO,MAAMkE,eAAe,GAAG,iBAAiB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACrG,OAAO,EAAEsG,OAAO,EAAE;EAC9C,IAAIC,eAAe,GAAGrG,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EAC9F,IAAIkG,eAAe,CAACrB,IAAI,CAACuB,OAAO,CAAC,EAAE;IACjCtG,OAAO,CAACwG,SAAS,GAAGD,eAAe,GAAG1G,QAAQ,CAACyG,OAAO,CAAC,GAAGA,OAAO;EACnE,CAAC,MAAM;IACLG,aAAa,CAACzG,OAAO,EAAEsG,OAAO,CAAC;EACjC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,aAAaA,CAACzG,OAAO,EAAEsG,OAAO,EAAE;EAC9C,MAAMpE,KAAK,GAAGlC,OAAO,CAAC0G,UAAU;EAChC,IAAIxE,KAAK,IAAIA,KAAK,CAACzB,QAAQ,KAAK,CAAC,IAAIyB,KAAK,CAACyE,WAAW,KAAK,IAAI,EAAE;IAC/D;IACAzE,KAAK,CAAC0E,WAAW,GAAGN,OAAO;EAC7B,CAAC,MAAM;IACL;IACAJ,KAAK,CAAClG,OAAO,CAAC;IACdA,OAAO,CAAC6G,WAAW,CAAC7G,OAAO,CAAC2C,aAAa,CAACmE,cAAc,CAACR,OAAO,CAAC,CAAC;EACpE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,SAASA,CAAC/G,OAAO,EAAE;EACjC,MAAMgH,eAAe,GAAGhH,OAAO,CAAC2C,aAAa,CAACqE,eAAe;EAC7D,IAAIC,IAAI,GAAGjH,OAAO;EAClB,OAAOiH,IAAI,KAAKD,eAAe,EAAE;IAC/B;IACA,IAAIC,IAAI,KAAK,IAAI,EAAE;MACjB;MACA,OAAO,KAAK;IACd,CAAC,MAAM,IAAIA,IAAI,CAACxG,QAAQ,KAAKC,IAAI,CAACC,sBAAsB,EAAE;MACxD,IAAIsG,IAAI,CAACzG,IAAI,EAAE;QACb;QACA;QACA;QACA,IAAIyG,IAAI,CAACzG,IAAI,CAAC0G,IAAI,EAAE;UAClB;UACA,OAAOH,SAAS,CAACE,IAAI,CAACzG,IAAI,CAAC0G,IAAI,CAAC;QAClC,CAAC,MAAM,IAAID,IAAI,CAACzG,IAAI,EAAE;UACpB;UACA,OAAOuG,SAAS,CAACE,IAAI,CAACzG,IAAI,CAAC;QAC7B;QACA,MAAM,IAAI2G,KAAK,CAAC,8BAA8B,CAAC;MACjD,CAAC,MAAM;QACL,OAAO,KAAK,CAAC,CAAC;MAChB;IACF,CAAC,MAAM,IAAIC,gBAAgB,CAACH,IAAI,CAAC,CAACI,OAAO,KAAK,MAAM,EAAE;MACpD,OAAO,KAAK;IACd;IACAJ,IAAI,GAAGA,IAAI,CAACrG,UAAU;EACxB;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0G,MAAMA,CAACtH,OAAO,EAAE;EAC9B,MAAMuH,YAAY,GAAGvH,OAAO,CAAC2C,aAAa;EAC1C,MAAM6E,UAAU,GAAGD,YAAY,CAAClF,WAAW;EAC3C,MAAM2E,eAAe,GAAGO,YAAY,CAACP,eAAe;EACpD,IAAIzG,cAAc,GAAGP,OAAO;EAC5B,IAAIyH,UAAU;EACd,IAAIC,SAAS;EACb,IAAIC,QAAQ;EACZF,UAAU,GAAGlH,cAAc,CAACkH,UAAU;EACtCC,SAAS,GAAGnH,cAAc,CAACmH,SAAS;EACpCC,QAAQ,GAAGpH,cAAc;;EAEzB;EACA,OAAOA,cAAc,GAAGA,cAAc,CAACqH,YAAY,EAAE;IACnD;IACA,IAAIrH,cAAc,KAAKgH,YAAY,CAACM,IAAI,EAAE;MACxC;IACF;IACA;IACA;IACA,IAAI,EAAE,YAAY,IAAItH,cAAc,CAAC,EAAE;MACrC;IACF;IACAkH,UAAU,IAAIlH,cAAc,CAACkH,UAAU;IACvCC,SAAS,IAAInH,cAAc,CAACmH,SAAS;IACrCC,QAAQ,GAAGpH,cAAc;EAC3B;;EAEA;EACA,IAAIoH,QAAQ,IAAIA,QAAQ,CAACG,KAAK,CAACC,QAAQ,KAAK,OAAO,EAAE;IACnD;IACAN,UAAU,IAAID,UAAU,CAACQ,WAAW,IAAIhB,eAAe,CAACiB,UAAU;IAClEP,SAAS,IAAIF,UAAU,CAACU,WAAW,IAAIlB,eAAe,CAACmB,SAAS;EAClE;EACA,OAAO;IACLC,IAAI,EAAEX,UAAU;IAChBY,GAAG,EAAEX;EACP,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,kBAAkBA,CAAA,EAAG;EACnC,IAAId,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,OAAOf,UAAU,CAACgB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAAA,EAAG;EACpC,IAAIjB,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,OAAOf,UAAU,CAACkB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAAC3I,OAAO,EAAE;EACpC,IAAIwH,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,IAAIvI,OAAO,KAAKwH,UAAU,EAAE;IAC1B,OAAOc,kBAAkB,CAACd,UAAU,CAAC;EACvC;EACA,OAAOxH,OAAO,CAACmI,SAAS;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,aAAaA,CAAC5I,OAAO,EAAE;EACrC,IAAIwH,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,IAAIvI,OAAO,KAAKwH,UAAU,EAAE;IAC1B,OAAOiB,mBAAmB,CAACjB,UAAU,CAAC;EACxC;EACA,OAAOxH,OAAO,CAACiI,UAAU;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,oBAAoBA,CAAC7I,OAAO,EAAE;EAC5C,IAAIuH,YAAY,GAAGvH,OAAO,CAAC2C,aAAa;EACxC,IAAI6E,UAAU,GAAGD,YAAY,GAAGA,YAAY,CAAClF,WAAW,GAAGjC,SAAS;EACpE,IAAI,CAACmH,YAAY,EAAE;IACjBA,YAAY,GAAGvH,OAAO,CAAC8I,QAAQ,GAAG9I,OAAO,CAAC8I,QAAQ,GAAG9I,OAAO;IAC5DwH,UAAU,GAAGD,YAAY,CAAClF,WAAW;EACvC;EACA,MAAM0G,KAAK,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC;EAChC,IAAIC,EAAE,GAAGhJ,OAAO,CAACY,UAAU;EAC3B,OAAOoI,EAAE,IAAIA,EAAE,CAAClB,KAAK,IAAIP,YAAY,CAACM,IAAI,KAAKmB,EAAE,EAAE;IACjD,IAAI;MACFC,QAAQ;MACRC,SAAS;MACTC;IACF,CAAC,GAAGH,EAAE,CAAClB,KAAK;IACZ,IAAI,CAACmB,QAAQ,EAAEC,SAAS,EAAEC,SAAS,CAAC,CAACvH,QAAQ,CAAC,QAAQ,CAAC,EAAE;MACvD,OAAOoH,EAAE;IACX,CAAC,MAAM;MACL,CAAC;QACCC,QAAQ;QACRC,SAAS;QACTC;MACF,CAAC,GAAG3B,UAAU,CAACJ,gBAAgB,CAAC4B,EAAE,CAAC;MACnC,IAAID,KAAK,CAACnH,QAAQ,CAACqH,QAAQ,CAAC,IAAIF,KAAK,CAACnH,QAAQ,CAACsH,SAAS,CAAC,IAAIH,KAAK,CAACnH,QAAQ,CAACuH,SAAS,CAAC,EAAE;QACtF,OAAOH,EAAE;MACX;IACF;;IAEA;IACA,IAAIA,EAAE,CAACI,YAAY,IAAIJ,EAAE,CAACK,YAAY,GAAG,CAAC,KAAKN,KAAK,CAACnH,QAAQ,CAACuH,SAAS,CAAC,IAAIJ,KAAK,CAACnH,QAAQ,CAACqH,QAAQ,CAAC,CAAC,EAAE;MACrG,OAAOD,EAAE;IACX;IACA,IAAIA,EAAE,CAACM,WAAW,IAAIN,EAAE,CAACO,WAAW,GAAG,CAAC,KAAKR,KAAK,CAACnH,QAAQ,CAACsH,SAAS,CAAC,IAAIH,KAAK,CAACnH,QAAQ,CAACqH,QAAQ,CAAC,CAAC,EAAE;MACnG,OAAOD,EAAE;IACX;IACAA,EAAE,GAAGA,EAAE,CAACpI,UAAU;EACpB;EACA,OAAO4G,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgC,mBAAmBA,CAACxJ,OAAO,EAAE;EAC3C,OAAOA,OAAO,CAACqJ,YAAY,GAAGrJ,OAAO,CAACoJ,YAAY;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,oBAAoBA,CAACzJ,OAAO,EAAE;EAC5C,OAAOA,OAAO,CAACuJ,WAAW,GAAGvJ,OAAO,CAACsJ,WAAW;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,oBAAoBA,CAACC,IAAI,EAAE;EACzC,MAAMpC,YAAY,GAAGoC,IAAI,CAAChH,aAAa;EACvC,MAAM6E,UAAU,GAAGD,YAAY,CAAClF,WAAW;EAC3C,IAAI2G,EAAE,GAAGW,IAAI,CAAC/I,UAAU;EACxB,OAAOoI,EAAE,IAAIA,EAAE,CAAClB,KAAK,IAAIP,YAAY,CAACM,IAAI,KAAKmB,EAAE,EAAE;IACjD,IAAIA,EAAE,CAAClB,KAAK,CAACmB,QAAQ,KAAK,SAAS,IAAID,EAAE,CAAClB,KAAK,CAACmB,QAAQ,KAAK,EAAE,EAAE;MAC/D,OAAOD,EAAE;IACX;IACA,MAAMY,aAAa,GAAGxC,gBAAgB,CAAC4B,EAAE,EAAExB,UAAU,CAAC;IACtD,MAAMqC,iBAAiB,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,CAAC;IACtD,MAAMC,QAAQ,GAAGF,aAAa,CAACG,gBAAgB,CAAC,UAAU,CAAC;IAC3D,MAAMC,SAAS,GAAGJ,aAAa,CAACG,gBAAgB,CAAC,YAAY,CAAC;IAC9D,MAAME,SAAS,GAAGL,aAAa,CAACG,gBAAgB,CAAC,YAAY,CAAC;IAC9D,IAAIF,iBAAiB,CAACjI,QAAQ,CAACkI,QAAQ,CAAC,IAAID,iBAAiB,CAACjI,QAAQ,CAACoI,SAAS,CAAC,IAAIH,iBAAiB,CAACjI,QAAQ,CAACqI,SAAS,CAAC,EAAE;MAC1H,OAAOjB,EAAE;IACX;IACAA,EAAE,GAAGA,EAAE,CAACpI,UAAU;EACpB;EACA,OAAO4G,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0C,QAAQA,CAAClK,OAAO,EAAEmK,IAAI,EAAE;EACtC,IAAI3C,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,IAAI,CAACvI,OAAO,EAAE;IACZ;EACF,CAAC,MAAM,IAAIA,OAAO,KAAKwH,UAAU,EAAE;IACjC,IAAI2C,IAAI,KAAK,OAAO,EAAE;MACpB,OAAO,GAAG3C,UAAU,CAAC4C,UAAU,IAAI;IACrC,CAAC,MAAM,IAAID,IAAI,KAAK,QAAQ,EAAE;MAC5B,OAAO,GAAG3C,UAAU,CAAC6C,WAAW,IAAI;IACtC;IACA;EACF;EACA,MAAMC,SAAS,GAAGtK,OAAO,CAAC8H,KAAK,CAACqC,IAAI,CAAC;EACrC,IAAIG,SAAS,KAAK,EAAE,IAAIA,SAAS,KAAKlK,SAAS,EAAE;IAC/C,OAAOkK,SAAS;EAClB;EACA,MAAMV,aAAa,GAAGxC,gBAAgB,CAACpH,OAAO,EAAEwH,UAAU,CAAC;EAC3D,IAAIoC,aAAa,CAACO,IAAI,CAAC,KAAK,EAAE,IAAIP,aAAa,CAACO,IAAI,CAAC,KAAK/J,SAAS,EAAE;IACnE,OAAOwJ,aAAa,CAACO,IAAI,CAAC;EAC5B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,eAAeA,CAACvK,OAAO,EAAEwK,IAAI,EAAE;EAC7C,MAAM;IACJC;EACF,CAAC,GAAGD,IAAI;EACR,IAAIE,MAAM,GAAG,KAAK;EAClB,IAAIF,IAAI,CAACG,IAAI,KAAKC,OAAO,CAACC,UAAU,IAAIJ,YAAY,EAAE;IACpD,IAAIzK,OAAO,CAAC8K,iBAAiB,EAAE;MAC7BJ,MAAM,GAAG1K,OAAO,CAAC8K,iBAAiB,CAACL,YAAY,CAAC;IAClD,CAAC,MAAM,IAAIzK,OAAO,CAAC+K,OAAO,EAAE;MAC1BL,MAAM,GAAG1K,OAAO,CAAC+K,OAAO,CAACN,YAAY,CAAC;IACxC;EACF;EACA,OAAOC,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAStD,gBAAgBA,CAACpH,OAAO,EAAE;EACxC,IAAIwH,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,OAAOvI,OAAO,CAACgL,YAAY,IAAIxD,UAAU,CAACJ,gBAAgB,CAACpH,OAAO,CAAC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiL,UAAUA,CAACjL,OAAO,EAAE;EAClC,OAAOA,OAAO,CAACkL,WAAW;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACnL,OAAO,EAAE;EACnC,OAAOA,OAAO,CAACoL,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASf,WAAWA,CAACrK,OAAO,EAAE;EACnC,OAAOA,OAAO,CAACoJ,YAAY,IAAIpJ,OAAO,CAACqK,WAAW;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASD,UAAUA,CAACpK,OAAO,EAAE;EAClC,OAAOA,OAAO,CAACsJ,WAAW,IAAItJ,OAAO,CAACoK,UAAU;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiB,QAAQA,CAACrL,OAAO,EAAEsL,KAAK,EAAEC,QAAQ,EAAE;EACjDvL,OAAO,CAACwL,gBAAgB,CAACF,KAAK,EAAEC,QAAQ,EAAE,KAAK,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,WAAWA,CAACzL,OAAO,EAAEsL,KAAK,EAAEC,QAAQ,EAAE;EACpDvL,OAAO,CAAC0L,mBAAmB,CAACJ,KAAK,EAAEC,QAAQ,EAAE,KAAK,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,gBAAgBA,CAAC3C,EAAE,EAAE;EACnC,IAAIA,EAAE,CAAC4C,cAAc,EAAE;IACrB,OAAO5C,EAAE,CAAC4C,cAAc;EAC1B;EACA,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuBA,CAAC7C,EAAE,EAAE;EAC1C,IAAIA,EAAE,CAAC8C,YAAY,EAAE;IACnB,OAAO9C,EAAE,CAAC8C,YAAY;EACxB;EACA,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAAA,EAAG;EACjC,IAAIvE,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F,MAAMhB,YAAY,GAAGC,UAAU,CAACsB,QAAQ;EACxC,IAAIkD,IAAI,GAAG,EAAE;EACb,IAAIxE,UAAU,CAACyE,YAAY,EAAE;IAC3BD,IAAI,GAAGxE,UAAU,CAACyE,YAAY,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;EAC7C,CAAC,MAAM,IAAI3E,YAAY,CAAC4E,SAAS,IAAI5E,YAAY,CAAC4E,SAAS,CAACxB,IAAI,KAAK,SAAS,EAAE;IAC9EqB,IAAI,GAAGzE,YAAY,CAAC4E,SAAS,CAACC,WAAW,CAAC,CAAC,CAACJ,IAAI;EAClD;EACA,OAAOA,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,kBAAkBA,CAAA,EAAG;EACnC,IAAI7E,UAAU,GAAGtH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGqI,MAAM;EAC3F;EACA,IAAIf,UAAU,CAACyE,YAAY,EAAE;IAC3B,IAAIzE,UAAU,CAACyE,YAAY,CAAC,CAAC,CAAC/F,KAAK,EAAE;MACnC;MACAsB,UAAU,CAACyE,YAAY,CAAC,CAAC,CAAC/F,KAAK,CAAC,CAAC;IACnC,CAAC,MAAM,IAAIsB,UAAU,CAACyE,YAAY,CAAC,CAAC,CAACK,eAAe,EAAE;MACpD;MACA9E,UAAU,CAACyE,YAAY,CAAC,CAAC,CAACK,eAAe,CAAC,CAAC;IAC7C;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACvM,OAAO,EAAEwM,GAAG,EAAEC,MAAM,EAAE;EACrD,IAAIA,MAAM,KAAKrM,SAAS,EAAE;IACxBqM,MAAM,GAAGD,GAAG;EACd;EACA,IAAIxM,OAAO,CAAC0M,iBAAiB,EAAE;IAC7B1M,OAAO,CAAC2M,KAAK,CAAC,CAAC;IACf,IAAI;MACF3M,OAAO,CAAC0M,iBAAiB,CAACF,GAAG,EAAEC,MAAM,CAAC;IACxC,CAAC,CAAC,OAAOG,GAAG,EAAE;MACZ,MAAMC,aAAa,GAAG7M,OAAO,CAACY,UAAU;MACxC,MAAMkM,kBAAkB,GAAGD,aAAa,CAAC/E,KAAK,CAACT,OAAO;MACtDwF,aAAa,CAAC/E,KAAK,CAACT,OAAO,GAAG,OAAO;MACrCrH,OAAO,CAAC0M,iBAAiB,CAACF,GAAG,EAAEC,MAAM,CAAC;MACtCI,aAAa,CAAC/E,KAAK,CAACT,OAAO,GAAGyF,kBAAkB;IAClD;EACF;AACF;AACA,IAAIC,oBAAoB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kCAAkCA,CAAA,EAAG;EAC5C,IAAIzF,YAAY,GAAGrH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG4I,QAAQ;EAC/F,MAAMmE,KAAK,GAAG1F,YAAY,CAAC2F,aAAa,CAAC,KAAK,CAAC;EAC/CD,KAAK,CAACnF,KAAK,CAACqF,MAAM,GAAG,OAAO;EAC5BF,KAAK,CAACnF,KAAK,CAACsF,KAAK,GAAG,MAAM;EAC1B,MAAMC,KAAK,GAAG9F,YAAY,CAAC2F,aAAa,CAAC,KAAK,CAAC;EAC/CG,KAAK,CAACvF,KAAK,CAACwF,SAAS,GAAG,aAAa;EACrCD,KAAK,CAACvF,KAAK,CAACqF,MAAM,GAAG,OAAO;EAC5BE,KAAK,CAACvF,KAAK,CAACM,IAAI,GAAG,KAAK;EACxBiF,KAAK,CAACvF,KAAK,CAACmB,QAAQ,GAAG,QAAQ;EAC/BoE,KAAK,CAACvF,KAAK,CAACC,QAAQ,GAAG,UAAU;EACjCsF,KAAK,CAACvF,KAAK,CAACO,GAAG,GAAG,KAAK;EACvBgF,KAAK,CAACvF,KAAK,CAACsF,KAAK,GAAG,OAAO;EAC3BC,KAAK,CAACvF,KAAK,CAACyF,UAAU,GAAG,QAAQ;EACjCF,KAAK,CAACxG,WAAW,CAACoG,KAAK,CAAC;EACxB,CAAC1F,YAAY,CAACM,IAAI,IAAIN,YAAY,CAACP,eAAe,EAAEH,WAAW,CAACwG,KAAK,CAAC;EACtE,MAAMG,EAAE,GAAGP,KAAK,CAAC/B,WAAW;EAC5BmC,KAAK,CAACvF,KAAK,CAACmB,QAAQ,GAAG,QAAQ;EAC/B,IAAIwE,EAAE,GAAGR,KAAK,CAAC/B,WAAW;EAC1B,IAAIsC,EAAE,KAAKC,EAAE,EAAE;IACbA,EAAE,GAAGJ,KAAK,CAAC/D,WAAW;EACxB;EACA,CAAC/B,YAAY,CAACM,IAAI,IAAIN,YAAY,CAACP,eAAe,EAAEjB,WAAW,CAACsH,KAAK,CAAC;EACtE,OAAOG,EAAE,GAAGC,EAAE;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,iBAAiBA,CAAA,EAAG;EAClC,IAAInG,YAAY,GAAGrH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG4I,QAAQ;EAC/F,IAAIiE,oBAAoB,KAAK3M,SAAS,EAAE;IACtC2M,oBAAoB,GAAGC,kCAAkC,CAACzF,YAAY,CAAC;EACzE;EACA,OAAOwF,oBAAoB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,oBAAoBA,CAAC3N,OAAO,EAAE;EAC5C,OAAOA,OAAO,CAACkL,WAAW,KAAKlL,OAAO,CAACsJ,WAAW;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsE,sBAAsBA,CAAC5N,OAAO,EAAE;EAC9C,OAAOA,OAAO,CAACoL,YAAY,KAAKpL,OAAO,CAACoJ,YAAY;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASyE,kBAAkBA,CAACC,WAAW,EAAE1F,IAAI,EAAEC,GAAG,EAAE;EACzDyF,WAAW,CAAChG,KAAK,CAACiG,SAAS,GAAG,eAAe3F,IAAI,IAAIC,GAAG,KAAK;AAC/D;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAAS2F,eAAeA,CAAChO,OAAO,EAAE;EACvC,IAAI+N,SAAS;EACb,IAAI/N,OAAO,CAAC8H,KAAK,CAACiG,SAAS,IAAI,CAACA,SAAS,GAAG/N,OAAO,CAAC8H,KAAK,CAACiG,SAAS,MAAM,EAAE,EAAE;IAC3E,OAAO,CAAC,WAAW,EAAEA,SAAS,CAAC;EACjC;EACA,OAAO,CAAC,CAAC;AACX;;AAEA;AACA;AACA;AACA,OAAO,SAASE,iBAAiBA,CAACjO,OAAO,EAAE;EACzC,IAAIA,OAAO,CAAC8H,KAAK,CAACiG,SAAS,IAAI/N,OAAO,CAAC8H,KAAK,CAACiG,SAAS,KAAK,EAAE,EAAE;IAC7D/N,OAAO,CAAC8H,KAAK,CAACiG,SAAS,GAAG,EAAE;EAC9B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,OAAOA,CAAClO,OAAO,EAAE;EAC/B,MAAMmO,MAAM,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,CAAC;EAC9C,OAAOnO,OAAO,KAAKmO,MAAM,CAACvL,OAAO,CAAC5C,OAAO,CAAC2B,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI3B,OAAO,CAACoO,eAAe,KAAK,MAAM,CAAC;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAcA,CAACrO,OAAO,EAAE;EACtC,OAAOkO,OAAO,CAAClO,OAAO,CAAC,IAAIA,OAAO,CAACsO,YAAY,CAAC,gBAAgB,CAAC,KAAK,KAAK;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sBAAsBA,CAACvO,OAAO,EAAE;EAC9C,MAAMwO,aAAa,GAAGxO,OAAO,CAAC2C,aAAa,CAAC6L,aAAa;EACzD,IAAI,CAACH,cAAc,CAACG,aAAa,CAAC,EAAE;IAClCxO,OAAO,CAACyO,MAAM,CAAC,CAAC;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAAC1O,OAAO,EAAE;EAClC,OAAO,CAACA,OAAO,CAACY,UAAU;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS+N,2BAA2BA,CAACC,mBAAmB,EAAErD,QAAQ,EAAE;EACzE,MAAMsD,kBAAkB,GAAG,IAAIC,oBAAoB,CAAC,CAACC,OAAO,EAAEC,QAAQ,KAAK;IACzED,OAAO,CAACnK,OAAO,CAACb,KAAK,IAAI;MACvB,IAAIA,KAAK,CAACkL,cAAc,IAAIL,mBAAmB,CAAChH,YAAY,KAAK,IAAI,EAAE;QACrE2D,QAAQ,CAAC,CAAC;QACVyD,QAAQ,CAACE,SAAS,CAACN,mBAAmB,CAAC;MACzC;IACF,CAAC,CAAC;EACJ,CAAC,EAAE;IACD1L,IAAI,EAAE0L,mBAAmB,CAACjM,aAAa,CAACkF;EAC1C,CAAC,CAAC;EACFgH,kBAAkB,CAACM,OAAO,CAACP,mBAAmB,CAAC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,6CAA6CA,CAACpP,OAAO,EAAE;EACrE,IAAIqP,kBAAkB,GAAGnP,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EACjG,IAAIoP,UAAU,GAAGpP,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EACzF,MAAMyC,aAAa,GAAG3C,OAAO,CAAC2C,aAAa;EAC3C,MAAM4M,KAAK,GAAG5M,aAAa,CAACyJ,WAAW,CAAC,CAAC;EACzC,MAAMoD,GAAG,GAAG7M,aAAa,CAACN,WAAW,CAAC4J,YAAY,CAAC,CAAC;EACpDjH,YAAY,CAAChF,OAAO,EAAE,iBAAiB,EAAE,IAAI,CAAC;EAC9C,IAAIsP,UAAU,EAAE;IACdtK,YAAY,CAAChF,OAAO,EAAE,GAAGF,WAAW,CAAC,CAAC,CAAC;EACzC;EACA,IAAIuP,kBAAkB,EAAE;IACtBhL,QAAQ,CAACrE,OAAO,EAAE,oBAAoB,CAAC;EACzC;EACAuP,KAAK,CAACE,kBAAkB,CAACzP,OAAO,CAAC;EACjCwP,GAAG,CAAClD,eAAe,CAAC,CAAC;EACrBkD,GAAG,CAACE,QAAQ,CAACH,KAAK,CAAC;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,2CAA2CA,CAACC,eAAe,EAAE;EAC3E,IAAIC,6BAA6B,GAAG3P,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EAC5G,MAAMsP,GAAG,GAAGI,eAAe,CAACjN,aAAa,CAACN,WAAW,CAAC4J,YAAY,CAAC,CAAC;EACpE,IAAI2D,eAAe,CAACtB,YAAY,CAAC,aAAa,CAAC,EAAE;IAC/CsB,eAAe,CAACtK,eAAe,CAAC,aAAa,CAAC;EAChD;EACAkK,GAAG,CAAClD,eAAe,CAAC,CAAC;EACrB,IAAIuD,6BAA6B,EAAE;IACjCrL,WAAW,CAACoL,eAAe,EAAE,oBAAoB,CAAC;EACpD;EACAA,eAAe,CAACtK,eAAe,CAAC,iBAAiB,CAAC;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASwK,qCAAqCA,CAAC9P,OAAO,EAAEuL,QAAQ,EAAE;EACvE,IAAI8D,kBAAkB,GAAGnP,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EACjGkP,6CAA6C,CAACpP,OAAO,EAAEqP,kBAAkB,CAAC;EAC1E9D,QAAQ,CAAC,CAAC;EACVoE,2CAA2C,CAAC3P,OAAO,EAAEqP,kBAAkB,CAAC;AAC1E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}