{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../../helpers/a11y.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport class Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    /**\n     *  The Walkontable settings.\n     *\n     * @private\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    const {\n      TABLE,\n      hider,\n      spreader,\n      holder,\n      wtRootElement\n    } = this.wot.wtTable; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.needFullRender = this.shouldBeRendered();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Checks if the overlay rendering state has changed.\n   *\n   * @returns {boolean}\n   */\n  hasRenderingStateChanged() {\n    return this.needFullRender !== this.shouldBeRendered();\n  }\n\n  /**\n   * Updates internal state with an information about the need of full rendering of the overlay in the next draw cycles.\n   *\n   * If the state is changed to render the overlay, the `needFullRender` property is set to `true` which means that\n   * the overlay will be fully rendered in the current draw cycle. If the state is changed to not render the overlay,\n   * the `needFullRender` property is set to `false` which means that the overlay will be fully rendered in the\n   * current draw cycle but it will not be rendered in the next draw cycles.\n   *\n   * @param {'before' | 'after'} drawPhase The phase of the rendering process.\n   */\n  updateStateOfRendering(drawPhase) {\n    if (drawPhase === 'before' && this.shouldBeRendered()) {\n      this.needFullRender = true;\n    } else if (drawPhase === 'after' && !this.shouldBeRendered()) {\n      this.needFullRender = false;\n    }\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return true;\n  }\n\n  /**\n   * Update the trimming container.\n   */\n  updateTrimmingContainer() {\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n  }\n\n  /**\n   * Update the main scrollable element.\n   */\n  updateMainScrollableElement() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = this.wot.wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element.\n   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n   *\n   * @param {HTMLElement} element The cell element to calculate the position for.\n   * @param {number} rowIndex Visual row index.\n   * @param {number} columnIndex Visual column index.\n   * @returns {{top: number, start: number}|undefined}\n   */\n  getRelativeCellPosition(element, rowIndex, columnIndex) {\n    if (this.clone.wtTable.holder.contains(element) === false) {\n      warn(`The provided element is not a child of the ${this.type} overlay`);\n      return;\n    }\n    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n    const fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n    const fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n    const spreader = this.clone.wtTable.spreader;\n    const spreaderOffset = {\n      start: this.getRelativeStartPosition(spreader),\n      top: spreader.offsetTop\n    };\n    const elementOffset = {\n      start: this.getRelativeStartPosition(element),\n      top: element.offsetTop\n    };\n    let offsetObject = null;\n    if (windowScroll) {\n      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n    } else {\n      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n    }\n    return offsetObject;\n  }\n\n  /**\n   * Get inline start value depending of direction.\n   *\n   * @param {HTMLElement} el Element.\n   * @returns {number}\n   */\n  getRelativeStartPosition(el) {\n    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = spreaderOffset.start;\n    } else {\n      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n      if (this.isRtl()) {\n        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n      }\n      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n    }\n    if (onFixedRowTop) {\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n    } else {\n      verticalOffset = spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start + horizontalOffset,\n      top: elementOffset.top + verticalOffset\n    };\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n    const tableScrollPosition = {\n      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n    };\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n    }\n    if (onFixedRowBottom) {\n      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n    } else if (!onFixedRowTop) {\n      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start - horizontalOffset,\n      top: elementOffset.top - verticalOffset\n    };\n  }\n\n  /**\n   * Make a clone of table for overlay.\n   *\n   * @returns {Clone}\n   */\n  makeClone() {\n    if (CLONE_TYPES.indexOf(this.type) === -1) {\n      throw new Error(`Clone type \"${this.type}\" is not supported.`);\n    }\n    const {\n      wtTable,\n      wtSettings\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const clone = rootDocument.createElement('div');\n    const clonedTable = rootDocument.createElement('table');\n    const tableParent = wtTable.wtRootElement.parentNode;\n    clone.className = `${CLONE_CLASS_NAMES.get(this.type)} handsontable`;\n    clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n    clone.style.position = 'absolute';\n    clone.style.top = 0;\n    clone.style.overflow = 'visible';\n    if (this.isRtl()) {\n      clone.style.right = 0;\n    } else {\n      clone.style.left = 0;\n    }\n    if (wtSettings.getSetting('ariaTags')) {\n      setAttribute(clone, [A11Y_PRESENTATION()]);\n    }\n    clonedTable.className = wtTable.TABLE.className;\n\n    // Clone the main table's `role` attribute to the cloned table.\n    const mainTableRole = wtTable.TABLE.getAttribute('role');\n    if (mainTableRole) {\n      clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));\n    }\n    clone.appendChild(clonedTable);\n    tableParent.appendChild(clone);\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n      this.mainTableScrollableElement = rootWindow;\n    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n\n    // Create a new instance of the Walkontable class\n    return new Clone(clonedTable, this.wtSettings, {\n      // todo ioc factory\n      source: this.wot,\n      overlay: this,\n      viewport: this.wot.wtViewport,\n      // todo ioc , or factor func if used only here\n      event: this.wot.wtEvent,\n      // todo ioc , or factory func if used only here\n      selectionManager: this.wot.selectionManager // todo ioc , or factory func if used only here\n    });\n  }\n\n  /**\n   * Refresh/Redraw overlay.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.needFullRender) {\n      this.clone.draw(fastDraw);\n    }\n  }\n\n  /**\n   * Reset overlay styles to initial values.\n   */\n  reset() {\n    const holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n    const hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n    const holderStyle = holder.style;\n    const hiderStyle = hider.style;\n    const rootStyle = holder.parentNode.style;\n    [holderStyle, hiderStyle, rootStyle].forEach(style => {\n      style.width = '';\n      style.height = '';\n    });\n  }\n\n  /**\n   * Determine if Walkontable is running in RTL mode.\n   *\n   * @returns {boolean}\n   */\n  isRtl() {\n    return this.wtSettings.getSetting('rtlMode');\n  }\n\n  /**\n   * Destroy overlay instance.\n   */\n  destroy() {\n    this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","getScrollableElement","getTrimmingContainer","getScrollbarWidth","setAttribute","defineGetter","warn","CLONE_TYPES","CLONE_CLASS_NAMES","CLONE_TOP","CLONE_INLINE_START","Clone","A11Y_PRESENTATION","Overlay","constructor","wotInstance","facadeGetter","type","wtSettings","domBindings","TABLE","hider","spreader","holder","wtRootElement","wot","wtTable","instance","mainTableScrollableElement","trimmingContainer","parentNode","needFullRender","shouldBeRendered","clone","makeClone","hasRenderingStateChanged","updateStateOfRendering","drawPhase","updateTrimmingContainer","updateMainScrollableElement","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","contains","windowScroll","fixedColumnStart","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","start","getRelativeStartPosition","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","el","isRtl","offsetParent","offsetWidth","offsetLeft","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteRootElementStartPosition","left","innerWidth","width","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","wtOverlays","inlineStartOverlay","getScrollPosition","vertical","topOverlay","indexOf","Error","rootDocument","createElement","clonedTable","tableParent","className","get","style","position","overflow","right","mainTableRole","getAttribute","appendChild","preventOverflow","source","overlay","viewport","wtViewport","event","wtEvent","selectionManager","refresh","fastDraw","arguments","length","undefined","draw","reset","holderStyle","hiderStyle","rootStyle","forEach","height","destroy","eventManager"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../../helpers/a11y.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport class Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    /**\n     *  The Walkontable settings.\n     *\n     * @private\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    const {\n      TABLE,\n      hider,\n      spreader,\n      holder,\n      wtRootElement\n    } = this.wot.wtTable; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.needFullRender = this.shouldBeRendered();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Checks if the overlay rendering state has changed.\n   *\n   * @returns {boolean}\n   */\n  hasRenderingStateChanged() {\n    return this.needFullRender !== this.shouldBeRendered();\n  }\n\n  /**\n   * Updates internal state with an information about the need of full rendering of the overlay in the next draw cycles.\n   *\n   * If the state is changed to render the overlay, the `needFullRender` property is set to `true` which means that\n   * the overlay will be fully rendered in the current draw cycle. If the state is changed to not render the overlay,\n   * the `needFullRender` property is set to `false` which means that the overlay will be fully rendered in the\n   * current draw cycle but it will not be rendered in the next draw cycles.\n   *\n   * @param {'before' | 'after'} drawPhase The phase of the rendering process.\n   */\n  updateStateOfRendering(drawPhase) {\n    if (drawPhase === 'before' && this.shouldBeRendered()) {\n      this.needFullRender = true;\n    } else if (drawPhase === 'after' && !this.shouldBeRendered()) {\n      this.needFullRender = false;\n    }\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return true;\n  }\n\n  /**\n   * Update the trimming container.\n   */\n  updateTrimmingContainer() {\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n  }\n\n  /**\n   * Update the main scrollable element.\n   */\n  updateMainScrollableElement() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = this.wot.wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element.\n   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n   *\n   * @param {HTMLElement} element The cell element to calculate the position for.\n   * @param {number} rowIndex Visual row index.\n   * @param {number} columnIndex Visual column index.\n   * @returns {{top: number, start: number}|undefined}\n   */\n  getRelativeCellPosition(element, rowIndex, columnIndex) {\n    if (this.clone.wtTable.holder.contains(element) === false) {\n      warn(`The provided element is not a child of the ${this.type} overlay`);\n      return;\n    }\n    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n    const fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n    const fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n    const spreader = this.clone.wtTable.spreader;\n    const spreaderOffset = {\n      start: this.getRelativeStartPosition(spreader),\n      top: spreader.offsetTop\n    };\n    const elementOffset = {\n      start: this.getRelativeStartPosition(element),\n      top: element.offsetTop\n    };\n    let offsetObject = null;\n    if (windowScroll) {\n      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n    } else {\n      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n    }\n    return offsetObject;\n  }\n\n  /**\n   * Get inline start value depending of direction.\n   *\n   * @param {HTMLElement} el Element.\n   * @returns {number}\n   */\n  getRelativeStartPosition(el) {\n    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = spreaderOffset.start;\n    } else {\n      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n      if (this.isRtl()) {\n        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n      }\n      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n    }\n    if (onFixedRowTop) {\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n    } else {\n      verticalOffset = spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start + horizontalOffset,\n      top: elementOffset.top + verticalOffset\n    };\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n    const tableScrollPosition = {\n      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n    };\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n    }\n    if (onFixedRowBottom) {\n      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n    } else if (!onFixedRowTop) {\n      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start - horizontalOffset,\n      top: elementOffset.top - verticalOffset\n    };\n  }\n\n  /**\n   * Make a clone of table for overlay.\n   *\n   * @returns {Clone}\n   */\n  makeClone() {\n    if (CLONE_TYPES.indexOf(this.type) === -1) {\n      throw new Error(`Clone type \"${this.type}\" is not supported.`);\n    }\n    const {\n      wtTable,\n      wtSettings\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const clone = rootDocument.createElement('div');\n    const clonedTable = rootDocument.createElement('table');\n    const tableParent = wtTable.wtRootElement.parentNode;\n    clone.className = `${CLONE_CLASS_NAMES.get(this.type)} handsontable`;\n    clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n    clone.style.position = 'absolute';\n    clone.style.top = 0;\n    clone.style.overflow = 'visible';\n    if (this.isRtl()) {\n      clone.style.right = 0;\n    } else {\n      clone.style.left = 0;\n    }\n    if (wtSettings.getSetting('ariaTags')) {\n      setAttribute(clone, [A11Y_PRESENTATION()]);\n    }\n    clonedTable.className = wtTable.TABLE.className;\n\n    // Clone the main table's `role` attribute to the cloned table.\n    const mainTableRole = wtTable.TABLE.getAttribute('role');\n    if (mainTableRole) {\n      clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));\n    }\n    clone.appendChild(clonedTable);\n    tableParent.appendChild(clone);\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n      this.mainTableScrollableElement = rootWindow;\n    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n\n    // Create a new instance of the Walkontable class\n    return new Clone(clonedTable, this.wtSettings, {\n      // todo ioc factory\n      source: this.wot,\n      overlay: this,\n      viewport: this.wot.wtViewport,\n      // todo ioc , or factor func if used only here\n      event: this.wot.wtEvent,\n      // todo ioc , or factory func if used only here\n      selectionManager: this.wot.selectionManager // todo ioc , or factory func if used only here\n    });\n  }\n\n  /**\n   * Refresh/Redraw overlay.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.needFullRender) {\n      this.clone.draw(fastDraw);\n    }\n  }\n\n  /**\n   * Reset overlay styles to initial values.\n   */\n  reset() {\n    const holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n    const hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n    const holderStyle = holder.style;\n    const hiderStyle = hider.style;\n    const rootStyle = holder.parentNode.style;\n    [holderStyle, hiderStyle, rootStyle].forEach(style => {\n      style.width = '';\n      style.height = '';\n    });\n  }\n\n  /**\n   * Determine if Walkontable is running in RTL mode.\n   *\n   * @returns {boolean}\n   */\n  isRtl() {\n    return this.wtSettings.getSetting('rtlMode');\n  }\n\n  /**\n   * Destroy overlay instance.\n   */\n  destroy() {\n    this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n  }\n}"],"mappings":"AACA,SAASA,eAAeA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAAE,OAAO,CAACD,CAAC,GAAGE,cAAc,CAACF,CAAC,CAAC,KAAKD,CAAC,GAAGI,MAAM,CAACC,cAAc,CAACL,CAAC,EAAEC,CAAC,EAAE;IAAEK,KAAK,EAAEJ,CAAC;IAAEK,UAAU,EAAE,CAAC,CAAC;IAAEC,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGT,CAAC,CAACC,CAAC,CAAC,GAAGC,CAAC,EAAEF,CAAC;AAAE;AACnL,SAASG,cAAcA,CAACD,CAAC,EAAE;EAAE,IAAIQ,CAAC,GAAGC,YAAY,CAACT,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOQ,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAACT,CAAC,EAAED,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOC,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIF,CAAC,GAAGE,CAAC,CAACU,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKb,CAAC,EAAE;IAAE,IAAIU,CAAC,GAAGV,CAAC,CAACc,IAAI,CAACZ,CAAC,EAAED,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOS,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIK,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKd,CAAC,GAAGe,MAAM,GAAGC,MAAM,EAAEf,CAAC,CAAC;AAAE;AACvT,SAASgB,oBAAoB,EAAEC,oBAAoB,EAAEC,iBAAiB,EAAEC,YAAY,QAAQ,qCAAqC;AACjI,SAASC,YAAY,QAAQ,gCAAgC;AAC7D,SAASC,IAAI,QAAQ,iCAAiC;AACtD,SAASC,WAAW,EAAEC,iBAAiB,EAAEC,SAAS,EAAEC,kBAAkB,QAAQ,iBAAiB;AAC/F,OAAOC,KAAK,MAAM,mBAAmB;AACrC,SAASC,iBAAiB,QAAQ,8BAA8B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,CAAC;EACnB;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,WAAW,EAAEC,YAAY,EAAEC,IAAI,EAAEC,UAAU,EAAEC,WAAW,EAAE;IACpE;AACJ;AACA;AACA;AACA;AACA;IACIrC,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC;IACzCuB,YAAY,CAAC,IAAI,EAAE,KAAK,EAAEU,WAAW,EAAE;MACrCvB,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,IAAI,CAAC2B,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACH,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACE,UAAU,GAAGA,UAAU;IAC5B,MAAM;MACJE,KAAK;MACLC,KAAK;MACLC,QAAQ;MACRC,MAAM;MACNC;IACF,CAAC,GAAG,IAAI,CAACC,GAAG,CAACC,OAAO,CAAC,CAAC;;IAEtB;IACA,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACF,GAAG;IACxB,IAAI,CAACR,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACW,0BAA0B,GAAG,IAAI;IACtC,IAAI,CAACR,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACK,iBAAiB,GAAG3B,oBAAoB,CAAC,IAAI,CAACmB,KAAK,CAACS,UAAU,CAACA,UAAU,CAAC;IAC/E,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;IAC7C,IAAI,CAACC,KAAK,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;EACEC,wBAAwBA,CAAA,EAAG;IACzB,OAAO,IAAI,CAACJ,cAAc,KAAK,IAAI,CAACC,gBAAgB,CAAC,CAAC;EACxD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,sBAAsBA,CAACC,SAAS,EAAE;IAChC,IAAIA,SAAS,KAAK,QAAQ,IAAI,IAAI,CAACL,gBAAgB,CAAC,CAAC,EAAE;MACrD,IAAI,CAACD,cAAc,GAAG,IAAI;IAC5B,CAAC,MAAM,IAAIM,SAAS,KAAK,OAAO,IAAI,CAAC,IAAI,CAACL,gBAAgB,CAAC,CAAC,EAAE;MAC5D,IAAI,CAACD,cAAc,GAAG,KAAK;IAC7B;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEC,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEM,uBAAuBA,CAAA,EAAG;IACxB,IAAI,CAACT,iBAAiB,GAAG3B,oBAAoB,CAAC,IAAI,CAACmB,KAAK,CAACS,UAAU,CAACA,UAAU,CAAC;EACjF;;EAEA;AACF;AACA;EACES,2BAA2BA,CAAA,EAAG;IAC5B,MAAM;MACJb;IACF,CAAC,GAAG,IAAI,CAACD,GAAG;IACZ,MAAM;MACJe;IACF,CAAC,GAAG,IAAI,CAACrB,WAAW;IACpB,IAAIqB,UAAU,CAACC,gBAAgB,CAACf,OAAO,CAACF,aAAa,CAACM,UAAU,CAAC,CAACY,gBAAgB,CAAC,UAAU,CAAC,KAAK,QAAQ,EAAE;MAC3G,IAAI,CAACd,0BAA0B,GAAG,IAAI,CAACH,GAAG,CAACC,OAAO,CAACH,MAAM;IAC3D,CAAC,MAAM;MACL,IAAI,CAACK,0BAA0B,GAAG3B,oBAAoB,CAACyB,OAAO,CAACN,KAAK,CAAC;IACvE;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuB,uBAAuBA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAE;IACtD,IAAI,IAAI,CAACb,KAAK,CAACP,OAAO,CAACH,MAAM,CAACwB,QAAQ,CAACH,OAAO,CAAC,KAAK,KAAK,EAAE;MACzDtC,IAAI,CAAC,8CAA8C,IAAI,CAACW,IAAI,UAAU,CAAC;MACvE;IACF;IACA,MAAM+B,YAAY,GAAG,IAAI,CAACpB,0BAA0B,KAAK,IAAI,CAACT,WAAW,CAACqB,UAAU;IACpF,MAAMS,gBAAgB,GAAGH,WAAW,GAAG,IAAI,CAAC5B,UAAU,CAACgC,UAAU,CAAC,mBAAmB,CAAC;IACtF,MAAMC,WAAW,GAAGN,QAAQ,GAAG,IAAI,CAAC3B,UAAU,CAACgC,UAAU,CAAC,cAAc,CAAC;IACzE,MAAME,cAAc,GAAGP,QAAQ,IAAI,IAAI,CAAC3B,UAAU,CAACgC,UAAU,CAAC,WAAW,CAAC,GAAG,IAAI,CAAChC,UAAU,CAACgC,UAAU,CAAC,iBAAiB,CAAC;IAC1H,MAAM5B,QAAQ,GAAG,IAAI,CAACW,KAAK,CAACP,OAAO,CAACJ,QAAQ;IAC5C,MAAM+B,cAAc,GAAG;MACrBC,KAAK,EAAE,IAAI,CAACC,wBAAwB,CAACjC,QAAQ,CAAC;MAC9CkC,GAAG,EAAElC,QAAQ,CAACmC;IAChB,CAAC;IACD,MAAMC,aAAa,GAAG;MACpBJ,KAAK,EAAE,IAAI,CAACC,wBAAwB,CAACX,OAAO,CAAC;MAC7CY,GAAG,EAAEZ,OAAO,CAACa;IACf,CAAC;IACD,IAAIE,YAAY,GAAG,IAAI;IACvB,IAAIX,YAAY,EAAE;MAChBW,YAAY,GAAG,IAAI,CAACC,mCAAmC,CAACT,WAAW,EAAEF,gBAAgB,EAAES,aAAa,EAAEL,cAAc,CAAC;IACvH,CAAC,MAAM;MACLM,YAAY,GAAG,IAAI,CAACE,mCAAmC,CAACV,WAAW,EAAEC,cAAc,EAAEH,gBAAgB,EAAES,aAAa,EAAEL,cAAc,CAAC;IACvI;IACA,OAAOM,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEJ,wBAAwBA,CAACO,EAAE,EAAE;IAC3B,OAAO,IAAI,CAACC,KAAK,CAAC,CAAC,GAAGD,EAAE,CAACE,YAAY,CAACC,WAAW,GAAGH,EAAE,CAACI,UAAU,GAAGJ,EAAE,CAACG,WAAW,GAAGH,EAAE,CAACI,UAAU;EACpG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEN,mCAAmCA,CAACO,aAAa,EAAEC,aAAa,EAAEV,aAAa,EAAEL,cAAc,EAAE;IAC/F,MAAMgB,2BAA2B,GAAG,IAAI,CAAC5C,GAAG,CAACC,OAAO,CAACF,aAAa,CAAC8C,qBAAqB,CAAC,CAAC,CAAC,CAAC;IAC5F,IAAIC,gBAAgB,GAAG,CAAC;IACxB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAI,CAACJ,aAAa,EAAE;MAClBG,gBAAgB,GAAGlB,cAAc,CAACC,KAAK;IACzC,CAAC,MAAM;MACL,IAAImB,gCAAgC,GAAGJ,2BAA2B,CAACK,IAAI;MACvE,IAAI,IAAI,CAACX,KAAK,CAAC,CAAC,EAAE;QAChBU,gCAAgC,GAAG,IAAI,CAACtD,WAAW,CAACqB,UAAU,CAACmC,UAAU,IAAIN,2BAA2B,CAACK,IAAI,GAAGL,2BAA2B,CAACO,KAAK,GAAGzE,iBAAiB,CAAC,CAAC,CAAC;MAC1K;MACAoE,gBAAgB,GAAGE,gCAAgC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAGA,gCAAgC,GAAG,CAAC;IACtG;IACA,IAAIN,aAAa,EAAE;MACjB,MAAMU,uBAAuB,GAAG,IAAI,CAAC5C,KAAK,CAACP,OAAO,CAACN,KAAK,CAACkD,qBAAqB,CAAC,CAAC;MAChFE,cAAc,GAAGK,uBAAuB,CAACrB,GAAG,GAAGa,2BAA2B,CAACb,GAAG;IAChF,CAAC,MAAM;MACLgB,cAAc,GAAGnB,cAAc,CAACG,GAAG;IACrC;IACA,OAAO;MACLF,KAAK,EAAEI,aAAa,CAACJ,KAAK,GAAGiB,gBAAgB;MAC7Cf,GAAG,EAAEE,aAAa,CAACF,GAAG,GAAGgB;IAC3B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEX,mCAAmCA,CAACM,aAAa,EAAEW,gBAAgB,EAAEV,aAAa,EAAEV,aAAa,EAAEL,cAAc,EAAE;IACjH,MAAM0B,mBAAmB,GAAG;MAC1BC,UAAU,EAAE,IAAI,CAACvD,GAAG,CAACwD,UAAU,CAACC,kBAAkB,CAACC,iBAAiB,CAAC,CAAC;MACtEC,QAAQ,EAAE,IAAI,CAAC3D,GAAG,CAACwD,UAAU,CAACI,UAAU,CAACF,iBAAiB,CAAC;IAC7D,CAAC;IACD,IAAIZ,gBAAgB,GAAG,CAAC;IACxB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAI,CAACJ,aAAa,EAAE;MAClBG,gBAAgB,GAAGQ,mBAAmB,CAACC,UAAU,GAAG3B,cAAc,CAACC,KAAK;IAC1E;IACA,IAAIwB,gBAAgB,EAAE;MACpB,MAAMT,2BAA2B,GAAG,IAAI,CAAC5C,GAAG,CAACC,OAAO,CAACF,aAAa,CAAC8C,qBAAqB,CAAC,CAAC,CAAC,CAAC;MAC5F,MAAMO,uBAAuB,GAAG,IAAI,CAAC5C,KAAK,CAACP,OAAO,CAACN,KAAK,CAACkD,qBAAqB,CAAC,CAAC,CAAC,CAAC;;MAElFE,cAAc,GAAGK,uBAAuB,CAACrB,GAAG,GAAG,CAAC,CAAC,GAAGa,2BAA2B,CAACb,GAAG;IACrF,CAAC,MAAM,IAAI,CAACW,aAAa,EAAE;MACzBK,cAAc,GAAGO,mBAAmB,CAACK,QAAQ,GAAG/B,cAAc,CAACG,GAAG;IACpE;IACA,OAAO;MACLF,KAAK,EAAEI,aAAa,CAACJ,KAAK,GAAGiB,gBAAgB;MAC7Cf,GAAG,EAAEE,aAAa,CAACF,GAAG,GAAGgB;IAC3B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEtC,SAASA,CAAA,EAAG;IACV,IAAI3B,WAAW,CAAC+E,OAAO,CAAC,IAAI,CAACrE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MACzC,MAAM,IAAIsE,KAAK,CAAC,eAAe,IAAI,CAACtE,IAAI,qBAAqB,CAAC;IAChE;IACA,MAAM;MACJS,OAAO;MACPR;IACF,CAAC,GAAG,IAAI,CAACO,GAAG;IACZ,MAAM;MACJ+D,YAAY;MACZhD;IACF,CAAC,GAAG,IAAI,CAACrB,WAAW;IACpB,MAAMc,KAAK,GAAGuD,YAAY,CAACC,aAAa,CAAC,KAAK,CAAC;IAC/C,MAAMC,WAAW,GAAGF,YAAY,CAACC,aAAa,CAAC,OAAO,CAAC;IACvD,MAAME,WAAW,GAAGjE,OAAO,CAACF,aAAa,CAACM,UAAU;IACpDG,KAAK,CAAC2D,SAAS,GAAG,GAAGpF,iBAAiB,CAACqF,GAAG,CAAC,IAAI,CAAC5E,IAAI,CAAC,eAAe;IACpEgB,KAAK,CAAC7B,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC2D,KAAK,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK,CAAC;IACvD9B,KAAK,CAAC6D,KAAK,CAACC,QAAQ,GAAG,UAAU;IACjC9D,KAAK,CAAC6D,KAAK,CAACtC,GAAG,GAAG,CAAC;IACnBvB,KAAK,CAAC6D,KAAK,CAACE,QAAQ,GAAG,SAAS;IAChC,IAAI,IAAI,CAACjC,KAAK,CAAC,CAAC,EAAE;MAChB9B,KAAK,CAAC6D,KAAK,CAACG,KAAK,GAAG,CAAC;IACvB,CAAC,MAAM;MACLhE,KAAK,CAAC6D,KAAK,CAACpB,IAAI,GAAG,CAAC;IACtB;IACA,IAAIxD,UAAU,CAACgC,UAAU,CAAC,UAAU,CAAC,EAAE;MACrC9C,YAAY,CAAC6B,KAAK,EAAE,CAACrB,iBAAiB,CAAC,CAAC,CAAC,CAAC;IAC5C;IACA8E,WAAW,CAACE,SAAS,GAAGlE,OAAO,CAACN,KAAK,CAACwE,SAAS;;IAE/C;IACA,MAAMM,aAAa,GAAGxE,OAAO,CAACN,KAAK,CAAC+E,YAAY,CAAC,MAAM,CAAC;IACxD,IAAID,aAAa,EAAE;MACjBR,WAAW,CAACtF,YAAY,CAAC,MAAM,EAAEsB,OAAO,CAACN,KAAK,CAAC+E,YAAY,CAAC,MAAM,CAAC,CAAC;IACtE;IACAlE,KAAK,CAACmE,WAAW,CAACV,WAAW,CAAC;IAC9BC,WAAW,CAACS,WAAW,CAACnE,KAAK,CAAC;IAC9B,MAAMoE,eAAe,GAAG,IAAI,CAACnF,UAAU,CAACgC,UAAU,CAAC,iBAAiB,CAAC;IACrE,IAAImD,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,YAAY,IAAI,IAAI,CAACpF,IAAI,KAAKR,SAAS,IAAI4F,eAAe,KAAK,UAAU,IAAI,IAAI,CAACpF,IAAI,KAAKP,kBAAkB,EAAE;MACjK,IAAI,CAACkB,0BAA0B,GAAGY,UAAU;IAC9C,CAAC,MAAM,IAAIA,UAAU,CAACC,gBAAgB,CAACkD,WAAW,CAAC,CAACjD,gBAAgB,CAAC,UAAU,CAAC,KAAK,QAAQ,EAAE;MAC7F,IAAI,CAACd,0BAA0B,GAAGF,OAAO,CAACH,MAAM;IAClD,CAAC,MAAM;MACL,IAAI,CAACK,0BAA0B,GAAG3B,oBAAoB,CAACyB,OAAO,CAACN,KAAK,CAAC;IACvE;;IAEA;IACA,OAAO,IAAIT,KAAK,CAAC+E,WAAW,EAAE,IAAI,CAACxE,UAAU,EAAE;MAC7C;MACAoF,MAAM,EAAE,IAAI,CAAC7E,GAAG;MAChB8E,OAAO,EAAE,IAAI;MACbC,QAAQ,EAAE,IAAI,CAAC/E,GAAG,CAACgF,UAAU;MAC7B;MACAC,KAAK,EAAE,IAAI,CAACjF,GAAG,CAACkF,OAAO;MACvB;MACAC,gBAAgB,EAAE,IAAI,CAACnF,GAAG,CAACmF,gBAAgB,CAAC;IAC9C,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAAA,EAAG;IACR,IAAIC,QAAQ,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;IACxF,IAAI,IAAI,CAAChF,cAAc,EAAE;MACvB,IAAI,CAACE,KAAK,CAACiF,IAAI,CAACJ,QAAQ,CAAC;IAC3B;EACF;;EAEA;AACF;AACA;EACEK,KAAKA,CAAA,EAAG;IACN,MAAM5F,MAAM,GAAG,IAAI,CAACU,KAAK,CAACP,OAAO,CAACH,MAAM,CAAC,CAAC;IAC1C,MAAMF,KAAK,GAAG,IAAI,CAACY,KAAK,CAACP,OAAO,CAACL,KAAK,CAAC,CAAC;IACxC,MAAM+F,WAAW,GAAG7F,MAAM,CAACuE,KAAK;IAChC,MAAMuB,UAAU,GAAGhG,KAAK,CAACyE,KAAK;IAC9B,MAAMwB,SAAS,GAAG/F,MAAM,CAACO,UAAU,CAACgE,KAAK;IACzC,CAACsB,WAAW,EAAEC,UAAU,EAAEC,SAAS,CAAC,CAACC,OAAO,CAACzB,KAAK,IAAI;MACpDA,KAAK,CAAClB,KAAK,GAAG,EAAE;MAChBkB,KAAK,CAAC0B,MAAM,GAAG,EAAE;IACnB,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;EACEzD,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAAC7C,UAAU,CAACgC,UAAU,CAAC,SAAS,CAAC;EAC9C;;EAEA;AACF;AACA;EACEuE,OAAOA,CAAA,EAAG;IACR,IAAI,CAACxF,KAAK,CAACyF,YAAY,CAACD,OAAO,CAAC,CAAC,CAAC,CAAC;EACrC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}