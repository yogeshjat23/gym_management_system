{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { addClass, clearTextSelection, empty, fastInnerHTML, fastInnerText, getScrollbarWidth, hasClass, isChildOf, isInput, isOutsideInput, isVisible, setAttribute, getParentWindow } from \"./helpers/dom/element.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isImmediatePropagationStopped, isRightClick, isLeftClick } from \"./helpers/dom/event.mjs\";\nimport Walkontable from \"./3rdparty/walkontable/src/index.mjs\";\nimport { handleMouseEvent } from \"./selection/mouseEventHandler.mjs\";\nimport { isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { A11Y_COLCOUNT, A11Y_MULTISELECTABLE, A11Y_PRESENTATION, A11Y_ROWCOUNT, A11Y_TREEGRID } from \"./helpers/a11y.mjs\";\n/**\n * @class TableView\n * @private\n */\nvar _columnHeadersCount = /*#__PURE__*/new WeakMap();\nvar _rowHeadersCount = /*#__PURE__*/new WeakMap();\nvar _selectionMouseDown = /*#__PURE__*/new WeakMap();\nvar _mouseDown = /*#__PURE__*/new WeakMap();\nvar _table = /*#__PURE__*/new WeakMap();\nvar _lastWidth = /*#__PURE__*/new WeakMap();\nvar _lastHeight = /*#__PURE__*/new WeakMap();\nvar _TableView_brand = /*#__PURE__*/new WeakSet();\nclass TableView {\n  /**\n   * @param {Hanstontable} hotInstance Instance of {@link Handsontable}.\n   */\n  constructor(hotInstance) {\n    /**\n     * Return the value of the `aria-colcount` attribute.\n     *\n     * @returns {number} The value of the `aria-colcount` attribute.\n     */\n    _classPrivateMethodInitSpec(this, _TableView_brand);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Current Handsontable's GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * Main <THEAD> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"THEAD\", void 0);\n    /**\n     * Main <TBODY> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"TBODY\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @private\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"_wt\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"activeWt\", void 0);\n    /**\n     * The total number of the column header renderers applied to the table through the\n     * `afterGetColumnHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnHeadersCount, 0);\n    /**\n     * The total number of the row header renderers applied to the table through the\n     * `afterGetRowHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _rowHeadersCount, 0);\n    /**\n     * The flag determines if the `adjustElementsSize` method call was made during\n     * the render suspending. If true, the method has to be triggered once after render\n     * resuming.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"postponedAdjustElementsSize\", false);\n    /**\n     * Defines if the text should be selected during mousemove.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _selectionMouseDown, false);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _mouseDown, void 0);\n    /**\n     * Main <TABLE> element.\n     *\n     * @type {HTMLTableElement}\n     */\n    _classPrivateFieldInitSpec(this, _table, void 0);\n    /**\n     * Cached width of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastWidth, 0);\n    /**\n     * Cached height of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastHeight, 0);\n    this.hot = hotInstance;\n    this.eventManager = new EventManager(this.hot);\n    this.settings = this.hot.getSettings();\n    this.createElements();\n    this.registerEvents();\n    this.initializeWalkontable();\n  }\n\n  /**\n   * Renders WalkontableUI.\n   */\n  render() {\n    if (!this.hot.isRenderSuspended()) {\n      this.hot.runHooks('beforeRender', this.hot.forceFullRender);\n      if (this.postponedAdjustElementsSize) {\n        this.postponedAdjustElementsSize = false;\n        this.adjustElementsSize(true);\n      }\n      this._wt.draw(!this.hot.forceFullRender);\n      this.hot.runHooks('afterRender', this.hot.forceFullRender);\n      this.hot.forceFullRender = false;\n      this.hot.renderCall = false;\n    }\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   */\n  adjustElementsSize() {\n    if (this.hot.isRenderSuspended()) {\n      this.postponedAdjustElementsSize = true;\n    } else {\n      this._wt.wtOverlays.adjustElementsSize();\n    }\n  }\n\n  /**\n   * Returns td object given coordinates.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.\n   * @returns {HTMLTableCellElement|null}\n   */\n  getCellAtCoords(coords, topmost) {\n    const td = this._wt.getCell(coords, topmost);\n    if (td < 0) {\n      // there was an exit code (cell is out of bounds)\n      return null;\n    }\n    return td;\n  }\n\n  /**\n   * Scroll viewport to a cell.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    return this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a column.\n   *\n   * @param {number} column Renderable column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    return this._wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a row.\n   *\n   * @param {number} row Renderable row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    return this._wt.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * Prepares DOMElements and adds correct className to the root element.\n   *\n   * @private\n   */\n  createElements() {\n    const {\n      rootElement,\n      rootDocument\n    } = this.hot;\n    const originalStyle = rootElement.getAttribute('style');\n    if (originalStyle) {\n      rootElement.setAttribute('data-originalstyle', originalStyle); // needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions\n    }\n    addClass(rootElement, 'handsontable');\n    _classPrivateFieldSet(_table, this, rootDocument.createElement('TABLE'));\n    addClass(_classPrivateFieldGet(_table, this), 'htCore');\n    if (this.hot.getSettings().tableClassName) {\n      addClass(_classPrivateFieldGet(_table, this), this.hot.getSettings().tableClassName);\n    }\n    if (this.settings.ariaTags) {\n      setAttribute(_classPrivateFieldGet(_table, this), [A11Y_PRESENTATION()]);\n      setAttribute(rootElement, [A11Y_TREEGRID(), A11Y_ROWCOUNT(-1), A11Y_COLCOUNT(this.hot.countCols()), A11Y_MULTISELECTABLE()]);\n    }\n    this.THEAD = rootDocument.createElement('THEAD');\n    _classPrivateFieldGet(_table, this).appendChild(this.THEAD);\n    this.TBODY = rootDocument.createElement('TBODY');\n    _classPrivateFieldGet(_table, this).appendChild(this.TBODY);\n    this.hot.table = _classPrivateFieldGet(_table, this);\n    this.hot.container.insertBefore(_classPrivateFieldGet(_table, this), this.hot.container.firstChild);\n  }\n\n  /**\n   * Attaches necessary listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      rootElement,\n      rootDocument,\n      selection,\n      rootWindow\n    } = this.hot;\n    const documentElement = rootDocument.documentElement;\n    this.eventManager.addEventListener(rootElement, 'mousedown', event => {\n      _classPrivateFieldSet(_selectionMouseDown, this, true);\n      if (!this.isTextSelectionAllowed(event.target)) {\n        clearTextSelection(rootWindow);\n        event.preventDefault();\n        rootWindow.focus(); // make sure that window that contains HOT is active. Important when HOT is in iframe.\n      }\n    });\n    this.eventManager.addEventListener(rootElement, 'mouseup', () => {\n      _classPrivateFieldSet(_selectionMouseDown, this, false);\n    });\n    this.eventManager.addEventListener(rootElement, 'mousemove', event => {\n      if (_classPrivateFieldGet(_selectionMouseDown, this) && !this.isTextSelectionAllowed(event.target)) {\n        // Clear selection only when fragmentSelection is enabled, otherwise clearing selection breaks the IME editor.\n        if (this.settings.fragmentSelection) {\n          clearTextSelection(rootWindow);\n        }\n        event.preventDefault();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'keyup', event => {\n      // TODO: is it the best place and way to finish cell selection?\n      if (selection.isInProgress() && !event.shiftKey) {\n        selection.finish();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'mouseup', event => {\n      if (selection.isInProgress() && isLeftClick(event)) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(_mouseDown, this, false);\n      const isOutsideInputElement = isOutsideInput(rootDocument.activeElement);\n      if (isInput(rootDocument.activeElement) && !isOutsideInputElement) {\n        return;\n      }\n      if (isOutsideInputElement || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event.target) && !isRightClick(event)) {\n        this.hot.unlisten();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'contextmenu', event => {\n      if (selection.isInProgress() && isRightClick(event)) {\n        selection.finish();\n        _classPrivateFieldSet(_mouseDown, this, false);\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'touchend', () => {\n      if (selection.isInProgress()) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(_mouseDown, this, false);\n    });\n    this.eventManager.addEventListener(documentElement, 'mousedown', event => {\n      const originalTarget = event.target;\n      const eventX = event.x || event.clientX;\n      const eventY = event.y || event.clientY;\n      let next = event.target;\n      if (_classPrivateFieldGet(_mouseDown, this) || !rootElement || !this.hot.view) {\n        return; // it must have been started in a cell\n      }\n\n      // immediate click on \"holder\" means click on the right side of vertical scrollbar\n      const {\n        holder\n      } = this._wt.wtTable;\n      if (next === holder) {\n        const scrollbarWidth = getScrollbarWidth(rootDocument);\n        if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder) {\n          return;\n        }\n      } else {\n        while (next !== documentElement) {\n          if (next === null) {\n            if (event.isTargetWebComponent) {\n              break;\n            }\n\n            // click on something that was a row but now is detached (possibly because your click triggered a rerender)\n            return;\n          }\n          if (next === rootElement) {\n            // click inside container\n            return;\n          }\n          next = next.parentNode;\n        }\n      }\n\n      // function did not return until here, we have an outside click!\n      const outsideClickDeselects = typeof this.settings.outsideClickDeselects === 'function' ? this.settings.outsideClickDeselects(originalTarget) : this.settings.outsideClickDeselects;\n      if (outsideClickDeselects) {\n        this.hot.deselectCell();\n      } else {\n        this.hot.destroyEditor(false, false);\n      }\n    });\n    let parentWindow = getParentWindow(rootWindow);\n    while (parentWindow !== null) {\n      this.eventManager.addEventListener(parentWindow.document.documentElement, 'click', () => {\n        this.hot.unlisten();\n      });\n      parentWindow = getParentWindow(parentWindow);\n    }\n    this.eventManager.addEventListener(_classPrivateFieldGet(_table, this), 'selectstart', event => {\n      if (this.settings.fragmentSelection || isInput(event.target)) {\n        return;\n      }\n      // https://github.com/handsontable/handsontable/issues/160\n      // Prevent text from being selected when performing drag down.\n      event.preventDefault();\n    });\n  }\n\n  /**\n   * Translate renderable cell coordinates to visual coordinates.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {CellCoords}\n   */\n  translateFromRenderableToVisualCoords(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    // TODO: To consider an idea to reusing the CellCoords instance instead creating new one.\n    return this.hot._createCellCoords(...this.translateFromRenderableToVisualIndex(row, col));\n  }\n\n  /**\n   * Translate renderable row and column indexes to visual row and column indexes.\n   *\n   * @param {number} renderableRow Renderable row index.\n   * @param {number} renderableColumn Renderable columnIndex.\n   * @returns {number[]}\n   */\n  translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {\n    // TODO: Some helper may be needed.\n    // We perform translation for indexes (without headers).\n    let visualRow = renderableRow >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;\n    let visualColumn = renderableColumn >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;\n    if (visualRow === null) {\n      visualRow = renderableRow;\n    }\n    if (visualColumn === null) {\n      visualColumn = renderableColumn;\n    }\n    return [visualRow, visualColumn];\n  }\n\n  /**\n   * Returns the number of renderable indexes.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} maxElements Maximum number of elements (rows or columns).\n   *\n   * @returns {number|*}\n   */\n  countRenderableIndexes(indexMapper, maxElements) {\n    const consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);\n    // Don't take hidden indexes into account. We are looking just for renderable indexes.\n    const firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);\n\n    // There are no renderable indexes.\n    if (firstNotHiddenIndex === null) {\n      return 0;\n    }\n    return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;\n  }\n\n  /**\n   * Returns the number of renderable columns.\n   *\n   * @returns {number}\n   */\n  countRenderableColumns() {\n    return this.countRenderableIndexes(this.hot.columnIndexMapper, this.settings.maxCols);\n  }\n\n  /**\n   * Returns the number of renderable rows.\n   *\n   * @returns {number}\n   */\n  countRenderableRows() {\n    return this.countRenderableIndexes(this.hot.rowIndexMapper, this.settings.maxRows);\n  }\n\n  /**\n   * Returns number of not hidden row indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenRowIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.rowIndexMapper, this.countRenderableRows());\n  }\n\n  /**\n   * Returns number of not hidden column indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenColumnIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.columnIndexMapper, this.countRenderableColumns());\n  }\n\n  /**\n   * Returns number of not hidden indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.\n   * @returns {number}\n   */\n  countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {\n    if (isNaN(visualIndex) || visualIndex < 0) {\n      return 0;\n    }\n    const firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);\n    const renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);\n    if (!Number.isInteger(renderableIndex)) {\n      return 0;\n    }\n    let notHiddenIndexes = 0;\n    if (incrementBy < 0) {\n      // Zero-based numbering for renderable indexes corresponds to a number of not hidden indexes.\n      notHiddenIndexes = renderableIndex + 1;\n    } else if (incrementBy > 0) {\n      notHiddenIndexes = renderableIndexesCount - renderableIndex;\n    }\n    return notHiddenIndexes;\n  }\n\n  /**\n   * The function returns the number of not hidden column indexes that fit between the first and\n   * last fixed column in the left (or right in RTL mode) overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedColumnsStart() {\n    const countCols = this.hot.countCols();\n    const visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;\n    return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the top overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsTop() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;\n    return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the bottom overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsBottom() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);\n    return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);\n  }\n\n  /**\n   * The function returns the number of renderable column indexes within the passed range of the visual indexes.\n   *\n   * @param {number} columnStart The column visual start index.\n   * @param {number} columnEnd The column visual end index.\n   * @returns {number}\n   */\n  countRenderableColumnsInRange(columnStart, columnEnd) {\n    let count = 0;\n    for (let column = columnStart; column <= columnEnd; column++) {\n      if (this.hot.columnIndexMapper.getRenderableFromVisualIndex(column) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * The function returns the number of renderable row indexes within the passed range of the visual indexes.\n   *\n   * @param {number} rowStart The row visual start index.\n   * @param {number} rowEnd The row visual end index.\n   * @returns {number}\n   */\n  countRenderableRowsInRange(rowStart, rowEnd) {\n    let count = 0;\n    for (let row = rowStart; row <= rowEnd; row++) {\n      if (this.hot.rowIndexMapper.getRenderableFromVisualIndex(row) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Checks if at least one cell than belongs to the main table is not covered by the top, left or\n   * bottom overlay.\n   *\n   * @returns {boolean}\n   */\n  isMainTableNotFullyCoveredByOverlays() {\n    const fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();\n    const fixedAllColumns = this.countNotHiddenFixedColumnsStart();\n    return this.hot.countRenderedRows() > fixedAllRows && this.hot.countRenderedCols() > fixedAllColumns;\n  }\n\n  /**\n   * Defines default configuration and initializes WalkOnTable instance.\n   *\n   * @private\n   */\n  initializeWalkontable() {\n    const walkontableConfig = {\n      ariaTags: this.settings.ariaTags,\n      rtlMode: this.hot.isRtl(),\n      externalRowCalculator: this.hot.getPlugin('autoRowSize') && this.hot.getPlugin('autoRowSize').isEnabled(),\n      table: _classPrivateFieldGet(_table, this),\n      isDataViewInstance: () => isRootInstance(this.hot),\n      preventOverflow: () => this.settings.preventOverflow,\n      preventWheel: () => this.settings.preventWheel,\n      stretchH: () => this.settings.stretchH,\n      data: (renderableRow, renderableColumn) => {\n        return this.hot.getDataAtCell(...this.translateFromRenderableToVisualIndex(renderableRow, renderableColumn));\n      },\n      totalRows: () => this.countRenderableRows(),\n      totalColumns: () => this.countRenderableColumns(),\n      // Number of renderable columns for the left overlay.\n      fixedColumnsStart: () => this.countNotHiddenFixedColumnsStart(),\n      // Number of renderable rows for the top overlay.\n      fixedRowsTop: () => this.countNotHiddenFixedRowsTop(),\n      // Number of renderable rows for the bottom overlay.\n      fixedRowsBottom: () => this.countNotHiddenFixedRowsBottom(),\n      // Enable the inline start overlay when conditions are met.\n      shouldRenderInlineStartOverlay: () => {\n        return this.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;\n      },\n      // Enable the top overlay when conditions are met.\n      shouldRenderTopOverlay: () => {\n        return this.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;\n      },\n      // Enable the bottom overlay when conditions are met.\n      shouldRenderBottomOverlay: () => {\n        return this.settings.fixedRowsBottom > 0;\n      },\n      minSpareRows: () => this.settings.minSpareRows,\n      renderAllRows: this.settings.renderAllRows,\n      renderAllColumns: this.settings.renderAllColumns,\n      rowHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasRowHeaders()) {\n          headerRenderers.push((renderableRowIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for row indexes (without row headers).\n            const visualRowIndex = renderableRowIndex >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n            this.appendRowHeader(visualRowIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetRowHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(_rowHeadersCount, this, headerRenderers.length);\n        if (this.hot.getSettings().ariaTags) {\n          // Update the aria-colcount attribute.\n          // Only needs to be done once after initialization/data update.\n          if (_assertClassBrand(_TableView_brand, this, _getAriaColcount).call(this) === this.hot.countCols()) {\n            _assertClassBrand(_TableView_brand, this, _updateAriaColcount).call(this, _classPrivateFieldGet(_rowHeadersCount, this));\n          }\n        }\n        return headerRenderers;\n      },\n      columnHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasColHeaders()) {\n          headerRenderers.push((renderedColumnIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for columns indexes (without column headers).\n            const visualColumnsIndex = renderedColumnIndex >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;\n            this.appendColHeader(visualColumnsIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetColumnHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(_columnHeadersCount, this, headerRenderers.length);\n        return headerRenderers;\n      },\n      columnWidth: renderedColumnIndex => {\n        const visualIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n\n        // It's not a bug that we can't find visual index for some handled by method indexes. The function is called also\n        // for indexes that are not displayed (indexes that are beyond the grid's boundaries), i.e. when `fixedColumnsStart` > `startCols` (wrong config?) or\n        // scrolling and dataset is empty (scroll should handle that?).\n        return this.hot.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);\n      },\n      rowHeight: renderedRowIndex => {\n        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\n        return this.hot.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);\n      },\n      rowHeightByOverlayName: (renderedRowIndex, overlayType) => {\n        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\n        const visualRowIndex = visualIndex === null ? renderedRowIndex : visualIndex;\n        return this.hot.runHooks('modifyRowHeightByOverlayName', this.hot.getRowHeight(visualRowIndex), visualRowIndex, overlayType);\n      },\n      cellRenderer: (renderedRowIndex, renderedColumnIndex, TD) => {\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex);\n\n        // Coords may be modified. For example, by the `MergeCells` plugin. It should affect cell value and cell meta.\n        const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex);\n        let visualRowToCheck = visualRowIndex;\n        let visualColumnToCheck = visualColumnIndex;\n        if (Array.isArray(modifiedCellCoords)) {\n          [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n        }\n        const cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n        const prop = this.hot.colToProp(visualColumnToCheck);\n        let value = this.hot.getDataAtRowProp(visualRowToCheck, prop);\n        if (this.hot.hasHook('beforeValueRender')) {\n          value = this.hot.runHooks('beforeValueRender', value, cellProperties);\n        }\n        this.hot.runHooks('beforeRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.getCellRenderer(cellProperties)(this.hot, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.runHooks('afterRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n      },\n      selections: this.hot.selection.highlight,\n      hideBorderOnMouseDownOver: () => this.settings.fragmentSelection,\n      onWindowResize: () => {\n        if (this.hot && !this.hot.isDestroyed) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onContainerElementResize: () => {\n        if (this.hot && !this.hot.isDestroyed && isVisible(this.hot.rootElement)) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onCellMouseDown: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.hot.listen();\n        this.activeWt = wt;\n        _classPrivateFieldSet(_mouseDown, this, true);\n        this.hot.runHooks('beforeOnCellMouseDown', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        handleMouseEvent(event, {\n          coords: visualCoords,\n          selection: this.hot.selection,\n          controller,\n          cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n        });\n        this.hot.runHooks('afterOnCellMouseDown', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellContextMenu: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        _classPrivateFieldSet(_mouseDown, this, false);\n        if (this.hot.selection.isInProgress()) {\n          this.hot.selection.finish();\n        }\n        this.hot.runHooks('beforeOnCellContextMenu', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellContextMenu', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOut: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOut', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseOut', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOver: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOver', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        if (_classPrivateFieldGet(_mouseDown, this)) {\n          handleMouseEvent(event, {\n            coords: visualCoords,\n            selection: this.hot.selection,\n            controller,\n            cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n          });\n        }\n        this.hot.runHooks('afterOnCellMouseOver', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseUp: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseUp', event, visualCoords, TD);\n\n        // TODO: The second condition check is a workaround. Callback corresponding the method `updateSettings`\n        // disable plugin and enable it again. Disabling plugin closes the menu. Thus, calling the\n        // `updateSettings` in a body of any callback executed right after some context-menu action\n        // breaks the table (#7231).\n        if (isImmediatePropagationStopped(event) || this.hot.isDestroyed) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseUp', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellCornerMouseDown: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerMouseDown', event);\n      },\n      onCellCornerDblClick: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerDblClick', event);\n      },\n      beforeDraw: (force, skipRender) => this.beforeRender(force, skipRender),\n      onDraw: force => this.afterRender(force),\n      onBeforeViewportScrollVertically: renderableRow => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n\n          // for an empty data return index as is\n          if (visualRow === null) {\n            return renderableRow;\n          }\n        }\n        visualRow = this.hot.runHooks('beforeViewportScrollVertically', visualRow);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(visualRow);\n        }\n        return visualRow;\n      },\n      onBeforeViewportScrollHorizontally: renderableColumn => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n\n          // for an empty data return index as is\n          if (visualColumn === null) {\n            return renderableColumn;\n          }\n        }\n        visualColumn = this.hot.runHooks('beforeViewportScrollHorizontally', visualColumn);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(visualColumn);\n        }\n        return visualColumn;\n      },\n      onScrollVertically: () => {\n        this.hot.runHooks('afterScrollVertically');\n        this.hot.runHooks('afterScroll');\n      },\n      onScrollHorizontally: () => {\n        this.hot.runHooks('afterScrollHorizontally');\n        this.hot.runHooks('afterScroll');\n      },\n      onBeforeRemoveCellClassNames: () => this.hot.runHooks('beforeRemoveCellClassNames'),\n      onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n        }\n        const newVisualRow = this.hot.runHooks('beforeHighlightingRowHeader', visualRow, headerLevel, highlightMeta);\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));\n        }\n        return newVisualRow;\n      },\n      onBeforeHighlightingColumnHeader: (renderableColumn, headerLevel, highlightMeta) => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n        }\n        const newVisualColumn = this.hot.runHooks('beforeHighlightingColumnHeader', visualColumn, headerLevel, highlightMeta);\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));\n        }\n        return newVisualColumn;\n      },\n      onAfterDrawSelection: (currentRow, currentColumn, layerLevel) => {\n        let cornersOfSelection;\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(currentRow, currentColumn);\n        const selectedRange = this.hot.selection.getSelectedRange();\n        const selectionRangeSize = selectedRange.size();\n        if (selectionRangeSize > 0) {\n          const selectionForLayer = selectedRange.peekByIndex(layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0);\n          cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];\n        }\n        return this.hot.runHooks('afterDrawSelection', visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);\n      },\n      onBeforeDrawBorders: (corners, borderClassName) => {\n        const [startRenderableRow, startRenderableColumn, endRenderableRow, endRenderableColumn] = corners;\n        const visualCorners = [this.hot.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), this.hot.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];\n        return this.hot.runHooks('beforeDrawBorders', visualCorners, borderClassName);\n      },\n      onBeforeTouchScroll: () => this.hot.runHooks('beforeTouchScroll'),\n      onAfterMomentumScroll: () => this.hot.runHooks('afterMomentumScroll'),\n      onBeforeStretchingColumnWidth: (stretchedWidth, renderedColumnIndex) => {\n        const visualColumnIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n        return this.hot.runHooks('beforeStretchingColumnWidth', stretchedWidth, visualColumnIndex);\n      },\n      onModifyRowHeaderWidth: rowHeaderWidth => this.hot.runHooks('modifyRowHeaderWidth', rowHeaderWidth),\n      onModifyGetCellCoords: (renderableRowIndex, renderableColumnIndex, topmost) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const columnMapper = this.hot.columnIndexMapper;\n\n        // Callback handle also headers. We shouldn't translate them.\n        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;\n        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n        const visualIndexes = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex, topmost);\n        if (Array.isArray(visualIndexes)) {\n          const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = visualIndexes;\n\n          // Result of the hook is handled by the Walkontable (renderable indexes).\n          return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];\n        }\n      },\n      viewportRowCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportRowRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedRowsTop) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableRows = this.countRenderableRows();\n          const firstRenderedRow = calc.startRow;\n          const lastRenderedRow = calc.endRow;\n          if (typeof viewportOffset === 'number') {\n            calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);\n            calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);\n          } else if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedRow / renderableRows * 12);\n            calc.startRow = Math.max(firstRenderedRow - offset, 0);\n            calc.endRow = Math.min(lastRenderedRow + offset, renderableRows - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportRowCalculatorOverride', calc);\n      },\n      viewportColumnCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportColumnRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedColumnsStart) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableColumns = this.countRenderableColumns();\n          const firstRenderedColumn = calc.startColumn;\n          const lastRenderedColumn = calc.endColumn;\n          if (typeof viewportOffset === 'number') {\n            calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);\n          }\n          if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedColumn / renderableColumns * 6);\n            calc.startColumn = Math.max(firstRenderedColumn - offset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + offset, renderableColumns - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportColumnCalculatorOverride', calc);\n      },\n      rowHeaderWidth: () => this.settings.rowHeaderWidth,\n      columnHeaderHeight: () => {\n        const columnHeaderHeight = this.hot.runHooks('modifyColumnHeaderHeight');\n        return this.settings.columnHeaderHeight || columnHeaderHeight;\n      }\n    };\n    this.hot.runHooks('beforeInitWalkontable', walkontableConfig);\n    this._wt = new Walkontable(walkontableConfig);\n    this.activeWt = this._wt;\n    const spreader = this._wt.wtTable.spreader;\n    // We have to cache width and height after Walkontable initialization.\n    const {\n      width,\n      height\n    } = this.hot.rootElement.getBoundingClientRect();\n    this.setLastSize(width, height);\n    this.eventManager.addEventListener(spreader, 'mousedown', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(spreader, 'contextmenu', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'click', () => {\n      if (this.settings.observeDOMVisibility) {\n        if (this._wt.drawInterrupted) {\n          this.hot.forceFullRender = true;\n          this.render();\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks if it's possible to create text selection in element.\n   *\n   * @private\n   * @param {HTMLElement} el The element to check.\n   * @returns {boolean}\n   */\n  isTextSelectionAllowed(el) {\n    if (isInput(el)) {\n      return true;\n    }\n    const isChildOfTableBody = isChildOf(el, this._wt.wtTable.spreader);\n    if (this.settings.fragmentSelection === true && isChildOfTableBody) {\n      return true;\n    }\n    if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {\n      return true;\n    }\n    if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks if user's been called mousedown.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isMouseDown() {\n    return _classPrivateFieldGet(_mouseDown, this);\n  }\n\n  /**\n   * Check if selected only one cell.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isSelectedOnlyCell() {\n    var _this$hot$getSelected, _this$hot$getSelected2;\n    return (_this$hot$getSelected = (_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.isSingleCell()) !== null && _this$hot$getSelected !== void 0 ? _this$hot$getSelected : false;\n  }\n\n  /**\n   * Checks if active cell is editing.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEdited() {\n    const activeEditor = this.hot.getActiveEditor();\n    return activeEditor && activeEditor.isOpened();\n  }\n\n  /**\n   * `beforeDraw` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering\n   *                            cycle will be skipped.\n   */\n  beforeRender(force, skipRender) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('beforeViewRender', this.hot.forceFullRender, skipRender);\n    }\n  }\n\n  /**\n   * `afterRender` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   */\n  afterRender(force) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('afterViewRender', this.hot.forceFullRender);\n    }\n  }\n\n  /**\n   * Append row header to a TH element.\n   *\n   * @private\n   * @param {number} visualRowIndex The visual row index.\n   * @param {HTMLTableHeaderCellElement} TH The table header element.\n   */\n  appendRowHeader(visualRowIndex, TH) {\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (!hasClass(container, 'relative')) {\n        empty(TH);\n        this.appendRowHeader(visualRowIndex, TH);\n        return;\n      }\n      this.updateCellHeader(container.querySelector('.rowHeader'), visualRowIndex, this.hot.getRowHeader);\n    } else {\n      const {\n        rootDocument,\n        getRowHeader\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      div.className = 'relative';\n      span.className = 'rowHeader';\n      this.updateCellHeader(span, visualRowIndex, getRowHeader);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetRowHeader', visualRowIndex, TH);\n  }\n\n  /**\n   * Append column header to a TH element.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {HTMLTableCellElement} TH The table header element.\n   * @param {Function} [label] The function that returns the header label.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  appendColHeader(visualColumnIndex, TH) {\n    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hot.getColHeader;\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const getColumnHeaderClassNames = () => {\n      const metaHeaderClassNames = visualColumnIndex >= 0 ? this.hot.getColumnMeta(visualColumnIndex).headerClassName : null;\n      return metaHeaderClassNames ? metaHeaderClassNames.split(' ') : [];\n    };\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (hasClass(container, 'relative')) {\n        this.updateCellHeader(container.querySelector('.colHeader'), visualColumnIndex, label, headerLevel);\n        container.className = '';\n        addClass(container, ['relative', ...getColumnHeaderClassNames()]);\n      } else {\n        empty(TH);\n        this.appendColHeader(visualColumnIndex, TH, label, headerLevel);\n      }\n    } else {\n      const {\n        rootDocument\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      const classNames = getColumnHeaderClassNames();\n      div.classList.add('relative', ...classNames);\n      span.className = 'colHeader';\n      if (this.settings.ariaTags) {\n        setAttribute(div, ...A11Y_PRESENTATION());\n        setAttribute(span, ...A11Y_PRESENTATION());\n      }\n      this.updateCellHeader(span, visualColumnIndex, label, headerLevel);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetColHeader', visualColumnIndex, TH, headerLevel);\n  }\n\n  /**\n   * Updates header cell content.\n   *\n   * @private\n   * @param {HTMLElement} element Element to update.\n   * @param {number} index Row index or column index.\n   * @param {Function} content Function which should be returns content for this cell.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  updateCellHeader(element, index, content) {\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let renderedIndex = index;\n    const parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;\n\n    // prevent wrong calculations from SampleGenerator\n    if (element.parentNode) {\n      if (hasClass(element, 'colHeader')) {\n        renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);\n      } else if (hasClass(element, 'rowHeader')) {\n        renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);\n      }\n    }\n    if (renderedIndex > -1) {\n      fastInnerHTML(element, content(index, headerLevel));\n    } else {\n      // workaround for https://github.com/handsontable/handsontable/issues/1946\n      fastInnerText(element, String.fromCharCode(160));\n      addClass(element, 'cornerHeader');\n    }\n  }\n\n  /**\n   * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum\n   * element width until the right (or left) edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} inlineOffset The left (or right in RTL mode) offset.\n   * @returns {number}\n   */\n  maximumVisibleElementWidth(inlineOffset) {\n    const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();\n    const maxWidth = workspaceWidth - inlineOffset;\n    return maxWidth > 0 ? maxWidth : 0;\n  }\n\n  /**\n   * Given a element's top position relative to the viewport, returns maximum element height until the bottom\n   * edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} topOffset The top offset.\n   * @returns {number}\n   */\n  maximumVisibleElementHeight(topOffset) {\n    const workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();\n    const maxHeight = workspaceHeight - topOffset;\n    return maxHeight > 0 ? maxHeight : 0;\n  }\n\n  /**\n   * Sets new dimensions of the container.\n   *\n   * @param {number} width The table width.\n   * @param {number} height The table height.\n   */\n  setLastSize(width, height) {\n    _classPrivateFieldSet(_lastWidth, this, width);\n    _classPrivateFieldSet(_lastHeight, this, height);\n  }\n\n  /**\n   * Returns cached dimensions.\n   *\n   * @returns {object}\n   */\n  getLastSize() {\n    return {\n      width: _classPrivateFieldGet(_lastWidth, this),\n      height: _classPrivateFieldGet(_lastHeight, this)\n    };\n  }\n\n  /**\n   * Returns the first rendered row in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getFirstRenderedVisibleRow() {\n    if (!this._wt.wtViewport.rowsRenderCalculator) {\n      return null;\n    }\n    return this.hot.rowIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getFirstRenderedRow(), 1);\n  }\n\n  /**\n   * Returns the last rendered row in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getLastRenderedVisibleRow() {\n    if (!this._wt.wtViewport.rowsRenderCalculator) {\n      return null;\n    }\n    return this.hot.rowIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getLastRenderedRow(), -1);\n  }\n\n  /**\n   * Returns the first rendered column in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getFirstRenderedVisibleColumn() {\n    if (!this._wt.wtViewport.columnsRenderCalculator) {\n      return null;\n    }\n    return this.hot.columnIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getFirstRenderedColumn(), 1);\n  }\n\n  /**\n   * Returns the last rendered column in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getLastRenderedVisibleColumn() {\n    if (!this._wt.wtViewport.columnsRenderCalculator) {\n      return null;\n    }\n    return this.hot.columnIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getLastRenderedColumn(), -1);\n  }\n\n  /**\n   * Returns the first fully visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstVisibleRow());\n  }\n\n  /**\n   * Returns the last fully visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastVisibleRow());\n  }\n\n  /**\n   * Returns the first fully visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstVisibleColumn());\n  }\n\n  /**\n   * Returns the last fully visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastVisibleColumn());\n  }\n\n  /**\n   * Returns the first partially visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstPartiallyVisibleRow());\n  }\n\n  /**\n   * Returns the last partially visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastPartiallyVisibleRow());\n  }\n\n  /**\n   * Returns the first partially visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstPartiallyVisibleColumn());\n  }\n\n  /**\n   * Returns the last partially visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastPartiallyVisibleColumn());\n  }\n\n  /**\n   * Returns the total count of the rendered column headers.\n   *\n   * @returns {number}\n   */\n  getColumnHeadersCount() {\n    return _classPrivateFieldGet(_columnHeadersCount, this);\n  }\n\n  /**\n   * Returns the total count of the rendered row headers.\n   *\n   * @returns {number}\n   */\n  getRowHeadersCount() {\n    return _classPrivateFieldGet(_rowHeadersCount, this);\n  }\n\n  /**\n   * Returns the table's viewport width. When the table has defined the size of the container,\n   * and the columns do not fill the entire viewport, the viewport width is equal to the sum of\n   * the columns' widths.\n   *\n   * @returns {number}\n   */\n  getViewportWidth() {\n    return this._wt.wtViewport.getViewportWidth();\n  }\n\n  /**\n   * Returns the table's total width including the scrollbar width.\n   *\n   * @returns {number}\n   */\n  getWorkspaceWidth() {\n    return this._wt.wtViewport.getWorkspaceWidth();\n  }\n\n  /**\n   * Returns the table's viewport height. When the table has defined the size of the container,\n   * and the rows do not fill the entire viewport, the viewport height is equal to the sum of\n   * the rows' heights.\n   *\n   * @returns {number}\n   */\n  getViewportHeight() {\n    return this._wt.wtViewport.getViewportHeight();\n  }\n\n  /**\n   * Returns the table's total height including the scrollbar height.\n   *\n   * @returns {number}\n   */\n  getWorkspaceHeight() {\n    return this._wt.wtViewport.getWorkspaceHeight();\n  }\n\n  /**\n   * Checks to what overlay the provided element belongs.\n   *\n   * @param {HTMLElement} element The DOM element to check.\n   * @returns {'master'|'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'}\n   */\n  getElementOverlayName(element) {\n    var _this$_wt$wtOverlays$;\n    return ((_this$_wt$wtOverlays$ = this._wt.wtOverlays.getParentOverlay(element)) !== null && _this$_wt$wtOverlays$ !== void 0 ? _this$_wt$wtOverlays$ : this._wt).wtTable.name;\n  }\n\n  /**\n   * Gets the overlay instance by its name.\n   *\n   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'} overlayName The overlay name.\n   * @returns {Overlay | null}\n   */\n  getOverlayByName(overlayName) {\n    return this._wt.getOverlayByName(overlayName);\n  }\n\n  /**\n   * Checks if the table is visible or not.\n   *\n   * @returns {boolean}\n   */\n  isVisible() {\n    return this._wt.wtTable.isVisible();\n  }\n  /**\n   * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.\n   *\n   * @private\n   */\n  destroy() {\n    this._wt.destroy();\n    this.eventManager.destroy();\n  }\n}\nfunction _getAriaColcount() {\n  return parseInt(this.hot.rootElement.getAttribute(A11Y_COLCOUNT()[0]), 10);\n}\n/**\n * Update the `aria-colcount` attribute by the provided value.\n *\n * @param {number} delta The number of columns to add or remove to the aria tag.\n */\nfunction _updateAriaColcount(delta) {\n  const colCount = _assertClassBrand(_TableView_brand, this, _getAriaColcount).call(this) + delta;\n  setAttribute(this.hot.rootElement, ...A11Y_COLCOUNT(colCount));\n}\nexport default TableView;","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","n","arguments","length","addClass","clearTextSelection","empty","fastInnerHTML","fastInnerText","getScrollbarWidth","hasClass","isChildOf","isInput","isOutsideInput","isVisible","setAttribute","getParentWindow","EventManager","isImmediatePropagationStopped","isRightClick","isLeftClick","Walkontable","handleMouseEvent","isRootInstance","A11Y_COLCOUNT","A11Y_MULTISELECTABLE","A11Y_PRESENTATION","A11Y_ROWCOUNT","A11Y_TREEGRID","_columnHeadersCount","WeakMap","_rowHeadersCount","_selectionMouseDown","_mouseDown","_table","_lastWidth","_lastHeight","_TableView_brand","WeakSet","TableView","constructor","hotInstance","hot","eventManager","settings","getSettings","createElements","registerEvents","initializeWalkontable","render","isRenderSuspended","runHooks","forceFullRender","postponedAdjustElementsSize","adjustElementsSize","_wt","draw","renderCall","wtOverlays","getCellAtCoords","coords","topmost","td","getCell","scrollViewport","snapToTop","snapToRight","snapToBottom","snapToLeft","scrollViewportHorizontally","column","scrollViewportVertically","row","rootElement","rootDocument","originalStyle","getAttribute","createElement","tableClassName","ariaTags","countCols","THEAD","appendChild","TBODY","table","container","insertBefore","firstChild","selection","rootWindow","documentElement","addEventListener","event","isTextSelectionAllowed","target","preventDefault","focus","fragmentSelection","isInProgress","shiftKey","finish","isOutsideInputElement","activeElement","isSelected","isSelectedByAnyHeader","contains","unlisten","originalTarget","eventX","x","clientX","eventY","y","clientY","next","view","holder","wtTable","scrollbarWidth","elementFromPoint","isTargetWebComponent","parentNode","outsideClickDeselects","deselectCell","destroyEditor","parentWindow","document","translateFromRenderableToVisualCoords","_ref","col","_createCellCoords","translateFromRenderableToVisualIndex","renderableRow","renderableColumn","visualRow","rowIndexMapper","getVisualFromRenderableIndex","visualColumn","columnIndexMapper","countRenderableIndexes","indexMapper","maxElements","consideredElements","Math","min","getNotTrimmedIndexesLength","firstNotHiddenIndex","getNearestNotHiddenIndex","getRenderableFromVisualIndex","countRenderableColumns","maxCols","countRenderableRows","maxRows","countNotHiddenRowIndexes","visualIndex","incrementBy","countNotHiddenIndexes","countNotHiddenColumnIndexes","renderableIndexesCount","isNaN","firstVisibleIndex","renderableIndex","isInteger","notHiddenIndexes","countNotHiddenFixedColumnsStart","visualFixedColumnsStart","parseInt","fixedColumnsStart","countNotHiddenFixedRowsTop","countRows","visualFixedRowsTop","fixedRowsTop","countNotHiddenFixedRowsBottom","visualFixedRowsBottom","max","fixedRowsBottom","countRenderableColumnsInRange","columnStart","columnEnd","count","countRenderableRowsInRange","rowStart","rowEnd","isMainTableNotFullyCoveredByOverlays","fixedAllRows","fixedAllColumns","countRenderedRows","countRenderedCols","walkontableConfig","rtlMode","isRtl","externalRowCalculator","getPlugin","isEnabled","isDataViewInstance","preventOverflow","preventWheel","stretchH","data","getDataAtCell","totalRows","totalColumns","shouldRenderInlineStartOverlay","rowHeaders","shouldRenderTopOverlay","columnHeaders","shouldRenderBottomOverlay","minSpareRows","renderAllRows","renderAllColumns","headerRenderers","hasRowHeaders","push","renderableRowIndex","TH","visualRowIndex","appendRowHeader","_getAriaColcount","_updateAriaColcount","hasColHeaders","renderedColumnIndex","visualColumnsIndex","appendColHeader","columnWidth","getColWidth","rowHeight","renderedRowIndex","getRowHeight","rowHeightByOverlayName","overlayType","cellRenderer","TD","visualColumnIndex","modifiedCellCoords","visualRowToCheck","visualColumnToCheck","Array","isArray","cellProperties","getCellMeta","prop","colToProp","getDataAtRowProp","hasHook","getCellRenderer","selections","highlight","hideBorderOnMouseDownOver","onWindowResize","isDestroyed","refreshDimensions","onContainerElementResize","onCellMouseDown","wt","visualCoords","controller","cell","listen","activeWt","cellCoordsFactory","onCellContextMenu","onCellMouseOut","onCellMouseOver","onCellMouseUp","onCellCornerMouseDown","onCellCornerDblClick","beforeDraw","force","skipRender","beforeRender","onDraw","afterRender","onBeforeViewportScrollVertically","rowMapper","areColumnHeadersSelected","onBeforeViewportScrollHorizontally","columnMapper","areRowHeadersSelected","onScrollVertically","onScrollHorizontally","onBeforeRemoveCellClassNames","onBeforeHighlightingRowHeader","headerLevel","highlightMeta","newVisualRow","onBeforeHighlightingColumnHeader","newVisualColumn","onAfterDrawSelection","currentRow","currentColumn","layerLevel","cornersOfSelection","selectedRange","getSelectedRange","selectionRangeSize","size","selectionForLayer","peekByIndex","from","to","onBeforeDrawBorders","corners","borderClassName","startRenderableRow","startRenderableColumn","endRenderableRow","endRenderableColumn","visualCorners","onBeforeTouchScroll","onAfterMomentumScroll","onBeforeStretchingColumnWidth","stretchedWidth","onModifyRowHeaderWidth","rowHeaderWidth","onModifyGetCellCoords","renderableColumnIndex","visualIndexes","visualRowFrom","visualColumnFrom","visualRowTo","visualColumnTo","viewportRowCalculatorOverride","calc","viewportOffset","viewportRowRenderingOffset","renderableRows","firstRenderedRow","startRow","lastRenderedRow","endRow","offset","ceil","viewportColumnCalculatorOverride","viewportColumnRenderingOffset","renderableColumns","firstRenderedColumn","startColumn","lastRenderedColumn","endColumn","columnHeaderHeight","spreader","width","height","getBoundingClientRect","setLastSize","which","stopPropagation","observeDOMVisibility","drawInterrupted","el","isChildOfTableBody","isSelectedOnlyCell","isCellEdited","isMouseDown","_this$hot$getSelected","_this$hot$getSelected2","getSelectedRangeLast","isSingleCell","activeEditor","getActiveEditor","isOpened","updateCellHeader","querySelector","getRowHeader","div","span","className","label","undefined","getColHeader","getColumnHeaderClassNames","metaHeaderClassNames","getColumnMeta","headerClassName","split","classNames","classList","element","index","content","renderedIndex","parentOverlay","getParentOverlay","columnFilter","sourceToRendered","rowFilter","fromCharCode","maximumVisibleElementWidth","inlineOffset","workspaceWidth","wtViewport","getWorkspaceWidth","maxWidth","maximumVisibleElementHeight","topOffset","workspaceHeight","getWorkspaceHeight","maxHeight","getLastSize","getFirstRenderedVisibleRow","rowsRenderCalculator","getFirstRenderedRow","getLastRenderedVisibleRow","getLastRenderedRow","getFirstRenderedVisibleColumn","columnsRenderCalculator","getFirstRenderedColumn","getLastRenderedVisibleColumn","getLastRenderedColumn","getFirstFullyVisibleRow","wtScroll","getFirstVisibleRow","getLastFullyVisibleRow","getLastVisibleRow","getFirstFullyVisibleColumn","getFirstVisibleColumn","getLastFullyVisibleColumn","getLastVisibleColumn","getFirstPartiallyVisibleRow","getLastPartiallyVisibleRow","getFirstPartiallyVisibleColumn","getLastPartiallyVisibleColumn","getColumnHeadersCount","getRowHeadersCount","getViewportWidth","getViewportHeight","getElementOverlayName","_this$_wt$wtOverlays$","name","getOverlayByName","overlayName","destroy","delta","colCount"],"sources":["D:/gym-project/frontend/node_modules/handsontable/tableView.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { addClass, clearTextSelection, empty, fastInnerHTML, fastInnerText, getScrollbarWidth, hasClass, isChildOf, isInput, isOutsideInput, isVisible, setAttribute, getParentWindow } from \"./helpers/dom/element.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isImmediatePropagationStopped, isRightClick, isLeftClick } from \"./helpers/dom/event.mjs\";\nimport Walkontable from \"./3rdparty/walkontable/src/index.mjs\";\nimport { handleMouseEvent } from \"./selection/mouseEventHandler.mjs\";\nimport { isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { A11Y_COLCOUNT, A11Y_MULTISELECTABLE, A11Y_PRESENTATION, A11Y_ROWCOUNT, A11Y_TREEGRID } from \"./helpers/a11y.mjs\";\n/**\n * @class TableView\n * @private\n */\nvar _columnHeadersCount = /*#__PURE__*/new WeakMap();\nvar _rowHeadersCount = /*#__PURE__*/new WeakMap();\nvar _selectionMouseDown = /*#__PURE__*/new WeakMap();\nvar _mouseDown = /*#__PURE__*/new WeakMap();\nvar _table = /*#__PURE__*/new WeakMap();\nvar _lastWidth = /*#__PURE__*/new WeakMap();\nvar _lastHeight = /*#__PURE__*/new WeakMap();\nvar _TableView_brand = /*#__PURE__*/new WeakSet();\nclass TableView {\n  /**\n   * @param {Hanstontable} hotInstance Instance of {@link Handsontable}.\n   */\n  constructor(hotInstance) {\n    /**\n     * Return the value of the `aria-colcount` attribute.\n     *\n     * @returns {number} The value of the `aria-colcount` attribute.\n     */\n    _classPrivateMethodInitSpec(this, _TableView_brand);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Current Handsontable's GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * Main <THEAD> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"THEAD\", void 0);\n    /**\n     * Main <TBODY> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"TBODY\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @private\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"_wt\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"activeWt\", void 0);\n    /**\n     * The total number of the column header renderers applied to the table through the\n     * `afterGetColumnHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnHeadersCount, 0);\n    /**\n     * The total number of the row header renderers applied to the table through the\n     * `afterGetRowHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _rowHeadersCount, 0);\n    /**\n     * The flag determines if the `adjustElementsSize` method call was made during\n     * the render suspending. If true, the method has to be triggered once after render\n     * resuming.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"postponedAdjustElementsSize\", false);\n    /**\n     * Defines if the text should be selected during mousemove.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _selectionMouseDown, false);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _mouseDown, void 0);\n    /**\n     * Main <TABLE> element.\n     *\n     * @type {HTMLTableElement}\n     */\n    _classPrivateFieldInitSpec(this, _table, void 0);\n    /**\n     * Cached width of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastWidth, 0);\n    /**\n     * Cached height of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastHeight, 0);\n    this.hot = hotInstance;\n    this.eventManager = new EventManager(this.hot);\n    this.settings = this.hot.getSettings();\n    this.createElements();\n    this.registerEvents();\n    this.initializeWalkontable();\n  }\n\n  /**\n   * Renders WalkontableUI.\n   */\n  render() {\n    if (!this.hot.isRenderSuspended()) {\n      this.hot.runHooks('beforeRender', this.hot.forceFullRender);\n      if (this.postponedAdjustElementsSize) {\n        this.postponedAdjustElementsSize = false;\n        this.adjustElementsSize(true);\n      }\n      this._wt.draw(!this.hot.forceFullRender);\n      this.hot.runHooks('afterRender', this.hot.forceFullRender);\n      this.hot.forceFullRender = false;\n      this.hot.renderCall = false;\n    }\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   */\n  adjustElementsSize() {\n    if (this.hot.isRenderSuspended()) {\n      this.postponedAdjustElementsSize = true;\n    } else {\n      this._wt.wtOverlays.adjustElementsSize();\n    }\n  }\n\n  /**\n   * Returns td object given coordinates.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.\n   * @returns {HTMLTableCellElement|null}\n   */\n  getCellAtCoords(coords, topmost) {\n    const td = this._wt.getCell(coords, topmost);\n    if (td < 0) {\n      // there was an exit code (cell is out of bounds)\n      return null;\n    }\n    return td;\n  }\n\n  /**\n   * Scroll viewport to a cell.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    return this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a column.\n   *\n   * @param {number} column Renderable column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    return this._wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a row.\n   *\n   * @param {number} row Renderable row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    return this._wt.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * Prepares DOMElements and adds correct className to the root element.\n   *\n   * @private\n   */\n  createElements() {\n    const {\n      rootElement,\n      rootDocument\n    } = this.hot;\n    const originalStyle = rootElement.getAttribute('style');\n    if (originalStyle) {\n      rootElement.setAttribute('data-originalstyle', originalStyle); // needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions\n    }\n    addClass(rootElement, 'handsontable');\n    _classPrivateFieldSet(_table, this, rootDocument.createElement('TABLE'));\n    addClass(_classPrivateFieldGet(_table, this), 'htCore');\n    if (this.hot.getSettings().tableClassName) {\n      addClass(_classPrivateFieldGet(_table, this), this.hot.getSettings().tableClassName);\n    }\n    if (this.settings.ariaTags) {\n      setAttribute(_classPrivateFieldGet(_table, this), [A11Y_PRESENTATION()]);\n      setAttribute(rootElement, [A11Y_TREEGRID(), A11Y_ROWCOUNT(-1), A11Y_COLCOUNT(this.hot.countCols()), A11Y_MULTISELECTABLE()]);\n    }\n    this.THEAD = rootDocument.createElement('THEAD');\n    _classPrivateFieldGet(_table, this).appendChild(this.THEAD);\n    this.TBODY = rootDocument.createElement('TBODY');\n    _classPrivateFieldGet(_table, this).appendChild(this.TBODY);\n    this.hot.table = _classPrivateFieldGet(_table, this);\n    this.hot.container.insertBefore(_classPrivateFieldGet(_table, this), this.hot.container.firstChild);\n  }\n\n  /**\n   * Attaches necessary listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      rootElement,\n      rootDocument,\n      selection,\n      rootWindow\n    } = this.hot;\n    const documentElement = rootDocument.documentElement;\n    this.eventManager.addEventListener(rootElement, 'mousedown', event => {\n      _classPrivateFieldSet(_selectionMouseDown, this, true);\n      if (!this.isTextSelectionAllowed(event.target)) {\n        clearTextSelection(rootWindow);\n        event.preventDefault();\n        rootWindow.focus(); // make sure that window that contains HOT is active. Important when HOT is in iframe.\n      }\n    });\n    this.eventManager.addEventListener(rootElement, 'mouseup', () => {\n      _classPrivateFieldSet(_selectionMouseDown, this, false);\n    });\n    this.eventManager.addEventListener(rootElement, 'mousemove', event => {\n      if (_classPrivateFieldGet(_selectionMouseDown, this) && !this.isTextSelectionAllowed(event.target)) {\n        // Clear selection only when fragmentSelection is enabled, otherwise clearing selection breaks the IME editor.\n        if (this.settings.fragmentSelection) {\n          clearTextSelection(rootWindow);\n        }\n        event.preventDefault();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'keyup', event => {\n      // TODO: is it the best place and way to finish cell selection?\n      if (selection.isInProgress() && !event.shiftKey) {\n        selection.finish();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'mouseup', event => {\n      if (selection.isInProgress() && isLeftClick(event)) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(_mouseDown, this, false);\n      const isOutsideInputElement = isOutsideInput(rootDocument.activeElement);\n      if (isInput(rootDocument.activeElement) && !isOutsideInputElement) {\n        return;\n      }\n      if (isOutsideInputElement || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event.target) && !isRightClick(event)) {\n        this.hot.unlisten();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'contextmenu', event => {\n      if (selection.isInProgress() && isRightClick(event)) {\n        selection.finish();\n        _classPrivateFieldSet(_mouseDown, this, false);\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'touchend', () => {\n      if (selection.isInProgress()) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(_mouseDown, this, false);\n    });\n    this.eventManager.addEventListener(documentElement, 'mousedown', event => {\n      const originalTarget = event.target;\n      const eventX = event.x || event.clientX;\n      const eventY = event.y || event.clientY;\n      let next = event.target;\n      if (_classPrivateFieldGet(_mouseDown, this) || !rootElement || !this.hot.view) {\n        return; // it must have been started in a cell\n      }\n\n      // immediate click on \"holder\" means click on the right side of vertical scrollbar\n      const {\n        holder\n      } = this._wt.wtTable;\n      if (next === holder) {\n        const scrollbarWidth = getScrollbarWidth(rootDocument);\n        if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder) {\n          return;\n        }\n      } else {\n        while (next !== documentElement) {\n          if (next === null) {\n            if (event.isTargetWebComponent) {\n              break;\n            }\n\n            // click on something that was a row but now is detached (possibly because your click triggered a rerender)\n            return;\n          }\n          if (next === rootElement) {\n            // click inside container\n            return;\n          }\n          next = next.parentNode;\n        }\n      }\n\n      // function did not return until here, we have an outside click!\n      const outsideClickDeselects = typeof this.settings.outsideClickDeselects === 'function' ? this.settings.outsideClickDeselects(originalTarget) : this.settings.outsideClickDeselects;\n      if (outsideClickDeselects) {\n        this.hot.deselectCell();\n      } else {\n        this.hot.destroyEditor(false, false);\n      }\n    });\n    let parentWindow = getParentWindow(rootWindow);\n    while (parentWindow !== null) {\n      this.eventManager.addEventListener(parentWindow.document.documentElement, 'click', () => {\n        this.hot.unlisten();\n      });\n      parentWindow = getParentWindow(parentWindow);\n    }\n    this.eventManager.addEventListener(_classPrivateFieldGet(_table, this), 'selectstart', event => {\n      if (this.settings.fragmentSelection || isInput(event.target)) {\n        return;\n      }\n      // https://github.com/handsontable/handsontable/issues/160\n      // Prevent text from being selected when performing drag down.\n      event.preventDefault();\n    });\n  }\n\n  /**\n   * Translate renderable cell coordinates to visual coordinates.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {CellCoords}\n   */\n  translateFromRenderableToVisualCoords(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    // TODO: To consider an idea to reusing the CellCoords instance instead creating new one.\n    return this.hot._createCellCoords(...this.translateFromRenderableToVisualIndex(row, col));\n  }\n\n  /**\n   * Translate renderable row and column indexes to visual row and column indexes.\n   *\n   * @param {number} renderableRow Renderable row index.\n   * @param {number} renderableColumn Renderable columnIndex.\n   * @returns {number[]}\n   */\n  translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {\n    // TODO: Some helper may be needed.\n    // We perform translation for indexes (without headers).\n    let visualRow = renderableRow >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;\n    let visualColumn = renderableColumn >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;\n    if (visualRow === null) {\n      visualRow = renderableRow;\n    }\n    if (visualColumn === null) {\n      visualColumn = renderableColumn;\n    }\n    return [visualRow, visualColumn];\n  }\n\n  /**\n   * Returns the number of renderable indexes.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} maxElements Maximum number of elements (rows or columns).\n   *\n   * @returns {number|*}\n   */\n  countRenderableIndexes(indexMapper, maxElements) {\n    const consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);\n    // Don't take hidden indexes into account. We are looking just for renderable indexes.\n    const firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);\n\n    // There are no renderable indexes.\n    if (firstNotHiddenIndex === null) {\n      return 0;\n    }\n    return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;\n  }\n\n  /**\n   * Returns the number of renderable columns.\n   *\n   * @returns {number}\n   */\n  countRenderableColumns() {\n    return this.countRenderableIndexes(this.hot.columnIndexMapper, this.settings.maxCols);\n  }\n\n  /**\n   * Returns the number of renderable rows.\n   *\n   * @returns {number}\n   */\n  countRenderableRows() {\n    return this.countRenderableIndexes(this.hot.rowIndexMapper, this.settings.maxRows);\n  }\n\n  /**\n   * Returns number of not hidden row indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenRowIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.rowIndexMapper, this.countRenderableRows());\n  }\n\n  /**\n   * Returns number of not hidden column indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenColumnIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.columnIndexMapper, this.countRenderableColumns());\n  }\n\n  /**\n   * Returns number of not hidden indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.\n   * @returns {number}\n   */\n  countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {\n    if (isNaN(visualIndex) || visualIndex < 0) {\n      return 0;\n    }\n    const firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);\n    const renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);\n    if (!Number.isInteger(renderableIndex)) {\n      return 0;\n    }\n    let notHiddenIndexes = 0;\n    if (incrementBy < 0) {\n      // Zero-based numbering for renderable indexes corresponds to a number of not hidden indexes.\n      notHiddenIndexes = renderableIndex + 1;\n    } else if (incrementBy > 0) {\n      notHiddenIndexes = renderableIndexesCount - renderableIndex;\n    }\n    return notHiddenIndexes;\n  }\n\n  /**\n   * The function returns the number of not hidden column indexes that fit between the first and\n   * last fixed column in the left (or right in RTL mode) overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedColumnsStart() {\n    const countCols = this.hot.countCols();\n    const visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;\n    return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the top overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsTop() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;\n    return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the bottom overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsBottom() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);\n    return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);\n  }\n\n  /**\n   * The function returns the number of renderable column indexes within the passed range of the visual indexes.\n   *\n   * @param {number} columnStart The column visual start index.\n   * @param {number} columnEnd The column visual end index.\n   * @returns {number}\n   */\n  countRenderableColumnsInRange(columnStart, columnEnd) {\n    let count = 0;\n    for (let column = columnStart; column <= columnEnd; column++) {\n      if (this.hot.columnIndexMapper.getRenderableFromVisualIndex(column) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * The function returns the number of renderable row indexes within the passed range of the visual indexes.\n   *\n   * @param {number} rowStart The row visual start index.\n   * @param {number} rowEnd The row visual end index.\n   * @returns {number}\n   */\n  countRenderableRowsInRange(rowStart, rowEnd) {\n    let count = 0;\n    for (let row = rowStart; row <= rowEnd; row++) {\n      if (this.hot.rowIndexMapper.getRenderableFromVisualIndex(row) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Checks if at least one cell than belongs to the main table is not covered by the top, left or\n   * bottom overlay.\n   *\n   * @returns {boolean}\n   */\n  isMainTableNotFullyCoveredByOverlays() {\n    const fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();\n    const fixedAllColumns = this.countNotHiddenFixedColumnsStart();\n    return this.hot.countRenderedRows() > fixedAllRows && this.hot.countRenderedCols() > fixedAllColumns;\n  }\n\n  /**\n   * Defines default configuration and initializes WalkOnTable instance.\n   *\n   * @private\n   */\n  initializeWalkontable() {\n    const walkontableConfig = {\n      ariaTags: this.settings.ariaTags,\n      rtlMode: this.hot.isRtl(),\n      externalRowCalculator: this.hot.getPlugin('autoRowSize') && this.hot.getPlugin('autoRowSize').isEnabled(),\n      table: _classPrivateFieldGet(_table, this),\n      isDataViewInstance: () => isRootInstance(this.hot),\n      preventOverflow: () => this.settings.preventOverflow,\n      preventWheel: () => this.settings.preventWheel,\n      stretchH: () => this.settings.stretchH,\n      data: (renderableRow, renderableColumn) => {\n        return this.hot.getDataAtCell(...this.translateFromRenderableToVisualIndex(renderableRow, renderableColumn));\n      },\n      totalRows: () => this.countRenderableRows(),\n      totalColumns: () => this.countRenderableColumns(),\n      // Number of renderable columns for the left overlay.\n      fixedColumnsStart: () => this.countNotHiddenFixedColumnsStart(),\n      // Number of renderable rows for the top overlay.\n      fixedRowsTop: () => this.countNotHiddenFixedRowsTop(),\n      // Number of renderable rows for the bottom overlay.\n      fixedRowsBottom: () => this.countNotHiddenFixedRowsBottom(),\n      // Enable the inline start overlay when conditions are met.\n      shouldRenderInlineStartOverlay: () => {\n        return this.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;\n      },\n      // Enable the top overlay when conditions are met.\n      shouldRenderTopOverlay: () => {\n        return this.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;\n      },\n      // Enable the bottom overlay when conditions are met.\n      shouldRenderBottomOverlay: () => {\n        return this.settings.fixedRowsBottom > 0;\n      },\n      minSpareRows: () => this.settings.minSpareRows,\n      renderAllRows: this.settings.renderAllRows,\n      renderAllColumns: this.settings.renderAllColumns,\n      rowHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasRowHeaders()) {\n          headerRenderers.push((renderableRowIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for row indexes (without row headers).\n            const visualRowIndex = renderableRowIndex >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n            this.appendRowHeader(visualRowIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetRowHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(_rowHeadersCount, this, headerRenderers.length);\n        if (this.hot.getSettings().ariaTags) {\n          // Update the aria-colcount attribute.\n          // Only needs to be done once after initialization/data update.\n          if (_assertClassBrand(_TableView_brand, this, _getAriaColcount).call(this) === this.hot.countCols()) {\n            _assertClassBrand(_TableView_brand, this, _updateAriaColcount).call(this, _classPrivateFieldGet(_rowHeadersCount, this));\n          }\n        }\n        return headerRenderers;\n      },\n      columnHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasColHeaders()) {\n          headerRenderers.push((renderedColumnIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for columns indexes (without column headers).\n            const visualColumnsIndex = renderedColumnIndex >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;\n            this.appendColHeader(visualColumnsIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetColumnHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(_columnHeadersCount, this, headerRenderers.length);\n        return headerRenderers;\n      },\n      columnWidth: renderedColumnIndex => {\n        const visualIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n\n        // It's not a bug that we can't find visual index for some handled by method indexes. The function is called also\n        // for indexes that are not displayed (indexes that are beyond the grid's boundaries), i.e. when `fixedColumnsStart` > `startCols` (wrong config?) or\n        // scrolling and dataset is empty (scroll should handle that?).\n        return this.hot.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);\n      },\n      rowHeight: renderedRowIndex => {\n        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\n        return this.hot.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);\n      },\n      rowHeightByOverlayName: (renderedRowIndex, overlayType) => {\n        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\n        const visualRowIndex = visualIndex === null ? renderedRowIndex : visualIndex;\n        return this.hot.runHooks('modifyRowHeightByOverlayName', this.hot.getRowHeight(visualRowIndex), visualRowIndex, overlayType);\n      },\n      cellRenderer: (renderedRowIndex, renderedColumnIndex, TD) => {\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex);\n\n        // Coords may be modified. For example, by the `MergeCells` plugin. It should affect cell value and cell meta.\n        const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex);\n        let visualRowToCheck = visualRowIndex;\n        let visualColumnToCheck = visualColumnIndex;\n        if (Array.isArray(modifiedCellCoords)) {\n          [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n        }\n        const cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n        const prop = this.hot.colToProp(visualColumnToCheck);\n        let value = this.hot.getDataAtRowProp(visualRowToCheck, prop);\n        if (this.hot.hasHook('beforeValueRender')) {\n          value = this.hot.runHooks('beforeValueRender', value, cellProperties);\n        }\n        this.hot.runHooks('beforeRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.getCellRenderer(cellProperties)(this.hot, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.runHooks('afterRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n      },\n      selections: this.hot.selection.highlight,\n      hideBorderOnMouseDownOver: () => this.settings.fragmentSelection,\n      onWindowResize: () => {\n        if (this.hot && !this.hot.isDestroyed) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onContainerElementResize: () => {\n        if (this.hot && !this.hot.isDestroyed && isVisible(this.hot.rootElement)) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onCellMouseDown: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.hot.listen();\n        this.activeWt = wt;\n        _classPrivateFieldSet(_mouseDown, this, true);\n        this.hot.runHooks('beforeOnCellMouseDown', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        handleMouseEvent(event, {\n          coords: visualCoords,\n          selection: this.hot.selection,\n          controller,\n          cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n        });\n        this.hot.runHooks('afterOnCellMouseDown', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellContextMenu: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        _classPrivateFieldSet(_mouseDown, this, false);\n        if (this.hot.selection.isInProgress()) {\n          this.hot.selection.finish();\n        }\n        this.hot.runHooks('beforeOnCellContextMenu', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellContextMenu', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOut: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOut', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseOut', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOver: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOver', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        if (_classPrivateFieldGet(_mouseDown, this)) {\n          handleMouseEvent(event, {\n            coords: visualCoords,\n            selection: this.hot.selection,\n            controller,\n            cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n          });\n        }\n        this.hot.runHooks('afterOnCellMouseOver', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseUp: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseUp', event, visualCoords, TD);\n\n        // TODO: The second condition check is a workaround. Callback corresponding the method `updateSettings`\n        // disable plugin and enable it again. Disabling plugin closes the menu. Thus, calling the\n        // `updateSettings` in a body of any callback executed right after some context-menu action\n        // breaks the table (#7231).\n        if (isImmediatePropagationStopped(event) || this.hot.isDestroyed) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseUp', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellCornerMouseDown: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerMouseDown', event);\n      },\n      onCellCornerDblClick: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerDblClick', event);\n      },\n      beforeDraw: (force, skipRender) => this.beforeRender(force, skipRender),\n      onDraw: force => this.afterRender(force),\n      onBeforeViewportScrollVertically: renderableRow => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n\n          // for an empty data return index as is\n          if (visualRow === null) {\n            return renderableRow;\n          }\n        }\n        visualRow = this.hot.runHooks('beforeViewportScrollVertically', visualRow);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(visualRow);\n        }\n        return visualRow;\n      },\n      onBeforeViewportScrollHorizontally: renderableColumn => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n\n          // for an empty data return index as is\n          if (visualColumn === null) {\n            return renderableColumn;\n          }\n        }\n        visualColumn = this.hot.runHooks('beforeViewportScrollHorizontally', visualColumn);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(visualColumn);\n        }\n        return visualColumn;\n      },\n      onScrollVertically: () => {\n        this.hot.runHooks('afterScrollVertically');\n        this.hot.runHooks('afterScroll');\n      },\n      onScrollHorizontally: () => {\n        this.hot.runHooks('afterScrollHorizontally');\n        this.hot.runHooks('afterScroll');\n      },\n      onBeforeRemoveCellClassNames: () => this.hot.runHooks('beforeRemoveCellClassNames'),\n      onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n        }\n        const newVisualRow = this.hot.runHooks('beforeHighlightingRowHeader', visualRow, headerLevel, highlightMeta);\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));\n        }\n        return newVisualRow;\n      },\n      onBeforeHighlightingColumnHeader: (renderableColumn, headerLevel, highlightMeta) => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n        }\n        const newVisualColumn = this.hot.runHooks('beforeHighlightingColumnHeader', visualColumn, headerLevel, highlightMeta);\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));\n        }\n        return newVisualColumn;\n      },\n      onAfterDrawSelection: (currentRow, currentColumn, layerLevel) => {\n        let cornersOfSelection;\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(currentRow, currentColumn);\n        const selectedRange = this.hot.selection.getSelectedRange();\n        const selectionRangeSize = selectedRange.size();\n        if (selectionRangeSize > 0) {\n          const selectionForLayer = selectedRange.peekByIndex(layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0);\n          cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];\n        }\n        return this.hot.runHooks('afterDrawSelection', visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);\n      },\n      onBeforeDrawBorders: (corners, borderClassName) => {\n        const [startRenderableRow, startRenderableColumn, endRenderableRow, endRenderableColumn] = corners;\n        const visualCorners = [this.hot.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), this.hot.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];\n        return this.hot.runHooks('beforeDrawBorders', visualCorners, borderClassName);\n      },\n      onBeforeTouchScroll: () => this.hot.runHooks('beforeTouchScroll'),\n      onAfterMomentumScroll: () => this.hot.runHooks('afterMomentumScroll'),\n      onBeforeStretchingColumnWidth: (stretchedWidth, renderedColumnIndex) => {\n        const visualColumnIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n        return this.hot.runHooks('beforeStretchingColumnWidth', stretchedWidth, visualColumnIndex);\n      },\n      onModifyRowHeaderWidth: rowHeaderWidth => this.hot.runHooks('modifyRowHeaderWidth', rowHeaderWidth),\n      onModifyGetCellCoords: (renderableRowIndex, renderableColumnIndex, topmost) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const columnMapper = this.hot.columnIndexMapper;\n\n        // Callback handle also headers. We shouldn't translate them.\n        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;\n        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n        const visualIndexes = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex, topmost);\n        if (Array.isArray(visualIndexes)) {\n          const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = visualIndexes;\n\n          // Result of the hook is handled by the Walkontable (renderable indexes).\n          return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];\n        }\n      },\n      viewportRowCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportRowRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedRowsTop) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableRows = this.countRenderableRows();\n          const firstRenderedRow = calc.startRow;\n          const lastRenderedRow = calc.endRow;\n          if (typeof viewportOffset === 'number') {\n            calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);\n            calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);\n          } else if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedRow / renderableRows * 12);\n            calc.startRow = Math.max(firstRenderedRow - offset, 0);\n            calc.endRow = Math.min(lastRenderedRow + offset, renderableRows - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportRowCalculatorOverride', calc);\n      },\n      viewportColumnCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportColumnRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedColumnsStart) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableColumns = this.countRenderableColumns();\n          const firstRenderedColumn = calc.startColumn;\n          const lastRenderedColumn = calc.endColumn;\n          if (typeof viewportOffset === 'number') {\n            calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);\n          }\n          if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedColumn / renderableColumns * 6);\n            calc.startColumn = Math.max(firstRenderedColumn - offset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + offset, renderableColumns - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportColumnCalculatorOverride', calc);\n      },\n      rowHeaderWidth: () => this.settings.rowHeaderWidth,\n      columnHeaderHeight: () => {\n        const columnHeaderHeight = this.hot.runHooks('modifyColumnHeaderHeight');\n        return this.settings.columnHeaderHeight || columnHeaderHeight;\n      }\n    };\n    this.hot.runHooks('beforeInitWalkontable', walkontableConfig);\n    this._wt = new Walkontable(walkontableConfig);\n    this.activeWt = this._wt;\n    const spreader = this._wt.wtTable.spreader;\n    // We have to cache width and height after Walkontable initialization.\n    const {\n      width,\n      height\n    } = this.hot.rootElement.getBoundingClientRect();\n    this.setLastSize(width, height);\n    this.eventManager.addEventListener(spreader, 'mousedown', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(spreader, 'contextmenu', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'click', () => {\n      if (this.settings.observeDOMVisibility) {\n        if (this._wt.drawInterrupted) {\n          this.hot.forceFullRender = true;\n          this.render();\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks if it's possible to create text selection in element.\n   *\n   * @private\n   * @param {HTMLElement} el The element to check.\n   * @returns {boolean}\n   */\n  isTextSelectionAllowed(el) {\n    if (isInput(el)) {\n      return true;\n    }\n    const isChildOfTableBody = isChildOf(el, this._wt.wtTable.spreader);\n    if (this.settings.fragmentSelection === true && isChildOfTableBody) {\n      return true;\n    }\n    if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {\n      return true;\n    }\n    if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks if user's been called mousedown.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isMouseDown() {\n    return _classPrivateFieldGet(_mouseDown, this);\n  }\n\n  /**\n   * Check if selected only one cell.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isSelectedOnlyCell() {\n    var _this$hot$getSelected, _this$hot$getSelected2;\n    return (_this$hot$getSelected = (_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.isSingleCell()) !== null && _this$hot$getSelected !== void 0 ? _this$hot$getSelected : false;\n  }\n\n  /**\n   * Checks if active cell is editing.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEdited() {\n    const activeEditor = this.hot.getActiveEditor();\n    return activeEditor && activeEditor.isOpened();\n  }\n\n  /**\n   * `beforeDraw` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering\n   *                            cycle will be skipped.\n   */\n  beforeRender(force, skipRender) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('beforeViewRender', this.hot.forceFullRender, skipRender);\n    }\n  }\n\n  /**\n   * `afterRender` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   */\n  afterRender(force) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('afterViewRender', this.hot.forceFullRender);\n    }\n  }\n\n  /**\n   * Append row header to a TH element.\n   *\n   * @private\n   * @param {number} visualRowIndex The visual row index.\n   * @param {HTMLTableHeaderCellElement} TH The table header element.\n   */\n  appendRowHeader(visualRowIndex, TH) {\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (!hasClass(container, 'relative')) {\n        empty(TH);\n        this.appendRowHeader(visualRowIndex, TH);\n        return;\n      }\n      this.updateCellHeader(container.querySelector('.rowHeader'), visualRowIndex, this.hot.getRowHeader);\n    } else {\n      const {\n        rootDocument,\n        getRowHeader\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      div.className = 'relative';\n      span.className = 'rowHeader';\n      this.updateCellHeader(span, visualRowIndex, getRowHeader);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetRowHeader', visualRowIndex, TH);\n  }\n\n  /**\n   * Append column header to a TH element.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {HTMLTableCellElement} TH The table header element.\n   * @param {Function} [label] The function that returns the header label.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  appendColHeader(visualColumnIndex, TH) {\n    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hot.getColHeader;\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const getColumnHeaderClassNames = () => {\n      const metaHeaderClassNames = visualColumnIndex >= 0 ? this.hot.getColumnMeta(visualColumnIndex).headerClassName : null;\n      return metaHeaderClassNames ? metaHeaderClassNames.split(' ') : [];\n    };\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (hasClass(container, 'relative')) {\n        this.updateCellHeader(container.querySelector('.colHeader'), visualColumnIndex, label, headerLevel);\n        container.className = '';\n        addClass(container, ['relative', ...getColumnHeaderClassNames()]);\n      } else {\n        empty(TH);\n        this.appendColHeader(visualColumnIndex, TH, label, headerLevel);\n      }\n    } else {\n      const {\n        rootDocument\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      const classNames = getColumnHeaderClassNames();\n      div.classList.add('relative', ...classNames);\n      span.className = 'colHeader';\n      if (this.settings.ariaTags) {\n        setAttribute(div, ...A11Y_PRESENTATION());\n        setAttribute(span, ...A11Y_PRESENTATION());\n      }\n      this.updateCellHeader(span, visualColumnIndex, label, headerLevel);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetColHeader', visualColumnIndex, TH, headerLevel);\n  }\n\n  /**\n   * Updates header cell content.\n   *\n   * @private\n   * @param {HTMLElement} element Element to update.\n   * @param {number} index Row index or column index.\n   * @param {Function} content Function which should be returns content for this cell.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  updateCellHeader(element, index, content) {\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let renderedIndex = index;\n    const parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;\n\n    // prevent wrong calculations from SampleGenerator\n    if (element.parentNode) {\n      if (hasClass(element, 'colHeader')) {\n        renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);\n      } else if (hasClass(element, 'rowHeader')) {\n        renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);\n      }\n    }\n    if (renderedIndex > -1) {\n      fastInnerHTML(element, content(index, headerLevel));\n    } else {\n      // workaround for https://github.com/handsontable/handsontable/issues/1946\n      fastInnerText(element, String.fromCharCode(160));\n      addClass(element, 'cornerHeader');\n    }\n  }\n\n  /**\n   * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum\n   * element width until the right (or left) edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} inlineOffset The left (or right in RTL mode) offset.\n   * @returns {number}\n   */\n  maximumVisibleElementWidth(inlineOffset) {\n    const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();\n    const maxWidth = workspaceWidth - inlineOffset;\n    return maxWidth > 0 ? maxWidth : 0;\n  }\n\n  /**\n   * Given a element's top position relative to the viewport, returns maximum element height until the bottom\n   * edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} topOffset The top offset.\n   * @returns {number}\n   */\n  maximumVisibleElementHeight(topOffset) {\n    const workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();\n    const maxHeight = workspaceHeight - topOffset;\n    return maxHeight > 0 ? maxHeight : 0;\n  }\n\n  /**\n   * Sets new dimensions of the container.\n   *\n   * @param {number} width The table width.\n   * @param {number} height The table height.\n   */\n  setLastSize(width, height) {\n    _classPrivateFieldSet(_lastWidth, this, width);\n    _classPrivateFieldSet(_lastHeight, this, height);\n  }\n\n  /**\n   * Returns cached dimensions.\n   *\n   * @returns {object}\n   */\n  getLastSize() {\n    return {\n      width: _classPrivateFieldGet(_lastWidth, this),\n      height: _classPrivateFieldGet(_lastHeight, this)\n    };\n  }\n\n  /**\n   * Returns the first rendered row in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getFirstRenderedVisibleRow() {\n    if (!this._wt.wtViewport.rowsRenderCalculator) {\n      return null;\n    }\n    return this.hot.rowIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getFirstRenderedRow(), 1);\n  }\n\n  /**\n   * Returns the last rendered row in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getLastRenderedVisibleRow() {\n    if (!this._wt.wtViewport.rowsRenderCalculator) {\n      return null;\n    }\n    return this.hot.rowIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getLastRenderedRow(), -1);\n  }\n\n  /**\n   * Returns the first rendered column in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getFirstRenderedVisibleColumn() {\n    if (!this._wt.wtViewport.columnsRenderCalculator) {\n      return null;\n    }\n    return this.hot.columnIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getFirstRenderedColumn(), 1);\n  }\n\n  /**\n   * Returns the last rendered column in the DOM (usually is not visible in the table's viewport).\n   *\n   * @returns {number | null}\n   */\n  getLastRenderedVisibleColumn() {\n    if (!this._wt.wtViewport.columnsRenderCalculator) {\n      return null;\n    }\n    return this.hot.columnIndexMapper.getNearestNotHiddenIndex(this._wt.wtTable.getLastRenderedColumn(), -1);\n  }\n\n  /**\n   * Returns the first fully visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstVisibleRow());\n  }\n\n  /**\n   * Returns the last fully visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastVisibleRow());\n  }\n\n  /**\n   * Returns the first fully visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstVisibleColumn());\n  }\n\n  /**\n   * Returns the last fully visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastVisibleColumn());\n  }\n\n  /**\n   * Returns the first partially visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstPartiallyVisibleRow());\n  }\n\n  /**\n   * Returns the last partially visible row in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastPartiallyVisibleRow());\n  }\n\n  /**\n   * Returns the first partially visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstPartiallyVisibleColumn());\n  }\n\n  /**\n   * Returns the last partially visible column in the table viewport. When the table has overlays the method returns\n   * the first row of the master table that is not overlapped by overlay.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastPartiallyVisibleColumn());\n  }\n\n  /**\n   * Returns the total count of the rendered column headers.\n   *\n   * @returns {number}\n   */\n  getColumnHeadersCount() {\n    return _classPrivateFieldGet(_columnHeadersCount, this);\n  }\n\n  /**\n   * Returns the total count of the rendered row headers.\n   *\n   * @returns {number}\n   */\n  getRowHeadersCount() {\n    return _classPrivateFieldGet(_rowHeadersCount, this);\n  }\n\n  /**\n   * Returns the table's viewport width. When the table has defined the size of the container,\n   * and the columns do not fill the entire viewport, the viewport width is equal to the sum of\n   * the columns' widths.\n   *\n   * @returns {number}\n   */\n  getViewportWidth() {\n    return this._wt.wtViewport.getViewportWidth();\n  }\n\n  /**\n   * Returns the table's total width including the scrollbar width.\n   *\n   * @returns {number}\n   */\n  getWorkspaceWidth() {\n    return this._wt.wtViewport.getWorkspaceWidth();\n  }\n\n  /**\n   * Returns the table's viewport height. When the table has defined the size of the container,\n   * and the rows do not fill the entire viewport, the viewport height is equal to the sum of\n   * the rows' heights.\n   *\n   * @returns {number}\n   */\n  getViewportHeight() {\n    return this._wt.wtViewport.getViewportHeight();\n  }\n\n  /**\n   * Returns the table's total height including the scrollbar height.\n   *\n   * @returns {number}\n   */\n  getWorkspaceHeight() {\n    return this._wt.wtViewport.getWorkspaceHeight();\n  }\n\n  /**\n   * Checks to what overlay the provided element belongs.\n   *\n   * @param {HTMLElement} element The DOM element to check.\n   * @returns {'master'|'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'}\n   */\n  getElementOverlayName(element) {\n    var _this$_wt$wtOverlays$;\n    return ((_this$_wt$wtOverlays$ = this._wt.wtOverlays.getParentOverlay(element)) !== null && _this$_wt$wtOverlays$ !== void 0 ? _this$_wt$wtOverlays$ : this._wt).wtTable.name;\n  }\n\n  /**\n   * Gets the overlay instance by its name.\n   *\n   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'} overlayName The overlay name.\n   * @returns {Overlay | null}\n   */\n  getOverlayByName(overlayName) {\n    return this._wt.getOverlayByName(overlayName);\n  }\n\n  /**\n   * Checks if the table is visible or not.\n   *\n   * @returns {boolean}\n   */\n  isVisible() {\n    return this._wt.wtTable.isVisible();\n  }\n  /**\n   * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.\n   *\n   * @private\n   */\n  destroy() {\n    this._wt.destroy();\n    this.eventManager.destroy();\n  }\n}\nfunction _getAriaColcount() {\n  return parseInt(this.hot.rootElement.getAttribute(A11Y_COLCOUNT()[0]), 10);\n}\n/**\n * Update the `aria-colcount` attribute by the provided value.\n *\n * @param {number} delta The number of columns to add or remove to the aria tag.\n */\nfunction _updateAriaColcount(delta) {\n  const colCount = _assertClassBrand(_TableView_brand, this, _getAriaColcount).call(this) + delta;\n  setAttribute(this.hot.rootElement, ...A11Y_COLCOUNT(colCount));\n}\nexport default TableView;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}