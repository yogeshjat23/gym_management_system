{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nvar _MergedCellsCollection_brand = /*#__PURE__*/new WeakSet();\nclass MergedCellsCollection {\n  constructor(mergeCellsPlugin) {\n    /**\n     * Gets the list of the indexes that do not intersect with other merged cells within the provided range.\n     *\n     * @param {CellRange} range The range to search within.\n     * @param {'row' | 'col'} axis The axis to search within.\n     * @param {number} scanDirection  The direction to scan the range. `1` for forward, `-1` for backward.\n     * @returns {number[]}\n     */\n    _classPrivateMethodInitSpec(this, _MergedCellsCollection_brand);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Array of merged cells.\n     *\n     * @type {MergedCellCoords[]}\n     */\n    _defineProperty(this, \"mergedCells\", []);\n    /**\n     * Matrix of cells (row, col) that points to the instances of the MergedCellCoords objects.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedCellsMatrix\", new Map());\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    this.plugin = mergeCellsPlugin;\n    this.hot = mergeCellsPlugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OVERLAPPING_WARNING(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    return toSingleLine`The merged cell declared at [${row}, ${col}], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup.`;\n  }\n\n  /**\n   * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n   */\n  get(row, column) {\n    var _this$mergedCellsMatr;\n    if (!this.mergedCellsMatrix.has(row)) {\n      return false;\n    }\n    return (_this$mergedCellsMatr = this.mergedCellsMatrix.get(row).get(column)) !== null && _this$mergedCellsMatr !== void 0 ? _this$mergedCellsMatr : false;\n  }\n\n  /**\n   * Get the first-found merged cell containing the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells for.\n   * @returns {MergedCellCoords|boolean}\n   */\n  getByRange(range) {\n    let result = false;\n    arrayEach(this.mergedCells, mergedCell => {\n      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n        result = mergedCell;\n        return result;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Filters merge cells objects provided by users from overlapping cells.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCellsInfo The merged cell information object.\n   * Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @returns {Array<{ row: number, col: number, rowspan: number, colspan: number }>}\n   */\n  filterOverlappingMergeCells(mergedCellsInfo) {\n    const occupiedCells = new Set();\n    this.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        col,\n        colspan,\n        rowspan\n      } = mergedCell;\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          occupiedCells.add(`r${r},c${c}`);\n        }\n      }\n    });\n    const filteredMergeCells = mergedCellsInfo.filter(mergedCell => {\n      const {\n        row,\n        col,\n        colspan,\n        rowspan\n      } = mergedCell;\n      const localOccupiedCells = new Set();\n      let isOverlapping = false;\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          const cellId = `r${r},c${c}`;\n          if (occupiedCells.has(cellId)) {\n            warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(mergedCell));\n            isOverlapping = true;\n            break;\n          }\n          localOccupiedCells.add(cellId);\n        }\n        if (isOverlapping) {\n          break;\n        }\n      }\n      if (!isOverlapping) {\n        occupiedCells.add(...localOccupiedCells);\n      }\n      return !isOverlapping;\n    });\n    return filteredMergeCells;\n  }\n\n  /**\n   * Get a merged cell contained in the provided range.\n   *\n   * @param {CellRange} range The range to search merged cells in.\n   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n   * @returns {MergedCellCoords[]} Array of found merged cells.\n   */\n  getWithinRange(range) {\n    let countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      row: rowStart,\n      col: columnStart\n    } = range.getTopStartCorner();\n    const {\n      row: rowEnd,\n      col: columnEnd\n    } = range.getBottomEndCorner();\n    const result = [];\n    for (let row = rowStart; row <= rowEnd; row++) {\n      for (let column = columnStart; column <= columnEnd; column++) {\n        const mergedCell = this.get(row, column);\n        if (mergedCell && (countPartials || !countPartials && mergedCell.row === row && mergedCell.col === column)) {\n          result.push(mergedCell);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Add a merged cell to the container.\n   *\n   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @param {boolean} [auto=false] `true` if called internally by the plugin (usually in batch).\n   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n   */\n  add(mergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const row = mergedCellInfo.row;\n    const column = mergedCellInfo.col;\n    const rowspan = mergedCellInfo.rowspan;\n    const colspan = mergedCellInfo.colspan;\n    const newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n    const alreadyExists = this.get(row, column);\n    const isOverlapping = auto ? false : this.isOverlapping(newMergedCell);\n    if (!alreadyExists && !isOverlapping) {\n      if (this.hot) {\n        newMergedCell.normalize(this.hot);\n      }\n      this.mergedCells.push(newMergedCell);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _addMergedCellToMatrix).call(this, newMergedCell);\n      return newMergedCell;\n    }\n    warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n    return false;\n  }\n\n  /**\n   * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n   */\n  remove(row, column) {\n    const mergedCell = this.get(row, column);\n    const mergedCellIndex = mergedCell ? this.mergedCells.indexOf(mergedCell) : -1;\n    if (mergedCell && mergedCellIndex !== -1) {\n      this.mergedCells.splice(mergedCellIndex, 1);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, mergedCell);\n      return mergedCell;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all the merged cells.\n   */\n  clear() {\n    arrayEach(this.mergedCells, _ref2 => {\n      let {\n        row,\n        col,\n        rowspan,\n        colspan\n      } = _ref2;\n      rangeEach(row, row + rowspan, r => {\n        rangeEach(col, col + colspan, c => {\n          const TD = this.hot.getCell(r, c);\n          if (TD) {\n            TD.removeAttribute('rowspan');\n            TD.removeAttribute('colspan');\n            TD.style.display = '';\n          }\n        });\n      });\n    });\n    this.mergedCells.length = 0;\n    this.mergedCellsMatrix = new Map();\n  }\n\n  /**\n   * Check if the provided merged cell overlaps with the others already added.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n   */\n  isOverlapping(mergedCell) {\n    const mergedCellRange = mergedCell.getRange();\n    for (let i = 0; i < this.mergedCells.length; i++) {\n      const otherMergedCell = this.mergedCells[i];\n      const otherMergedCellRange = otherMergedCell.getRange();\n      if (otherMergedCellRange.overlaps(mergedCellRange)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean}\n   */\n  isFirstRenderableMergedCell(row, column) {\n    const mergeParent = this.get(row, column);\n\n    // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n  }\n\n  /**\n   * Get the first renderable coords of the merged cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n   *                        merged cell.\n   */\n  getFirstRenderableCoords(row, column) {\n    const mergeParent = this.get(row, column);\n    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n      return this.hot._createCellCoords(row, column);\n    }\n    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n  }\n\n  /**\n   * Gets the start-most visual column index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualColumnIndex The visual column index to start the search from.\n   * @returns {number}\n   */\n  getStartMostColumnIndex(range, visualColumnIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'col', -1);\n    let startMostIndex = visualColumnIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] <= visualColumnIndex) {\n        startMostIndex = indexes[i];\n        break;\n      }\n    }\n    return startMostIndex;\n  }\n\n  /**\n   * Gets the end-most visual column index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualColumnIndex The visual column index to start the search from.\n   * @returns {number}\n   */\n  getEndMostColumnIndex(range, visualColumnIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'col', 1);\n    let endMostIndex = visualColumnIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] >= visualColumnIndex) {\n        endMostIndex = indexes[i];\n        break;\n      }\n    }\n    return endMostIndex;\n  }\n\n  /**\n   * Gets the top-most visual row index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualRowIndex The visual row index to start the search from.\n   * @returns {number}\n   */\n  getTopMostRowIndex(range, visualRowIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'row', -1);\n    let topMostIndex = visualRowIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] <= visualRowIndex) {\n        topMostIndex = indexes[i];\n        break;\n      }\n    }\n    return topMostIndex;\n  }\n\n  /**\n   * Gets the bottom-most visual row index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualRowIndex The visual row index to start the search from.\n   * @returns {number}\n   */\n  getBottomMostRowIndex(range, visualRowIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'row', 1);\n    let bottomMostIndex = visualRowIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] >= visualRowIndex) {\n        bottomMostIndex = indexes[i];\n        break;\n      }\n    }\n    return bottomMostIndex;\n  }\n  /**\n   * Shift the merged cell in the direction and by an offset defined in the arguments.\n   *\n   * @param {string} direction `right`, `left`, `up` or `down`.\n   * @param {number} index Index where the change, which caused the shifting took place.\n   * @param {number} count Number of rows/columns added/removed in the preceding action.\n   */\n  shiftCollections(direction, index, count) {\n    const shiftVector = [0, 0];\n    switch (direction) {\n      case 'right':\n        shiftVector[0] += count;\n        break;\n      case 'left':\n        shiftVector[0] -= count;\n        break;\n      case 'down':\n        shiftVector[1] += count;\n        break;\n      case 'up':\n        shiftVector[1] -= count;\n        break;\n      default:\n    }\n    arrayEach(this.mergedCells, currentMerge => {\n      _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, currentMerge);\n      currentMerge.shift(shiftVector, index);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _addMergedCellToMatrix).call(this, currentMerge);\n    });\n    rangeEachReverse(this.mergedCells.length - 1, 0, i => {\n      const currentMerge = this.mergedCells[i];\n      if (currentMerge && currentMerge.removed) {\n        this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);\n        _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, currentMerge);\n      }\n    });\n  }\n\n  /**\n   * Adds a merged cell to the matrix.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to add.\n   */\n}\nfunction _getNonIntersectingIndexes(range, axis) {\n  let scanDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const indexes = new Map();\n  const from = scanDirection === 1 ? range.getTopStartCorner() : range.getBottomEndCorner();\n  const to = scanDirection === 1 ? range.getBottomEndCorner() : range.getTopStartCorner();\n  for (let row = from.row; scanDirection === 1 ? row <= to.row : row >= to.row; row += scanDirection) {\n    for (let column = from.col; scanDirection === 1 ? column <= to.col : column >= to.col; column += scanDirection) {\n      const index = axis === 'row' ? row : column;\n      const mergedCell = this.get(row, column);\n      let lastIndex = index;\n      if (mergedCell) {\n        lastIndex = scanDirection === 1 ? mergedCell[axis] + mergedCell[`${axis}span`] - 1 : mergedCell[axis];\n      }\n      if (!indexes.has(index)) {\n        indexes.set(index, new Set());\n      }\n      indexes.get(index).add(lastIndex);\n    }\n  }\n  return Array.from(new Set(Array.from(indexes.entries()).filter(_ref3 => {\n    let [, set] = _ref3;\n    return set.size === 1;\n  }).flatMap(_ref4 => {\n    let [, set] = _ref4;\n    return Array.from(set);\n  })));\n}\nfunction _addMergedCellToMatrix(mergedCell) {\n  for (let row = mergedCell.row; row < mergedCell.row + mergedCell.rowspan; row++) {\n    for (let col = mergedCell.col; col < mergedCell.col + mergedCell.colspan; col++) {\n      if (!this.mergedCellsMatrix.has(row)) {\n        this.mergedCellsMatrix.set(row, new Map());\n      }\n      this.mergedCellsMatrix.get(row).set(col, mergedCell);\n    }\n  }\n}\n/**\n * Removes a merged cell from the matrix.\n *\n * @param {MergedCellCoords} mergedCell The merged cell to remove.\n */\nfunction _removeMergedCellFromMatrix(mergedCell) {\n  for (let row = mergedCell.row; row < mergedCell.row + mergedCell.rowspan; row++) {\n    for (let col = mergedCell.col; col < mergedCell.col + mergedCell.colspan; col++) {\n      this.mergedCellsMatrix.get(row).delete(col);\n    }\n  }\n}\nexport default MergedCellsCollection;","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","t","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_assertClassBrand","n","arguments","length","MergedCellCoords","rangeEach","rangeEachReverse","warn","arrayEach","toSingleLine","_MergedCellsCollection_brand","WeakSet","MergedCellsCollection","constructor","mergeCellsPlugin","Map","plugin","hot","IS_OVERLAPPING_WARNING","_ref","row","col","get","column","_this$mergedCellsMatr","mergedCellsMatrix","getByRange","range","result","mergedCells","mergedCell","from","rowspan","to","colspan","filterOverlappingMergeCells","mergedCellsInfo","occupiedCells","Set","forEach","c","filteredMergeCells","filter","localOccupiedCells","isOverlapping","cellId","getWithinRange","countPartials","undefined","rowStart","columnStart","getTopStartCorner","rowEnd","columnEnd","getBottomEndCorner","push","mergedCellInfo","auto","newMergedCell","_createCellCoords","_createCellRange","alreadyExists","normalize","_addMergedCellToMatrix","remove","mergedCellIndex","indexOf","splice","_removeMergedCellFromMatrix","clear","_ref2","TD","getCell","removeAttribute","style","display","mergedCellRange","getRange","otherMergedCell","otherMergedCellRange","overlaps","isFirstRenderableMergedCell","mergeParent","rowIndexMapper","getNearestNotHiddenIndex","columnIndexMapper","getFirstRenderableCoords","firstRenderableRow","firstRenderableColumn","getStartMostColumnIndex","visualColumnIndex","indexes","_getNonIntersectingIndexes","startMostIndex","getEndMostColumnIndex","endMostIndex","getTopMostRowIndex","visualRowIndex","topMostIndex","getBottomMostRowIndex","bottomMostIndex","shiftCollections","direction","index","count","shiftVector","currentMerge","shift","removed","axis","scanDirection","lastIndex","set","Array","entries","_ref3","size","flatMap","_ref4","delete"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unscopables.flat-map.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nvar _MergedCellsCollection_brand = /*#__PURE__*/new WeakSet();\nclass MergedCellsCollection {\n  constructor(mergeCellsPlugin) {\n    /**\n     * Gets the list of the indexes that do not intersect with other merged cells within the provided range.\n     *\n     * @param {CellRange} range The range to search within.\n     * @param {'row' | 'col'} axis The axis to search within.\n     * @param {number} scanDirection  The direction to scan the range. `1` for forward, `-1` for backward.\n     * @returns {number[]}\n     */\n    _classPrivateMethodInitSpec(this, _MergedCellsCollection_brand);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Array of merged cells.\n     *\n     * @type {MergedCellCoords[]}\n     */\n    _defineProperty(this, \"mergedCells\", []);\n    /**\n     * Matrix of cells (row, col) that points to the instances of the MergedCellCoords objects.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedCellsMatrix\", new Map());\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    this.plugin = mergeCellsPlugin;\n    this.hot = mergeCellsPlugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OVERLAPPING_WARNING(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    return toSingleLine`The merged cell declared at [${row}, ${col}], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup.`;\n  }\n\n  /**\n   * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n   */\n  get(row, column) {\n    var _this$mergedCellsMatr;\n    if (!this.mergedCellsMatrix.has(row)) {\n      return false;\n    }\n    return (_this$mergedCellsMatr = this.mergedCellsMatrix.get(row).get(column)) !== null && _this$mergedCellsMatr !== void 0 ? _this$mergedCellsMatr : false;\n  }\n\n  /**\n   * Get the first-found merged cell containing the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells for.\n   * @returns {MergedCellCoords|boolean}\n   */\n  getByRange(range) {\n    let result = false;\n    arrayEach(this.mergedCells, mergedCell => {\n      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n        result = mergedCell;\n        return result;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Filters merge cells objects provided by users from overlapping cells.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCellsInfo The merged cell information object.\n   * Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @returns {Array<{ row: number, col: number, rowspan: number, colspan: number }>}\n   */\n  filterOverlappingMergeCells(mergedCellsInfo) {\n    const occupiedCells = new Set();\n    this.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        col,\n        colspan,\n        rowspan\n      } = mergedCell;\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          occupiedCells.add(`r${r},c${c}`);\n        }\n      }\n    });\n    const filteredMergeCells = mergedCellsInfo.filter(mergedCell => {\n      const {\n        row,\n        col,\n        colspan,\n        rowspan\n      } = mergedCell;\n      const localOccupiedCells = new Set();\n      let isOverlapping = false;\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          const cellId = `r${r},c${c}`;\n          if (occupiedCells.has(cellId)) {\n            warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(mergedCell));\n            isOverlapping = true;\n            break;\n          }\n          localOccupiedCells.add(cellId);\n        }\n        if (isOverlapping) {\n          break;\n        }\n      }\n      if (!isOverlapping) {\n        occupiedCells.add(...localOccupiedCells);\n      }\n      return !isOverlapping;\n    });\n    return filteredMergeCells;\n  }\n\n  /**\n   * Get a merged cell contained in the provided range.\n   *\n   * @param {CellRange} range The range to search merged cells in.\n   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n   * @returns {MergedCellCoords[]} Array of found merged cells.\n   */\n  getWithinRange(range) {\n    let countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      row: rowStart,\n      col: columnStart\n    } = range.getTopStartCorner();\n    const {\n      row: rowEnd,\n      col: columnEnd\n    } = range.getBottomEndCorner();\n    const result = [];\n    for (let row = rowStart; row <= rowEnd; row++) {\n      for (let column = columnStart; column <= columnEnd; column++) {\n        const mergedCell = this.get(row, column);\n        if (mergedCell && (countPartials || !countPartials && mergedCell.row === row && mergedCell.col === column)) {\n          result.push(mergedCell);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Add a merged cell to the container.\n   *\n   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @param {boolean} [auto=false] `true` if called internally by the plugin (usually in batch).\n   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n   */\n  add(mergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const row = mergedCellInfo.row;\n    const column = mergedCellInfo.col;\n    const rowspan = mergedCellInfo.rowspan;\n    const colspan = mergedCellInfo.colspan;\n    const newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n    const alreadyExists = this.get(row, column);\n    const isOverlapping = auto ? false : this.isOverlapping(newMergedCell);\n    if (!alreadyExists && !isOverlapping) {\n      if (this.hot) {\n        newMergedCell.normalize(this.hot);\n      }\n      this.mergedCells.push(newMergedCell);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _addMergedCellToMatrix).call(this, newMergedCell);\n      return newMergedCell;\n    }\n    warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n    return false;\n  }\n\n  /**\n   * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n   */\n  remove(row, column) {\n    const mergedCell = this.get(row, column);\n    const mergedCellIndex = mergedCell ? this.mergedCells.indexOf(mergedCell) : -1;\n    if (mergedCell && mergedCellIndex !== -1) {\n      this.mergedCells.splice(mergedCellIndex, 1);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, mergedCell);\n      return mergedCell;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all the merged cells.\n   */\n  clear() {\n    arrayEach(this.mergedCells, _ref2 => {\n      let {\n        row,\n        col,\n        rowspan,\n        colspan\n      } = _ref2;\n      rangeEach(row, row + rowspan, r => {\n        rangeEach(col, col + colspan, c => {\n          const TD = this.hot.getCell(r, c);\n          if (TD) {\n            TD.removeAttribute('rowspan');\n            TD.removeAttribute('colspan');\n            TD.style.display = '';\n          }\n        });\n      });\n    });\n    this.mergedCells.length = 0;\n    this.mergedCellsMatrix = new Map();\n  }\n\n  /**\n   * Check if the provided merged cell overlaps with the others already added.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n   */\n  isOverlapping(mergedCell) {\n    const mergedCellRange = mergedCell.getRange();\n    for (let i = 0; i < this.mergedCells.length; i++) {\n      const otherMergedCell = this.mergedCells[i];\n      const otherMergedCellRange = otherMergedCell.getRange();\n      if (otherMergedCellRange.overlaps(mergedCellRange)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean}\n   */\n  isFirstRenderableMergedCell(row, column) {\n    const mergeParent = this.get(row, column);\n\n    // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n  }\n\n  /**\n   * Get the first renderable coords of the merged cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n   *                        merged cell.\n   */\n  getFirstRenderableCoords(row, column) {\n    const mergeParent = this.get(row, column);\n    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n      return this.hot._createCellCoords(row, column);\n    }\n    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n  }\n\n  /**\n   * Gets the start-most visual column index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualColumnIndex The visual column index to start the search from.\n   * @returns {number}\n   */\n  getStartMostColumnIndex(range, visualColumnIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'col', -1);\n    let startMostIndex = visualColumnIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] <= visualColumnIndex) {\n        startMostIndex = indexes[i];\n        break;\n      }\n    }\n    return startMostIndex;\n  }\n\n  /**\n   * Gets the end-most visual column index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualColumnIndex The visual column index to start the search from.\n   * @returns {number}\n   */\n  getEndMostColumnIndex(range, visualColumnIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'col', 1);\n    let endMostIndex = visualColumnIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] >= visualColumnIndex) {\n        endMostIndex = indexes[i];\n        break;\n      }\n    }\n    return endMostIndex;\n  }\n\n  /**\n   * Gets the top-most visual row index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualRowIndex The visual row index to start the search from.\n   * @returns {number}\n   */\n  getTopMostRowIndex(range, visualRowIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'row', -1);\n    let topMostIndex = visualRowIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] <= visualRowIndex) {\n        topMostIndex = indexes[i];\n        break;\n      }\n    }\n    return topMostIndex;\n  }\n\n  /**\n   * Gets the bottom-most visual row index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualRowIndex The visual row index to start the search from.\n   * @returns {number}\n   */\n  getBottomMostRowIndex(range, visualRowIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'row', 1);\n    let bottomMostIndex = visualRowIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] >= visualRowIndex) {\n        bottomMostIndex = indexes[i];\n        break;\n      }\n    }\n    return bottomMostIndex;\n  }\n  /**\n   * Shift the merged cell in the direction and by an offset defined in the arguments.\n   *\n   * @param {string} direction `right`, `left`, `up` or `down`.\n   * @param {number} index Index where the change, which caused the shifting took place.\n   * @param {number} count Number of rows/columns added/removed in the preceding action.\n   */\n  shiftCollections(direction, index, count) {\n    const shiftVector = [0, 0];\n    switch (direction) {\n      case 'right':\n        shiftVector[0] += count;\n        break;\n      case 'left':\n        shiftVector[0] -= count;\n        break;\n      case 'down':\n        shiftVector[1] += count;\n        break;\n      case 'up':\n        shiftVector[1] -= count;\n        break;\n      default:\n    }\n    arrayEach(this.mergedCells, currentMerge => {\n      _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, currentMerge);\n      currentMerge.shift(shiftVector, index);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _addMergedCellToMatrix).call(this, currentMerge);\n    });\n    rangeEachReverse(this.mergedCells.length - 1, 0, i => {\n      const currentMerge = this.mergedCells[i];\n      if (currentMerge && currentMerge.removed) {\n        this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);\n        _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, currentMerge);\n      }\n    });\n  }\n\n  /**\n   * Adds a merged cell to the matrix.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to add.\n   */\n}\nfunction _getNonIntersectingIndexes(range, axis) {\n  let scanDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const indexes = new Map();\n  const from = scanDirection === 1 ? range.getTopStartCorner() : range.getBottomEndCorner();\n  const to = scanDirection === 1 ? range.getBottomEndCorner() : range.getTopStartCorner();\n  for (let row = from.row; scanDirection === 1 ? row <= to.row : row >= to.row; row += scanDirection) {\n    for (let column = from.col; scanDirection === 1 ? column <= to.col : column >= to.col; column += scanDirection) {\n      const index = axis === 'row' ? row : column;\n      const mergedCell = this.get(row, column);\n      let lastIndex = index;\n      if (mergedCell) {\n        lastIndex = scanDirection === 1 ? mergedCell[axis] + mergedCell[`${axis}span`] - 1 : mergedCell[axis];\n      }\n      if (!indexes.has(index)) {\n        indexes.set(index, new Set());\n      }\n      indexes.get(index).add(lastIndex);\n    }\n  }\n  return Array.from(new Set(Array.from(indexes.entries()).filter(_ref3 => {\n    let [, set] = _ref3;\n    return set.size === 1;\n  }).flatMap(_ref4 => {\n    let [, set] = _ref4;\n    return Array.from(set);\n  })));\n}\nfunction _addMergedCellToMatrix(mergedCell) {\n  for (let row = mergedCell.row; row < mergedCell.row + mergedCell.rowspan; row++) {\n    for (let col = mergedCell.col; col < mergedCell.col + mergedCell.colspan; col++) {\n      if (!this.mergedCellsMatrix.has(row)) {\n        this.mergedCellsMatrix.set(row, new Map());\n      }\n      this.mergedCellsMatrix.get(row).set(col, mergedCell);\n    }\n  }\n}\n/**\n * Removes a merged cell from the matrix.\n *\n * @param {MergedCellCoords} mergedCell The merged cell to remove.\n */\nfunction _removeMergedCellFromMatrix(mergedCell) {\n  for (let row = mergedCell.row; row < mergedCell.row + mergedCell.rowspan; row++) {\n    for (let col = mergedCell.col; col < mergedCell.col + mergedCell.colspan; col++) {\n      this.mergedCellsMatrix.get(row).delete(col);\n    }\n  }\n}\nexport default MergedCellsCollection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}