{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { addClass, closest, isChildOf, hasClass, outerHeight } from \"../../helpers/dom/element.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { deepClone, deepExtend, isObject } from \"../../helpers/object.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport CommentEditor from \"./commentEditor.mjs\";\nimport DisplaySwitch from \"./displaySwitch.mjs\";\nimport { SEPARATOR } from \"../contextMenu/predefinedItems/index.mjs\";\nimport addEditCommentItem from \"./contextMenuItem/addEditComment.mjs\";\nimport removeCommentItem from \"./contextMenuItem/removeComment.mjs\";\nimport readOnlyCommentItem from \"./contextMenuItem/readOnlyComment.mjs\";\nexport const PLUGIN_KEY = 'comments';\nexport const PLUGIN_PRIORITY = 60;\nexport const META_COMMENT = 'comment';\nexport const META_COMMENT_VALUE = 'value';\nexport const META_STYLE = 'style';\nexport const META_READONLY = 'readOnly';\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\nconst SHORTCUTS_CONTEXT_NAME = `plugin:${PLUGIN_KEY}`;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin Comments\n * @class Comments\n *\n * @description\n * This plugin allows setting and managing cell comments by either an option in the context menu or with the use of\n * the API.\n *\n * To enable the plugin, you'll need to set the comments property of the config object to `true`:\n * ```js\n * comments: true\n * ```\n *\n * or an object with extra predefined plugin config:\n *\n * ```js\n * comments: {\n *   displayDelay: 1000,\n *   readOnly: true,\n *   style: {\n *     width: 300,\n *     height: 100\n *   }\n * }\n * ```\n *\n * To add comments at the table initialization, define the `comment` property in the `cell` config array as in an example below.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   comments: true,\n *   cell: [\n *     {row: 1, col: 1, comment: {value: 'Foo'}},\n *     {row: 2, col: 2, comment: {value: 'Bar'}}\n *   ]\n * });\n *\n * // Access to the Comments plugin instance:\n * const commentsPlugin = hot.getPlugin('comments');\n *\n * // Manage comments programmatically:\n * commentsPlugin.setCommentAtCell(1, 6, 'Comment contents');\n * commentsPlugin.showAtCell(1, 6);\n * commentsPlugin.removeCommentAtCell(1, 6);\n *\n * // You can also set range once and use proper methods:\n * commentsPlugin.setRange({from: {row: 1, col: 6}});\n * commentsPlugin.setComment('Comment contents');\n * commentsPlugin.show();\n * commentsPlugin.removeComment();\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   comments={true}\n *   cell={[\n *     {row: 1, col: 1, comment: {value: 'Foo'}},\n *     {row: 2, col: 2, comment: {value: 'Bar'}}\n *   ]}\n * />\n *\n * // Access to the Comments plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const commentsPlugin = hot.getPlugin('comments');\n *\n * // Manage comments programmatically:\n * commentsPlugin.setCommentAtCell(1, 6, 'Comment contents');\n * commentsPlugin.showAtCell(1, 6);\n * commentsPlugin.removeCommentAtCell(1, 6);\n *\n * // You can also set range once and use proper methods:\n * commentsPlugin.setRange({from: {row: 1, col: 6}});\n * commentsPlugin.setComment('Comment contents');\n * commentsPlugin.show();\n * commentsPlugin.removeComment();\n * ```\n * :::\n */\nvar _editor = /*#__PURE__*/new WeakMap();\nvar _displaySwitch = /*#__PURE__*/new WeakMap();\nvar _preventEditorAutoSwitch = /*#__PURE__*/new WeakMap();\nvar _preventEditorHiding = /*#__PURE__*/new WeakMap();\nvar _cellBelowCursor = /*#__PURE__*/new WeakMap();\nvar _commentValueBeforeSave = /*#__PURE__*/new WeakMap();\nvar _Comments_brand = /*#__PURE__*/new WeakSet();\nexport class Comments extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `mousedown` event callback.\n     *\n     * @param {MouseEvent} event The `mousedown` event.\n     */\n    _classPrivateMethodInitSpec(this, _Comments_brand);\n    /**\n     * Current cell range, an object with `from` property, with `row` and `col` properties (e.q. `{from: {row: 1, col: 6}}`).\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"range\", {});\n    /**\n     * Instance of {@link CommentEditor}.\n     *\n     * @private\n     * @type {CommentEditor}\n     */\n    _classPrivateFieldInitSpec(this, _editor, null);\n    /**\n     * Instance of {@link DisplaySwitch}.\n     *\n     * @private\n     * @type {DisplaySwitch}\n     */\n    _classPrivateFieldInitSpec(this, _displaySwitch, null);\n    /**\n     * Prevents showing/hiding editor that reacts on the logic triggered by the \"mouseover\" events.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventEditorAutoSwitch, false);\n    /**\n     * Prevents hiding editor when the table viewport is scrolled and that scroll is triggered by the\n     * keyboard shortcut that insert or edits the comment.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventEditorHiding, false);\n    /**\n     * The flag that allows processing mousedown event correctly when comments editor is triggered.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _cellBelowCursor, null);\n    /**\n     * Holds the comment value before it's actually saved to the cell meta.\n     *\n     * @private\n     * @type {string}\n     */\n    _classPrivateFieldInitSpec(this, _commentValueBeforeSave, '');\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Comments#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    if (!_classPrivateFieldGet(_editor, this)) {\n      _classPrivateFieldSet(_editor, this, new CommentEditor(this.hot.rootDocument, this.hot.isRtl()));\n      _classPrivateFieldGet(_editor, this).addLocalHook('resize', function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return _assertClassBrand(_Comments_brand, _this, _onEditorResize).call(_this, ...args);\n      });\n    }\n    if (!_classPrivateFieldGet(_displaySwitch, this)) {\n      _classPrivateFieldSet(_displaySwitch, this, new DisplaySwitch(this.getDisplayDelaySetting()));\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => this.addToContextMenu(options));\n    this.addHook('afterRenderer', (TD, row, col, prop, value, cellProperties) => _assertClassBrand(_Comments_brand, this, _onAfterRenderer).call(this, TD, cellProperties));\n    this.addHook('afterScroll', () => _assertClassBrand(_Comments_brand, this, _onAfterScroll).call(this));\n    this.addHook('afterBeginEditing', () => this.hide());\n    this.addHook('afterDocumentKeyDown', event => _assertClassBrand(_Comments_brand, this, _onAfterDocumentKeyDown).call(this, event));\n    _classPrivateFieldGet(_displaySwitch, this).addLocalHook('hide', () => this.hide());\n    _classPrivateFieldGet(_displaySwitch, this).addLocalHook('show', (row, col) => this.showAtCell(row, col));\n    this.registerShortcuts();\n    this.registerListeners();\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *   - [`comments`](@/api/options.md#comments)\n   */\n  updatePlugin() {\n    _classPrivateFieldGet(_displaySwitch, this).updateDelay(this.getDisplayDelaySetting());\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.unregisterShortcuts();\n    super.disablePlugin();\n  }\n\n  /**\n   * Register shortcuts responsible for toggling context menu.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const manager = this.hot.getShortcutManager();\n    const gridContext = manager.getContext('grid');\n    const pluginContext = manager.addContext(SHORTCUTS_CONTEXT_NAME);\n    gridContext.addShortcut({\n      keys: [['Control', 'Alt', 'M']],\n      callback: () => {\n        const range = this.hot.getSelectedRangeLast();\n        _classPrivateFieldSet(_preventEditorHiding, this, true);\n        this.hot.scrollToFocusedCell(() => {\n          this.setRange(range);\n          this.show();\n          this.focusEditor();\n          manager.setActiveContextName(SHORTCUTS_CONTEXT_NAME);\n          this.hot._registerTimeout(() => {\n            _classPrivateFieldSet(_preventEditorHiding, this, false);\n          });\n        });\n      },\n      stopPropagation: true,\n      runOnlyIf: () => {\n        var _this$hot$getSelected;\n        return ((_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight.isCell()) && !_classPrivateFieldGet(_editor, this).isVisible();\n      },\n      group: SHORTCUTS_GROUP\n    });\n    pluginContext.addShortcut({\n      keys: [['Escape']],\n      callback: () => {\n        _classPrivateFieldGet(_editor, this).setValue(_classPrivateFieldGet(_commentValueBeforeSave, this));\n        this.hide();\n        manager.setActiveContextName('grid');\n      },\n      runOnlyIf: () => _classPrivateFieldGet(_editor, this).isVisible() && _classPrivateFieldGet(_editor, this).isFocused(),\n      group: SHORTCUTS_GROUP\n    });\n    pluginContext.addShortcut({\n      keys: [['Control/Meta', 'Enter']],\n      callback: () => {\n        this.hide();\n        manager.setActiveContextName('grid');\n      },\n      runOnlyIf: () => _classPrivateFieldGet(_editor, this).isVisible() && _classPrivateFieldGet(_editor, this).isFocused(),\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for toggling context menu.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    this.hot.getShortcutManager().getContext('grid').removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n\n  /**\n   * Registers all necessary DOM listeners.\n   *\n   * @private\n   */\n  registerListeners() {\n    const {\n      rootDocument\n    } = this.hot;\n    const editorElement = this.getEditorInputElement();\n    this.eventManager.addEventListener(rootDocument, 'mouseover', event => _assertClassBrand(_Comments_brand, this, _onMouseOver).call(this, event));\n    this.eventManager.addEventListener(rootDocument, 'mousedown', event => _assertClassBrand(_Comments_brand, this, _onMouseDown).call(this, event));\n    this.eventManager.addEventListener(rootDocument, 'mouseup', () => _assertClassBrand(_Comments_brand, this, _onMouseUp).call(this));\n    this.eventManager.addEventListener(editorElement, 'focus', () => _assertClassBrand(_Comments_brand, this, _onEditorFocus).call(this));\n    this.eventManager.addEventListener(editorElement, 'blur', () => _assertClassBrand(_Comments_brand, this, _onEditorBlur).call(this));\n  }\n\n  /**\n   * Sets the current cell range to be able to use general methods like {@link Comments#setComment}, {@link Comments#removeComment}, {@link Comments#show}.\n   *\n   * @param {object} range Object with `from` property, each with `row` and `col` properties.\n   */\n  setRange(range) {\n    this.range = range;\n  }\n\n  /**\n   * Clears the currently selected cell.\n   */\n  clearRange() {\n    this.range = {};\n  }\n\n  /**\n   * Checks if the event target is a cell containing a comment.\n   *\n   * @private\n   * @param {Event} event DOM event.\n   * @returns {boolean}\n   */\n  targetIsCellWithComment(event) {\n    const closestCell = closest(event.target, 'TD', 'TBODY');\n    return !!(closestCell && hasClass(closestCell, 'htCommentCell') && closest(closestCell, [this.hot.rootElement]));\n  }\n\n  /**\n   * Checks if the event target is a comment textarea.\n   *\n   * @private\n   * @param {Event} event DOM event.\n   * @returns {boolean}\n   */\n  targetIsCommentTextArea(event) {\n    return this.getEditorInputElement() === event.target;\n  }\n\n  /**\n   * Sets a comment for a cell according to the previously set range (see {@link Comments#setRange}).\n   *\n   * @param {string} value Comment contents.\n   */\n  setComment(value) {\n    if (!this.range.from) {\n      throw new Error('Before using this method, first set cell range (hot.getPlugin(\"comment\").setRange())');\n    }\n    const editorValue = _classPrivateFieldGet(_editor, this).getValue();\n    let comment = '';\n    if (value !== null && value !== undefined) {\n      comment = value;\n    } else if (editorValue !== null && editorValue !== undefined) {\n      comment = editorValue;\n    }\n    const row = this.range.from.row;\n    const col = this.range.from.col;\n    this.updateCommentMeta(row, col, {\n      [META_COMMENT_VALUE]: comment\n    });\n    this.hot.render();\n  }\n\n  /**\n   * Sets a comment for a specified cell.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} value Comment contents.\n   */\n  setCommentAtCell(row, column, value) {\n    this.setRange({\n      from: this.hot._createCellCoords(row, column)\n    });\n    this.setComment(value);\n  }\n\n  /**\n   * Removes a comment from a cell according to previously set range (see {@link Comments#setRange}).\n   *\n   * @param {boolean} [forceRender=true] If set to `true`, the table will be re-rendered at the end of the operation.\n   */\n  removeComment() {\n    let forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!this.range.from) {\n      throw new Error('Before using this method, first set cell range (hot.getPlugin(\"comment\").setRange())');\n    }\n    this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT);\n    if (forceRender) {\n      this.hot.render();\n    }\n    this.hide();\n  }\n\n  /**\n   * Removes a comment from a specified cell.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [forceRender=true] If `true`, the table will be re-rendered at the end of the operation.\n   */\n  removeCommentAtCell(row, column) {\n    let forceRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    this.setRange({\n      from: this.hot._createCellCoords(row, column)\n    });\n    this.removeComment(forceRender);\n  }\n\n  /**\n   * Gets comment from a cell according to previously set range (see {@link Comments#setRange}).\n   *\n   * @returns {string|undefined} Returns a content of the comment.\n   */\n  getComment() {\n    const row = this.range.from.row;\n    const column = this.range.from.col;\n    return this.getCommentMeta(row, column, META_COMMENT_VALUE);\n  }\n\n  /**\n   * Gets comment from a cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string|undefined} Returns a content of the comment.\n   */\n  getCommentAtCell(row, column) {\n    return this.getCommentMeta(row, column, META_COMMENT_VALUE);\n  }\n\n  /**\n   * Shows the comment editor accordingly to the previously set range (see {@link Comments#setRange}).\n   *\n   * @returns {boolean} Returns `true` if comment editor was shown.\n   */\n  show() {\n    var _ref;\n    if (!this.range.from) {\n      throw new Error('Before using this method, first set cell range (hot.getPlugin(\"comment\").setRange())');\n    }\n    const {\n      from: {\n        row,\n        col\n      }\n    } = this.range;\n    if (row < 0 || row > this.hot.countSourceRows() - 1 || col < 0 || col > this.hot.countSourceCols() - 1) {\n      return false;\n    }\n    const meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);\n    _classPrivateFieldGet(_displaySwitch, this).cancelHiding();\n    _classPrivateFieldGet(_editor, this).setValue((_ref = meta[META_COMMENT] ? meta[META_COMMENT][META_COMMENT_VALUE] : null) !== null && _ref !== void 0 ? _ref : '');\n    _classPrivateFieldGet(_editor, this).show();\n    this.refreshEditor(true);\n    return true;\n  }\n\n  /**\n   * Shows comment editor according to cell coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean} Returns `true` if comment editor was shown.\n   */\n  showAtCell(row, column) {\n    this.setRange({\n      from: this.hot._createCellCoords(row, column)\n    });\n    return this.show();\n  }\n\n  /**\n   * Hides the comment editor.\n   */\n  hide() {\n    _classPrivateFieldGet(_editor, this).hide();\n  }\n\n  /**\n   * Refreshes comment editor position and styling.\n   *\n   * @param {boolean} [force=false] If `true` then recalculation will be forced.\n   */\n  refreshEditor() {\n    var _renderableRow, _renderableColumn;\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!force && (!this.range.from || !_classPrivateFieldGet(_editor, this).isVisible())) {\n      return;\n    }\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const {\n      row: visualRow,\n      col: visualColumn\n    } = this.range.from;\n    let renderableRow = rowIndexMapper.getRenderableFromVisualIndex(visualRow);\n    let renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(visualColumn);\n    // Used when the requested row is hidden, and the editor needs to be positioned on the previous row's coords.\n    const targetingPreviousRow = renderableRow === null;\n\n    // Reset the editor position to (0, 0) so the opening direction calculation wouldn't be influenced by its\n    // previous position\n    _classPrivateFieldGet(_editor, this).setPosition(0, 0);\n    if (renderableRow === null) {\n      renderableRow = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(visualRow, -1));\n    }\n    if (renderableColumn === null) {\n      renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(visualColumn, -1));\n    }\n    const isBeforeRenderedRows = renderableRow === null;\n    const isBeforeRenderedColumns = renderableColumn === null;\n    renderableRow = (_renderableRow = renderableRow) !== null && _renderableRow !== void 0 ? _renderableRow : 0;\n    renderableColumn = (_renderableColumn = renderableColumn) !== null && _renderableColumn !== void 0 ? _renderableColumn : 0;\n    const {\n      rootWindow,\n      view: {\n        _wt: wt\n      }\n    } = this.hot;\n    const {\n      wtTable\n    } = wt;\n    // TODO: Probably using `hot.getCell` would be the best. However, case for showing comment editor for hidden cell\n    // potentially should be removed with that change (currently a test for it is passing).\n    const TD = wt.getCell({\n      row: renderableRow,\n      col: renderableColumn\n    }, true);\n    const commentStyle = this.getCommentMeta(visualRow, visualColumn, META_STYLE);\n    if (commentStyle) {\n      _classPrivateFieldGet(_editor, this).setSize(commentStyle.width, commentStyle.height);\n    } else {\n      _classPrivateFieldGet(_editor, this).resetSize();\n    }\n    const lastColWidth = isBeforeRenderedColumns ? 0 : wtTable.getStretchedColumnWidth(renderableColumn);\n    const lastRowHeight = targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;\n    const {\n      left,\n      top,\n      width: cellWidth,\n      height: cellHeight\n    } = TD.getBoundingClientRect();\n    const {\n      width: editorWidth,\n      height: editorHeight\n    } = _classPrivateFieldGet(_editor, this).getSize();\n    const {\n      innerWidth,\n      innerHeight\n    } = this.hot.rootWindow;\n    const documentElement = this.hot.rootDocument.documentElement;\n    let x = left + rootWindow.scrollX + lastColWidth;\n    let y = top + rootWindow.scrollY + lastRowHeight;\n    if (this.hot.isRtl()) {\n      x -= editorWidth + lastColWidth;\n    }\n\n    // flip to the right or left the comments editor position when it goes out of browser viewport\n    if (this.hot.isLtr() && left + cellWidth + editorWidth > innerWidth) {\n      x = left + rootWindow.scrollX - editorWidth - 1;\n    } else if (this.hot.isRtl() && x < -(documentElement.scrollWidth - documentElement.clientWidth)) {\n      x = left + rootWindow.scrollX + lastColWidth + 1;\n    }\n    if (top + editorHeight > innerHeight) {\n      y -= editorHeight - cellHeight + 1;\n    }\n    _classPrivateFieldGet(_editor, this).setPosition(x, y);\n    _classPrivateFieldGet(_editor, this).setReadOnlyState(this.getCommentMeta(visualRow, visualColumn, META_READONLY));\n    _classPrivateFieldGet(_editor, this).observeSize();\n  }\n\n  /**\n   * Focuses the comments editor element.\n   */\n  focusEditor() {\n    _classPrivateFieldGet(_editor, this).focus();\n  }\n\n  /**\n   * Sets or update the comment-related cell meta.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} metaObject Object defining all the comment-related meta information.\n   */\n  updateCommentMeta(row, column, metaObject) {\n    const oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];\n    let newComment;\n    if (oldComment) {\n      newComment = deepClone(oldComment);\n      deepExtend(newComment, metaObject);\n    } else {\n      newComment = metaObject;\n    }\n    this.hot.setCellMeta(row, column, META_COMMENT, newComment);\n  }\n\n  /**\n   * Gets the comment related meta information.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} property Cell meta property.\n   * @returns {Mixed}\n   */\n  getCommentMeta(row, column, property) {\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if (!cellMeta[META_COMMENT]) {\n      return undefined;\n    }\n    return cellMeta[META_COMMENT][property];\n  }\n  /**\n   * Add Comments plugin options to the Context Menu.\n   *\n   * @private\n   * @param {object} options The menu options.\n   */\n  addToContextMenu(options) {\n    options.items.push({\n      name: SEPARATOR\n    }, addEditCommentItem(this), removeCommentItem(this), readOnlyCommentItem(this));\n  }\n\n  /**\n   * Get `displayDelay` setting of comment plugin.\n   *\n   * @private\n   * @returns {number|undefined}\n   */\n  getDisplayDelaySetting() {\n    const commentSetting = this.hot.getSettings()[PLUGIN_KEY];\n    if (isObject(commentSetting)) {\n      return commentSetting.displayDelay;\n    }\n  }\n\n  /**\n   * Gets the editors input element.\n   *\n   * @private\n   * @returns {HTMLTextAreaElement}\n   */\n  getEditorInputElement() {\n    return _classPrivateFieldGet(_editor, this).getInputElement();\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    (_classPrivateFieldGet2 = _classPrivateFieldGet(_editor, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.destroy();\n    (_classPrivateFieldGet3 = _classPrivateFieldGet(_displaySwitch, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.destroy();\n    super.destroy();\n  }\n}\nfunction _onMouseDown(event) {\n  if (!this.hot.view || !this.hot.view._wt) {\n    return;\n  }\n  if (!_classPrivateFieldGet(_preventEditorAutoSwitch, this) && !this.targetIsCommentTextArea(event)) {\n    const eventCell = closest(event.target, 'TD', 'TBODY');\n    let coordinates = null;\n    if (eventCell) {\n      coordinates = this.hot.getCoords(eventCell);\n    }\n    if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {\n      this.hide();\n    }\n  }\n}\n/**\n * `mouseover` event callback.\n *\n * @param {MouseEvent} event The `mouseover` event.\n */\nfunction _onMouseOver(event) {\n  const {\n    rootDocument\n  } = this.hot;\n  if (_classPrivateFieldGet(_preventEditorAutoSwitch, this) || _classPrivateFieldGet(_editor, this).isFocused() || hasClass(event.target, 'wtBorder') || _classPrivateFieldGet(_cellBelowCursor, this) === event.target || !_classPrivateFieldGet(_editor, this)) {\n    return;\n  }\n  _classPrivateFieldSet(_cellBelowCursor, this, rootDocument.elementFromPoint(event.clientX, event.clientY));\n  if (this.targetIsCellWithComment(event)) {\n    const range = this.hot._createCellRange(this.hot.getCoords(event.target));\n    _classPrivateFieldGet(_displaySwitch, this).show(range);\n  } else if (isChildOf(event.target, rootDocument) && !this.targetIsCommentTextArea(event)) {\n    _classPrivateFieldGet(_displaySwitch, this).hide();\n  }\n}\n/**\n * `mouseup` event callback.\n */\nfunction _onMouseUp() {\n  _classPrivateFieldSet(_preventEditorAutoSwitch, this, false);\n}\n/**\n * The `afterRenderer` hook callback.\n *\n * @param {HTMLTableCellElement} TD The rendered `TD` element.\n * @param {object} cellProperties The rendered cell's property object.\n */\nfunction _onAfterRenderer(TD, cellProperties) {\n  if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {\n    addClass(TD, cellProperties.commentedCellClassName);\n  }\n}\n/**\n * Hook observer the \"blur\" event from the comments editor element. The hook clears the\n * editor content and gives back the keyboard shortcuts control by switching to the \"grid\" context.\n */\nfunction _onEditorBlur() {\n  _classPrivateFieldSet(_commentValueBeforeSave, this, '');\n  this.hot.getShortcutManager().setActiveContextName('grid');\n  this.setComment();\n}\n/**\n * Hook observer the \"focus\" event from the comments editor element. The hook takes the control of\n * the keyboard shortcuts by switching the context to plugins one.\n */\nfunction _onEditorFocus() {\n  _classPrivateFieldSet(_commentValueBeforeSave, this, this.getComment());\n  this.hot.listen();\n  this.hot.getShortcutManager().setActiveContextName(SHORTCUTS_CONTEXT_NAME);\n}\n/**\n * Saves the comments editor size to the cell meta.\n *\n * @param {number} width The new width of the editor.\n * @param {number} height The new height of the editor.\n */\nfunction _onEditorResize(width, height) {\n  this.updateCommentMeta(this.range.from.row, this.range.from.col, {\n    [META_STYLE]: {\n      width,\n      height\n    }\n  });\n}\n/**\n * Observes the pressed keys and if there is already opened the comment editor prevents open\n * the table editor into the fast edit mode.\n *\n * @param {Event} event The keydown event.\n */\nfunction _onAfterDocumentKeyDown(event) {\n  if (_classPrivateFieldGet(_editor, this).isVisible()) {\n    stopImmediatePropagation(event);\n  }\n}\n/**\n * Observes the changes in the scroll position if triggered it hides the comment editor.\n */\nfunction _onAfterScroll() {\n  if (!_classPrivateFieldGet(_preventEditorHiding, this)) {\n    this.hide();\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldSet","s","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","addClass","closest","isChildOf","hasClass","outerHeight","stopImmediatePropagation","deepClone","deepExtend","isObject","BasePlugin","CommentEditor","DisplaySwitch","SEPARATOR","addEditCommentItem","removeCommentItem","readOnlyCommentItem","PLUGIN_KEY","PLUGIN_PRIORITY","META_COMMENT","META_COMMENT_VALUE","META_STYLE","META_READONLY","SHORTCUTS_GROUP","SHORTCUTS_CONTEXT_NAME","_editor","WeakMap","_displaySwitch","_preventEditorAutoSwitch","_preventEditorHiding","_cellBelowCursor","_commentValueBeforeSave","_Comments_brand","WeakSet","Comments","constructor","isEnabled","hot","getSettings","enablePlugin","_this","enabled","rootDocument","isRtl","addLocalHook","_len","args","Array","_key","_onEditorResize","getDisplayDelaySetting","addHook","options","addToContextMenu","TD","row","col","prop","cellProperties","_onAfterRenderer","_onAfterScroll","hide","event","_onAfterDocumentKeyDown","showAtCell","registerShortcuts","registerListeners","updatePlugin","updateDelay","disablePlugin","unregisterShortcuts","manager","getShortcutManager","gridContext","getContext","pluginContext","addContext","addShortcut","keys","callback","range","getSelectedRangeLast","scrollToFocusedCell","setRange","show","focusEditor","setActiveContextName","_registerTimeout","stopPropagation","runOnlyIf","_this$hot$getSelected","highlight","isCell","isVisible","group","setValue","isFocused","removeShortcutsByGroup","editorElement","getEditorInputElement","eventManager","addEventListener","_onMouseOver","_onMouseDown","_onMouseUp","_onEditorFocus","_onEditorBlur","clearRange","targetIsCellWithComment","closestCell","target","rootElement","targetIsCommentTextArea","setComment","from","Error","editorValue","getValue","comment","undefined","updateCommentMeta","render","setCommentAtCell","column","_createCellCoords","removeComment","forceRender","setCellMeta","removeCommentAtCell","getComment","getCommentMeta","getCommentAtCell","_ref","countSourceRows","countSourceCols","meta","getCellMeta","cancelHiding","refreshEditor","_renderableRow","_renderableColumn","force","rowIndexMapper","columnIndexMapper","visualRow","visualColumn","renderableRow","getRenderableFromVisualIndex","renderableColumn","targetingPreviousRow","setPosition","getNearestNotHiddenIndex","isBeforeRenderedRows","isBeforeRenderedColumns","rootWindow","view","_wt","wt","wtTable","getCell","commentStyle","setSize","width","height","resetSize","lastColWidth","getStretchedColumnWidth","lastRowHeight","left","top","cellWidth","cellHeight","getBoundingClientRect","editorWidth","editorHeight","getSize","innerWidth","innerHeight","documentElement","x","scrollX","y","scrollY","isLtr","scrollWidth","clientWidth","setReadOnlyState","observeSize","focus","metaObject","oldComment","newComment","property","cellMeta","items","push","name","commentSetting","displayDelay","getInputElement","destroy","_classPrivateFieldGet2","_classPrivateFieldGet3","eventCell","coordinates","getCoords","elementFromPoint","clientX","clientY","_createCellRange","commentedCellClassName","listen"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/comments/comments.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { addClass, closest, isChildOf, hasClass, outerHeight } from \"../../helpers/dom/element.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { deepClone, deepExtend, isObject } from \"../../helpers/object.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport CommentEditor from \"./commentEditor.mjs\";\nimport DisplaySwitch from \"./displaySwitch.mjs\";\nimport { SEPARATOR } from \"../contextMenu/predefinedItems/index.mjs\";\nimport addEditCommentItem from \"./contextMenuItem/addEditComment.mjs\";\nimport removeCommentItem from \"./contextMenuItem/removeComment.mjs\";\nimport readOnlyCommentItem from \"./contextMenuItem/readOnlyComment.mjs\";\nexport const PLUGIN_KEY = 'comments';\nexport const PLUGIN_PRIORITY = 60;\nexport const META_COMMENT = 'comment';\nexport const META_COMMENT_VALUE = 'value';\nexport const META_STYLE = 'style';\nexport const META_READONLY = 'readOnly';\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\nconst SHORTCUTS_CONTEXT_NAME = `plugin:${PLUGIN_KEY}`;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin Comments\n * @class Comments\n *\n * @description\n * This plugin allows setting and managing cell comments by either an option in the context menu or with the use of\n * the API.\n *\n * To enable the plugin, you'll need to set the comments property of the config object to `true`:\n * ```js\n * comments: true\n * ```\n *\n * or an object with extra predefined plugin config:\n *\n * ```js\n * comments: {\n *   displayDelay: 1000,\n *   readOnly: true,\n *   style: {\n *     width: 300,\n *     height: 100\n *   }\n * }\n * ```\n *\n * To add comments at the table initialization, define the `comment` property in the `cell` config array as in an example below.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   comments: true,\n *   cell: [\n *     {row: 1, col: 1, comment: {value: 'Foo'}},\n *     {row: 2, col: 2, comment: {value: 'Bar'}}\n *   ]\n * });\n *\n * // Access to the Comments plugin instance:\n * const commentsPlugin = hot.getPlugin('comments');\n *\n * // Manage comments programmatically:\n * commentsPlugin.setCommentAtCell(1, 6, 'Comment contents');\n * commentsPlugin.showAtCell(1, 6);\n * commentsPlugin.removeCommentAtCell(1, 6);\n *\n * // You can also set range once and use proper methods:\n * commentsPlugin.setRange({from: {row: 1, col: 6}});\n * commentsPlugin.setComment('Comment contents');\n * commentsPlugin.show();\n * commentsPlugin.removeComment();\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   comments={true}\n *   cell={[\n *     {row: 1, col: 1, comment: {value: 'Foo'}},\n *     {row: 2, col: 2, comment: {value: 'Bar'}}\n *   ]}\n * />\n *\n * // Access to the Comments plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const commentsPlugin = hot.getPlugin('comments');\n *\n * // Manage comments programmatically:\n * commentsPlugin.setCommentAtCell(1, 6, 'Comment contents');\n * commentsPlugin.showAtCell(1, 6);\n * commentsPlugin.removeCommentAtCell(1, 6);\n *\n * // You can also set range once and use proper methods:\n * commentsPlugin.setRange({from: {row: 1, col: 6}});\n * commentsPlugin.setComment('Comment contents');\n * commentsPlugin.show();\n * commentsPlugin.removeComment();\n * ```\n * :::\n */\nvar _editor = /*#__PURE__*/new WeakMap();\nvar _displaySwitch = /*#__PURE__*/new WeakMap();\nvar _preventEditorAutoSwitch = /*#__PURE__*/new WeakMap();\nvar _preventEditorHiding = /*#__PURE__*/new WeakMap();\nvar _cellBelowCursor = /*#__PURE__*/new WeakMap();\nvar _commentValueBeforeSave = /*#__PURE__*/new WeakMap();\nvar _Comments_brand = /*#__PURE__*/new WeakSet();\nexport class Comments extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `mousedown` event callback.\n     *\n     * @param {MouseEvent} event The `mousedown` event.\n     */\n    _classPrivateMethodInitSpec(this, _Comments_brand);\n    /**\n     * Current cell range, an object with `from` property, with `row` and `col` properties (e.q. `{from: {row: 1, col: 6}}`).\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"range\", {});\n    /**\n     * Instance of {@link CommentEditor}.\n     *\n     * @private\n     * @type {CommentEditor}\n     */\n    _classPrivateFieldInitSpec(this, _editor, null);\n    /**\n     * Instance of {@link DisplaySwitch}.\n     *\n     * @private\n     * @type {DisplaySwitch}\n     */\n    _classPrivateFieldInitSpec(this, _displaySwitch, null);\n    /**\n     * Prevents showing/hiding editor that reacts on the logic triggered by the \"mouseover\" events.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventEditorAutoSwitch, false);\n    /**\n     * Prevents hiding editor when the table viewport is scrolled and that scroll is triggered by the\n     * keyboard shortcut that insert or edits the comment.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventEditorHiding, false);\n    /**\n     * The flag that allows processing mousedown event correctly when comments editor is triggered.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _cellBelowCursor, null);\n    /**\n     * Holds the comment value before it's actually saved to the cell meta.\n     *\n     * @private\n     * @type {string}\n     */\n    _classPrivateFieldInitSpec(this, _commentValueBeforeSave, '');\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Comments#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    if (!_classPrivateFieldGet(_editor, this)) {\n      _classPrivateFieldSet(_editor, this, new CommentEditor(this.hot.rootDocument, this.hot.isRtl()));\n      _classPrivateFieldGet(_editor, this).addLocalHook('resize', function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return _assertClassBrand(_Comments_brand, _this, _onEditorResize).call(_this, ...args);\n      });\n    }\n    if (!_classPrivateFieldGet(_displaySwitch, this)) {\n      _classPrivateFieldSet(_displaySwitch, this, new DisplaySwitch(this.getDisplayDelaySetting()));\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => this.addToContextMenu(options));\n    this.addHook('afterRenderer', (TD, row, col, prop, value, cellProperties) => _assertClassBrand(_Comments_brand, this, _onAfterRenderer).call(this, TD, cellProperties));\n    this.addHook('afterScroll', () => _assertClassBrand(_Comments_brand, this, _onAfterScroll).call(this));\n    this.addHook('afterBeginEditing', () => this.hide());\n    this.addHook('afterDocumentKeyDown', event => _assertClassBrand(_Comments_brand, this, _onAfterDocumentKeyDown).call(this, event));\n    _classPrivateFieldGet(_displaySwitch, this).addLocalHook('hide', () => this.hide());\n    _classPrivateFieldGet(_displaySwitch, this).addLocalHook('show', (row, col) => this.showAtCell(row, col));\n    this.registerShortcuts();\n    this.registerListeners();\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *   - [`comments`](@/api/options.md#comments)\n   */\n  updatePlugin() {\n    _classPrivateFieldGet(_displaySwitch, this).updateDelay(this.getDisplayDelaySetting());\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.unregisterShortcuts();\n    super.disablePlugin();\n  }\n\n  /**\n   * Register shortcuts responsible for toggling context menu.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const manager = this.hot.getShortcutManager();\n    const gridContext = manager.getContext('grid');\n    const pluginContext = manager.addContext(SHORTCUTS_CONTEXT_NAME);\n    gridContext.addShortcut({\n      keys: [['Control', 'Alt', 'M']],\n      callback: () => {\n        const range = this.hot.getSelectedRangeLast();\n        _classPrivateFieldSet(_preventEditorHiding, this, true);\n        this.hot.scrollToFocusedCell(() => {\n          this.setRange(range);\n          this.show();\n          this.focusEditor();\n          manager.setActiveContextName(SHORTCUTS_CONTEXT_NAME);\n          this.hot._registerTimeout(() => {\n            _classPrivateFieldSet(_preventEditorHiding, this, false);\n          });\n        });\n      },\n      stopPropagation: true,\n      runOnlyIf: () => {\n        var _this$hot$getSelected;\n        return ((_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight.isCell()) && !_classPrivateFieldGet(_editor, this).isVisible();\n      },\n      group: SHORTCUTS_GROUP\n    });\n    pluginContext.addShortcut({\n      keys: [['Escape']],\n      callback: () => {\n        _classPrivateFieldGet(_editor, this).setValue(_classPrivateFieldGet(_commentValueBeforeSave, this));\n        this.hide();\n        manager.setActiveContextName('grid');\n      },\n      runOnlyIf: () => _classPrivateFieldGet(_editor, this).isVisible() && _classPrivateFieldGet(_editor, this).isFocused(),\n      group: SHORTCUTS_GROUP\n    });\n    pluginContext.addShortcut({\n      keys: [['Control/Meta', 'Enter']],\n      callback: () => {\n        this.hide();\n        manager.setActiveContextName('grid');\n      },\n      runOnlyIf: () => _classPrivateFieldGet(_editor, this).isVisible() && _classPrivateFieldGet(_editor, this).isFocused(),\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for toggling context menu.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    this.hot.getShortcutManager().getContext('grid').removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n\n  /**\n   * Registers all necessary DOM listeners.\n   *\n   * @private\n   */\n  registerListeners() {\n    const {\n      rootDocument\n    } = this.hot;\n    const editorElement = this.getEditorInputElement();\n    this.eventManager.addEventListener(rootDocument, 'mouseover', event => _assertClassBrand(_Comments_brand, this, _onMouseOver).call(this, event));\n    this.eventManager.addEventListener(rootDocument, 'mousedown', event => _assertClassBrand(_Comments_brand, this, _onMouseDown).call(this, event));\n    this.eventManager.addEventListener(rootDocument, 'mouseup', () => _assertClassBrand(_Comments_brand, this, _onMouseUp).call(this));\n    this.eventManager.addEventListener(editorElement, 'focus', () => _assertClassBrand(_Comments_brand, this, _onEditorFocus).call(this));\n    this.eventManager.addEventListener(editorElement, 'blur', () => _assertClassBrand(_Comments_brand, this, _onEditorBlur).call(this));\n  }\n\n  /**\n   * Sets the current cell range to be able to use general methods like {@link Comments#setComment}, {@link Comments#removeComment}, {@link Comments#show}.\n   *\n   * @param {object} range Object with `from` property, each with `row` and `col` properties.\n   */\n  setRange(range) {\n    this.range = range;\n  }\n\n  /**\n   * Clears the currently selected cell.\n   */\n  clearRange() {\n    this.range = {};\n  }\n\n  /**\n   * Checks if the event target is a cell containing a comment.\n   *\n   * @private\n   * @param {Event} event DOM event.\n   * @returns {boolean}\n   */\n  targetIsCellWithComment(event) {\n    const closestCell = closest(event.target, 'TD', 'TBODY');\n    return !!(closestCell && hasClass(closestCell, 'htCommentCell') && closest(closestCell, [this.hot.rootElement]));\n  }\n\n  /**\n   * Checks if the event target is a comment textarea.\n   *\n   * @private\n   * @param {Event} event DOM event.\n   * @returns {boolean}\n   */\n  targetIsCommentTextArea(event) {\n    return this.getEditorInputElement() === event.target;\n  }\n\n  /**\n   * Sets a comment for a cell according to the previously set range (see {@link Comments#setRange}).\n   *\n   * @param {string} value Comment contents.\n   */\n  setComment(value) {\n    if (!this.range.from) {\n      throw new Error('Before using this method, first set cell range (hot.getPlugin(\"comment\").setRange())');\n    }\n    const editorValue = _classPrivateFieldGet(_editor, this).getValue();\n    let comment = '';\n    if (value !== null && value !== undefined) {\n      comment = value;\n    } else if (editorValue !== null && editorValue !== undefined) {\n      comment = editorValue;\n    }\n    const row = this.range.from.row;\n    const col = this.range.from.col;\n    this.updateCommentMeta(row, col, {\n      [META_COMMENT_VALUE]: comment\n    });\n    this.hot.render();\n  }\n\n  /**\n   * Sets a comment for a specified cell.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} value Comment contents.\n   */\n  setCommentAtCell(row, column, value) {\n    this.setRange({\n      from: this.hot._createCellCoords(row, column)\n    });\n    this.setComment(value);\n  }\n\n  /**\n   * Removes a comment from a cell according to previously set range (see {@link Comments#setRange}).\n   *\n   * @param {boolean} [forceRender=true] If set to `true`, the table will be re-rendered at the end of the operation.\n   */\n  removeComment() {\n    let forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!this.range.from) {\n      throw new Error('Before using this method, first set cell range (hot.getPlugin(\"comment\").setRange())');\n    }\n    this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT);\n    if (forceRender) {\n      this.hot.render();\n    }\n    this.hide();\n  }\n\n  /**\n   * Removes a comment from a specified cell.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [forceRender=true] If `true`, the table will be re-rendered at the end of the operation.\n   */\n  removeCommentAtCell(row, column) {\n    let forceRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    this.setRange({\n      from: this.hot._createCellCoords(row, column)\n    });\n    this.removeComment(forceRender);\n  }\n\n  /**\n   * Gets comment from a cell according to previously set range (see {@link Comments#setRange}).\n   *\n   * @returns {string|undefined} Returns a content of the comment.\n   */\n  getComment() {\n    const row = this.range.from.row;\n    const column = this.range.from.col;\n    return this.getCommentMeta(row, column, META_COMMENT_VALUE);\n  }\n\n  /**\n   * Gets comment from a cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string|undefined} Returns a content of the comment.\n   */\n  getCommentAtCell(row, column) {\n    return this.getCommentMeta(row, column, META_COMMENT_VALUE);\n  }\n\n  /**\n   * Shows the comment editor accordingly to the previously set range (see {@link Comments#setRange}).\n   *\n   * @returns {boolean} Returns `true` if comment editor was shown.\n   */\n  show() {\n    var _ref;\n    if (!this.range.from) {\n      throw new Error('Before using this method, first set cell range (hot.getPlugin(\"comment\").setRange())');\n    }\n    const {\n      from: {\n        row,\n        col\n      }\n    } = this.range;\n    if (row < 0 || row > this.hot.countSourceRows() - 1 || col < 0 || col > this.hot.countSourceCols() - 1) {\n      return false;\n    }\n    const meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);\n    _classPrivateFieldGet(_displaySwitch, this).cancelHiding();\n    _classPrivateFieldGet(_editor, this).setValue((_ref = meta[META_COMMENT] ? meta[META_COMMENT][META_COMMENT_VALUE] : null) !== null && _ref !== void 0 ? _ref : '');\n    _classPrivateFieldGet(_editor, this).show();\n    this.refreshEditor(true);\n    return true;\n  }\n\n  /**\n   * Shows comment editor according to cell coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean} Returns `true` if comment editor was shown.\n   */\n  showAtCell(row, column) {\n    this.setRange({\n      from: this.hot._createCellCoords(row, column)\n    });\n    return this.show();\n  }\n\n  /**\n   * Hides the comment editor.\n   */\n  hide() {\n    _classPrivateFieldGet(_editor, this).hide();\n  }\n\n  /**\n   * Refreshes comment editor position and styling.\n   *\n   * @param {boolean} [force=false] If `true` then recalculation will be forced.\n   */\n  refreshEditor() {\n    var _renderableRow, _renderableColumn;\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!force && (!this.range.from || !_classPrivateFieldGet(_editor, this).isVisible())) {\n      return;\n    }\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const {\n      row: visualRow,\n      col: visualColumn\n    } = this.range.from;\n    let renderableRow = rowIndexMapper.getRenderableFromVisualIndex(visualRow);\n    let renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(visualColumn);\n    // Used when the requested row is hidden, and the editor needs to be positioned on the previous row's coords.\n    const targetingPreviousRow = renderableRow === null;\n\n    // Reset the editor position to (0, 0) so the opening direction calculation wouldn't be influenced by its\n    // previous position\n    _classPrivateFieldGet(_editor, this).setPosition(0, 0);\n    if (renderableRow === null) {\n      renderableRow = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(visualRow, -1));\n    }\n    if (renderableColumn === null) {\n      renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(visualColumn, -1));\n    }\n    const isBeforeRenderedRows = renderableRow === null;\n    const isBeforeRenderedColumns = renderableColumn === null;\n    renderableRow = (_renderableRow = renderableRow) !== null && _renderableRow !== void 0 ? _renderableRow : 0;\n    renderableColumn = (_renderableColumn = renderableColumn) !== null && _renderableColumn !== void 0 ? _renderableColumn : 0;\n    const {\n      rootWindow,\n      view: {\n        _wt: wt\n      }\n    } = this.hot;\n    const {\n      wtTable\n    } = wt;\n    // TODO: Probably using `hot.getCell` would be the best. However, case for showing comment editor for hidden cell\n    // potentially should be removed with that change (currently a test for it is passing).\n    const TD = wt.getCell({\n      row: renderableRow,\n      col: renderableColumn\n    }, true);\n    const commentStyle = this.getCommentMeta(visualRow, visualColumn, META_STYLE);\n    if (commentStyle) {\n      _classPrivateFieldGet(_editor, this).setSize(commentStyle.width, commentStyle.height);\n    } else {\n      _classPrivateFieldGet(_editor, this).resetSize();\n    }\n    const lastColWidth = isBeforeRenderedColumns ? 0 : wtTable.getStretchedColumnWidth(renderableColumn);\n    const lastRowHeight = targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;\n    const {\n      left,\n      top,\n      width: cellWidth,\n      height: cellHeight\n    } = TD.getBoundingClientRect();\n    const {\n      width: editorWidth,\n      height: editorHeight\n    } = _classPrivateFieldGet(_editor, this).getSize();\n    const {\n      innerWidth,\n      innerHeight\n    } = this.hot.rootWindow;\n    const documentElement = this.hot.rootDocument.documentElement;\n    let x = left + rootWindow.scrollX + lastColWidth;\n    let y = top + rootWindow.scrollY + lastRowHeight;\n    if (this.hot.isRtl()) {\n      x -= editorWidth + lastColWidth;\n    }\n\n    // flip to the right or left the comments editor position when it goes out of browser viewport\n    if (this.hot.isLtr() && left + cellWidth + editorWidth > innerWidth) {\n      x = left + rootWindow.scrollX - editorWidth - 1;\n    } else if (this.hot.isRtl() && x < -(documentElement.scrollWidth - documentElement.clientWidth)) {\n      x = left + rootWindow.scrollX + lastColWidth + 1;\n    }\n    if (top + editorHeight > innerHeight) {\n      y -= editorHeight - cellHeight + 1;\n    }\n    _classPrivateFieldGet(_editor, this).setPosition(x, y);\n    _classPrivateFieldGet(_editor, this).setReadOnlyState(this.getCommentMeta(visualRow, visualColumn, META_READONLY));\n    _classPrivateFieldGet(_editor, this).observeSize();\n  }\n\n  /**\n   * Focuses the comments editor element.\n   */\n  focusEditor() {\n    _classPrivateFieldGet(_editor, this).focus();\n  }\n\n  /**\n   * Sets or update the comment-related cell meta.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} metaObject Object defining all the comment-related meta information.\n   */\n  updateCommentMeta(row, column, metaObject) {\n    const oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];\n    let newComment;\n    if (oldComment) {\n      newComment = deepClone(oldComment);\n      deepExtend(newComment, metaObject);\n    } else {\n      newComment = metaObject;\n    }\n    this.hot.setCellMeta(row, column, META_COMMENT, newComment);\n  }\n\n  /**\n   * Gets the comment related meta information.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} property Cell meta property.\n   * @returns {Mixed}\n   */\n  getCommentMeta(row, column, property) {\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if (!cellMeta[META_COMMENT]) {\n      return undefined;\n    }\n    return cellMeta[META_COMMENT][property];\n  }\n  /**\n   * Add Comments plugin options to the Context Menu.\n   *\n   * @private\n   * @param {object} options The menu options.\n   */\n  addToContextMenu(options) {\n    options.items.push({\n      name: SEPARATOR\n    }, addEditCommentItem(this), removeCommentItem(this), readOnlyCommentItem(this));\n  }\n\n  /**\n   * Get `displayDelay` setting of comment plugin.\n   *\n   * @private\n   * @returns {number|undefined}\n   */\n  getDisplayDelaySetting() {\n    const commentSetting = this.hot.getSettings()[PLUGIN_KEY];\n    if (isObject(commentSetting)) {\n      return commentSetting.displayDelay;\n    }\n  }\n\n  /**\n   * Gets the editors input element.\n   *\n   * @private\n   * @returns {HTMLTextAreaElement}\n   */\n  getEditorInputElement() {\n    return _classPrivateFieldGet(_editor, this).getInputElement();\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    (_classPrivateFieldGet2 = _classPrivateFieldGet(_editor, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.destroy();\n    (_classPrivateFieldGet3 = _classPrivateFieldGet(_displaySwitch, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.destroy();\n    super.destroy();\n  }\n}\nfunction _onMouseDown(event) {\n  if (!this.hot.view || !this.hot.view._wt) {\n    return;\n  }\n  if (!_classPrivateFieldGet(_preventEditorAutoSwitch, this) && !this.targetIsCommentTextArea(event)) {\n    const eventCell = closest(event.target, 'TD', 'TBODY');\n    let coordinates = null;\n    if (eventCell) {\n      coordinates = this.hot.getCoords(eventCell);\n    }\n    if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {\n      this.hide();\n    }\n  }\n}\n/**\n * `mouseover` event callback.\n *\n * @param {MouseEvent} event The `mouseover` event.\n */\nfunction _onMouseOver(event) {\n  const {\n    rootDocument\n  } = this.hot;\n  if (_classPrivateFieldGet(_preventEditorAutoSwitch, this) || _classPrivateFieldGet(_editor, this).isFocused() || hasClass(event.target, 'wtBorder') || _classPrivateFieldGet(_cellBelowCursor, this) === event.target || !_classPrivateFieldGet(_editor, this)) {\n    return;\n  }\n  _classPrivateFieldSet(_cellBelowCursor, this, rootDocument.elementFromPoint(event.clientX, event.clientY));\n  if (this.targetIsCellWithComment(event)) {\n    const range = this.hot._createCellRange(this.hot.getCoords(event.target));\n    _classPrivateFieldGet(_displaySwitch, this).show(range);\n  } else if (isChildOf(event.target, rootDocument) && !this.targetIsCommentTextArea(event)) {\n    _classPrivateFieldGet(_displaySwitch, this).hide();\n  }\n}\n/**\n * `mouseup` event callback.\n */\nfunction _onMouseUp() {\n  _classPrivateFieldSet(_preventEditorAutoSwitch, this, false);\n}\n/**\n * The `afterRenderer` hook callback.\n *\n * @param {HTMLTableCellElement} TD The rendered `TD` element.\n * @param {object} cellProperties The rendered cell's property object.\n */\nfunction _onAfterRenderer(TD, cellProperties) {\n  if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {\n    addClass(TD, cellProperties.commentedCellClassName);\n  }\n}\n/**\n * Hook observer the \"blur\" event from the comments editor element. The hook clears the\n * editor content and gives back the keyboard shortcuts control by switching to the \"grid\" context.\n */\nfunction _onEditorBlur() {\n  _classPrivateFieldSet(_commentValueBeforeSave, this, '');\n  this.hot.getShortcutManager().setActiveContextName('grid');\n  this.setComment();\n}\n/**\n * Hook observer the \"focus\" event from the comments editor element. The hook takes the control of\n * the keyboard shortcuts by switching the context to plugins one.\n */\nfunction _onEditorFocus() {\n  _classPrivateFieldSet(_commentValueBeforeSave, this, this.getComment());\n  this.hot.listen();\n  this.hot.getShortcutManager().setActiveContextName(SHORTCUTS_CONTEXT_NAME);\n}\n/**\n * Saves the comments editor size to the cell meta.\n *\n * @param {number} width The new width of the editor.\n * @param {number} height The new height of the editor.\n */\nfunction _onEditorResize(width, height) {\n  this.updateCommentMeta(this.range.from.row, this.range.from.col, {\n    [META_STYLE]: {\n      width,\n      height\n    }\n  });\n}\n/**\n * Observes the pressed keys and if there is already opened the comment editor prevents open\n * the table editor into the fast edit mode.\n *\n * @param {Event} event The keydown event.\n */\nfunction _onAfterDocumentKeyDown(event) {\n  if (_classPrivateFieldGet(_editor, this).isVisible()) {\n    stopImmediatePropagation(event);\n  }\n}\n/**\n * Observes the changes in the scroll position if triggered it hides the comment editor.\n */\nfunction _onAfterScroll() {\n  if (!_classPrivateFieldGet(_preventEditorHiding, this)) {\n    this.hide();\n  }\n}"],"mappings":"AAEA,SAASA,2BAA2BA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAAEC,0BAA0B,CAACF,CAAC,EAAEC,CAAC,CAAC,EAAEA,CAAC,CAACE,GAAG,CAACH,CAAC,CAAC;AAAE;AACzF,SAASI,0BAA0BA,CAACJ,CAAC,EAAEK,CAAC,EAAEJ,CAAC,EAAE;EAAEC,0BAA0B,CAACF,CAAC,EAAEK,CAAC,CAAC,EAAEA,CAAC,CAACC,GAAG,CAACN,CAAC,EAAEC,CAAC,CAAC;AAAE;AAC9F,SAASC,0BAA0BA,CAACF,CAAC,EAAEK,CAAC,EAAE;EAAE,IAAIA,CAAC,CAACE,GAAG,CAACP,CAAC,CAAC,EAAE,MAAM,IAAIQ,SAAS,CAAC,gEAAgE,CAAC;AAAE;AACjJ,SAASC,eAAeA,CAACT,CAAC,EAAEU,CAAC,EAAEL,CAAC,EAAE;EAAE,OAAO,CAACK,CAAC,GAAGC,cAAc,CAACD,CAAC,CAAC,KAAKV,CAAC,GAAGY,MAAM,CAACC,cAAc,CAACb,CAAC,EAAEU,CAAC,EAAE;IAAEI,KAAK,EAAET,CAAC;IAAEU,UAAU,EAAE,CAAC,CAAC;IAAEC,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGjB,CAAC,CAACU,CAAC,CAAC,GAAGL,CAAC,EAAEL,CAAC;AAAE;AACnL,SAASW,cAAcA,CAACN,CAAC,EAAE;EAAE,IAAIa,CAAC,GAAGC,YAAY,CAACd,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOa,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAACd,CAAC,EAAEK,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOL,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIL,CAAC,GAAGK,CAAC,CAACe,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKrB,CAAC,EAAE;IAAE,IAAIkB,CAAC,GAAGlB,CAAC,CAACsB,IAAI,CAACjB,CAAC,EAAEK,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOQ,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIV,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKE,CAAC,GAAGa,MAAM,GAAGC,MAAM,EAAEnB,CAAC,CAAC;AAAE;AACvT,SAASoB,qBAAqBA,CAACC,CAAC,EAAEzB,CAAC,EAAES,CAAC,EAAE;EAAE,OAAOgB,CAAC,CAACpB,GAAG,CAACqB,iBAAiB,CAACD,CAAC,EAAEzB,CAAC,CAAC,EAAES,CAAC,CAAC,EAAEA,CAAC;AAAE;AACvF,SAASkB,qBAAqBA,CAACF,CAAC,EAAEzB,CAAC,EAAE;EAAE,OAAOyB,CAAC,CAACG,GAAG,CAACF,iBAAiB,CAACD,CAAC,EAAEzB,CAAC,CAAC,CAAC;AAAE;AAC9E,SAAS0B,iBAAiBA,CAAC3B,CAAC,EAAEK,CAAC,EAAEyB,CAAC,EAAE;EAAE,IAAI,UAAU,IAAI,OAAO9B,CAAC,GAAGA,CAAC,KAAKK,CAAC,GAAGL,CAAC,CAACO,GAAG,CAACF,CAAC,CAAC,EAAE,OAAO0B,SAAS,CAACC,MAAM,GAAG,CAAC,GAAG3B,CAAC,GAAGyB,CAAC;EAAE,MAAM,IAAItB,SAAS,CAAC,+CAA+C,CAAC;AAAE;AAClM,SAASyB,QAAQ,EAAEC,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,+BAA+B;AACnG,SAASC,wBAAwB,QAAQ,6BAA6B;AACtE,SAASC,SAAS,EAAEC,UAAU,EAAEC,QAAQ,QAAQ,0BAA0B;AAC1E,SAASC,UAAU,QAAQ,mBAAmB;AAC9C,OAAOC,aAAa,MAAM,qBAAqB;AAC/C,OAAOC,aAAa,MAAM,qBAAqB;AAC/C,SAASC,SAAS,QAAQ,0CAA0C;AACpE,OAAOC,kBAAkB,MAAM,sCAAsC;AACrE,OAAOC,iBAAiB,MAAM,qCAAqC;AACnE,OAAOC,mBAAmB,MAAM,uCAAuC;AACvE,OAAO,MAAMC,UAAU,GAAG,UAAU;AACpC,OAAO,MAAMC,eAAe,GAAG,EAAE;AACjC,OAAO,MAAMC,YAAY,GAAG,SAAS;AACrC,OAAO,MAAMC,kBAAkB,GAAG,OAAO;AACzC,OAAO,MAAMC,UAAU,GAAG,OAAO;AACjC,OAAO,MAAMC,aAAa,GAAG,UAAU;AACvC,MAAMC,eAAe,GAAGN,UAAU;AAClC,MAAMO,sBAAsB,GAAG,UAAUP,UAAU,EAAE;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIQ,OAAO,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AACxC,IAAIC,cAAc,GAAG,aAAa,IAAID,OAAO,CAAC,CAAC;AAC/C,IAAIE,wBAAwB,GAAG,aAAa,IAAIF,OAAO,CAAC,CAAC;AACzD,IAAIG,oBAAoB,GAAG,aAAa,IAAIH,OAAO,CAAC,CAAC;AACrD,IAAII,gBAAgB,GAAG,aAAa,IAAIJ,OAAO,CAAC,CAAC;AACjD,IAAIK,uBAAuB,GAAG,aAAa,IAAIL,OAAO,CAAC,CAAC;AACxD,IAAIM,eAAe,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AAChD,OAAO,MAAMC,QAAQ,SAASxB,UAAU,CAAC;EACvCyB,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,GAAGpC,SAAS,CAAC;IACnB;AACJ;AACA;AACA;AACA;IACIhC,2BAA2B,CAAC,IAAI,EAAEiE,eAAe,CAAC;IAClD;AACJ;AACA;AACA;AACA;IACIvD,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;IAClC;AACJ;AACA;AACA;AACA;AACA;IACIL,0BAA0B,CAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}