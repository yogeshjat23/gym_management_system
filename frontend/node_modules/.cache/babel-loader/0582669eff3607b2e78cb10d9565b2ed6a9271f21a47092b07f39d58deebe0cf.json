{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { stopImmediatePropagation as _stopImmediatePropagation } from \"./helpers/dom/event.mjs\";\n/**\n * Counter which tracks unregistered listeners (useful for detecting memory leaks).\n *\n * @type {number}\n */\nlet listenersCounter = 0;\n\n/**\n * Event DOM manager for internal use in Handsontable.\n *\n * @class EventManager\n */\nclass EventManager {\n  /**\n   * @param {object} [context=null] An object to which event listeners will be stored.\n   * @private\n   */\n  constructor() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    /**\n     * @type {object}\n     */\n    _defineProperty(this, \"context\", void 0);\n    this.context = context || this;\n\n    // TODO it modify external object. Rethink that.\n    if (!this.context.eventListeners) {\n      this.context.eventListeners = []; // TODO perf It would be more performant if every instance of EventManager tracked its own listeners only\n    }\n  }\n\n  /**\n   * Register specified listener (`eventName`) to the element.\n   *\n   * @param {Element} element Target element.\n   * @param {string} eventName Event name.\n   * @param {Function} callback Function which will be called after event occur.\n   * @param {AddEventListenerOptions|boolean} [options] Listener options if object or useCapture if boolean.\n   * @returns {Function} Returns function which you can easily call to remove that event.\n   */\n  addEventListener(element, eventName, callback) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /**\n     * @private\n     * @param {Event} event The event object.\n     */\n    function callbackProxy(event) {\n      callback.call(this, extendEvent(event));\n    }\n    this.context.eventListeners.push({\n      element,\n      event: eventName,\n      callback,\n      callbackProxy,\n      options,\n      eventManager: this\n    });\n    element.addEventListener(eventName, callbackProxy, options);\n    listenersCounter += 1;\n    return () => {\n      this.removeEventListener(element, eventName, callback);\n    };\n  }\n\n  /**\n   * Remove the event listener previously registered.\n   *\n   * @param {Element} element Target element.\n   * @param {string} eventName Event name.\n   * @param {Function} callback Function to remove from the event target. It must be the same as during registration listener.\n   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.\n   */\n  removeEventListener(element, eventName, callback) {\n    let onlyOwnEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let len = this.context.eventListeners.length;\n    let tmpEvent;\n    while (len) {\n      len -= 1;\n      tmpEvent = this.context.eventListeners[len];\n      if (tmpEvent.event === eventName && tmpEvent.element === element) {\n        if (callback && callback !== tmpEvent.callback) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        // TODO rethink that, main bulk is that it needs multi instances to handle same context, but with a different scopes.\n        // TODO I suppose much more efficient way will be comparing string with scope id, or any similar approach.\n        if (onlyOwnEvents && tmpEvent.eventManager !== this) {\n          continue;\n        }\n        this.context.eventListeners.splice(len, 1);\n        tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, tmpEvent.options);\n        listenersCounter -= 1;\n      }\n    }\n  }\n\n  /**\n   * Clear all previously registered events.\n   *\n   * @private\n   * @since 0.15.0-beta3\n   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.\n   */\n  clearEvents() {\n    let onlyOwnEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.context) {\n      return;\n    }\n    let len = this.context.eventListeners.length;\n    while (len) {\n      len -= 1;\n      const event = this.context.eventListeners[len];\n      if (onlyOwnEvents && event.eventManager !== this) {\n        continue;\n      }\n      this.context.eventListeners.splice(len, 1);\n      event.element.removeEventListener(event.event, event.callbackProxy, event.options);\n      listenersCounter -= 1;\n    }\n  }\n\n  /**\n   * Clear all previously registered events.\n   */\n  clear() {\n    this.clearEvents();\n  }\n\n  /**\n   * Destroy instance of EventManager, clearing all events of the context.\n   */\n  destroy() {\n    this.clearEvents();\n    this.context = null;\n  }\n\n  /**\n   * Destroy instance of EventManager, clearing only the own events.\n   */\n  destroyWithOwnEventsOnly() {\n    this.clearEvents(true);\n    this.context = null;\n  }\n\n  /**\n   * Trigger event at the specified target element.\n   *\n   * @param {Element} element Target element.\n   * @param {string} eventName Event name.\n   */\n  fireEvent(element, eventName) {\n    let rootDocument = element.document;\n    let rootWindow = element;\n    if (!rootDocument) {\n      rootDocument = element.ownerDocument ? element.ownerDocument : element;\n      rootWindow = rootDocument.defaultView;\n    }\n    const options = {\n      bubbles: true,\n      cancelable: eventName !== 'mousemove',\n      view: rootWindow,\n      detail: 0,\n      screenX: 0,\n      screenY: 0,\n      clientX: 1,\n      clientY: 1,\n      ctrlKey: false,\n      altKey: false,\n      shiftKey: false,\n      metaKey: false,\n      button: 0,\n      relatedTarget: undefined\n    };\n    let event;\n    if (rootDocument.createEvent) {\n      event = rootDocument.createEvent('MouseEvents');\n      event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || rootDocument.body.parentNode);\n    } else {\n      event = rootDocument.createEventObject();\n    }\n    if (element.dispatchEvent) {\n      element.dispatchEvent(event);\n    } else {\n      element.fireEvent(`on${eventName}`, event);\n    }\n  }\n}\n\n/**\n * @private\n * @param {Event} event The event object.\n * @returns {Event}\n */\nfunction extendEvent(event) {\n  const nativeStopImmediatePropagation = event.stopImmediatePropagation;\n  event.stopImmediatePropagation = function () {\n    nativeStopImmediatePropagation.apply(this);\n    _stopImmediatePropagation(this);\n  };\n  return event;\n}\nexport default EventManager;\n\n/**\n * @private\n * @returns {number}\n */\nexport function getListenersCounter() {\n  return listenersCounter;\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","stopImmediatePropagation","_stopImmediatePropagation","listenersCounter","EventManager","constructor","context","arguments","length","undefined","eventListeners","addEventListener","element","eventName","callback","options","callbackProxy","event","extendEvent","push","eventManager","removeEventListener","onlyOwnEvents","len","tmpEvent","splice","clearEvents","clear","destroy","destroyWithOwnEventsOnly","fireEvent","rootDocument","document","rootWindow","ownerDocument","defaultView","bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","createEvent","initMouseEvent","body","parentNode","createEventObject","dispatchEvent","nativeStopImmediatePropagation","apply","getListenersCounter"],"sources":["D:/gym-project/frontend/node_modules/handsontable/eventManager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { stopImmediatePropagation as _stopImmediatePropagation } from \"./helpers/dom/event.mjs\";\n/**\n * Counter which tracks unregistered listeners (useful for detecting memory leaks).\n *\n * @type {number}\n */\nlet listenersCounter = 0;\n\n/**\n * Event DOM manager for internal use in Handsontable.\n *\n * @class EventManager\n */\nclass EventManager {\n  /**\n   * @param {object} [context=null] An object to which event listeners will be stored.\n   * @private\n   */\n  constructor() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    /**\n     * @type {object}\n     */\n    _defineProperty(this, \"context\", void 0);\n    this.context = context || this;\n\n    // TODO it modify external object. Rethink that.\n    if (!this.context.eventListeners) {\n      this.context.eventListeners = []; // TODO perf It would be more performant if every instance of EventManager tracked its own listeners only\n    }\n  }\n\n  /**\n   * Register specified listener (`eventName`) to the element.\n   *\n   * @param {Element} element Target element.\n   * @param {string} eventName Event name.\n   * @param {Function} callback Function which will be called after event occur.\n   * @param {AddEventListenerOptions|boolean} [options] Listener options if object or useCapture if boolean.\n   * @returns {Function} Returns function which you can easily call to remove that event.\n   */\n  addEventListener(element, eventName, callback) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /**\n     * @private\n     * @param {Event} event The event object.\n     */\n    function callbackProxy(event) {\n      callback.call(this, extendEvent(event));\n    }\n    this.context.eventListeners.push({\n      element,\n      event: eventName,\n      callback,\n      callbackProxy,\n      options,\n      eventManager: this\n    });\n    element.addEventListener(eventName, callbackProxy, options);\n    listenersCounter += 1;\n    return () => {\n      this.removeEventListener(element, eventName, callback);\n    };\n  }\n\n  /**\n   * Remove the event listener previously registered.\n   *\n   * @param {Element} element Target element.\n   * @param {string} eventName Event name.\n   * @param {Function} callback Function to remove from the event target. It must be the same as during registration listener.\n   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.\n   */\n  removeEventListener(element, eventName, callback) {\n    let onlyOwnEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let len = this.context.eventListeners.length;\n    let tmpEvent;\n    while (len) {\n      len -= 1;\n      tmpEvent = this.context.eventListeners[len];\n      if (tmpEvent.event === eventName && tmpEvent.element === element) {\n        if (callback && callback !== tmpEvent.callback) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        // TODO rethink that, main bulk is that it needs multi instances to handle same context, but with a different scopes.\n        // TODO I suppose much more efficient way will be comparing string with scope id, or any similar approach.\n        if (onlyOwnEvents && tmpEvent.eventManager !== this) {\n          continue;\n        }\n        this.context.eventListeners.splice(len, 1);\n        tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, tmpEvent.options);\n        listenersCounter -= 1;\n      }\n    }\n  }\n\n  /**\n   * Clear all previously registered events.\n   *\n   * @private\n   * @since 0.15.0-beta3\n   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.\n   */\n  clearEvents() {\n    let onlyOwnEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.context) {\n      return;\n    }\n    let len = this.context.eventListeners.length;\n    while (len) {\n      len -= 1;\n      const event = this.context.eventListeners[len];\n      if (onlyOwnEvents && event.eventManager !== this) {\n        continue;\n      }\n      this.context.eventListeners.splice(len, 1);\n      event.element.removeEventListener(event.event, event.callbackProxy, event.options);\n      listenersCounter -= 1;\n    }\n  }\n\n  /**\n   * Clear all previously registered events.\n   */\n  clear() {\n    this.clearEvents();\n  }\n\n  /**\n   * Destroy instance of EventManager, clearing all events of the context.\n   */\n  destroy() {\n    this.clearEvents();\n    this.context = null;\n  }\n\n  /**\n   * Destroy instance of EventManager, clearing only the own events.\n   */\n  destroyWithOwnEventsOnly() {\n    this.clearEvents(true);\n    this.context = null;\n  }\n\n  /**\n   * Trigger event at the specified target element.\n   *\n   * @param {Element} element Target element.\n   * @param {string} eventName Event name.\n   */\n  fireEvent(element, eventName) {\n    let rootDocument = element.document;\n    let rootWindow = element;\n    if (!rootDocument) {\n      rootDocument = element.ownerDocument ? element.ownerDocument : element;\n      rootWindow = rootDocument.defaultView;\n    }\n    const options = {\n      bubbles: true,\n      cancelable: eventName !== 'mousemove',\n      view: rootWindow,\n      detail: 0,\n      screenX: 0,\n      screenY: 0,\n      clientX: 1,\n      clientY: 1,\n      ctrlKey: false,\n      altKey: false,\n      shiftKey: false,\n      metaKey: false,\n      button: 0,\n      relatedTarget: undefined\n    };\n    let event;\n    if (rootDocument.createEvent) {\n      event = rootDocument.createEvent('MouseEvents');\n      event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || rootDocument.body.parentNode);\n    } else {\n      event = rootDocument.createEventObject();\n    }\n    if (element.dispatchEvent) {\n      element.dispatchEvent(event);\n    } else {\n      element.fireEvent(`on${eventName}`, event);\n    }\n  }\n}\n\n/**\n * @private\n * @param {Event} event The event object.\n * @returns {Event}\n */\nfunction extendEvent(event) {\n  const nativeStopImmediatePropagation = event.stopImmediatePropagation;\n  event.stopImmediatePropagation = function () {\n    nativeStopImmediatePropagation.apply(this);\n    _stopImmediatePropagation(this);\n  };\n  return event;\n}\nexport default EventManager;\n\n/**\n * @private\n * @returns {number}\n */\nexport function getListenersCounter() {\n  return listenersCounter;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}