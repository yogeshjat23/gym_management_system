{"ast":null,"code":"import { align, getAlignmentClasses, checkSelectionConsistency, markLabelAsSelected } from \"../utils.mjs\";\nimport { KEY as SEPARATOR } from \"./separator.mjs\";\nimport * as C from \"../../../i18n/constants.mjs\";\nexport const KEY = 'alignment';\n\n/**\n * @returns {object}\n */\nexport default function alignmentItem() {\n  return {\n    key: KEY,\n    name() {\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT);\n    },\n    disabled() {\n      if (this.countRows() === 0 || this.countCols() === 0) {\n        return true;\n      }\n      const range = this.getSelectedRangeLast();\n      if (!range) {\n        return true;\n      }\n      if (range.isSingleHeader()) {\n        return true;\n      }\n      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());\n    },\n    submenu: {\n      items: [{\n        key: `${KEY}:left`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htLeft') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htLeft';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:center`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htCenter') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htCenter';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:right`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htRight') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htRight';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:justify`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htJustify') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htJustify';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        name: SEPARATOR\n      }, {\n        key: `${KEY}:top`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_TOP);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htTop') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'vertical';\n          const alignment = 'htTop';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:middle`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htMiddle') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'vertical';\n          const alignment = 'htMiddle';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:bottom`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htBottom') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'vertical';\n          const alignment = 'htBottom';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }]\n    }\n  };\n}","map":{"version":3,"names":["align","getAlignmentClasses","checkSelectionConsistency","markLabelAsSelected","KEY","SEPARATOR","C","alignmentItem","key","name","getTranslatedPhrase","CONTEXTMENU_ITEMS_ALIGNMENT","disabled","countRows","countCols","range","getSelectedRangeLast","isSingleHeader","getSelectedRange","selection","isSelectedByCorner","submenu","items","label","CONTEXTMENU_ITEMS_ALIGNMENT_LEFT","hasClass","row","col","className","getCellMeta","indexOf","callback","selectedRange","stateBefore","type","alignment","runHooks","value","setCellMeta","render","CONTEXTMENU_ITEMS_ALIGNMENT_CENTER","CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT","CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY","CONTEXTMENU_ITEMS_ALIGNMENT_TOP","CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE","CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/contextMenu/predefinedItems/alignment.mjs"],"sourcesContent":["import { align, getAlignmentClasses, checkSelectionConsistency, markLabelAsSelected } from \"../utils.mjs\";\nimport { KEY as SEPARATOR } from \"./separator.mjs\";\nimport * as C from \"../../../i18n/constants.mjs\";\nexport const KEY = 'alignment';\n\n/**\n * @returns {object}\n */\nexport default function alignmentItem() {\n  return {\n    key: KEY,\n    name() {\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT);\n    },\n    disabled() {\n      if (this.countRows() === 0 || this.countCols() === 0) {\n        return true;\n      }\n      const range = this.getSelectedRangeLast();\n      if (!range) {\n        return true;\n      }\n      if (range.isSingleHeader()) {\n        return true;\n      }\n      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());\n    },\n    submenu: {\n      items: [{\n        key: `${KEY}:left`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htLeft') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htLeft';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:center`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htCenter') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htCenter';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:right`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htRight') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htRight';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:justify`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htJustify') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'horizontal';\n          const alignment = 'htJustify';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        name: SEPARATOR\n      }, {\n        key: `${KEY}:top`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_TOP);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htTop') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'vertical';\n          const alignment = 'htTop';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:middle`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htMiddle') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'vertical';\n          const alignment = 'htMiddle';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }, {\n        key: `${KEY}:bottom`,\n        name() {\n          let label = this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);\n          const hasClass = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {\n            const className = this.getCellMeta(row, col).className;\n            if (className && className.indexOf('htBottom') !== -1) {\n              return true;\n            }\n          });\n          if (hasClass) {\n            label = markLabelAsSelected(label);\n          }\n          return label;\n        },\n        callback() {\n          const selectedRange = this.getSelectedRange();\n          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);\n          const type = 'vertical';\n          const alignment = 'htBottom';\n          this.runHooks('beforeCellAlignment', stateBefore, selectedRange, type, alignment);\n          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));\n          this.render();\n        },\n        disabled: false\n      }]\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}