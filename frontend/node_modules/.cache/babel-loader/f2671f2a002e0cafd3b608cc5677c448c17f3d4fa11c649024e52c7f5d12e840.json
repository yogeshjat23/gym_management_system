{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { BaseEditor, EDITOR_STATE } from \"../baseEditor/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { isEdge, isIOS } from \"../../helpers/browser.mjs\";\nimport { addClass, getComputedStyle, isThisHotChild, setCaretPosition, hasClass, removeClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { createInputElementResizer } from \"../../utils/autoResize.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { updateCaretPosition } from \"./caretPositioner.mjs\";\nimport { A11Y_HIDDEN, A11Y_TABINDEX } from \"../../helpers/a11y.mjs\";\nconst EDITOR_VISIBLE_CLASS_NAME = 'ht_editor_visible';\nconst EDITOR_HIDDEN_CLASS_NAME = 'ht_editor_hidden';\nconst SHORTCUTS_GROUP = 'textEditor';\nexport const EDITOR_TYPE = 'text';\n\n/**\n * @private\n * @class TextEditor\n */\nexport class TextEditor extends BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Instance of {@link EventManager}.\n   *\n   * @private\n   * @type {EventManager}\n   */\n\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  constructor(hotInstance) {\n    super(hotInstance);\n    _defineProperty(this, \"eventManager\", new EventManager(this));\n    /**\n     * Autoresize instance. Automagically resizes editor after changes.\n     *\n     * @private\n     * @type {Function}\n     */\n    _defineProperty(this, \"autoResize\", createInputElementResizer(this.hot.rootDocument));\n    /**\n     * An TEXTAREA element.\n     *\n     * @private\n     * @type {HTMLTextAreaElement}\n     */\n    _defineProperty(this, \"TEXTAREA\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaStyle\", void 0);\n    /**\n     * Parent element of the TEXTAREA.\n     *\n     * @private\n     * @type {HTMLDivElement}\n     */\n    _defineProperty(this, \"TEXTAREA_PARENT\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA_PARENT element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaParentStyle\", void 0);\n    /**\n     * Z-index class style for the editor.\n     *\n     * @private\n     * @type {string}\n     */\n    _defineProperty(this, \"layerClass\", void 0);\n    this.eventManager = new EventManager(this);\n    this.createElements();\n    this.bindEvents();\n    this.hot.addHookOnce('afterDestroy', () => this.destroy());\n  }\n\n  /**\n   * Gets current value from editable element.\n   *\n   * @returns {number}\n   */\n  getValue() {\n    return this.TEXTAREA.value;\n  }\n\n  /**\n   * Sets new value into editable element.\n   *\n   * @param {*} newValue The editor value.\n   */\n  setValue(newValue) {\n    this.TEXTAREA.value = newValue;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    this.refreshDimensions(); // need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348\n    this.showEditableElement();\n    this.hot.getShortcutManager().setActiveContextName('editor');\n    this.registerShortcuts();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    this.autoResize.unObserve();\n    if (isThisHotChild(this.hot.rootDocument.activeElement, this.hot.rootElement)) {\n      this.hot.listen(); // don't refocus the table if user focused some cell outside of HT on purpose\n    }\n    this.hideEditableElement();\n    this.unregisterShortcuts();\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    const previousState = this.state;\n    super.prepare(row, col, prop, td, value, cellProperties);\n    if (!cellProperties.readOnly) {\n      this.refreshDimensions(true);\n      const {\n        allowInvalid\n      } = cellProperties;\n      if (allowInvalid && !this.isOpened()) {\n        // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste\n        // functionality work with IME)\n        this.TEXTAREA.value = '';\n      }\n      if (previousState !== EDITOR_STATE.FINISHED && !this.isOpened()) {\n        this.hideEditableElement();\n      }\n    }\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    this.TEXTAREA.value = ''; // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste functionality work with IME).\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Sets focus state on the select element.\n   */\n  focus() {\n    // For IME editor textarea element must be focused using \".select\" method.\n    // Using \".focus\" browser automatically scroll into the focused element which\n    // is undesired effect.\n    this.TEXTAREA.select();\n    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    const {\n      rootDocument\n    } = this.hot;\n    this.TEXTAREA = rootDocument.createElement('TEXTAREA');\n\n    // Makes the element recognizable by Hot as its own\n    // component's element.\n    setAttribute(this.TEXTAREA, [['data-hot-input', ''], A11Y_TABINDEX(-1)]);\n    if (this.hot.getSettings().ariaTags) {\n      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);\n    }\n    addClass(this.TEXTAREA, 'handsontableInput');\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n    this.textareaStyle.overflowY = 'visible';\n    this.TEXTAREA_PARENT = rootDocument.createElement('DIV');\n    addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');\n    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {\n      removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    this.textareaParentStyle = this.TEXTAREA_PARENT.style;\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);\n  }\n\n  /**\n   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.\n   *\n   * @private\n   */\n  hideEditableElement() {\n    if (isEdge()) {\n      this.textareaStyle.textIndent = '-99999px';\n    }\n    this.textareaStyle.overflowY = 'visible';\n    this.textareaParentStyle.opacity = '0';\n    this.textareaParentStyle.height = '1px';\n    removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n  }\n\n  /**\n   * Resets an editable element position.\n   *\n   * @private\n   */\n  showEditableElement() {\n    this.textareaParentStyle.height = '';\n    this.textareaParentStyle.overflow = '';\n    this.textareaParentStyle.position = '';\n    this.textareaParentStyle[this.hot.isRtl() ? 'left' : 'right'] = 'auto';\n    this.textareaParentStyle.opacity = '1';\n    this.textareaStyle.textIndent = '';\n    const childNodes = this.TEXTAREA_PARENT.childNodes;\n    let hasClassHandsontableEditor = false;\n    rangeEach(childNodes.length - 1, index => {\n      const childNode = childNodes[index];\n      if (hasClass(childNode, 'handsontableEditor')) {\n        hasClassHandsontableEditor = true;\n        return false;\n      }\n    });\n    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {\n      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    }\n    if (hasClassHandsontableEditor) {\n      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    } else {\n      this.layerClass = this.getEditedCellsLayerClass();\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n  }\n\n  /**\n   * Refreshes editor's value using source data.\n   *\n   * @private\n   */\n  refreshValue() {\n    const physicalRow = this.hot.toPhysicalRow(this.row);\n    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);\n    this.originalValue = sourceData;\n    this.setValue(sourceData);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Refreshes editor's size and position.\n   *\n   * @private\n   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.\n   */\n  refreshDimensions() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.state !== EDITOR_STATE.EDITING && !force) {\n      return;\n    }\n    this.TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!this.TD) {\n      if (!force) {\n        this.close(); // TODO shouldn't it be this.finishEditing() ?\n      }\n      return;\n    }\n    const {\n      top,\n      start,\n      width,\n      maxWidth,\n      height,\n      maxHeight\n    } = this.getEditedCellRect();\n    this.textareaParentStyle.top = `${top}px`;\n    this.textareaParentStyle[this.hot.isRtl() ? 'right' : 'left'] = `${start}px`;\n    this.showEditableElement();\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;\n    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;\n    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;\n    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);\n    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);\n    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);\n    const finalWidth = width - horizontalPadding;\n    const finalHeight = height - verticalPadding;\n    const finalMaxWidth = maxWidth - horizontalPadding;\n    const finalMaxHeight = maxHeight - verticalPadding;\n    this.autoResize.init(this.TEXTAREA, {\n      minWidth: Math.min(finalWidth, finalMaxWidth),\n      minHeight: Math.min(finalHeight, finalMaxHeight),\n      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n      maxWidth: finalMaxWidth,\n      maxHeight: finalMaxHeight\n    }, true);\n  }\n\n  /**\n   * Binds events and hooks.\n   *\n   * @private\n   */\n  bindEvents() {\n    if (isIOS()) {\n      // on iOS after click \"Done\" the edit isn't hidden by default, so we need to handle it manually.\n      this.eventManager.addEventListener(this.TEXTAREA, 'focusout', () => this.finishEditing(false));\n    }\n    this.addHook('afterScrollHorizontally', () => this.refreshDimensions());\n    this.addHook('afterScrollVertically', () => this.refreshDimensions());\n    this.addHook('afterColumnResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n    this.addHook('afterRowResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n  }\n\n  /**\n   * Ugly hack for autocompleteEditor.\n   *\n   * @private\n   */\n  allowKeyEventPropagation() {}\n\n  /**\n   * Destroys the internal event manager and clears attached hooks.\n   *\n   * @private\n   */\n  destroy() {\n    this.eventManager.destroy();\n    this.clearHooks();\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP\n    };\n    const insertNewLine = () => {\n      this.hot.rootDocument.execCommand('insertText', false, '\\n');\n    };\n    editorContext.addShortcuts([{\n      keys: [['Control', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n      runOnlyIf: event => !this.hot.selection.isMultiple() &&\n      // We trigger a data population for multiple selection.\n      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n      !event.altKey\n    }, {\n      keys: [['Meta', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n      runOnlyIf: () => !this.hot.selection.isMultiple() // We trigger a data population for multiple selection.\n    }, {\n      keys: [['Alt', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      }\n    }, {\n      keys: [['Home']],\n      callback: (event, _ref) => {\n        let [keyName] = _ref;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }, {\n      keys: [['End']],\n      callback: (event, _ref2) => {\n        let [keyName] = _ref2;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","BaseEditor","EDITOR_STATE","EventManager","isEdge","isIOS","addClass","getComputedStyle","isThisHotChild","setCaretPosition","hasClass","removeClass","setAttribute","rangeEach","createInputElementResizer","isDefined","updateCaretPosition","A11Y_HIDDEN","A11Y_TABINDEX","EDITOR_VISIBLE_CLASS_NAME","EDITOR_HIDDEN_CLASS_NAME","SHORTCUTS_GROUP","EDITOR_TYPE","TextEditor","constructor","hotInstance","hot","rootDocument","eventManager","createElements","bindEvents","addHookOnce","destroy","getValue","TEXTAREA","setValue","newValue","open","refreshDimensions","showEditableElement","getShortcutManager","setActiveContextName","registerShortcuts","close","autoResize","unObserve","activeElement","rootElement","listen","hideEditableElement","unregisterShortcuts","prepare","row","col","prop","td","cellProperties","previousState","state","readOnly","allowInvalid","isOpened","FINISHED","beginEditing","newInitialValue","event","VIRGIN","focus","select","length","createElement","getSettings","ariaTags","textareaStyle","style","width","height","overflowY","TEXTAREA_PARENT","layerClass","textareaParentStyle","appendChild","textIndent","opacity","overflow","position","isRtl","childNodes","hasClassHandsontableEditor","index","childNode","getEditedCellsLayerClass","refreshValue","physicalRow","toPhysicalRow","sourceData","getSourceDataAtCell","originalValue","force","arguments","undefined","EDITING","TD","getEditedCell","top","start","maxWidth","maxHeight","getEditedCellRect","cellComputedStyle","rootWindow","fontSize","fontFamily","backgroundColor","textareaComputedStyle","horizontalPadding","parseInt","paddingLeft","paddingRight","verticalPadding","paddingTop","paddingBottom","finalWidth","finalHeight","finalMaxWidth","finalMaxHeight","init","minWidth","Math","min","minHeight","addEventListener","finishEditing","addHook","allowKeyEventPropagation","clearHooks","shortcutManager","editorContext","getContext","contextConfig","runOnlyIf","getSelected","group","insertNewLine","execCommand","addShortcuts","keys","callback","selection","isMultiple","altKey","_ref","keyName","_ref2","removeShortcutsByGroup"],"sources":["D:/gym-project/frontend/node_modules/handsontable/editors/textEditor/textEditor.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { BaseEditor, EDITOR_STATE } from \"../baseEditor/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { isEdge, isIOS } from \"../../helpers/browser.mjs\";\nimport { addClass, getComputedStyle, isThisHotChild, setCaretPosition, hasClass, removeClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { createInputElementResizer } from \"../../utils/autoResize.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { updateCaretPosition } from \"./caretPositioner.mjs\";\nimport { A11Y_HIDDEN, A11Y_TABINDEX } from \"../../helpers/a11y.mjs\";\nconst EDITOR_VISIBLE_CLASS_NAME = 'ht_editor_visible';\nconst EDITOR_HIDDEN_CLASS_NAME = 'ht_editor_hidden';\nconst SHORTCUTS_GROUP = 'textEditor';\nexport const EDITOR_TYPE = 'text';\n\n/**\n * @private\n * @class TextEditor\n */\nexport class TextEditor extends BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Instance of {@link EventManager}.\n   *\n   * @private\n   * @type {EventManager}\n   */\n\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  constructor(hotInstance) {\n    super(hotInstance);\n    _defineProperty(this, \"eventManager\", new EventManager(this));\n    /**\n     * Autoresize instance. Automagically resizes editor after changes.\n     *\n     * @private\n     * @type {Function}\n     */\n    _defineProperty(this, \"autoResize\", createInputElementResizer(this.hot.rootDocument));\n    /**\n     * An TEXTAREA element.\n     *\n     * @private\n     * @type {HTMLTextAreaElement}\n     */\n    _defineProperty(this, \"TEXTAREA\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaStyle\", void 0);\n    /**\n     * Parent element of the TEXTAREA.\n     *\n     * @private\n     * @type {HTMLDivElement}\n     */\n    _defineProperty(this, \"TEXTAREA_PARENT\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA_PARENT element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaParentStyle\", void 0);\n    /**\n     * Z-index class style for the editor.\n     *\n     * @private\n     * @type {string}\n     */\n    _defineProperty(this, \"layerClass\", void 0);\n    this.eventManager = new EventManager(this);\n    this.createElements();\n    this.bindEvents();\n    this.hot.addHookOnce('afterDestroy', () => this.destroy());\n  }\n\n  /**\n   * Gets current value from editable element.\n   *\n   * @returns {number}\n   */\n  getValue() {\n    return this.TEXTAREA.value;\n  }\n\n  /**\n   * Sets new value into editable element.\n   *\n   * @param {*} newValue The editor value.\n   */\n  setValue(newValue) {\n    this.TEXTAREA.value = newValue;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    this.refreshDimensions(); // need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348\n    this.showEditableElement();\n    this.hot.getShortcutManager().setActiveContextName('editor');\n    this.registerShortcuts();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    this.autoResize.unObserve();\n    if (isThisHotChild(this.hot.rootDocument.activeElement, this.hot.rootElement)) {\n      this.hot.listen(); // don't refocus the table if user focused some cell outside of HT on purpose\n    }\n    this.hideEditableElement();\n    this.unregisterShortcuts();\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    const previousState = this.state;\n    super.prepare(row, col, prop, td, value, cellProperties);\n    if (!cellProperties.readOnly) {\n      this.refreshDimensions(true);\n      const {\n        allowInvalid\n      } = cellProperties;\n      if (allowInvalid && !this.isOpened()) {\n        // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste\n        // functionality work with IME)\n        this.TEXTAREA.value = '';\n      }\n      if (previousState !== EDITOR_STATE.FINISHED && !this.isOpened()) {\n        this.hideEditableElement();\n      }\n    }\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    this.TEXTAREA.value = ''; // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste functionality work with IME).\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Sets focus state on the select element.\n   */\n  focus() {\n    // For IME editor textarea element must be focused using \".select\" method.\n    // Using \".focus\" browser automatically scroll into the focused element which\n    // is undesired effect.\n    this.TEXTAREA.select();\n    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    const {\n      rootDocument\n    } = this.hot;\n    this.TEXTAREA = rootDocument.createElement('TEXTAREA');\n\n    // Makes the element recognizable by Hot as its own\n    // component's element.\n    setAttribute(this.TEXTAREA, [['data-hot-input', ''], A11Y_TABINDEX(-1)]);\n    if (this.hot.getSettings().ariaTags) {\n      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);\n    }\n    addClass(this.TEXTAREA, 'handsontableInput');\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n    this.textareaStyle.overflowY = 'visible';\n    this.TEXTAREA_PARENT = rootDocument.createElement('DIV');\n    addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');\n    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {\n      removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    this.textareaParentStyle = this.TEXTAREA_PARENT.style;\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);\n  }\n\n  /**\n   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.\n   *\n   * @private\n   */\n  hideEditableElement() {\n    if (isEdge()) {\n      this.textareaStyle.textIndent = '-99999px';\n    }\n    this.textareaStyle.overflowY = 'visible';\n    this.textareaParentStyle.opacity = '0';\n    this.textareaParentStyle.height = '1px';\n    removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n  }\n\n  /**\n   * Resets an editable element position.\n   *\n   * @private\n   */\n  showEditableElement() {\n    this.textareaParentStyle.height = '';\n    this.textareaParentStyle.overflow = '';\n    this.textareaParentStyle.position = '';\n    this.textareaParentStyle[this.hot.isRtl() ? 'left' : 'right'] = 'auto';\n    this.textareaParentStyle.opacity = '1';\n    this.textareaStyle.textIndent = '';\n    const childNodes = this.TEXTAREA_PARENT.childNodes;\n    let hasClassHandsontableEditor = false;\n    rangeEach(childNodes.length - 1, index => {\n      const childNode = childNodes[index];\n      if (hasClass(childNode, 'handsontableEditor')) {\n        hasClassHandsontableEditor = true;\n        return false;\n      }\n    });\n    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {\n      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    }\n    if (hasClassHandsontableEditor) {\n      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    } else {\n      this.layerClass = this.getEditedCellsLayerClass();\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n  }\n\n  /**\n   * Refreshes editor's value using source data.\n   *\n   * @private\n   */\n  refreshValue() {\n    const physicalRow = this.hot.toPhysicalRow(this.row);\n    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);\n    this.originalValue = sourceData;\n    this.setValue(sourceData);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Refreshes editor's size and position.\n   *\n   * @private\n   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.\n   */\n  refreshDimensions() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.state !== EDITOR_STATE.EDITING && !force) {\n      return;\n    }\n    this.TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!this.TD) {\n      if (!force) {\n        this.close(); // TODO shouldn't it be this.finishEditing() ?\n      }\n      return;\n    }\n    const {\n      top,\n      start,\n      width,\n      maxWidth,\n      height,\n      maxHeight\n    } = this.getEditedCellRect();\n    this.textareaParentStyle.top = `${top}px`;\n    this.textareaParentStyle[this.hot.isRtl() ? 'right' : 'left'] = `${start}px`;\n    this.showEditableElement();\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;\n    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;\n    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;\n    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);\n    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);\n    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);\n    const finalWidth = width - horizontalPadding;\n    const finalHeight = height - verticalPadding;\n    const finalMaxWidth = maxWidth - horizontalPadding;\n    const finalMaxHeight = maxHeight - verticalPadding;\n    this.autoResize.init(this.TEXTAREA, {\n      minWidth: Math.min(finalWidth, finalMaxWidth),\n      minHeight: Math.min(finalHeight, finalMaxHeight),\n      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n      maxWidth: finalMaxWidth,\n      maxHeight: finalMaxHeight\n    }, true);\n  }\n\n  /**\n   * Binds events and hooks.\n   *\n   * @private\n   */\n  bindEvents() {\n    if (isIOS()) {\n      // on iOS after click \"Done\" the edit isn't hidden by default, so we need to handle it manually.\n      this.eventManager.addEventListener(this.TEXTAREA, 'focusout', () => this.finishEditing(false));\n    }\n    this.addHook('afterScrollHorizontally', () => this.refreshDimensions());\n    this.addHook('afterScrollVertically', () => this.refreshDimensions());\n    this.addHook('afterColumnResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n    this.addHook('afterRowResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n  }\n\n  /**\n   * Ugly hack for autocompleteEditor.\n   *\n   * @private\n   */\n  allowKeyEventPropagation() {}\n\n  /**\n   * Destroys the internal event manager and clears attached hooks.\n   *\n   * @private\n   */\n  destroy() {\n    this.eventManager.destroy();\n    this.clearHooks();\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP\n    };\n    const insertNewLine = () => {\n      this.hot.rootDocument.execCommand('insertText', false, '\\n');\n    };\n    editorContext.addShortcuts([{\n      keys: [['Control', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n      runOnlyIf: event => !this.hot.selection.isMultiple() &&\n      // We trigger a data population for multiple selection.\n      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n      !event.altKey\n    }, {\n      keys: [['Meta', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n      runOnlyIf: () => !this.hot.selection.isMultiple() // We trigger a data population for multiple selection.\n    }, {\n      keys: [['Alt', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      }\n    }, {\n      keys: [['Home']],\n      callback: (event, _ref) => {\n        let [keyName] = _ref;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }, {\n      keys: [['End']],\n      callback: (event, _ref2) => {\n        let [keyName] = _ref2;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}