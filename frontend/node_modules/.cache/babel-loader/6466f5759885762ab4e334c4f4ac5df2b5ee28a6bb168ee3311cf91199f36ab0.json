{"ast":null,"code":"import { arrayEach } from \"./array.mjs\";\n/**\n * Generate schema for passed object.\n *\n * @param {Array|object} object An object to analyze.\n * @returns {Array|object}\n */\nexport function duckSchema(object) {\n  let schema;\n  if (Array.isArray(object)) {\n    schema = object.length ? new Array(object.length).fill(null) : [];\n  } else {\n    schema = {};\n    objectEach(object, (value, key) => {\n      if (key === '__children') {\n        return;\n      }\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        schema[key] = duckSchema(value);\n      } else if (Array.isArray(value)) {\n        if (value.length && typeof value[0] === 'object' && !Array.isArray(value[0])) {\n          schema[key] = [duckSchema(value[0])];\n        } else {\n          schema[key] = [];\n        }\n      } else {\n        schema[key] = null;\n      }\n    });\n  }\n  return schema;\n}\n\n/**\n * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.\n * Creates temporary dummy function to call it as constructor.\n * Described in ticket: https://github.com/handsontable/handsontable/pull/516.\n *\n * @param {object} Child The child class.\n * @param {object} Parent The parent class.\n * @returns {object}\n */\nexport function inherit(Child, Parent) {\n  Parent.prototype.constructor = Parent;\n  Child.prototype = new Parent();\n  Child.prototype.constructor = Child;\n  return Child;\n}\n\n/**\n * Perform shallow extend of a target object with extension's own properties.\n *\n * @param {object} target An object that will receive the new properties.\n * @param {object} extension An object containing additional properties to merge into the target.\n * @param {string[]} [writableKeys] An array of keys that are writable to target object.\n * @returns {object}\n */\nexport function extend(target, extension, writableKeys) {\n  const hasWritableKeys = Array.isArray(writableKeys);\n  objectEach(extension, (value, key) => {\n    if (hasWritableKeys === false || writableKeys.includes(key)) {\n      target[key] = value;\n    }\n  });\n  return target;\n}\n\n/**\n * Perform deep extend of a target object with extension's own properties.\n *\n * @param {object} target An object that will receive the new properties.\n * @param {object} extension An object containing additional properties to merge into the target.\n */\nexport function deepExtend(target, extension) {\n  objectEach(extension, (value, key) => {\n    if (extension[key] && typeof extension[key] === 'object') {\n      if (!target[key]) {\n        if (Array.isArray(extension[key])) {\n          target[key] = [];\n        } else if (Object.prototype.toString.call(extension[key]) === '[object Date]') {\n          target[key] = extension[key];\n        } else {\n          target[key] = {};\n        }\n      }\n      deepExtend(target[key], extension[key]);\n    } else {\n      target[key] = extension[key];\n    }\n  });\n}\n\n/**\n * Perform deep clone of an object.\n * WARNING! Only clones JSON properties. Will cause error when `obj` contains a function, Date, etc.\n *\n * @param {object} obj An object that will be cloned.\n * @returns {object}\n */\nexport function deepClone(obj) {\n  if (typeof obj === 'object') {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  return obj;\n}\n\n/**\n * Shallow clone object.\n *\n * @param {object} object An object to clone.\n * @returns {object}\n */\nexport function clone(object) {\n  const result = {};\n  objectEach(object, (value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\n/**\n * Extend the Base object (usually prototype) of the functionality the `mixins` objects.\n *\n * @param {object} Base Base object which will be extended.\n * @param {object} mixins The object of the functionality will be \"copied\".\n * @returns {object}\n */\nexport function mixin(Base) {\n  if (!Base.MIXINS) {\n    Base.MIXINS = [];\n  }\n  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n  arrayEach(mixins, mixinItem => {\n    Base.MIXINS.push(mixinItem.MIXIN_NAME);\n    objectEach(mixinItem, (value, key) => {\n      if (Base.prototype[key] !== undefined) {\n        throw new Error(`Mixin conflict. Property '${key}' already exist and cannot be overwritten.`);\n      }\n      if (typeof value === 'function') {\n        Base.prototype[key] = value;\n      } else {\n        const getter = function _getter(property, initialValue) {\n          const propertyName = `_${property}`;\n          const initValue = newValue => {\n            let result = newValue;\n            if (Array.isArray(result) || isObject(result)) {\n              result = deepClone(result);\n            }\n            return result;\n          };\n          return function () {\n            if (this[propertyName] === undefined) {\n              this[propertyName] = initValue(initialValue);\n            }\n            return this[propertyName];\n          };\n        };\n        const setter = function _setter(property) {\n          const propertyName = `_${property}`;\n          return function (newValue) {\n            this[propertyName] = newValue;\n          };\n        };\n        Object.defineProperty(Base.prototype, key, {\n          get: getter(key, value),\n          set: setter(key),\n          configurable: true\n        });\n      }\n    });\n  });\n  return Base;\n}\n\n/**\n * Checks if two objects or arrays are (deep) equal.\n *\n * @param {object|Array} object1 The first object to compare.\n * @param {object|Array} object2 The second object to compare.\n * @returns {boolean}\n */\nexport function isObjectEqual(object1, object2) {\n  return JSON.stringify(object1) === JSON.stringify(object2);\n}\n\n/**\n * Determines whether given object is a plain Object.\n * Note: String and Array are not plain Objects.\n *\n * @param {*} object An object to check.\n * @returns {boolean}\n */\nexport function isObject(object) {\n  return Object.prototype.toString.call(object) === '[object Object]';\n}\n\n/**\n * @param {object} object The object on which to define the property.\n * @param {string} property The name of the property to be defined or modified.\n * @param {*} value The value associated with the property.\n * @param {object} options The descriptor for the property being defined or modified.\n */\nexport function defineGetter(object, property, value, options) {\n  options.value = value;\n  options.writable = options.writable !== false;\n  options.enumerable = options.enumerable !== false;\n  options.configurable = options.configurable !== false;\n  Object.defineProperty(object, property, options);\n}\n\n/**\n * A specialized version of `.forEach` for objects.\n *\n * @param {object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {object} Returns `object`.\n */\nexport function objectEach(object, iteratee) {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in object) {\n    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {\n      if (iteratee(object[key], key, object) === false) {\n        break;\n      }\n    }\n  }\n  return object;\n}\n\n/**\n * Get object property by its name. Access to sub properties can be achieved by dot notation (e.q. `'foo.bar.baz'`).\n *\n * @param {object} object Object which value will be exported.\n * @param {string} name Object property name.\n * @returns {*}\n */\nexport function getProperty(object, name) {\n  const names = name.split('.');\n  let result = object;\n  objectEach(names, nameItem => {\n    result = result[nameItem];\n    if (result === undefined) {\n      result = undefined;\n      return false;\n    }\n  });\n  return result;\n}\n\n/**\n * Set a property value on the provided object. Works on nested object prop names as well (e.g. `first.name`).\n *\n * @param {object} object Object to work on.\n * @param {string} name Prop name.\n * @param {*} value Value to be assigned at the provided property.\n */\nexport function setProperty(object, name, value) {\n  const names = name.split('.');\n  let workingObject = object;\n  names.forEach((propName, index) => {\n    if (index !== names.length - 1) {\n      if (!hasOwnProperty(workingObject, propName)) {\n        workingObject[propName] = {};\n      }\n      workingObject = workingObject[propName];\n    } else {\n      workingObject[propName] = value;\n    }\n  });\n}\n\n/**\n * Return object length (recursively).\n *\n * @param {*} object Object for which we want get length.\n * @returns {number}\n */\nexport function deepObjectSize(object) {\n  if (!isObject(object)) {\n    return 0;\n  }\n  const recursObjLen = function (obj) {\n    let result = 0;\n    if (isObject(obj)) {\n      objectEach(obj, (value, key) => {\n        if (key === '__children') {\n          return;\n        }\n        result += recursObjLen(value);\n      });\n    } else {\n      result += 1;\n    }\n    return result;\n  };\n  return recursObjLen(object);\n}\n\n/**\n * Create object with property where its value change will be observed.\n *\n * @param {*} [defaultValue=undefined] Default value.\n * @param {string} [propertyToListen='value'] Property to listen.\n * @returns {object}\n */\nexport function createObjectPropListener(defaultValue) {\n  let propertyToListen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';\n  const privateProperty = `_${propertyToListen}`;\n  const holder = {\n    _touched: false,\n    [privateProperty]: defaultValue,\n    isTouched() {\n      return this._touched;\n    }\n  };\n  Object.defineProperty(holder, propertyToListen, {\n    get() {\n      return this[privateProperty];\n    },\n    set(value) {\n      this._touched = true;\n      this[privateProperty] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return holder;\n}\n\n/**\n * Check if at specified `key` there is any value for `object`.\n *\n * @param {object} object Object to search value at specific key.\n * @param {string} key String key to check.\n * @returns {boolean}\n */\nexport function hasOwnProperty(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}","map":{"version":3,"names":["arrayEach","duckSchema","object","schema","Array","isArray","length","fill","objectEach","value","key","inherit","Child","Parent","prototype","constructor","extend","target","extension","writableKeys","hasWritableKeys","includes","deepExtend","Object","toString","call","deepClone","obj","JSON","parse","stringify","clone","result","mixin","Base","MIXINS","_len","arguments","mixins","_key","mixinItem","push","MIXIN_NAME","undefined","Error","getter","_getter","property","initialValue","propertyName","initValue","newValue","isObject","setter","_setter","defineProperty","get","set","configurable","isObjectEqual","object1","object2","defineGetter","options","writable","enumerable","iteratee","hasOwnProperty","getProperty","name","names","split","nameItem","setProperty","workingObject","forEach","propName","index","deepObjectSize","recursObjLen","createObjectPropListener","defaultValue","propertyToListen","privateProperty","holder","_touched","isTouched"],"sources":["D:/gym-project/frontend/node_modules/handsontable/helpers/object.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport { arrayEach } from \"./array.mjs\";\n/**\n * Generate schema for passed object.\n *\n * @param {Array|object} object An object to analyze.\n * @returns {Array|object}\n */\nexport function duckSchema(object) {\n  let schema;\n  if (Array.isArray(object)) {\n    schema = object.length ? new Array(object.length).fill(null) : [];\n  } else {\n    schema = {};\n    objectEach(object, (value, key) => {\n      if (key === '__children') {\n        return;\n      }\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        schema[key] = duckSchema(value);\n      } else if (Array.isArray(value)) {\n        if (value.length && typeof value[0] === 'object' && !Array.isArray(value[0])) {\n          schema[key] = [duckSchema(value[0])];\n        } else {\n          schema[key] = [];\n        }\n      } else {\n        schema[key] = null;\n      }\n    });\n  }\n  return schema;\n}\n\n/**\n * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.\n * Creates temporary dummy function to call it as constructor.\n * Described in ticket: https://github.com/handsontable/handsontable/pull/516.\n *\n * @param {object} Child The child class.\n * @param {object} Parent The parent class.\n * @returns {object}\n */\nexport function inherit(Child, Parent) {\n  Parent.prototype.constructor = Parent;\n  Child.prototype = new Parent();\n  Child.prototype.constructor = Child;\n  return Child;\n}\n\n/**\n * Perform shallow extend of a target object with extension's own properties.\n *\n * @param {object} target An object that will receive the new properties.\n * @param {object} extension An object containing additional properties to merge into the target.\n * @param {string[]} [writableKeys] An array of keys that are writable to target object.\n * @returns {object}\n */\nexport function extend(target, extension, writableKeys) {\n  const hasWritableKeys = Array.isArray(writableKeys);\n  objectEach(extension, (value, key) => {\n    if (hasWritableKeys === false || writableKeys.includes(key)) {\n      target[key] = value;\n    }\n  });\n  return target;\n}\n\n/**\n * Perform deep extend of a target object with extension's own properties.\n *\n * @param {object} target An object that will receive the new properties.\n * @param {object} extension An object containing additional properties to merge into the target.\n */\nexport function deepExtend(target, extension) {\n  objectEach(extension, (value, key) => {\n    if (extension[key] && typeof extension[key] === 'object') {\n      if (!target[key]) {\n        if (Array.isArray(extension[key])) {\n          target[key] = [];\n        } else if (Object.prototype.toString.call(extension[key]) === '[object Date]') {\n          target[key] = extension[key];\n        } else {\n          target[key] = {};\n        }\n      }\n      deepExtend(target[key], extension[key]);\n    } else {\n      target[key] = extension[key];\n    }\n  });\n}\n\n/**\n * Perform deep clone of an object.\n * WARNING! Only clones JSON properties. Will cause error when `obj` contains a function, Date, etc.\n *\n * @param {object} obj An object that will be cloned.\n * @returns {object}\n */\nexport function deepClone(obj) {\n  if (typeof obj === 'object') {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  return obj;\n}\n\n/**\n * Shallow clone object.\n *\n * @param {object} object An object to clone.\n * @returns {object}\n */\nexport function clone(object) {\n  const result = {};\n  objectEach(object, (value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\n/**\n * Extend the Base object (usually prototype) of the functionality the `mixins` objects.\n *\n * @param {object} Base Base object which will be extended.\n * @param {object} mixins The object of the functionality will be \"copied\".\n * @returns {object}\n */\nexport function mixin(Base) {\n  if (!Base.MIXINS) {\n    Base.MIXINS = [];\n  }\n  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n  arrayEach(mixins, mixinItem => {\n    Base.MIXINS.push(mixinItem.MIXIN_NAME);\n    objectEach(mixinItem, (value, key) => {\n      if (Base.prototype[key] !== undefined) {\n        throw new Error(`Mixin conflict. Property '${key}' already exist and cannot be overwritten.`);\n      }\n      if (typeof value === 'function') {\n        Base.prototype[key] = value;\n      } else {\n        const getter = function _getter(property, initialValue) {\n          const propertyName = `_${property}`;\n          const initValue = newValue => {\n            let result = newValue;\n            if (Array.isArray(result) || isObject(result)) {\n              result = deepClone(result);\n            }\n            return result;\n          };\n          return function () {\n            if (this[propertyName] === undefined) {\n              this[propertyName] = initValue(initialValue);\n            }\n            return this[propertyName];\n          };\n        };\n        const setter = function _setter(property) {\n          const propertyName = `_${property}`;\n          return function (newValue) {\n            this[propertyName] = newValue;\n          };\n        };\n        Object.defineProperty(Base.prototype, key, {\n          get: getter(key, value),\n          set: setter(key),\n          configurable: true\n        });\n      }\n    });\n  });\n  return Base;\n}\n\n/**\n * Checks if two objects or arrays are (deep) equal.\n *\n * @param {object|Array} object1 The first object to compare.\n * @param {object|Array} object2 The second object to compare.\n * @returns {boolean}\n */\nexport function isObjectEqual(object1, object2) {\n  return JSON.stringify(object1) === JSON.stringify(object2);\n}\n\n/**\n * Determines whether given object is a plain Object.\n * Note: String and Array are not plain Objects.\n *\n * @param {*} object An object to check.\n * @returns {boolean}\n */\nexport function isObject(object) {\n  return Object.prototype.toString.call(object) === '[object Object]';\n}\n\n/**\n * @param {object} object The object on which to define the property.\n * @param {string} property The name of the property to be defined or modified.\n * @param {*} value The value associated with the property.\n * @param {object} options The descriptor for the property being defined or modified.\n */\nexport function defineGetter(object, property, value, options) {\n  options.value = value;\n  options.writable = options.writable !== false;\n  options.enumerable = options.enumerable !== false;\n  options.configurable = options.configurable !== false;\n  Object.defineProperty(object, property, options);\n}\n\n/**\n * A specialized version of `.forEach` for objects.\n *\n * @param {object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {object} Returns `object`.\n */\nexport function objectEach(object, iteratee) {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in object) {\n    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {\n      if (iteratee(object[key], key, object) === false) {\n        break;\n      }\n    }\n  }\n  return object;\n}\n\n/**\n * Get object property by its name. Access to sub properties can be achieved by dot notation (e.q. `'foo.bar.baz'`).\n *\n * @param {object} object Object which value will be exported.\n * @param {string} name Object property name.\n * @returns {*}\n */\nexport function getProperty(object, name) {\n  const names = name.split('.');\n  let result = object;\n  objectEach(names, nameItem => {\n    result = result[nameItem];\n    if (result === undefined) {\n      result = undefined;\n      return false;\n    }\n  });\n  return result;\n}\n\n/**\n * Set a property value on the provided object. Works on nested object prop names as well (e.g. `first.name`).\n *\n * @param {object} object Object to work on.\n * @param {string} name Prop name.\n * @param {*} value Value to be assigned at the provided property.\n */\nexport function setProperty(object, name, value) {\n  const names = name.split('.');\n  let workingObject = object;\n  names.forEach((propName, index) => {\n    if (index !== names.length - 1) {\n      if (!hasOwnProperty(workingObject, propName)) {\n        workingObject[propName] = {};\n      }\n      workingObject = workingObject[propName];\n    } else {\n      workingObject[propName] = value;\n    }\n  });\n}\n\n/**\n * Return object length (recursively).\n *\n * @param {*} object Object for which we want get length.\n * @returns {number}\n */\nexport function deepObjectSize(object) {\n  if (!isObject(object)) {\n    return 0;\n  }\n  const recursObjLen = function (obj) {\n    let result = 0;\n    if (isObject(obj)) {\n      objectEach(obj, (value, key) => {\n        if (key === '__children') {\n          return;\n        }\n        result += recursObjLen(value);\n      });\n    } else {\n      result += 1;\n    }\n    return result;\n  };\n  return recursObjLen(object);\n}\n\n/**\n * Create object with property where its value change will be observed.\n *\n * @param {*} [defaultValue=undefined] Default value.\n * @param {string} [propertyToListen='value'] Property to listen.\n * @returns {object}\n */\nexport function createObjectPropListener(defaultValue) {\n  let propertyToListen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';\n  const privateProperty = `_${propertyToListen}`;\n  const holder = {\n    _touched: false,\n    [privateProperty]: defaultValue,\n    isTouched() {\n      return this._touched;\n    }\n  };\n  Object.defineProperty(holder, propertyToListen, {\n    get() {\n      return this[privateProperty];\n    },\n    set(value) {\n      this._touched = true;\n      this[privateProperty] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return holder;\n}\n\n/**\n * Check if at specified `key` there is any value for `object`.\n *\n * @param {object} object Object to search value at specific key.\n * @param {string} key String key to check.\n * @returns {boolean}\n */\nexport function hasOwnProperty(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}