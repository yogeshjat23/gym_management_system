{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport CellCoords from \"./../cell/coords.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)\n * that form a [selection range](@/guides/cell-features/selection/selection.md#select-ranges).\n *\n * A single `CellRange` instance represents a single unit of selection\n * that contains either a single cell or multiple adjacent cells.\n *\n * To import the `CellRange` class:\n *\n * ```js\n * import Handsontable, { CellRange } from '/handsontable';\n *\n * // or, using modules\n * import Handsontable, { CellRange } from '/handsontable/base';\n * ```\n */\nvar _isRtl = /*#__PURE__*/new WeakMap();\nclass CellRange {\n  constructor(highlight) {\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    let isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\n     * coordinates object is normalized while assigning.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"highlight\", null);\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change\n     * highlight within a selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"from\", null);\n    /**\n     * End selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"to\", null);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isRtl, false);\n    this.highlight = highlight.clone();\n    this.from = from.clone();\n    this.to = to.clone();\n    _classPrivateFieldSet(_isRtl, this, isRtl);\n  }\n\n  /**\n   * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setHighlight(coords) {\n    this.highlight = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the start of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setFrom(coords) {\n    this.from = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the end of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setTo(coords) {\n    this.to = coords.clone();\n    return this;\n  }\n\n  /**\n   * Checks if the coordinates in your `CellRange` instance are valid\n   * in the context of given table parameters.\n   *\n   * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.\n   *\n   * @param {object} tableParams An object with a defined table size.\n   * @param {number} tableParams.countRows The total number of rows.\n   * @param {number} tableParams.countCols The total number of columns.\n   * @param {number} tableParams.countRowHeaders A number of row headers.\n   * @param {number} tableParams.countColHeaders A number of column headers.\n   * @returns {boolean}\n   */\n  isValid(tableParams) {\n    return this.from.isValid(tableParams) && this.to.isValid(tableParams);\n  }\n\n  /**\n   * Checks if your range is just a single cell or header.\n   *\n   * @returns {boolean}\n   */\n  isSingle() {\n    return this.isSingleCell() || this.isSingleHeader();\n  }\n\n  /**\n   * Checks if your range is just a single cell.\n   *\n   * @returns {boolean}\n   */\n  isSingleCell() {\n    return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range is just a single header.\n   *\n   * @returns {boolean}\n   */\n  isSingleHeader() {\n    return (this.from.row < 0 || this.from.col < 0) && this.from.row === this.to.row && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range covers only headers range (negative coordinates, without any cells).\n   *\n   * @returns {boolean}\n   */\n  isHeader() {\n    if (this.from.isHeader() && this.to.isHeader()) {\n      return true;\n    }\n    return this.from.col < 0 && this.to.col < 0 || this.from.row < 0 && this.to.row < 0;\n  }\n\n  /**\n   * Checks if your range overlaps headers range (negative coordinates).\n   *\n   * @returns {boolean}\n   */\n  containsHeaders() {\n    return this.from.isHeader() || this.to.isHeader();\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, including row headers).\n   *\n   * @returns {number}\n   */\n  getOuterHeight() {\n    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, including column headers).\n   *\n   * @returns {number}\n   */\n  getOuterWidth() {\n    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, excluding row headers).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    // if the selection contains only row headers, return 0\n    if (this.from.row < 0 && this.to.row < 0) {\n      return 0;\n    }\n    const fromRow = Math.max(this.from.row, 0);\n    const toRow = Math.max(this.to.row, 0);\n    return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, excluding column headers).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    // if the selection contains only column headers, return 0\n    if (this.from.col < 0 && this.to.col < 0) {\n      return 0;\n    }\n    const fromCol = Math.max(this.from.col, 0);\n    const toCol = Math.max(this.to.col, 0);\n    return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n  }\n\n  /**\n   * Returns the number of cells within your range (excluding column and row headers).\n   *\n   * @returns {number}\n   */\n  getCellsCount() {\n    return this.getWidth() * this.getHeight();\n  }\n\n  /**\n   * Checks if another set of coordinates (`cellCoords`)\n   * is within the `from` and `to` coordinates of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  includes(cellCoords) {\n    const {\n      row,\n      col\n    } = cellCoords;\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is within your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  includesRange(cellRange) {\n    return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is equal to your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isEqual(cellRange) {\n    return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range.\n   *\n   * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  overlaps(cellRange) {\n    return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Checks if coordinates point is south-east of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isSouthEastOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isSouthEastOf(cellCoords) || this.getOuterBottomRightCorner().isSouthEastOf(cellCoords);\n  }\n\n  /**\n   * Checks if coordinates point is north-west of your range.\n   *\n   * @param {CellRange} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isNorthWestOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isNorthWestOf(cellCoords) || this.getOuterBottomRightCorner().isNorthWestOf(cellCoords);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range horizontally.\n   *\n   * For example: returns `true` if the last column of your range is `5`\n   * and the first column of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingHorizontally(cellRange) {\n    return this.getOuterTopEndCorner().col >= cellRange.getOuterTopStartCorner().col && this.getOuterTopEndCorner().col <= cellRange.getOuterTopEndCorner().col || this.getOuterTopStartCorner().col <= cellRange.getOuterTopEndCorner().col && this.getOuterTopStartCorner().col >= cellRange.getOuterTopStartCorner().col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range vertically.\n   *\n   * For example: returns `true` if the last row of your range is `5`\n   * and the first row of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingVertically(cellRange) {\n    return this.getOuterBottomStartCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomStartCorner().row <= cellRange.getOuterBottomStartCorner().row || this.getOuterTopEndCorner().row <= cellRange.getOuterBottomStartCorner().row && this.getOuterTopEndCorner().row >= cellRange.getOuterTopRightCorner().row;\n  }\n\n  /**\n   * Adds a cell to your range, at `cellCoords` coordinates.\n   *\n   * The `cellCoords` coordinates must exceed a corner of your range.\n   *\n   * @param {CellCoords} cellCoords A new cell's coordinates.\n   * @returns {boolean}\n   */\n  expand(cellCoords) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {\n      this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));\n      this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Expand your range with another range (`expandingRange`).\n   *\n   * @param {CellRange} expandingRange A new range.\n   * @param {boolean} [changeDirection=true] If `true`, the direction of your range is changed to the direction\n   * of the `expandingRange` range.\n   * @returns {boolean}\n   */\n  expandByRange(expandingRange) {\n    let changeDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n      return false;\n    }\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const initialDirection = this.getDirection();\n    const expandingTopStart = expandingRange.getOuterTopStartCorner();\n    const expandingBottomEnd = expandingRange.getOuterBottomEndCorner();\n    const resultTopRow = Math.min(topStart.row, expandingTopStart.row);\n    const resultTopCol = Math.min(topStart.col, expandingTopStart.col);\n    const resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);\n    const resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);\n    const finalFrom = this._createCellCoords(resultTopRow, resultTopCol);\n    const finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);\n    this.from = finalFrom;\n    this.to = finalTo;\n    this.setDirection(initialDirection);\n    if (changeDirection) {\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Gets the direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  getDirection() {\n    if (this.from.isNorthWestOf(this.to)) {\n      // NorthWest - SouthEast\n      return 'NW-SE';\n    } else if (this.from.isNorthEastOf(this.to)) {\n      // NorthEast - SouthWest\n      return 'NE-SW';\n    } else if (this.from.isSouthEastOf(this.to)) {\n      // SouthEast - NorthWest\n      return 'SE-NW';\n    } else if (this.from.isSouthWestOf(this.to)) {\n      // SouthWest - NorthEast\n      return 'SW-NE';\n    }\n  }\n\n  /**\n   * Sets the direction of the selection.\n   *\n   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  setDirection(direction) {\n    switch (direction) {\n      case 'NW-SE':\n        [this.from, this.to] = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n        break;\n      case 'NE-SW':\n        [this.from, this.to] = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n        break;\n      case 'SE-NW':\n        [this.from, this.to] = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n        break;\n      case 'SW-NE':\n        [this.from, this.to] = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the vertical direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n   */\n  getVerticalDirection() {\n    return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n  }\n\n  /**\n   * Gets the horizontal direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n   */\n  getHorizontalDirection() {\n    return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n  }\n\n  /**\n   * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).\n   */\n  flipDirectionVertically() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('SW-NE');\n        break;\n      case 'NE-SW':\n        this.setDirection('SE-NW');\n        break;\n      case 'SE-NW':\n        this.setDirection('NE-SW');\n        break;\n      case 'SW-NE':\n        this.setDirection('NW-SE');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).\n   */\n  flipDirectionHorizontally() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('NE-SW');\n        break;\n      case 'NE-SW':\n        this.setDirection('NW-SE');\n        break;\n      case 'SE-NW':\n        this.setDirection('SW-NE');\n        break;\n      case 'SW-NE':\n        this.setDirection('SE-NW');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top-left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getTopEndCorner() : this.getTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getBottomStartCorner() : this.getBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getTopStartCorner() : this.getTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getBottomEndCorner() : this.getBottomStartCorner();\n  }\n\n  /**\n   * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();\n  }\n\n  /**\n   * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {boolean}\n   */\n  isCorner(coords) {\n    return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Gets the coordinates of a range corner opposite to the provided `coords`.\n   *\n   * For example: if the `coords` coordinates match the bottom-right corner of your range,\n   * the coordinates of the top-left corner of your range are returned.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {CellCoords}\n   */\n  getOppositeCorner(coords) {\n    if (!(coords instanceof CellCoords)) {\n      return false;\n    }\n    if (coords.isEqual(this.getOuterBottomEndCorner())) {\n      return this.getOuterTopStartCorner();\n    } else if (coords.isEqual(this.getOuterTopStartCorner())) {\n      return this.getOuterBottomEndCorner();\n    } else if (coords.isEqual(this.getOuterTopEndCorner())) {\n      return this.getOuterBottomStartCorner();\n    } else if (coords.isEqual(this.getOuterBottomStartCorner())) {\n      return this.getOuterTopEndCorner();\n    }\n  }\n\n  /**\n   * Indicates which borders (top, right, bottom, left) are shared between\n   * your `CellRange`instance and another `range` that's within your range.\n   *\n   * @param {CellRange} range A range to compare with.\n   * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}\n   */\n  getBordersSharedWith(range) {\n    if (!this.includesRange(range)) {\n      return [];\n    }\n    const thisBorders = {\n      top: Math.min(this.from.row, this.to.row),\n      bottom: Math.max(this.from.row, this.to.row),\n      left: Math.min(this.from.col, this.to.col),\n      right: Math.max(this.from.col, this.to.col)\n    };\n    const rangeBorders = {\n      top: Math.min(range.from.row, range.to.row),\n      bottom: Math.max(range.from.row, range.to.row),\n      left: Math.min(range.from.col, range.to.col),\n      right: Math.max(range.from.col, range.to.col)\n    };\n    const result = [];\n    if (thisBorders.top === rangeBorders.top) {\n      result.push('top');\n    }\n    if (thisBorders.right === rangeBorders.right) {\n      result.push(_classPrivateFieldGet(_isRtl, this) ? 'left' : 'right');\n    }\n    if (thisBorders.bottom === rangeBorders.bottom) {\n      result.push('bottom');\n    }\n    if (thisBorders.left === rangeBorders.left) {\n      result.push(_classPrivateFieldGet(_isRtl, this) ? 'right' : 'left');\n    }\n    return result;\n  }\n\n  /**\n   * Gets the coordinates of the inner cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getInner() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets the coordinates of all cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getAll() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (topStart.row === r && topStart.col === c) {\n          out.push(topStart);\n        } else if (bottomEnd.row === r && bottomEnd.col === c) {\n          out.push(bottomEnd);\n        } else {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Runs a callback function on all cells within your range.\n   *\n   * You can break the iteration by returning `false` in the callback function.\n   *\n   * @param {function(number, number): boolean} callback A callback function.\n   */\n  forAll(callback) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        const breakIteration = callback(r, c);\n        if (breakIteration === false) {\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Clones your `CellRange` instance.\n   *\n   * @returns {CellRange}\n   */\n  clone() {\n    return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(_isRtl, this));\n  }\n\n  /**\n   * Converts your `CellRange` instance into an object literal with the following properties:\n   *\n   * - `from`\n   *    - `row`\n   *    - `col`\n   * - `to`\n   *    - `row`\n   *    - `col`\n   *\n   * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.\n   */\n  toObject() {\n    return {\n      from: this.from.toObject(),\n      to: this.to.toObject()\n    };\n  }\n\n  /**\n   * Creates and returns a new instance of the `CellCoords` class.\n   *\n   * The new `CellCoords` instance automatically inherits the LTR/RTL flag\n   * from your `CellRange` instance.\n   *\n   * @private\n   * @param {number} row A row index.\n   * @param {number} column A column index.\n   * @returns {CellCoords}\n   */\n  _createCellCoords(row, column) {\n    return new CellCoords(row, column, _classPrivateFieldGet(_isRtl, this));\n  }\n}\nexport default CellRange;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","n","arguments","length","CellCoords","_isRtl","WeakMap","CellRange","constructor","highlight","from","undefined","to","isRtl","clone","setHighlight","coords","setFrom","setTo","isValid","tableParams","isSingle","isSingleCell","isSingleHeader","row","col","isHeader","containsHeaders","getOuterHeight","Math","max","min","getOuterWidth","getHeight","fromRow","toRow","getWidth","fromCol","toCol","getCellsCount","includes","cellCoords","topStart","getOuterTopStartCorner","bottomEnd","getOuterBottomEndCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","getOuterTopLeftCorner","isNorthWestOf","getOuterBottomRightCorner","isOverlappingHorizontally","getOuterTopEndCorner","isOverlappingVertically","getOuterBottomStartCorner","getOuterTopRightCorner","expand","_createCellCoords","expandByRange","expandingRange","changeDirection","initialDirection","getDirection","expandingTopStart","expandingBottomEnd","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","getOuterBottomLeftCorner","indexOf","getTopStartCorner","normalize","getTopLeftCorner","getTopEndCorner","getBottomEndCorner","getBottomRightCorner","getBottomStartCorner","getTopRightCorner","getBottomLeftCorner","isCorner","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","c","getAll","forAll","callback","breakIteration","toObject","column"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport CellCoords from \"./../cell/coords.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)\n * that form a [selection range](@/guides/cell-features/selection/selection.md#select-ranges).\n *\n * A single `CellRange` instance represents a single unit of selection\n * that contains either a single cell or multiple adjacent cells.\n *\n * To import the `CellRange` class:\n *\n * ```js\n * import Handsontable, { CellRange } from '/handsontable';\n *\n * // or, using modules\n * import Handsontable, { CellRange } from '/handsontable/base';\n * ```\n */\nvar _isRtl = /*#__PURE__*/new WeakMap();\nclass CellRange {\n  constructor(highlight) {\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    let isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\n     * coordinates object is normalized while assigning.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"highlight\", null);\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change\n     * highlight within a selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"from\", null);\n    /**\n     * End selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"to\", null);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isRtl, false);\n    this.highlight = highlight.clone();\n    this.from = from.clone();\n    this.to = to.clone();\n    _classPrivateFieldSet(_isRtl, this, isRtl);\n  }\n\n  /**\n   * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setHighlight(coords) {\n    this.highlight = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the start of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setFrom(coords) {\n    this.from = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the end of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setTo(coords) {\n    this.to = coords.clone();\n    return this;\n  }\n\n  /**\n   * Checks if the coordinates in your `CellRange` instance are valid\n   * in the context of given table parameters.\n   *\n   * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.\n   *\n   * @param {object} tableParams An object with a defined table size.\n   * @param {number} tableParams.countRows The total number of rows.\n   * @param {number} tableParams.countCols The total number of columns.\n   * @param {number} tableParams.countRowHeaders A number of row headers.\n   * @param {number} tableParams.countColHeaders A number of column headers.\n   * @returns {boolean}\n   */\n  isValid(tableParams) {\n    return this.from.isValid(tableParams) && this.to.isValid(tableParams);\n  }\n\n  /**\n   * Checks if your range is just a single cell or header.\n   *\n   * @returns {boolean}\n   */\n  isSingle() {\n    return this.isSingleCell() || this.isSingleHeader();\n  }\n\n  /**\n   * Checks if your range is just a single cell.\n   *\n   * @returns {boolean}\n   */\n  isSingleCell() {\n    return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range is just a single header.\n   *\n   * @returns {boolean}\n   */\n  isSingleHeader() {\n    return (this.from.row < 0 || this.from.col < 0) && this.from.row === this.to.row && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range covers only headers range (negative coordinates, without any cells).\n   *\n   * @returns {boolean}\n   */\n  isHeader() {\n    if (this.from.isHeader() && this.to.isHeader()) {\n      return true;\n    }\n    return this.from.col < 0 && this.to.col < 0 || this.from.row < 0 && this.to.row < 0;\n  }\n\n  /**\n   * Checks if your range overlaps headers range (negative coordinates).\n   *\n   * @returns {boolean}\n   */\n  containsHeaders() {\n    return this.from.isHeader() || this.to.isHeader();\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, including row headers).\n   *\n   * @returns {number}\n   */\n  getOuterHeight() {\n    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, including column headers).\n   *\n   * @returns {number}\n   */\n  getOuterWidth() {\n    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, excluding row headers).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    // if the selection contains only row headers, return 0\n    if (this.from.row < 0 && this.to.row < 0) {\n      return 0;\n    }\n    const fromRow = Math.max(this.from.row, 0);\n    const toRow = Math.max(this.to.row, 0);\n    return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, excluding column headers).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    // if the selection contains only column headers, return 0\n    if (this.from.col < 0 && this.to.col < 0) {\n      return 0;\n    }\n    const fromCol = Math.max(this.from.col, 0);\n    const toCol = Math.max(this.to.col, 0);\n    return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n  }\n\n  /**\n   * Returns the number of cells within your range (excluding column and row headers).\n   *\n   * @returns {number}\n   */\n  getCellsCount() {\n    return this.getWidth() * this.getHeight();\n  }\n\n  /**\n   * Checks if another set of coordinates (`cellCoords`)\n   * is within the `from` and `to` coordinates of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  includes(cellCoords) {\n    const {\n      row,\n      col\n    } = cellCoords;\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is within your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  includesRange(cellRange) {\n    return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is equal to your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isEqual(cellRange) {\n    return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range.\n   *\n   * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  overlaps(cellRange) {\n    return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Checks if coordinates point is south-east of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isSouthEastOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isSouthEastOf(cellCoords) || this.getOuterBottomRightCorner().isSouthEastOf(cellCoords);\n  }\n\n  /**\n   * Checks if coordinates point is north-west of your range.\n   *\n   * @param {CellRange} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isNorthWestOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isNorthWestOf(cellCoords) || this.getOuterBottomRightCorner().isNorthWestOf(cellCoords);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range horizontally.\n   *\n   * For example: returns `true` if the last column of your range is `5`\n   * and the first column of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingHorizontally(cellRange) {\n    return this.getOuterTopEndCorner().col >= cellRange.getOuterTopStartCorner().col && this.getOuterTopEndCorner().col <= cellRange.getOuterTopEndCorner().col || this.getOuterTopStartCorner().col <= cellRange.getOuterTopEndCorner().col && this.getOuterTopStartCorner().col >= cellRange.getOuterTopStartCorner().col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range vertically.\n   *\n   * For example: returns `true` if the last row of your range is `5`\n   * and the first row of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingVertically(cellRange) {\n    return this.getOuterBottomStartCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomStartCorner().row <= cellRange.getOuterBottomStartCorner().row || this.getOuterTopEndCorner().row <= cellRange.getOuterBottomStartCorner().row && this.getOuterTopEndCorner().row >= cellRange.getOuterTopRightCorner().row;\n  }\n\n  /**\n   * Adds a cell to your range, at `cellCoords` coordinates.\n   *\n   * The `cellCoords` coordinates must exceed a corner of your range.\n   *\n   * @param {CellCoords} cellCoords A new cell's coordinates.\n   * @returns {boolean}\n   */\n  expand(cellCoords) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {\n      this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));\n      this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Expand your range with another range (`expandingRange`).\n   *\n   * @param {CellRange} expandingRange A new range.\n   * @param {boolean} [changeDirection=true] If `true`, the direction of your range is changed to the direction\n   * of the `expandingRange` range.\n   * @returns {boolean}\n   */\n  expandByRange(expandingRange) {\n    let changeDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n      return false;\n    }\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const initialDirection = this.getDirection();\n    const expandingTopStart = expandingRange.getOuterTopStartCorner();\n    const expandingBottomEnd = expandingRange.getOuterBottomEndCorner();\n    const resultTopRow = Math.min(topStart.row, expandingTopStart.row);\n    const resultTopCol = Math.min(topStart.col, expandingTopStart.col);\n    const resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);\n    const resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);\n    const finalFrom = this._createCellCoords(resultTopRow, resultTopCol);\n    const finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);\n    this.from = finalFrom;\n    this.to = finalTo;\n    this.setDirection(initialDirection);\n    if (changeDirection) {\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Gets the direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  getDirection() {\n    if (this.from.isNorthWestOf(this.to)) {\n      // NorthWest - SouthEast\n      return 'NW-SE';\n    } else if (this.from.isNorthEastOf(this.to)) {\n      // NorthEast - SouthWest\n      return 'NE-SW';\n    } else if (this.from.isSouthEastOf(this.to)) {\n      // SouthEast - NorthWest\n      return 'SE-NW';\n    } else if (this.from.isSouthWestOf(this.to)) {\n      // SouthWest - NorthEast\n      return 'SW-NE';\n    }\n  }\n\n  /**\n   * Sets the direction of the selection.\n   *\n   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  setDirection(direction) {\n    switch (direction) {\n      case 'NW-SE':\n        [this.from, this.to] = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n        break;\n      case 'NE-SW':\n        [this.from, this.to] = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n        break;\n      case 'SE-NW':\n        [this.from, this.to] = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n        break;\n      case 'SW-NE':\n        [this.from, this.to] = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the vertical direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n   */\n  getVerticalDirection() {\n    return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n  }\n\n  /**\n   * Gets the horizontal direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n   */\n  getHorizontalDirection() {\n    return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n  }\n\n  /**\n   * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).\n   */\n  flipDirectionVertically() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('SW-NE');\n        break;\n      case 'NE-SW':\n        this.setDirection('SE-NW');\n        break;\n      case 'SE-NW':\n        this.setDirection('NE-SW');\n        break;\n      case 'SW-NE':\n        this.setDirection('NW-SE');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).\n   */\n  flipDirectionHorizontally() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('NE-SW');\n        break;\n      case 'NE-SW':\n        this.setDirection('NW-SE');\n        break;\n      case 'SE-NW':\n        this.setDirection('SW-NE');\n        break;\n      case 'SW-NE':\n        this.setDirection('SE-NW');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top-left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getTopEndCorner() : this.getTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getBottomStartCorner() : this.getBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getTopStartCorner() : this.getTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getBottomEndCorner() : this.getBottomStartCorner();\n  }\n\n  /**\n   * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopRightCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomLeftCorner() {\n    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();\n  }\n\n  /**\n   * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {boolean}\n   */\n  isCorner(coords) {\n    return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Gets the coordinates of a range corner opposite to the provided `coords`.\n   *\n   * For example: if the `coords` coordinates match the bottom-right corner of your range,\n   * the coordinates of the top-left corner of your range are returned.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {CellCoords}\n   */\n  getOppositeCorner(coords) {\n    if (!(coords instanceof CellCoords)) {\n      return false;\n    }\n    if (coords.isEqual(this.getOuterBottomEndCorner())) {\n      return this.getOuterTopStartCorner();\n    } else if (coords.isEqual(this.getOuterTopStartCorner())) {\n      return this.getOuterBottomEndCorner();\n    } else if (coords.isEqual(this.getOuterTopEndCorner())) {\n      return this.getOuterBottomStartCorner();\n    } else if (coords.isEqual(this.getOuterBottomStartCorner())) {\n      return this.getOuterTopEndCorner();\n    }\n  }\n\n  /**\n   * Indicates which borders (top, right, bottom, left) are shared between\n   * your `CellRange`instance and another `range` that's within your range.\n   *\n   * @param {CellRange} range A range to compare with.\n   * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}\n   */\n  getBordersSharedWith(range) {\n    if (!this.includesRange(range)) {\n      return [];\n    }\n    const thisBorders = {\n      top: Math.min(this.from.row, this.to.row),\n      bottom: Math.max(this.from.row, this.to.row),\n      left: Math.min(this.from.col, this.to.col),\n      right: Math.max(this.from.col, this.to.col)\n    };\n    const rangeBorders = {\n      top: Math.min(range.from.row, range.to.row),\n      bottom: Math.max(range.from.row, range.to.row),\n      left: Math.min(range.from.col, range.to.col),\n      right: Math.max(range.from.col, range.to.col)\n    };\n    const result = [];\n    if (thisBorders.top === rangeBorders.top) {\n      result.push('top');\n    }\n    if (thisBorders.right === rangeBorders.right) {\n      result.push(_classPrivateFieldGet(_isRtl, this) ? 'left' : 'right');\n    }\n    if (thisBorders.bottom === rangeBorders.bottom) {\n      result.push('bottom');\n    }\n    if (thisBorders.left === rangeBorders.left) {\n      result.push(_classPrivateFieldGet(_isRtl, this) ? 'right' : 'left');\n    }\n    return result;\n  }\n\n  /**\n   * Gets the coordinates of the inner cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getInner() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets the coordinates of all cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getAll() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (topStart.row === r && topStart.col === c) {\n          out.push(topStart);\n        } else if (bottomEnd.row === r && bottomEnd.col === c) {\n          out.push(bottomEnd);\n        } else {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Runs a callback function on all cells within your range.\n   *\n   * You can break the iteration by returning `false` in the callback function.\n   *\n   * @param {function(number, number): boolean} callback A callback function.\n   */\n  forAll(callback) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        const breakIteration = callback(r, c);\n        if (breakIteration === false) {\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Clones your `CellRange` instance.\n   *\n   * @returns {CellRange}\n   */\n  clone() {\n    return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(_isRtl, this));\n  }\n\n  /**\n   * Converts your `CellRange` instance into an object literal with the following properties:\n   *\n   * - `from`\n   *    - `row`\n   *    - `col`\n   * - `to`\n   *    - `row`\n   *    - `col`\n   *\n   * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.\n   */\n  toObject() {\n    return {\n      from: this.from.toObject(),\n      to: this.to.toObject()\n    };\n  }\n\n  /**\n   * Creates and returns a new instance of the `CellCoords` class.\n   *\n   * The new `CellCoords` instance automatically inherits the LTR/RTL flag\n   * from your `CellRange` instance.\n   *\n   * @private\n   * @param {number} row A row index.\n   * @param {number} column A column index.\n   * @returns {CellCoords}\n   */\n  _createCellCoords(row, column) {\n    return new CellCoords(row, column, _classPrivateFieldGet(_isRtl, this));\n  }\n}\nexport default CellRange;"],"mappings":"AAEA,SAASA,0BAA0BA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAAEC,0BAA0B,CAACH,CAAC,EAAEC,CAAC,CAAC,EAAEA,CAAC,CAACG,GAAG,CAACJ,CAAC,EAAEE,CAAC,CAAC;AAAE;AAC9F,SAASC,0BAA0BA,CAACH,CAAC,EAAEC,CAAC,EAAE;EAAE,IAAIA,CAAC,CAACI,GAAG,CAACL,CAAC,CAAC,EAAE,MAAM,IAAIM,SAAS,CAAC,gEAAgE,CAAC;AAAE;AACjJ,SAASC,eAAeA,CAACP,CAAC,EAAEQ,CAAC,EAAEP,CAAC,EAAE;EAAE,OAAO,CAACO,CAAC,GAAGC,cAAc,CAACD,CAAC,CAAC,KAAKR,CAAC,GAAGU,MAAM,CAACC,cAAc,CAACX,CAAC,EAAEQ,CAAC,EAAE;IAAEI,KAAK,EAAEX,CAAC;IAAEY,UAAU,EAAE,CAAC,CAAC;IAAEC,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGf,CAAC,CAACQ,CAAC,CAAC,GAAGP,CAAC,EAAED,CAAC;AAAE;AACnL,SAASS,cAAcA,CAACR,CAAC,EAAE;EAAE,IAAIe,CAAC,GAAGC,YAAY,CAAChB,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOe,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAAChB,CAAC,EAAEO,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOP,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAID,CAAC,GAAGC,CAAC,CAACiB,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKnB,CAAC,EAAE;IAAE,IAAIgB,CAAC,GAAGhB,CAAC,CAACoB,IAAI,CAACnB,CAAC,EAAEO,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOQ,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIV,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKE,CAAC,GAAGa,MAAM,GAAGC,MAAM,EAAErB,CAAC,CAAC;AAAE;AACvT,SAASsB,qBAAqBA,CAACC,CAAC,EAAEtB,CAAC,EAAE;EAAE,OAAOsB,CAAC,CAACC,GAAG,CAACC,iBAAiB,CAACF,CAAC,EAAEtB,CAAC,CAAC,CAAC;AAAE;AAC9E,SAASyB,qBAAqBA,CAACH,CAAC,EAAEtB,CAAC,EAAEM,CAAC,EAAE;EAAE,OAAOgB,CAAC,CAACpB,GAAG,CAACsB,iBAAiB,CAACF,CAAC,EAAEtB,CAAC,CAAC,EAAEM,CAAC,CAAC,EAAEA,CAAC;AAAE;AACvF,SAASkB,iBAAiBA,CAAC1B,CAAC,EAAEC,CAAC,EAAE2B,CAAC,EAAE;EAAE,IAAI,UAAU,IAAI,OAAO5B,CAAC,GAAGA,CAAC,KAAKC,CAAC,GAAGD,CAAC,CAACK,GAAG,CAACJ,CAAC,CAAC,EAAE,OAAO4B,SAAS,CAACC,MAAM,GAAG,CAAC,GAAG7B,CAAC,GAAG2B,CAAC;EAAE,MAAM,IAAItB,SAAS,CAAC,+CAA+C,CAAC;AAAE;AAClM,OAAOyB,UAAU,MAAM,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,MAAM,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AACvC,MAAMC,SAAS,CAAC;EACdC,WAAWA,CAACC,SAAS,EAAE;IACrB,IAAIC,IAAI,GAAGR,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKS,SAAS,GAAGT,SAAS,CAAC,CAAC,CAAC,GAAGO,SAAS;IACxF,IAAIG,EAAE,GAAGV,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKS,SAAS,GAAGT,SAAS,CAAC,CAAC,CAAC,GAAGO,SAAS;IACtF,IAAII,KAAK,GAAGX,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKS,SAAS,GAAGT,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;IACrF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACItB,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC;IACxC;AACJ;AACA;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC;IACnC;AACJ;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACjC;AACJ;AACA;IACIR,0BAA0B,CAAC,IAAI,EAAEiC,MAAM,EAAE,KAAK,CAAC;IAC/C,IAAI,CAACI,SAAS,GAAGA,SAAS,CAACK,KAAK,CAAC,CAAC;IAClC,IAAI,CAACJ,IAAI,GAAGA,IAAI,CAACI,KAAK,CAAC,CAAC;IACxB,IAAI,CAACF,EAAE,GAAGA,EAAE,CAACE,KAAK,CAAC,CAAC;IACpBd,qBAAqB,CAACK,MAAM,EAAE,IAAI,EAAEQ,KAAK,CAAC;EAC5C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEE,YAAYA,CAACC,MAAM,EAAE;IACnB,IAAI,CAACP,SAAS,GAAGO,MAAM,CAACF,KAAK,CAAC,CAAC;IAC/B,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,OAAOA,CAACD,MAAM,EAAE;IACd,IAAI,CAACN,IAAI,GAAGM,MAAM,CAACF,KAAK,CAAC,CAAC;IAC1B,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEI,KAAKA,CAACF,MAAM,EAAE;IACZ,IAAI,CAACJ,EAAE,GAAGI,MAAM,CAACF,KAAK,CAAC,CAAC;IACxB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,OAAOA,CAACC,WAAW,EAAE;IACnB,OAAO,IAAI,CAACV,IAAI,CAACS,OAAO,CAACC,WAAW,CAAC,IAAI,IAAI,CAACR,EAAE,CAACO,OAAO,CAACC,WAAW,CAAC;EACvE;;EAEA;AACF;AACA;AACA;AACA;EACEC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACC,YAAY,CAAC,CAAC,IAAI,IAAI,CAACC,cAAc,CAAC,CAAC;EACrD;;EAEA;AACF;AACA;AACA;AACA;EACED,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACZ,IAAI,CAACc,GAAG,IAAI,CAAC,IAAI,IAAI,CAACd,IAAI,CAACc,GAAG,KAAK,IAAI,CAACZ,EAAE,CAACY,GAAG,IAAI,IAAI,CAACd,IAAI,CAACe,GAAG,IAAI,CAAC,IAAI,IAAI,CAACf,IAAI,CAACe,GAAG,KAAK,IAAI,CAACb,EAAE,CAACa,GAAG;EACnH;;EAEA;AACF;AACA;AACA;AACA;EACEF,cAAcA,CAAA,EAAG;IACf,OAAO,CAAC,IAAI,CAACb,IAAI,CAACc,GAAG,GAAG,CAAC,IAAI,IAAI,CAACd,IAAI,CAACe,GAAG,GAAG,CAAC,KAAK,IAAI,CAACf,IAAI,CAACc,GAAG,KAAK,IAAI,CAACZ,EAAE,CAACY,GAAG,IAAI,IAAI,CAACd,IAAI,CAACe,GAAG,KAAK,IAAI,CAACb,EAAE,CAACa,GAAG;EACnH;;EAEA;AACF;AACA;AACA;AACA;EACEC,QAAQA,CAAA,EAAG;IACT,IAAI,IAAI,CAAChB,IAAI,CAACgB,QAAQ,CAAC,CAAC,IAAI,IAAI,CAACd,EAAE,CAACc,QAAQ,CAAC,CAAC,EAAE;MAC9C,OAAO,IAAI;IACb;IACA,OAAO,IAAI,CAAChB,IAAI,CAACe,GAAG,GAAG,CAAC,IAAI,IAAI,CAACb,EAAE,CAACa,GAAG,GAAG,CAAC,IAAI,IAAI,CAACf,IAAI,CAACc,GAAG,GAAG,CAAC,IAAI,IAAI,CAACZ,EAAE,CAACY,GAAG,GAAG,CAAC;EACrF;;EAEA;AACF;AACA;AACA;AACA;EACEG,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACjB,IAAI,CAACgB,QAAQ,CAAC,CAAC,IAAI,IAAI,CAACd,EAAE,CAACc,QAAQ,CAAC,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;EACEE,cAAcA,CAAA,EAAG;IACf,OAAOC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,GAAGK,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,GAAG,CAAC;EACxF;;EAEA;AACF;AACA;AACA;AACA;EACEQ,aAAaA,CAAA,EAAG;IACd,OAAOH,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,GAAGI,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,GAAG,CAAC;EACxF;;EAEA;AACF;AACA;AACA;AACA;EACEQ,SAASA,CAAA,EAAG;IACV;IACA,IAAI,IAAI,CAACvB,IAAI,CAACc,GAAG,GAAG,CAAC,IAAI,IAAI,CAACZ,EAAE,CAACY,GAAG,GAAG,CAAC,EAAE;MACxC,OAAO,CAAC;IACV;IACA,MAAMU,OAAO,GAAGL,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,CAAC,CAAC;IAC1C,MAAMW,KAAK,GAAGN,IAAI,CAACC,GAAG,CAAC,IAAI,CAAClB,EAAE,CAACY,GAAG,EAAE,CAAC,CAAC;IACtC,OAAOK,IAAI,CAACC,GAAG,CAACI,OAAO,EAAEC,KAAK,CAAC,GAAGN,IAAI,CAACE,GAAG,CAACG,OAAO,EAAEC,KAAK,CAAC,GAAG,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;EACEC,QAAQA,CAAA,EAAG;IACT;IACA,IAAI,IAAI,CAAC1B,IAAI,CAACe,GAAG,GAAG,CAAC,IAAI,IAAI,CAACb,EAAE,CAACa,GAAG,GAAG,CAAC,EAAE;MACxC,OAAO,CAAC;IACV;IACA,MAAMY,OAAO,GAAGR,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,CAAC,CAAC;IAC1C,MAAMa,KAAK,GAAGT,IAAI,CAACC,GAAG,CAAC,IAAI,CAAClB,EAAE,CAACa,GAAG,EAAE,CAAC,CAAC;IACtC,OAAOI,IAAI,CAACC,GAAG,CAACO,OAAO,EAAEC,KAAK,CAAC,GAAGT,IAAI,CAACE,GAAG,CAACM,OAAO,EAAEC,KAAK,CAAC,GAAG,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;EACEC,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACH,QAAQ,CAAC,CAAC,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;EAC3C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEO,QAAQA,CAACC,UAAU,EAAE;IACnB,MAAM;MACJjB,GAAG;MACHC;IACF,CAAC,GAAGgB,UAAU;IACd,MAAMC,QAAQ,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC9C,MAAMC,SAAS,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChD,OAAOH,QAAQ,CAAClB,GAAG,IAAIA,GAAG,IAAIoB,SAAS,CAACpB,GAAG,IAAIA,GAAG,IAAIkB,QAAQ,CAACjB,GAAG,IAAIA,GAAG,IAAImB,SAAS,CAACnB,GAAG,IAAIA,GAAG;EACnG;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEqB,aAAaA,CAACC,SAAS,EAAE;IACvB,OAAO,IAAI,CAACP,QAAQ,CAACO,SAAS,CAACJ,sBAAsB,CAAC,CAAC,CAAC,IAAI,IAAI,CAACH,QAAQ,CAACO,SAAS,CAACF,uBAAuB,CAAC,CAAC,CAAC;EAChH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,OAAOA,CAACD,SAAS,EAAE;IACjB,OAAOlB,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,KAAKK,IAAI,CAACE,GAAG,CAACgB,SAAS,CAACrC,IAAI,CAACc,GAAG,EAAEuB,SAAS,CAACnC,EAAE,CAACY,GAAG,CAAC,IAAIK,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,KAAKK,IAAI,CAACC,GAAG,CAACiB,SAAS,CAACrC,IAAI,CAACc,GAAG,EAAEuB,SAAS,CAACnC,EAAE,CAACY,GAAG,CAAC,IAAIK,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,KAAKI,IAAI,CAACE,GAAG,CAACgB,SAAS,CAACrC,IAAI,CAACe,GAAG,EAAEsB,SAAS,CAACnC,EAAE,CAACa,GAAG,CAAC,IAAII,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,KAAKI,IAAI,CAACC,GAAG,CAACiB,SAAS,CAACrC,IAAI,CAACe,GAAG,EAAEsB,SAAS,CAACnC,EAAE,CAACa,GAAG,CAAC;EACjX;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEwB,QAAQA,CAACF,SAAS,EAAE;IAClB,OAAOA,SAAS,CAACG,aAAa,CAAC,IAAI,CAACC,qBAAqB,CAAC,CAAC,CAAC,IAAIJ,SAAS,CAACK,aAAa,CAAC,IAAI,CAACC,yBAAyB,CAAC,CAAC,CAAC;EAC3H;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEH,aAAaA,CAACT,UAAU,EAAE;IACxB,OAAO,IAAI,CAACU,qBAAqB,CAAC,CAAC,CAACD,aAAa,CAACT,UAAU,CAAC,IAAI,IAAI,CAACY,yBAAyB,CAAC,CAAC,CAACH,aAAa,CAACT,UAAU,CAAC;EAC7H;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEW,aAAaA,CAACX,UAAU,EAAE;IACxB,OAAO,IAAI,CAACU,qBAAqB,CAAC,CAAC,CAACC,aAAa,CAACX,UAAU,CAAC,IAAI,IAAI,CAACY,yBAAyB,CAAC,CAAC,CAACD,aAAa,CAACX,UAAU,CAAC;EAC7H;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEa,yBAAyBA,CAACP,SAAS,EAAE;IACnC,OAAO,IAAI,CAACQ,oBAAoB,CAAC,CAAC,CAAC9B,GAAG,IAAIsB,SAAS,CAACJ,sBAAsB,CAAC,CAAC,CAAClB,GAAG,IAAI,IAAI,CAAC8B,oBAAoB,CAAC,CAAC,CAAC9B,GAAG,IAAIsB,SAAS,CAACQ,oBAAoB,CAAC,CAAC,CAAC9B,GAAG,IAAI,IAAI,CAACkB,sBAAsB,CAAC,CAAC,CAAClB,GAAG,IAAIsB,SAAS,CAACQ,oBAAoB,CAAC,CAAC,CAAC9B,GAAG,IAAI,IAAI,CAACkB,sBAAsB,CAAC,CAAC,CAAClB,GAAG,IAAIsB,SAAS,CAACJ,sBAAsB,CAAC,CAAC,CAAClB,GAAG;EACzT;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+B,uBAAuBA,CAACT,SAAS,EAAE;IACjC,OAAO,IAAI,CAACU,yBAAyB,CAAC,CAAC,CAACjC,GAAG,IAAIuB,SAAS,CAACW,sBAAsB,CAAC,CAAC,CAAClC,GAAG,IAAI,IAAI,CAACiC,yBAAyB,CAAC,CAAC,CAACjC,GAAG,IAAIuB,SAAS,CAACU,yBAAyB,CAAC,CAAC,CAACjC,GAAG,IAAI,IAAI,CAAC+B,oBAAoB,CAAC,CAAC,CAAC/B,GAAG,IAAIuB,SAAS,CAACU,yBAAyB,CAAC,CAAC,CAACjC,GAAG,IAAI,IAAI,CAAC+B,oBAAoB,CAAC,CAAC,CAAC/B,GAAG,IAAIuB,SAAS,CAACW,sBAAsB,CAAC,CAAC,CAAClC,GAAG;EACzU;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEmC,MAAMA,CAAClB,UAAU,EAAE;IACjB,MAAMC,QAAQ,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC9C,MAAMC,SAAS,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChD,IAAIJ,UAAU,CAACjB,GAAG,GAAGkB,QAAQ,CAAClB,GAAG,IAAIiB,UAAU,CAAChB,GAAG,GAAGiB,QAAQ,CAACjB,GAAG,IAAIgB,UAAU,CAACjB,GAAG,GAAGoB,SAAS,CAACpB,GAAG,IAAIiB,UAAU,CAAChB,GAAG,GAAGmB,SAAS,CAACnB,GAAG,EAAE;MACtI,IAAI,CAACf,IAAI,GAAG,IAAI,CAACkD,iBAAiB,CAAC/B,IAAI,CAACE,GAAG,CAACW,QAAQ,CAAClB,GAAG,EAAEiB,UAAU,CAACjB,GAAG,CAAC,EAAEK,IAAI,CAACE,GAAG,CAACW,QAAQ,CAACjB,GAAG,EAAEgB,UAAU,CAAChB,GAAG,CAAC,CAAC;MAClH,IAAI,CAACb,EAAE,GAAG,IAAI,CAACgD,iBAAiB,CAAC/B,IAAI,CAACC,GAAG,CAACc,SAAS,CAACpB,GAAG,EAAEiB,UAAU,CAACjB,GAAG,CAAC,EAAEK,IAAI,CAACC,GAAG,CAACc,SAAS,CAACnB,GAAG,EAAEgB,UAAU,CAAChB,GAAG,CAAC,CAAC;MAClH,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEoC,aAAaA,CAACC,cAAc,EAAE;IAC5B,IAAIC,eAAe,GAAG7D,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKS,SAAS,GAAGT,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;IAC9F,IAAI,IAAI,CAAC4C,aAAa,CAACgB,cAAc,CAAC,IAAI,CAAC,IAAI,CAACb,QAAQ,CAACa,cAAc,CAAC,EAAE;MACxE,OAAO,KAAK;IACd;IACA,MAAMpB,QAAQ,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC9C,MAAMC,SAAS,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChD,MAAMmB,gBAAgB,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IAC5C,MAAMC,iBAAiB,GAAGJ,cAAc,CAACnB,sBAAsB,CAAC,CAAC;IACjE,MAAMwB,kBAAkB,GAAGL,cAAc,CAACjB,uBAAuB,CAAC,CAAC;IACnE,MAAMuB,YAAY,GAAGvC,IAAI,CAACE,GAAG,CAACW,QAAQ,CAAClB,GAAG,EAAE0C,iBAAiB,CAAC1C,GAAG,CAAC;IAClE,MAAM6C,YAAY,GAAGxC,IAAI,CAACE,GAAG,CAACW,QAAQ,CAACjB,GAAG,EAAEyC,iBAAiB,CAACzC,GAAG,CAAC;IAClE,MAAM6C,eAAe,GAAGzC,IAAI,CAACC,GAAG,CAACc,SAAS,CAACpB,GAAG,EAAE2C,kBAAkB,CAAC3C,GAAG,CAAC;IACvE,MAAM+C,eAAe,GAAG1C,IAAI,CAACC,GAAG,CAACc,SAAS,CAACnB,GAAG,EAAE0C,kBAAkB,CAAC1C,GAAG,CAAC;IACvE,MAAM+C,SAAS,GAAG,IAAI,CAACZ,iBAAiB,CAACQ,YAAY,EAAEC,YAAY,CAAC;IACpE,MAAMI,OAAO,GAAG,IAAI,CAACb,iBAAiB,CAACU,eAAe,EAAEC,eAAe,CAAC;IACxE,IAAI,CAAC7D,IAAI,GAAG8D,SAAS;IACrB,IAAI,CAAC5D,EAAE,GAAG6D,OAAO;IACjB,IAAI,CAACC,YAAY,CAACV,gBAAgB,CAAC;IACnC,IAAID,eAAe,EAAE;MACnB,IAAI,IAAI,CAACtD,SAAS,CAACe,GAAG,KAAK,IAAI,CAAC6B,yBAAyB,CAAC,CAAC,CAAC7B,GAAG,IAAI,IAAI,CAACmD,oBAAoB,CAAC,CAAC,KAAK,KAAK,EAAE;QACxG,IAAI,CAACC,uBAAuB,CAAC,CAAC;MAChC;MACA,IAAI,IAAI,CAACnE,SAAS,CAACgB,GAAG,KAAK,IAAI,CAACiC,sBAAsB,CAAC,CAAC,CAACjC,GAAG,IAAI,IAAI,CAACoD,sBAAsB,CAAC,CAAC,KAAK,KAAK,EAAE;QACvG,IAAI,CAACC,yBAAyB,CAAC,CAAC;MAClC;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEb,YAAYA,CAAA,EAAG;IACb,IAAI,IAAI,CAACvD,IAAI,CAAC0C,aAAa,CAAC,IAAI,CAACxC,EAAE,CAAC,EAAE;MACpC;MACA,OAAO,OAAO;IAChB,CAAC,MAAM,IAAI,IAAI,CAACF,IAAI,CAACqE,aAAa,CAAC,IAAI,CAACnE,EAAE,CAAC,EAAE;MAC3C;MACA,OAAO,OAAO;IAChB,CAAC,MAAM,IAAI,IAAI,CAACF,IAAI,CAACwC,aAAa,CAAC,IAAI,CAACtC,EAAE,CAAC,EAAE;MAC3C;MACA,OAAO,OAAO;IAChB,CAAC,MAAM,IAAI,IAAI,CAACF,IAAI,CAACsE,aAAa,CAAC,IAAI,CAACpE,EAAE,CAAC,EAAE;MAC3C;MACA,OAAO,OAAO;IAChB;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE8D,YAAYA,CAACO,SAAS,EAAE;IACtB,QAAQA,SAAS;MACf,KAAK,OAAO;QACV,CAAC,IAAI,CAACvE,IAAI,EAAE,IAAI,CAACE,EAAE,CAAC,GAAG,CAAC,IAAI,CAACuC,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAACE,yBAAyB,CAAC,CAAC,CAAC;QACvF;MACF,KAAK,OAAO;QACV,CAAC,IAAI,CAAC3C,IAAI,EAAE,IAAI,CAACE,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC8C,sBAAsB,CAAC,CAAC,EAAE,IAAI,CAACwB,wBAAwB,CAAC,CAAC,CAAC;QACvF;MACF,KAAK,OAAO;QACV,CAAC,IAAI,CAACxE,IAAI,EAAE,IAAI,CAACE,EAAE,CAAC,GAAG,CAAC,IAAI,CAACyC,yBAAyB,CAAC,CAAC,EAAE,IAAI,CAACF,qBAAqB,CAAC,CAAC,CAAC;QACvF;MACF,KAAK,OAAO;QACV,CAAC,IAAI,CAACzC,IAAI,EAAE,IAAI,CAACE,EAAE,CAAC,GAAG,CAAC,IAAI,CAACsE,wBAAwB,CAAC,CAAC,EAAE,IAAI,CAACxB,sBAAsB,CAAC,CAAC,CAAC;QACvF;MACF;QACE;IACJ;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEiB,oBAAoBA,CAAA,EAAG;IACrB,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAACQ,OAAO,CAAC,IAAI,CAAClB,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK;EAC7E;;EAEA;AACF;AACA;AACA;AACA;EACEY,sBAAsBA,CAAA,EAAG;IACvB,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAACM,OAAO,CAAC,IAAI,CAAClB,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK;EAC7E;;EAEA;AACF;AACA;EACEW,uBAAuBA,CAAA,EAAG;IACxB,MAAMK,SAAS,GAAG,IAAI,CAAChB,YAAY,CAAC,CAAC;IACrC,QAAQgB,SAAS;MACf,KAAK,OAAO;QACV,IAAI,CAACP,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF,KAAK,OAAO;QACV,IAAI,CAACA,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF,KAAK,OAAO;QACV,IAAI,CAACA,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF,KAAK,OAAO;QACV,IAAI,CAACA,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF;QACE;IACJ;EACF;;EAEA;AACF;AACA;EACEI,yBAAyBA,CAAA,EAAG;IAC1B,MAAMG,SAAS,GAAG,IAAI,CAAChB,YAAY,CAAC,CAAC;IACrC,QAAQgB,SAAS;MACf,KAAK,OAAO;QACV,IAAI,CAACP,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF,KAAK,OAAO;QACV,IAAI,CAACA,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF,KAAK,OAAO;QACV,IAAI,CAACA,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF,KAAK,OAAO;QACV,IAAI,CAACA,YAAY,CAAC,OAAO,CAAC;QAC1B;MACF;QACE;IACJ;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACxB,iBAAiB,CAAC/B,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC,CAAC4D,SAAS,CAAC,CAAC;EACvH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,gBAAgBA,CAAA,EAAG;IACjB,OAAO1F,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACkF,eAAe,CAAC,CAAC,GAAG,IAAI,CAACH,iBAAiB,CAAC,CAAC;EAChG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,kBAAkBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAAC5B,iBAAiB,CAAC/B,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC,CAAC4D,SAAS,CAAC,CAAC;EACvH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,oBAAoBA,CAAA,EAAG;IACrB,OAAO7F,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACqF,oBAAoB,CAAC,CAAC,GAAG,IAAI,CAACF,kBAAkB,CAAC,CAAC;EACtG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACED,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAAC3B,iBAAiB,CAAC/B,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC,CAAC4D,SAAS,CAAC,CAAC;EACvH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,iBAAiBA,CAAA,EAAG;IAClB,OAAO/F,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC+E,iBAAiB,CAAC,CAAC,GAAG,IAAI,CAACG,eAAe,CAAC,CAAC;EAChG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,oBAAoBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAAC9B,iBAAiB,CAAC/B,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC,CAAC4D,SAAS,CAAC,CAAC;EACvH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,mBAAmBA,CAAA,EAAG;IACpB,OAAOhG,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACmF,kBAAkB,CAAC,CAAC,GAAG,IAAI,CAACE,oBAAoB,CAAC,CAAC;EACtG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE/C,sBAAsBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAACiB,iBAAiB,CAAC/B,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC;EAC3G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE0B,qBAAqBA,CAAA,EAAG;IACtB,OAAOvD,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACkD,oBAAoB,CAAC,CAAC,GAAG,IAAI,CAACZ,sBAAsB,CAAC,CAAC;EAC1G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,uBAAuBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAACe,iBAAiB,CAAC/B,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC;EAC3G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4B,yBAAyBA,CAAA,EAAG;IAC1B,OAAOzD,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACoD,yBAAyB,CAAC,CAAC,GAAG,IAAI,CAACZ,uBAAuB,CAAC,CAAC;EAChH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,oBAAoBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAACK,iBAAiB,CAAC/B,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC;EAC3G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiC,sBAAsBA,CAAA,EAAG;IACvB,OAAO9D,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACsC,sBAAsB,CAAC,CAAC,GAAG,IAAI,CAACY,oBAAoB,CAAC,CAAC;EAC1G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,yBAAyBA,CAAA,EAAG;IAC1B,OAAO,IAAI,CAACG,iBAAiB,CAAC/B,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC,EAAEK,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC,CAAC;EAC3G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyD,wBAAwBA,CAAA,EAAG;IACzB,OAAOtF,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAACwC,uBAAuB,CAAC,CAAC,GAAG,IAAI,CAACY,yBAAyB,CAAC,CAAC;EAChH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEoC,QAAQA,CAAC7E,MAAM,EAAE;IACf,OAAOA,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACG,qBAAqB,CAAC,CAAC,CAAC,IAAInC,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACU,sBAAsB,CAAC,CAAC,CAAC,IAAI1C,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACkC,wBAAwB,CAAC,CAAC,CAAC,IAAIlE,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACK,yBAAyB,CAAC,CAAC,CAAC;EAC7M;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyC,iBAAiBA,CAAC9E,MAAM,EAAE;IACxB,IAAI,EAAEA,MAAM,YAAYZ,UAAU,CAAC,EAAE;MACnC,OAAO,KAAK;IACd;IACA,IAAIY,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACH,uBAAuB,CAAC,CAAC,CAAC,EAAE;MAClD,OAAO,IAAI,CAACF,sBAAsB,CAAC,CAAC;IACtC,CAAC,MAAM,IAAI3B,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACL,sBAAsB,CAAC,CAAC,CAAC,EAAE;MACxD,OAAO,IAAI,CAACE,uBAAuB,CAAC,CAAC;IACvC,CAAC,MAAM,IAAI7B,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACO,oBAAoB,CAAC,CAAC,CAAC,EAAE;MACtD,OAAO,IAAI,CAACE,yBAAyB,CAAC,CAAC;IACzC,CAAC,MAAM,IAAIzC,MAAM,CAACgC,OAAO,CAAC,IAAI,CAACS,yBAAyB,CAAC,CAAC,CAAC,EAAE;MAC3D,OAAO,IAAI,CAACF,oBAAoB,CAAC,CAAC;IACpC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEwC,oBAAoBA,CAACC,KAAK,EAAE;IAC1B,IAAI,CAAC,IAAI,CAAClD,aAAa,CAACkD,KAAK,CAAC,EAAE;MAC9B,OAAO,EAAE;IACX;IACA,MAAMC,WAAW,GAAG;MAClBC,GAAG,EAAErE,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC;MACzC2E,MAAM,EAAEtE,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACc,GAAG,EAAE,IAAI,CAACZ,EAAE,CAACY,GAAG,CAAC;MAC5C4E,IAAI,EAAEvE,IAAI,CAACE,GAAG,CAAC,IAAI,CAACrB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG,CAAC;MAC1C4E,KAAK,EAAExE,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,IAAI,CAACe,GAAG,EAAE,IAAI,CAACb,EAAE,CAACa,GAAG;IAC5C,CAAC;IACD,MAAM6E,YAAY,GAAG;MACnBJ,GAAG,EAAErE,IAAI,CAACE,GAAG,CAACiE,KAAK,CAACtF,IAAI,CAACc,GAAG,EAAEwE,KAAK,CAACpF,EAAE,CAACY,GAAG,CAAC;MAC3C2E,MAAM,EAAEtE,IAAI,CAACC,GAAG,CAACkE,KAAK,CAACtF,IAAI,CAACc,GAAG,EAAEwE,KAAK,CAACpF,EAAE,CAACY,GAAG,CAAC;MAC9C4E,IAAI,EAAEvE,IAAI,CAACE,GAAG,CAACiE,KAAK,CAACtF,IAAI,CAACe,GAAG,EAAEuE,KAAK,CAACpF,EAAE,CAACa,GAAG,CAAC;MAC5C4E,KAAK,EAAExE,IAAI,CAACC,GAAG,CAACkE,KAAK,CAACtF,IAAI,CAACe,GAAG,EAAEuE,KAAK,CAACpF,EAAE,CAACa,GAAG;IAC9C,CAAC;IACD,MAAM8E,MAAM,GAAG,EAAE;IACjB,IAAIN,WAAW,CAACC,GAAG,KAAKI,YAAY,CAACJ,GAAG,EAAE;MACxCK,MAAM,CAACC,IAAI,CAAC,KAAK,CAAC;IACpB;IACA,IAAIP,WAAW,CAACI,KAAK,KAAKC,YAAY,CAACD,KAAK,EAAE;MAC5CE,MAAM,CAACC,IAAI,CAAC5G,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,MAAM,GAAG,OAAO,CAAC;IACrE;IACA,IAAI4F,WAAW,CAACE,MAAM,KAAKG,YAAY,CAACH,MAAM,EAAE;MAC9CI,MAAM,CAACC,IAAI,CAAC,QAAQ,CAAC;IACvB;IACA,IAAIP,WAAW,CAACG,IAAI,KAAKE,YAAY,CAACF,IAAI,EAAE;MAC1CG,MAAM,CAACC,IAAI,CAAC5G,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,GAAG,OAAO,GAAG,MAAM,CAAC;IACrE;IACA,OAAOkG,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;EACEE,QAAQA,CAAA,EAAG;IACT,MAAM/D,QAAQ,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC9C,MAAMC,SAAS,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChD,MAAM6D,GAAG,GAAG,EAAE;IACd,KAAK,IAAI7H,CAAC,GAAG6D,QAAQ,CAAClB,GAAG,EAAE3C,CAAC,IAAI+D,SAAS,CAACpB,GAAG,EAAE3C,CAAC,EAAE,EAAE;MAClD,KAAK,IAAI8H,CAAC,GAAGjE,QAAQ,CAACjB,GAAG,EAAEkF,CAAC,IAAI/D,SAAS,CAACnB,GAAG,EAAEkF,CAAC,EAAE,EAAE;QAClD,IAAI,EAAE,IAAI,CAACjG,IAAI,CAACc,GAAG,KAAK3C,CAAC,IAAI,IAAI,CAAC6B,IAAI,CAACe,GAAG,KAAKkF,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC/F,EAAE,CAACY,GAAG,KAAK3C,CAAC,IAAI,IAAI,CAAC+B,EAAE,CAACa,GAAG,KAAKkF,CAAC,CAAC,EAAE;UAC9FD,GAAG,CAACF,IAAI,CAAC,IAAI,CAAC5C,iBAAiB,CAAC/E,CAAC,EAAE8H,CAAC,CAAC,CAAC;QACxC;MACF;IACF;IACA,OAAOD,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;EACEE,MAAMA,CAAA,EAAG;IACP,MAAMlE,QAAQ,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC9C,MAAMC,SAAS,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChD,MAAM6D,GAAG,GAAG,EAAE;IACd,KAAK,IAAI7H,CAAC,GAAG6D,QAAQ,CAAClB,GAAG,EAAE3C,CAAC,IAAI+D,SAAS,CAACpB,GAAG,EAAE3C,CAAC,EAAE,EAAE;MAClD,KAAK,IAAI8H,CAAC,GAAGjE,QAAQ,CAACjB,GAAG,EAAEkF,CAAC,IAAI/D,SAAS,CAACnB,GAAG,EAAEkF,CAAC,EAAE,EAAE;QAClD,IAAIjE,QAAQ,CAAClB,GAAG,KAAK3C,CAAC,IAAI6D,QAAQ,CAACjB,GAAG,KAAKkF,CAAC,EAAE;UAC5CD,GAAG,CAACF,IAAI,CAAC9D,QAAQ,CAAC;QACpB,CAAC,MAAM,IAAIE,SAAS,CAACpB,GAAG,KAAK3C,CAAC,IAAI+D,SAAS,CAACnB,GAAG,KAAKkF,CAAC,EAAE;UACrDD,GAAG,CAACF,IAAI,CAAC5D,SAAS,CAAC;QACrB,CAAC,MAAM;UACL8D,GAAG,CAACF,IAAI,CAAC,IAAI,CAAC5C,iBAAiB,CAAC/E,CAAC,EAAE8H,CAAC,CAAC,CAAC;QACxC;MACF;IACF;IACA,OAAOD,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,MAAMA,CAACC,QAAQ,EAAE;IACf,MAAMpE,QAAQ,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC9C,MAAMC,SAAS,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChD,KAAK,IAAIhE,CAAC,GAAG6D,QAAQ,CAAClB,GAAG,EAAE3C,CAAC,IAAI+D,SAAS,CAACpB,GAAG,EAAE3C,CAAC,EAAE,EAAE;MAClD,KAAK,IAAI8H,CAAC,GAAGjE,QAAQ,CAACjB,GAAG,EAAEkF,CAAC,IAAI/D,SAAS,CAACnB,GAAG,EAAEkF,CAAC,EAAE,EAAE;QAClD,MAAMI,cAAc,GAAGD,QAAQ,CAACjI,CAAC,EAAE8H,CAAC,CAAC;QACrC,IAAII,cAAc,KAAK,KAAK,EAAE;UAC5B;QACF;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEjG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIP,SAAS,CAAC,IAAI,CAACE,SAAS,EAAE,IAAI,CAACC,IAAI,EAAE,IAAI,CAACE,EAAE,EAAEhB,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,CAAC;EAC/F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2G,QAAQA,CAAA,EAAG;IACT,OAAO;MACLtG,IAAI,EAAE,IAAI,CAACA,IAAI,CAACsG,QAAQ,CAAC,CAAC;MAC1BpG,EAAE,EAAE,IAAI,CAACA,EAAE,CAACoG,QAAQ,CAAC;IACvB,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEpD,iBAAiBA,CAACpC,GAAG,EAAEyF,MAAM,EAAE;IAC7B,OAAO,IAAI7G,UAAU,CAACoB,GAAG,EAAEyF,MAAM,EAAErH,qBAAqB,CAACS,MAAM,EAAE,IAAI,CAAC,CAAC;EACzE;AACF;AACA,eAAeE,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}