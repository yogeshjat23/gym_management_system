{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { arrayMap, arrayReduce } from \"../../../helpers/array.mjs\";\nimport SourceSettings from \"./sourceSettings.mjs\";\nimport HeadersTree from \"./headersTree.mjs\";\nimport { triggerNodeModification } from \"./nodeModifiers/index.mjs\";\nimport { generateMatrix } from \"./matrixGenerator.mjs\";\nimport { TRAVERSAL_DF_PRE } from \"../../../utils/dataStructures/tree.mjs\";\n/**\n * The state manager is a source of truth for nested headers configuration.\n * The state generation process is divided into three stages.\n *\n *   +---------------------+  1. User-defined configuration normalization;\n *   │                     │  The source settings class normalizes and shares API for\n *   │   SourceSettings    │  raw settings passed by the developer. It is only consumed by\n *   │                     │  the header tree module.\n *   +---------------------+\n *             │\n *            \\│/\n *   +---------------------+  2. Building a tree structure for validation and easier node manipulation;\n *   │                     │  The header tree generates a tree based on source settings for future\n *   │     HeadersTree     │  node manipulation (such as collapsible columns feature). While generating a tree\n *   │                     │  the source settings is checked to see if the configuration has overlapping headers.\n *   +---------------------+  If `true` the colspan matrix generation is skipped, overlapped headers are not supported.\n *             │\n *            \\│/\n *   +---------------------+  3. Matrix generation;\n *   │                     │  Based on built trees the matrix generation is performed. That part of code\n *   │  matrix generation  │  generates an array structure similar to normalized data from the SourceSettings\n *   │                     │  but with the difference that this structure contains column settings which changed\n *   +---------------------+  during runtime (after the tree manipulation) e.q after collapse or expand column.\n *                            That settings describes how the TH element should be modified (colspan attribute,\n *                            CSS classes, etc) for a specific column and layer level.\n *\n * @class StateManager\n */\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nvar _headersTree = /*#__PURE__*/new WeakMap();\nvar _stateMatrix = /*#__PURE__*/new WeakMap();\nexport default class StateManager {\n  constructor() {\n    /**\n     * The instance of the source settings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, new SourceSettings());\n    /**\n     * The instance of the headers tree. The tree is generated after setting new configuration data.\n     *\n     * @private\n     * @type {HeadersTree}\n     */\n    _classPrivateFieldInitSpec(this, _headersTree, new HeadersTree(_classPrivateFieldGet(_sourceSettings, this)));\n    /**\n     * Cached matrix which is generated from the tree structure.\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _stateMatrix, [[]]);\n  }\n  /**\n   * Sets a new state for the nested headers plugin based on settings passed\n   * directly to the plugin.\n   *\n   * @param {Array[]} nestedHeadersSettings The user-defined settings.\n   * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.\n   */\n  setState(nestedHeadersSettings) {\n    _classPrivateFieldGet(_sourceSettings, this).setData(nestedHeadersSettings);\n    let hasError = false;\n    try {\n      _classPrivateFieldGet(_headersTree, this).buildTree();\n    } catch (ex) {\n      _classPrivateFieldGet(_headersTree, this).clear();\n      _classPrivateFieldGet(_sourceSettings, this).clear();\n      hasError = true;\n    }\n    _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n    return hasError;\n  }\n\n  /**\n   * Sets columns limit to the state will be trimmed. All headers (colspans) which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldGet(_sourceSettings, this).setColumnsLimit(columnsCount);\n  }\n\n  /**\n   * Merges settings with current plugin state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {object[]} settings An array of objects to merge with the current source settings.\n   *                            It is a requirement that every object has `row` and `col` properties\n   *                            which points to the specific header settings object.\n   */\n  mergeStateWith(settings) {\n    const transformedSettings = arrayMap(settings, _ref => {\n      let {\n        row,\n        ...rest\n      } = _ref;\n      return {\n        row: row < 0 ? this.rowCoordsToLevel(row) : row,\n        ...rest\n      };\n    });\n    _classPrivateFieldGet(_sourceSettings, this).mergeWith(transformedSettings);\n    _classPrivateFieldGet(_headersTree, this).buildTree();\n    _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n  }\n\n  /**\n   * Maps the current state with a callback. For each header settings the callback function\n   * is called. If the function returns value that value is merged with the state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {Function} callback A function that is called for every header source settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  mapState(callback) {\n    _classPrivateFieldGet(_sourceSettings, this).map(callback);\n    _classPrivateFieldGet(_headersTree, this).buildTree();\n    _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n  }\n\n  /**\n   * Maps the current tree nodes with a callback. For each node the callback function\n   * is called. If the function returns value that value is added to returned array.\n   *\n   * @param {Function} callback A function that is called for every tree node.\n   *                            Each time the callback is called, the returned value is\n   *                            added to returned array.\n   * @returns {Array}\n   */\n  mapNodes(callback) {\n    return arrayReduce(_classPrivateFieldGet(_headersTree, this).getRoots(), (acc, rootNode) => {\n      rootNode.walkDown(node => {\n        const result = callback(node.data);\n        if (result !== undefined) {\n          acc.push(result);\n        }\n      });\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Triggers an action (e.g. \"collapse\") from the NodeModifiers module. The module\n   * modifies a tree structure in such a way as to obtain the correct structure consistent with the\n   * called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} headerLevel Header level index (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerNodeModification(action, headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    const nodeToProcess = _classPrivateFieldGet(_headersTree, this).getNode(headerLevel, columnIndex);\n    let actionResult;\n    if (nodeToProcess) {\n      actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);\n\n      // TODO (perf-tip): Trigger matrix generation once after multiple node modifications.\n      _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n    }\n    return actionResult;\n  }\n\n  /**\n   * Triggers an action (e.g. \"hide-column\") from the NodeModifiers module. The action is\n   * triggered starting from the lowest header. The module modifies a tree structure in\n   * such a way as to obtain the correct structure consistent with the called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerColumnModification(action, columnIndex) {\n    return this.triggerNodeModification(action, -1, columnIndex);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function rowCoordsToLevel\n   *\n   * Translates row coordinates into header level. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Row coords             Header level\n   *           +--------------+\n   *       -3  │ A1 │ A1      │  0\n   *           +--------------+\n   *       -2  │ B1 │ B2 │ B3 │  1\n   *           +--------------+\n   *       -1  │ C1 │ C2 │ C3 │  2\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} rowIndex A visual row index.\n   * @returns {number|null} Returns unsigned number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  rowCoordsToLevel(rowIndex) {\n    if (rowIndex >= 0) {\n      return null;\n    }\n    const headerLevel = rowIndex + Math.max(this.getLayersCount(), 1);\n    if (headerLevel < 0) {\n      return null;\n    }\n    return headerLevel;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function levelToRowCoords\n   *\n   * Translates header level into row coordinates. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Header level            Row coords\n   *           +--------------+\n   *        0  │ A1 │ A1      │  -3\n   *           +--------------+\n   *        1  │ B1 │ B2 │ B3 │  -2\n   *           +--------------+\n   *        2  │ C1 │ C2 │ C3 │  -1\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} headerLevel Header level index.\n   * @returns {number} Returns negative number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  levelToRowCoords(headerLevel) {\n    if (headerLevel < 0) {\n      return null;\n    }\n    const rowIndex = headerLevel - Math.max(this.getLayersCount(), 1);\n    if (rowIndex >= 0) {\n      return null;\n    }\n    return rowIndex;\n  }\n\n  /**\n   * Gets column header settings for a specified column and header index. The returned object contains\n   * all information necessary for header renderers. It contains header label, colspan length, or hidden\n   * flag.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_stateMatrix, this)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;\n  }\n\n  /**\n   * Gets tree data that is connected to the column header. The returned object contains all information\n   * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header\n   * label, colspan length, or visual column index that indicates which column index the node is rendered from.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderTreeNodeData(headerLevel, columnIndex) {\n    const node = this.getHeaderTreeNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return {\n      ...node.data\n    };\n  }\n\n  /**\n   * Gets tree node that is connected to the column header.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|null}\n   */\n  getHeaderTreeNode(headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    const node = _classPrivateFieldGet(_headersTree, this).getNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return node;\n  }\n\n  /**\n   * Finds the most top header level of the column header that is rendered entirely within\n   * the passed visual columns range. If multiple columns headers are found within the range the\n   * most top header level value will be returned.\n   *\n   * @param {number} columnIndexFrom A visual column index.\n   * @param {number} [columnIndexTo] A visual column index.\n   * @returns {number} Returns a header level in format -1 to -N.\n   */\n  findTopMostEntireHeaderLevel(columnIndexFrom) {\n    var _headerLevel;\n    let columnIndexTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : columnIndexFrom;\n    const columnsWidth = columnIndexTo - columnIndexFrom + 1;\n    let atLeastOneRootFound = false;\n    let headerLevel = null;\n    for (let columnIndex = columnIndexFrom; columnIndex <= columnIndexTo; columnIndex++) {\n      const rootNode = _classPrivateFieldGet(_headersTree, this).getRootByColumn(columnIndex);\n      if (!rootNode) {\n        break;\n      }\n      atLeastOneRootFound = true;\n\n      // eslint-disable-next-line\n      rootNode.walkDown(node => {\n        const {\n          columnIndex: nodeColumnIndex,\n          headerLevel: nodeHeaderLevel,\n          origColspan,\n          isHidden\n        } = node.data;\n        if (isHidden) {\n          return;\n        }\n\n        // if the header fits entirely within the columns range get and save the node header level\n        if (origColspan <= columnsWidth && nodeColumnIndex >= columnIndexFrom && nodeColumnIndex + origColspan - 1 <= columnIndexTo && (headerLevel === null || nodeHeaderLevel < headerLevel)) {\n          headerLevel = nodeHeaderLevel;\n        }\n      }, TRAVERSAL_DF_PRE);\n    }\n    if (atLeastOneRootFound && headerLevel === null) {\n      return -1;\n    }\n    return this.levelToRowCoords((_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : 0);\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the left-most column index\n   * where the nested header begins.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findLeftMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin;\n    const {\n      isRoot\n    } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {\n      isRoot: true\n    };\n    if (isRoot) {\n      return columnIndex;\n    }\n    let stepBackColumn = columnIndex - 1;\n    while (stepBackColumn >= 0) {\n      var _this$getHeaderSettin2;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepBackColumn -= 1;\n    }\n    return stepBackColumn;\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the right-most column index\n   * where the nested header ends.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findRightMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin3;\n    const {\n      isRoot,\n      origColspan\n    } = (_this$getHeaderSettin3 = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin3 !== void 0 ? _this$getHeaderSettin3 : {\n      isRoot: true,\n      origColspan: 1\n    };\n    if (isRoot) {\n      return columnIndex + origColspan - 1;\n    }\n    let stepForthColumn = columnIndex + 1;\n    while (stepForthColumn < this.getColumnsCount()) {\n      var _this$getHeaderSettin4;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin4 = this.getHeaderSettings(headerLevel, stepForthColumn)) !== null && _this$getHeaderSettin4 !== void 0 ? _this$getHeaderSettin4 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepForthColumn += 1;\n    }\n    return stepForthColumn - 1;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_sourceSettings, this).getLayersCount();\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(_sourceSettings, this).getColumnsCount();\n  }\n\n  /**\n   * Clears the column state manager to the initial state.\n   */\n  clear() {\n    _classPrivateFieldSet(_stateMatrix, this, []);\n    _classPrivateFieldGet(_sourceSettings, this).clear();\n    _classPrivateFieldGet(_headersTree, this).clear();\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldSet","s","r","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","arrayMap","arrayReduce","SourceSettings","HeadersTree","triggerNodeModification","generateMatrix","TRAVERSAL_DF_PRE","_sourceSettings","WeakMap","_headersTree","_stateMatrix","StateManager","constructor","setState","nestedHeadersSettings","setData","hasError","buildTree","ex","clear","getRoots","setColumnsLimit","columnsCount","mergeStateWith","settings","transformedSettings","_ref","row","rest","rowCoordsToLevel","mergeWith","mapState","callback","map","mapNodes","acc","rootNode","walkDown","node","result","data","undefined","push","action","headerLevel","columnIndex","nodeToProcess","getNode","actionResult","triggerColumnModification","rowIndex","Math","max","getLayersCount","levelToRowCoords","getHeaderSettings","_classPrivateFieldGet2","_classPrivateFieldGet3","getHeaderTreeNodeData","getHeaderTreeNode","findTopMostEntireHeaderLevel","columnIndexFrom","_headerLevel","columnIndexTo","columnsWidth","atLeastOneRootFound","getRootByColumn","nodeColumnIndex","nodeHeaderLevel","origColspan","isHidden","findLeftMostColumnIndex","_this$getHeaderSettin","isRoot","stepBackColumn","_this$getHeaderSettin2","isRootNode","findRightMostColumnIndex","_this$getHeaderSettin3","stepForthColumn","getColumnsCount","_this$getHeaderSettin4"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedHeaders/stateManager/index.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { arrayMap, arrayReduce } from \"../../../helpers/array.mjs\";\nimport SourceSettings from \"./sourceSettings.mjs\";\nimport HeadersTree from \"./headersTree.mjs\";\nimport { triggerNodeModification } from \"./nodeModifiers/index.mjs\";\nimport { generateMatrix } from \"./matrixGenerator.mjs\";\nimport { TRAVERSAL_DF_PRE } from \"../../../utils/dataStructures/tree.mjs\";\n/**\n * The state manager is a source of truth for nested headers configuration.\n * The state generation process is divided into three stages.\n *\n *   +---------------------+  1. User-defined configuration normalization;\n *   │                     │  The source settings class normalizes and shares API for\n *   │   SourceSettings    │  raw settings passed by the developer. It is only consumed by\n *   │                     │  the header tree module.\n *   +---------------------+\n *             │\n *            \\│/\n *   +---------------------+  2. Building a tree structure for validation and easier node manipulation;\n *   │                     │  The header tree generates a tree based on source settings for future\n *   │     HeadersTree     │  node manipulation (such as collapsible columns feature). While generating a tree\n *   │                     │  the source settings is checked to see if the configuration has overlapping headers.\n *   +---------------------+  If `true` the colspan matrix generation is skipped, overlapped headers are not supported.\n *             │\n *            \\│/\n *   +---------------------+  3. Matrix generation;\n *   │                     │  Based on built trees the matrix generation is performed. That part of code\n *   │  matrix generation  │  generates an array structure similar to normalized data from the SourceSettings\n *   │                     │  but with the difference that this structure contains column settings which changed\n *   +---------------------+  during runtime (after the tree manipulation) e.q after collapse or expand column.\n *                            That settings describes how the TH element should be modified (colspan attribute,\n *                            CSS classes, etc) for a specific column and layer level.\n *\n * @class StateManager\n */\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nvar _headersTree = /*#__PURE__*/new WeakMap();\nvar _stateMatrix = /*#__PURE__*/new WeakMap();\nexport default class StateManager {\n  constructor() {\n    /**\n     * The instance of the source settings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, new SourceSettings());\n    /**\n     * The instance of the headers tree. The tree is generated after setting new configuration data.\n     *\n     * @private\n     * @type {HeadersTree}\n     */\n    _classPrivateFieldInitSpec(this, _headersTree, new HeadersTree(_classPrivateFieldGet(_sourceSettings, this)));\n    /**\n     * Cached matrix which is generated from the tree structure.\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _stateMatrix, [[]]);\n  }\n  /**\n   * Sets a new state for the nested headers plugin based on settings passed\n   * directly to the plugin.\n   *\n   * @param {Array[]} nestedHeadersSettings The user-defined settings.\n   * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.\n   */\n  setState(nestedHeadersSettings) {\n    _classPrivateFieldGet(_sourceSettings, this).setData(nestedHeadersSettings);\n    let hasError = false;\n    try {\n      _classPrivateFieldGet(_headersTree, this).buildTree();\n    } catch (ex) {\n      _classPrivateFieldGet(_headersTree, this).clear();\n      _classPrivateFieldGet(_sourceSettings, this).clear();\n      hasError = true;\n    }\n    _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n    return hasError;\n  }\n\n  /**\n   * Sets columns limit to the state will be trimmed. All headers (colspans) which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldGet(_sourceSettings, this).setColumnsLimit(columnsCount);\n  }\n\n  /**\n   * Merges settings with current plugin state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {object[]} settings An array of objects to merge with the current source settings.\n   *                            It is a requirement that every object has `row` and `col` properties\n   *                            which points to the specific header settings object.\n   */\n  mergeStateWith(settings) {\n    const transformedSettings = arrayMap(settings, _ref => {\n      let {\n        row,\n        ...rest\n      } = _ref;\n      return {\n        row: row < 0 ? this.rowCoordsToLevel(row) : row,\n        ...rest\n      };\n    });\n    _classPrivateFieldGet(_sourceSettings, this).mergeWith(transformedSettings);\n    _classPrivateFieldGet(_headersTree, this).buildTree();\n    _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n  }\n\n  /**\n   * Maps the current state with a callback. For each header settings the callback function\n   * is called. If the function returns value that value is merged with the state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {Function} callback A function that is called for every header source settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  mapState(callback) {\n    _classPrivateFieldGet(_sourceSettings, this).map(callback);\n    _classPrivateFieldGet(_headersTree, this).buildTree();\n    _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n  }\n\n  /**\n   * Maps the current tree nodes with a callback. For each node the callback function\n   * is called. If the function returns value that value is added to returned array.\n   *\n   * @param {Function} callback A function that is called for every tree node.\n   *                            Each time the callback is called, the returned value is\n   *                            added to returned array.\n   * @returns {Array}\n   */\n  mapNodes(callback) {\n    return arrayReduce(_classPrivateFieldGet(_headersTree, this).getRoots(), (acc, rootNode) => {\n      rootNode.walkDown(node => {\n        const result = callback(node.data);\n        if (result !== undefined) {\n          acc.push(result);\n        }\n      });\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Triggers an action (e.g. \"collapse\") from the NodeModifiers module. The module\n   * modifies a tree structure in such a way as to obtain the correct structure consistent with the\n   * called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} headerLevel Header level index (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerNodeModification(action, headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    const nodeToProcess = _classPrivateFieldGet(_headersTree, this).getNode(headerLevel, columnIndex);\n    let actionResult;\n    if (nodeToProcess) {\n      actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);\n\n      // TODO (perf-tip): Trigger matrix generation once after multiple node modifications.\n      _classPrivateFieldSet(_stateMatrix, this, generateMatrix(_classPrivateFieldGet(_headersTree, this).getRoots()));\n    }\n    return actionResult;\n  }\n\n  /**\n   * Triggers an action (e.g. \"hide-column\") from the NodeModifiers module. The action is\n   * triggered starting from the lowest header. The module modifies a tree structure in\n   * such a way as to obtain the correct structure consistent with the called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerColumnModification(action, columnIndex) {\n    return this.triggerNodeModification(action, -1, columnIndex);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function rowCoordsToLevel\n   *\n   * Translates row coordinates into header level. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Row coords             Header level\n   *           +--------------+\n   *       -3  │ A1 │ A1      │  0\n   *           +--------------+\n   *       -2  │ B1 │ B2 │ B3 │  1\n   *           +--------------+\n   *       -1  │ C1 │ C2 │ C3 │  2\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} rowIndex A visual row index.\n   * @returns {number|null} Returns unsigned number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  rowCoordsToLevel(rowIndex) {\n    if (rowIndex >= 0) {\n      return null;\n    }\n    const headerLevel = rowIndex + Math.max(this.getLayersCount(), 1);\n    if (headerLevel < 0) {\n      return null;\n    }\n    return headerLevel;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function levelToRowCoords\n   *\n   * Translates header level into row coordinates. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Header level            Row coords\n   *           +--------------+\n   *        0  │ A1 │ A1      │  -3\n   *           +--------------+\n   *        1  │ B1 │ B2 │ B3 │  -2\n   *           +--------------+\n   *        2  │ C1 │ C2 │ C3 │  -1\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} headerLevel Header level index.\n   * @returns {number} Returns negative number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  levelToRowCoords(headerLevel) {\n    if (headerLevel < 0) {\n      return null;\n    }\n    const rowIndex = headerLevel - Math.max(this.getLayersCount(), 1);\n    if (rowIndex >= 0) {\n      return null;\n    }\n    return rowIndex;\n  }\n\n  /**\n   * Gets column header settings for a specified column and header index. The returned object contains\n   * all information necessary for header renderers. It contains header label, colspan length, or hidden\n   * flag.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_stateMatrix, this)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;\n  }\n\n  /**\n   * Gets tree data that is connected to the column header. The returned object contains all information\n   * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header\n   * label, colspan length, or visual column index that indicates which column index the node is rendered from.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderTreeNodeData(headerLevel, columnIndex) {\n    const node = this.getHeaderTreeNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return {\n      ...node.data\n    };\n  }\n\n  /**\n   * Gets tree node that is connected to the column header.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|null}\n   */\n  getHeaderTreeNode(headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    const node = _classPrivateFieldGet(_headersTree, this).getNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return node;\n  }\n\n  /**\n   * Finds the most top header level of the column header that is rendered entirely within\n   * the passed visual columns range. If multiple columns headers are found within the range the\n   * most top header level value will be returned.\n   *\n   * @param {number} columnIndexFrom A visual column index.\n   * @param {number} [columnIndexTo] A visual column index.\n   * @returns {number} Returns a header level in format -1 to -N.\n   */\n  findTopMostEntireHeaderLevel(columnIndexFrom) {\n    var _headerLevel;\n    let columnIndexTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : columnIndexFrom;\n    const columnsWidth = columnIndexTo - columnIndexFrom + 1;\n    let atLeastOneRootFound = false;\n    let headerLevel = null;\n    for (let columnIndex = columnIndexFrom; columnIndex <= columnIndexTo; columnIndex++) {\n      const rootNode = _classPrivateFieldGet(_headersTree, this).getRootByColumn(columnIndex);\n      if (!rootNode) {\n        break;\n      }\n      atLeastOneRootFound = true;\n\n      // eslint-disable-next-line\n      rootNode.walkDown(node => {\n        const {\n          columnIndex: nodeColumnIndex,\n          headerLevel: nodeHeaderLevel,\n          origColspan,\n          isHidden\n        } = node.data;\n        if (isHidden) {\n          return;\n        }\n\n        // if the header fits entirely within the columns range get and save the node header level\n        if (origColspan <= columnsWidth && nodeColumnIndex >= columnIndexFrom && nodeColumnIndex + origColspan - 1 <= columnIndexTo && (headerLevel === null || nodeHeaderLevel < headerLevel)) {\n          headerLevel = nodeHeaderLevel;\n        }\n      }, TRAVERSAL_DF_PRE);\n    }\n    if (atLeastOneRootFound && headerLevel === null) {\n      return -1;\n    }\n    return this.levelToRowCoords((_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : 0);\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the left-most column index\n   * where the nested header begins.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findLeftMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin;\n    const {\n      isRoot\n    } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {\n      isRoot: true\n    };\n    if (isRoot) {\n      return columnIndex;\n    }\n    let stepBackColumn = columnIndex - 1;\n    while (stepBackColumn >= 0) {\n      var _this$getHeaderSettin2;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepBackColumn -= 1;\n    }\n    return stepBackColumn;\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the right-most column index\n   * where the nested header ends.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findRightMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin3;\n    const {\n      isRoot,\n      origColspan\n    } = (_this$getHeaderSettin3 = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin3 !== void 0 ? _this$getHeaderSettin3 : {\n      isRoot: true,\n      origColspan: 1\n    };\n    if (isRoot) {\n      return columnIndex + origColspan - 1;\n    }\n    let stepForthColumn = columnIndex + 1;\n    while (stepForthColumn < this.getColumnsCount()) {\n      var _this$getHeaderSettin4;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin4 = this.getHeaderSettings(headerLevel, stepForthColumn)) !== null && _this$getHeaderSettin4 !== void 0 ? _this$getHeaderSettin4 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepForthColumn += 1;\n    }\n    return stepForthColumn - 1;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_sourceSettings, this).getLayersCount();\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(_sourceSettings, this).getColumnsCount();\n  }\n\n  /**\n   * Clears the column state manager to the initial state.\n   */\n  clear() {\n    _classPrivateFieldSet(_stateMatrix, this, []);\n    _classPrivateFieldGet(_sourceSettings, this).clear();\n    _classPrivateFieldGet(_headersTree, this).clear();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}