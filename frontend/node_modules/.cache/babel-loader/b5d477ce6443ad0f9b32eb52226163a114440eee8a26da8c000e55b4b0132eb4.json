{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { getScrollableElement, getScrollbarWidth } from \"../../../helpers/dom/element.mjs\";\nimport { requestAnimationFrame } from \"../../../helpers/feature.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { isKey } from \"../../../helpers/unicode.mjs\";\nimport { isChrome } from \"../../../helpers/browser.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { InlineStartOverlay, TopOverlay, TopInlineStartCornerOverlay, BottomOverlay, BottomInlineStartCornerOverlay } from \"./overlay/index.mjs\";\n/**\n * @class Overlays\n */\nvar _overlays = /*#__PURE__*/new WeakMap();\nvar _hasRenderingStateChanged = /*#__PURE__*/new WeakMap();\nvar _containerDomResizeCount = /*#__PURE__*/new WeakMap();\nvar _containerDomResizeCountTimeout = /*#__PURE__*/new WeakMap();\nclass Overlays {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @todo refactoring remove.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The walkontable event manager.\n   * @param {MasterTable} wtTable The master table.\n   */\n  constructor(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {\n    /**\n     * Walkontable instance's reference.\n     *\n     * @protected\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"wot\", null);\n    /**\n     * An array of the all overlays.\n     *\n     * @type {Overlay[]}\n     */\n    _classPrivateFieldInitSpec(this, _overlays, []);\n    /**\n     * Refer to the TopOverlay instance.\n     *\n     * @protected\n     * @type {TopOverlay}\n     */\n    _defineProperty(this, \"topOverlay\", null);\n    /**\n     * Refer to the BottomOverlay instance.\n     *\n     * @protected\n     * @type {BottomOverlay}\n     */\n    _defineProperty(this, \"bottomOverlay\", null);\n    /**\n     * Refer to the InlineStartOverlay or instance.\n     *\n     * @protected\n     * @type {InlineStartOverlay}\n     */\n    _defineProperty(this, \"inlineStartOverlay\", null);\n    /**\n     * Refer to the TopInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {TopInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"topInlineStartCornerOverlay\", null);\n    /**\n     * Refer to the BottomInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {BottomInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"bottomInlineStartCornerOverlay\", null);\n    /**\n     * Browser line height for purposes of translating mouse wheel.\n     *\n     * @private\n     * @type {number}\n     */\n    _defineProperty(this, \"browserLineHeight\", undefined);\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    /**\n     * Indicates whether the rendering state has changed for one of the overlays.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hasRenderingStateChanged, false);\n    /**\n     * The amount of times the ResizeObserver callback was fired in direct succession.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _containerDomResizeCount, 0);\n    /**\n     * The timeout ID for the ResizeObserver endless-loop-blocking logic.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _containerDomResizeCountTimeout, null);\n    /**\n     * The instance of the ResizeObserver that observes the size of the Walkontable wrapper element.\n     * In case of the size change detection the `onContainerElementResize` is fired.\n     *\n     * @private\n     * @type {ResizeObserver}\n     */\n    _defineProperty(this, \"resizeObserver\", new ResizeObserver(entries => {\n      requestAnimationFrame(() => {\n        if (!Array.isArray(entries) || !entries.length) {\n          return;\n        }\n        _classPrivateFieldSet(_containerDomResizeCount, this, _classPrivateFieldGet(_containerDomResizeCount, this) + 1);\n        if (_classPrivateFieldGet(_containerDomResizeCount, this) === 100) {\n          warn('The ResizeObserver callback was fired too many times in direct succession.' + '\\nThis may be due to an infinite loop caused by setting a dynamic height/width (for example, ' + 'with the `dvh` units) to a Handsontable container\\'s parent. ' + '\\nThe observer will be disconnected.');\n          this.resizeObserver.disconnect();\n        }\n\n        // This logic is required to prevent an endless loop of the ResizeObserver callback.\n        // https://github.com/handsontable/dev-handsontable/issues/1898#issuecomment-2154794817\n        if (_classPrivateFieldGet(_containerDomResizeCountTimeout, this) !== null) {\n          clearTimeout(_classPrivateFieldGet(_containerDomResizeCountTimeout, this));\n        }\n        _classPrivateFieldSet(_containerDomResizeCountTimeout, this, setTimeout(() => {\n          _classPrivateFieldSet(_containerDomResizeCount, this, 0);\n        }, 100));\n        this.wtSettings.getSetting('onContainerElementResize');\n      });\n    }));\n    this.wot = wotInstance;\n    this.wtSettings = wtSettings;\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtTable = wtTable;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n\n    // legacy support\n    this.instance = this.wot; // todo refactoring: move to facade\n    this.eventManager = eventManager;\n\n    // TODO refactoring: probably invalid place to this logic\n    this.scrollbarSize = getScrollbarWidth(rootDocument);\n    const isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden';\n    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);\n    this.initOverlays();\n    this.hasScrollbarBottom = false;\n    this.hasScrollbarRight = false;\n    this.destroyed = false;\n    this.keyPressed = false;\n    this.spreaderLastSize = {\n      width: null,\n      height: null\n    };\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n    this.initBrowserLineHeight();\n    this.registerListeners();\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n  }\n\n  /**\n   * Get the list of references to all overlays.\n   *\n   * @param {boolean} [includeMaster = false] If set to `true`, the list will contain the master table as the last\n   * element.\n   * @returns {(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|BottomInlineStartCornerOverlay)[]}\n   */\n  getOverlays() {\n    let includeMaster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const overlays = [..._classPrivateFieldGet(_overlays, this)];\n    if (includeMaster) {\n      overlays.push(this.wtTable);\n    }\n    return overlays;\n  }\n\n  /**\n   * Retrieve browser line height and apply its value to `browserLineHeight`.\n   *\n   * @private\n   */\n  initBrowserLineHeight() {\n    const {\n      rootWindow,\n      rootDocument\n    } = this.domBindings;\n    const computedStyle = rootWindow.getComputedStyle(rootDocument.body);\n    /**\n     * Sometimes `line-height` might be set to 'normal'. In that case, a default `font-size` should be multiplied by roughly 1.2.\n     * Https://developer.mozilla.org/pl/docs/Web/CSS/line-height#Values.\n     */\n    const lineHeight = parseInt(computedStyle.lineHeight, 10);\n    const lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;\n    this.browserLineHeight = lineHeight || lineHeightFalback;\n  }\n\n  /**\n   * Prepare overlays based on user settings.\n   *\n   * @private\n   */\n  initOverlays() {\n    const args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];\n\n    // todo refactoring: IOC, collection or factories.\n    // TODO refactoring, conceive about using generic collection of overlays.\n    this.topOverlay = new TopOverlay(...args);\n    this.bottomOverlay = new BottomOverlay(...args);\n    this.inlineStartOverlay = new InlineStartOverlay(...args);\n\n    // TODO discuss, the controversial here would be removing the lazy creation mechanism for corners.\n    // TODO cond. Has no any visual impact. They're initially hidden in same way like left, top, and bottom overlays.\n    this.topInlineStartCornerOverlay = new TopInlineStartCornerOverlay(...args, this.topOverlay, this.inlineStartOverlay);\n    this.bottomInlineStartCornerOverlay = new BottomInlineStartCornerOverlay(...args, this.bottomOverlay, this.inlineStartOverlay);\n    _classPrivateFieldSet(_overlays, this, [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay]);\n  }\n\n  /**\n   * Runs logic for the overlays before the table is drawn.\n   */\n  beforeDraw() {\n    _classPrivateFieldSet(_hasRenderingStateChanged, this, _classPrivateFieldGet(_overlays, this).reduce((acc, overlay) => {\n      return overlay.hasRenderingStateChanged() || acc;\n    }, false));\n    _classPrivateFieldGet(_overlays, this).forEach(overlay => overlay.updateStateOfRendering('before'));\n  }\n\n  /**\n   * Runs logic for the overlays after the table is drawn.\n   */\n  afterDraw() {\n    this.syncScrollWithMaster();\n    _classPrivateFieldGet(_overlays, this).forEach(overlay => {\n      const hasRenderingStateChanged = overlay.hasRenderingStateChanged();\n      overlay.updateStateOfRendering('after');\n      if (hasRenderingStateChanged && !overlay.needFullRender) {\n        overlay.reset();\n      }\n    });\n  }\n\n  /**\n   * Refresh and redraw table.\n   */\n  refreshAll() {\n    if (!this.wot.drawn) {\n      return;\n    }\n    if (!this.wtTable.holder.parentNode) {\n      // Walkontable was detached from DOM, but this handler was not removed\n      this.destroy();\n      return;\n    }\n    this.wot.draw(true);\n    if (this.verticalScrolling) {\n      this.inlineStartOverlay.onScroll(); // todo the inlineStartOverlay.onScroll() fires hook. Why is it needed there, not in any another place?\n    }\n    if (this.horizontalScrolling) {\n      this.topOverlay.onScroll();\n    }\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n  }\n\n  /**\n   * Register all necessary event listeners.\n   */\n  registerListeners() {\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const {\n      mainTableScrollableElement: topOverlayScrollableElement\n    } = this.topOverlay;\n    const {\n      mainTableScrollableElement: inlineStartOverlayScrollableElement\n    } = this.inlineStartOverlay;\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keydown', event => this.onKeyDown(event));\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keyup', () => this.onKeyUp());\n    this.eventManager.addEventListener(rootDocument, 'visibilitychange', () => this.onKeyUp());\n    this.eventManager.addEventListener(topOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n      passive: true\n    });\n    if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {\n      this.eventManager.addEventListener(inlineStartOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n        passive: true\n      });\n    }\n    const isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;\n    const isScrollOnWindow = this.scrollableElement === rootWindow;\n    const preventWheel = this.wtSettings.getSetting('preventWheel');\n    const wheelEventOptions = {\n      passive: isScrollOnWindow\n    };\n    if (preventWheel || isHighPixelRatio || !isChrome()) {\n      this.eventManager.addEventListener(this.wtTable.wtRootElement, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n    }\n    const overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    overlays.forEach(overlay => {\n      if (overlay && overlay.needFullRender) {\n        const {\n          holder\n        } = overlay.clone.wtTable; // todo rethink, maybe: overlay.getHolder()\n\n        this.eventManager.addEventListener(holder, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n      }\n    });\n    let resizeTimeout;\n    this.eventManager.addEventListener(rootWindow, 'resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.wtSettings.getSetting('onWindowResize');\n\n        // Remove resizing the window from the ResizeObserver's endless-loop-blocking logic.\n        _classPrivateFieldSet(_containerDomResizeCount, this, 0);\n      }, 200);\n    });\n    if (!isScrollOnWindow) {\n      this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);\n    }\n  }\n\n  /**\n   * Deregister all previously registered listeners.\n   */\n  deregisterListeners() {\n    this.eventManager.clearEvents(true);\n  }\n\n  /**\n   * Scroll listener.\n   *\n   * @param {Event} event The mouse event object.\n   */\n  onTableScroll(event) {\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n    const rootWindow = this.domBindings.rootWindow;\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    if (this.keyPressed) {\n      if (masterVertical !== rootWindow && target !== rootWindow && !event.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event.target.contains(masterHorizontal)) {\n        return;\n      }\n    }\n    this.syncScrollPositions(event);\n  }\n\n  /**\n   * Wheel listener for cloned overlays.\n   *\n   * @param {Event} event The mouse event object.\n   * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.\n   */\n  onCloneWheel(event, preventDefault) {\n    const {\n      rootWindow\n    } = this.domBindings;\n\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    const shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);\n    const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);\n    if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally) || this.scrollableElement === rootWindow) {\n      return;\n    }\n    const isScrollPossible = this.translateMouseWheelToScroll(event);\n    if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Key down listener.\n   *\n   * @param {Event} event The keyboard event object.\n   */\n  onKeyDown(event) {\n    this.keyPressed = isKey(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');\n  }\n\n  /**\n   * Key up listener.\n   */\n  onKeyUp() {\n    this.keyPressed = false;\n  }\n\n  /**\n   * Translate wheel event into scroll event and sync scroll overlays position.\n   *\n   * @private\n   * @param {Event} event The mouse event object.\n   * @returns {boolean}\n   */\n  translateMouseWheelToScroll(event) {\n    let deltaY = isNaN(event.deltaY) ? -1 * event.wheelDeltaY : event.deltaY;\n    let deltaX = isNaN(event.deltaX) ? -1 * event.wheelDeltaX : event.deltaX;\n    if (event.deltaMode === 1) {\n      deltaX += deltaX * this.browserLineHeight;\n      deltaY += deltaY * this.browserLineHeight;\n    }\n    const isScrollVerticallyPossible = this.scrollVertically(deltaY);\n    const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);\n    return isScrollVerticallyPossible || isScrollHorizontallyPossible;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollVertically(delta) {\n    const previousScroll = this.scrollableElement.scrollTop;\n    this.scrollableElement.scrollTop += delta;\n    return previousScroll !== this.scrollableElement.scrollTop;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollHorizontally(delta) {\n    const previousScroll = this.scrollableElement.scrollLeft;\n    this.scrollableElement.scrollLeft += delta;\n    return previousScroll !== this.scrollableElement.scrollLeft;\n  }\n\n  /**\n   * Synchronize scroll position between master table and overlay table.\n   *\n   * @private\n   */\n  syncScrollPositions() {\n    if (this.destroyed) {\n      return;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const topHolder = this.topOverlay.clone.wtTable.holder; // todo rethink\n    const leftHolder = this.inlineStartOverlay.clone.wtTable.holder; // todo rethink\n\n    const [scrollLeft, scrollTop] = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop];\n    this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;\n    this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n    if (this.horizontalScrolling) {\n      topHolder.scrollLeft = scrollLeft;\n      const bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null; // todo rethink\n\n      if (bottomHolder) {\n        bottomHolder.scrollLeft = scrollLeft;\n      }\n    }\n    if (this.verticalScrolling) {\n      leftHolder.scrollTop = scrollTop;\n    }\n    this.refreshAll();\n  }\n\n  /**\n   * Synchronize overlay scrollbars with the master scrollbar.\n   */\n  syncScrollWithMaster() {\n    if (!_classPrivateFieldGet(_hasRenderingStateChanged, this)) {\n      return;\n    }\n    const master = this.topOverlay.mainTableScrollableElement;\n    const {\n      scrollLeft,\n      scrollTop\n    } = master;\n    if (this.topOverlay.needFullRender) {\n      this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n    if (this.inlineStartOverlay.needFullRender) {\n      this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop; // todo rethink, *overlay.setScroll*()\n    }\n    _classPrivateFieldSet(_hasRenderingStateChanged, this, false);\n  }\n\n  /**\n   * Update the main scrollable elements for all the overlays.\n   */\n  updateMainScrollableElements() {\n    this.deregisterListeners();\n    this.inlineStartOverlay.updateMainScrollableElement();\n    this.topOverlay.updateMainScrollableElement();\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.updateMainScrollableElement();\n    }\n    const {\n      wtTable\n    } = this;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.scrollableElement = wtTable.holder;\n    } else {\n      this.scrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n    this.registerListeners();\n  }\n\n  /**\n   *\n   */\n  destroy() {\n    this.resizeObserver.disconnect();\n    this.eventManager.destroy();\n    // todo, probably all below `destory` calls has no sense. To analyze\n    this.topOverlay.destroy();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.destroy();\n    }\n    this.inlineStartOverlay.destroy();\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.destroy();\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.destroy();\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const wasSpreaderSizeUpdated = this.updateLastSpreaderSize();\n    if (wasSpreaderSizeUpdated) {\n      this.adjustElementsSize();\n    }\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.refresh(fastDraw);\n    }\n    this.inlineStartOverlay.refresh(fastDraw);\n    this.topOverlay.refresh(fastDraw);\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.refresh(fastDraw);\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.refresh(fastDraw);\n    }\n  }\n\n  /**\n   * Update the last cached spreader size with the current size.\n   *\n   * @returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` otherwise.\n   */\n  updateLastSpreaderSize() {\n    const spreader = this.wtTable.spreader;\n    const width = spreader.clientWidth;\n    const height = spreader.clientHeight;\n    const needsUpdating = width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height;\n    if (needsUpdating) {\n      this.spreaderLastSize.width = width;\n      this.spreaderLastSize.height = height;\n    }\n    return needsUpdating;\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   */\n  adjustElementsSize() {\n    const {\n      wtViewport\n    } = this.wot;\n    const {\n      wtTable\n    } = this;\n    const {\n      rootWindow\n    } = this.domBindings;\n    const isWindowScrolled = this.scrollableElement === rootWindow;\n    const totalColumns = this.wtSettings.getSetting('totalColumns');\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const headerRowSize = wtViewport.getRowHeaderWidth();\n    const headerColumnSize = wtViewport.getColumnHeaderHeight();\n    const proposedHiderHeight = headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1;\n    const proposedHiderWidth = headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns);\n    const hiderElement = wtTable.hider;\n    const hiderStyle = hiderElement.style;\n    const isScrolledBeyondHiderHeight = () => {\n      return isWindowScrolled ? false : this.scrollableElement.scrollTop > Math.max(0, proposedHiderHeight - wtTable.holder.clientHeight);\n    };\n    const isScrolledBeyondHiderWidth = () => {\n      return isWindowScrolled ? false : this.scrollableElement.scrollLeft > Math.max(0, proposedHiderWidth - wtTable.holder.clientWidth);\n    };\n    const columnHeaderBorderCompensation = isScrolledBeyondHiderHeight() ? 1 : 0;\n    const rowHeaderBorderCompensation = isScrolledBeyondHiderWidth() ? 1 : 0;\n\n    // If the elements are being adjusted after scrolling the table from the very beginning to the very end,\n    // we need to adjust the hider dimensions by the header border size. (https://github.com/handsontable/dev-handsontable/issues/1772)\n    hiderStyle.width = `${proposedHiderWidth + rowHeaderBorderCompensation}px`;\n    hiderStyle.height = `${proposedHiderHeight + columnHeaderBorderCompensation}px`;\n    if (this.scrollbarSize > 0) {\n      // todo refactoring, looking as a part of logic which should be moved outside the class\n      const {\n        scrollHeight: rootElemScrollHeight,\n        scrollWidth: rootElemScrollWidth\n      } = wtTable.wtRootElement;\n      const {\n        scrollHeight: holderScrollHeight,\n        scrollWidth: holderScrollWidth\n      } = wtTable.holder;\n      this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;\n      this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;\n      if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {\n        this.hasScrollbarBottom = true;\n      } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {\n        this.hasScrollbarRight = true;\n      }\n    }\n    this.topOverlay.adjustElementsSize();\n    this.inlineStartOverlay.adjustElementsSize();\n    this.bottomOverlay.adjustElementsSize();\n  }\n\n  /**\n   * Expand the hider vertically element by the provided delta value.\n   *\n   * @param {number} heightDelta The delta value to expand the hider element by.\n   */\n  expandHiderVerticallyBy(heightDelta) {\n    const {\n      wtTable\n    } = this;\n    wtTable.hider.style.height = `${parseInt(wtTable.hider.style.height, 10) + heightDelta}px`;\n  }\n\n  /**\n   * Expand the hider horizontally element by the provided delta value.\n   *\n   * @param {number} widthDelta The delta value to expand the hider element by.\n   */\n  expandHiderHorizontallyBy(widthDelta) {\n    const {\n      wtTable\n    } = this;\n    wtTable.hider.style.width = `${parseInt(wtTable.hider.style.width, 10) + widthDelta}px`;\n  }\n\n  /**\n   *\n   */\n  applyToDOM() {\n    if (!this.wtTable.isVisible()) {\n      return;\n    }\n    this.topOverlay.applyToDOM();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.applyToDOM();\n    }\n    this.inlineStartOverlay.applyToDOM();\n  }\n\n  /**\n   * Get the parent overlay of the provided element.\n   *\n   * @param {HTMLElement} element An element to process.\n   * @returns {object|null}\n   */\n  getParentOverlay(element) {\n    if (!element) {\n      return null;\n    }\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    let result = null;\n    arrayEach(overlays, overlay => {\n      if (!overlay) {\n        return;\n      }\n      if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {\n        // todo demeter\n        result = overlay.clone;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Synchronize the class names between the main overlay table and the tables on the other overlays.\n   *\n   */\n  syncOverlayTableClassNames() {\n    const masterTable = this.wtTable.TABLE;\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    arrayEach(overlays, elem => {\n      if (!elem) {\n        return;\n      }\n      elem.clone.wtTable.TABLE.className = masterTable.className; // todo demeter\n    });\n  }\n}\nexport default Overlays;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldSet","s","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","getScrollableElement","getScrollbarWidth","requestAnimationFrame","arrayEach","isKey","isChrome","warn","InlineStartOverlay","TopOverlay","TopInlineStartCornerOverlay","BottomOverlay","BottomInlineStartCornerOverlay","_overlays","WeakMap","_hasRenderingStateChanged","_containerDomResizeCount","_containerDomResizeCountTimeout","Overlays","constructor","wotInstance","facadeGetter","domBindings","wtSettings","eventManager","wtTable","undefined","ResizeObserver","entries","Array","isArray","resizeObserver","disconnect","clearTimeout","setTimeout","getSetting","wot","rootDocument","rootWindow","instance","scrollbarSize","isOverflowHidden","getComputedStyle","wtRootElement","parentNode","getPropertyValue","scrollableElement","holder","TABLE","initOverlays","hasScrollbarBottom","hasScrollbarRight","destroyed","keyPressed","spreaderLastSize","width","height","verticalScrolling","horizontalScrolling","initBrowserLineHeight","registerListeners","lastScrollX","scrollX","lastScrollY","scrollY","getOverlays","includeMaster","overlays","push","computedStyle","body","lineHeight","parseInt","lineHeightFalback","fontSize","browserLineHeight","args","topOverlay","bottomOverlay","inlineStartOverlay","topInlineStartCornerOverlay","bottomInlineStartCornerOverlay","beforeDraw","reduce","acc","overlay","hasRenderingStateChanged","forEach","updateStateOfRendering","afterDraw","syncScrollWithMaster","needFullRender","reset","refreshAll","drawn","destroy","draw","onScroll","mainTableScrollableElement","topOverlayScrollableElement","inlineStartOverlayScrollableElement","addEventListener","documentElement","event","onKeyDown","onKeyUp","onTableScroll","passive","isHighPixelRatio","devicePixelRatio","isScrollOnWindow","preventWheel","wheelEventOptions","onCloneWheel","clone","resizeTimeout","observe","parentElement","deregisterListeners","clearEvents","masterHorizontal","masterVertical","target","contains","syncScrollPositions","preventDefault","shouldNotWheelVertically","shouldNotWheelHorizontally","isScrollPossible","translateMouseWheelToScroll","keyCode","deltaY","isNaN","wheelDeltaY","deltaX","wheelDeltaX","deltaMode","isScrollVerticallyPossible","scrollVertically","isScrollHorizontallyPossible","scrollHorizontally","delta","previousScroll","scrollTop","scrollLeft","topHolder","leftHolder","bottomHolder","master","updateMainScrollableElements","updateMainScrollableElement","refresh","fastDraw","wasSpreaderSizeUpdated","updateLastSpreaderSize","adjustElementsSize","spreader","clientWidth","clientHeight","needsUpdating","wtViewport","isWindowScrolled","totalColumns","totalRows","headerRowSize","getRowHeaderWidth","headerColumnSize","getColumnHeaderHeight","proposedHiderHeight","sumCellSizes","proposedHiderWidth","hiderElement","hider","hiderStyle","style","isScrolledBeyondHiderHeight","Math","max","isScrolledBeyondHiderWidth","columnHeaderBorderCompensation","rowHeaderBorderCompensation","scrollHeight","rootElemScrollHeight","scrollWidth","rootElemScrollWidth","holderScrollHeight","holderScrollWidth","expandHiderVerticallyBy","heightDelta","expandHiderHorizontallyBy","widthDelta","applyToDOM","isVisible","getParentOverlay","element","result","syncOverlayTableClassNames","masterTable","elem","className"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/overlays.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { getScrollableElement, getScrollbarWidth } from \"../../../helpers/dom/element.mjs\";\nimport { requestAnimationFrame } from \"../../../helpers/feature.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { isKey } from \"../../../helpers/unicode.mjs\";\nimport { isChrome } from \"../../../helpers/browser.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { InlineStartOverlay, TopOverlay, TopInlineStartCornerOverlay, BottomOverlay, BottomInlineStartCornerOverlay } from \"./overlay/index.mjs\";\n/**\n * @class Overlays\n */\nvar _overlays = /*#__PURE__*/new WeakMap();\nvar _hasRenderingStateChanged = /*#__PURE__*/new WeakMap();\nvar _containerDomResizeCount = /*#__PURE__*/new WeakMap();\nvar _containerDomResizeCountTimeout = /*#__PURE__*/new WeakMap();\nclass Overlays {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @todo refactoring remove.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The walkontable event manager.\n   * @param {MasterTable} wtTable The master table.\n   */\n  constructor(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {\n    /**\n     * Walkontable instance's reference.\n     *\n     * @protected\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"wot\", null);\n    /**\n     * An array of the all overlays.\n     *\n     * @type {Overlay[]}\n     */\n    _classPrivateFieldInitSpec(this, _overlays, []);\n    /**\n     * Refer to the TopOverlay instance.\n     *\n     * @protected\n     * @type {TopOverlay}\n     */\n    _defineProperty(this, \"topOverlay\", null);\n    /**\n     * Refer to the BottomOverlay instance.\n     *\n     * @protected\n     * @type {BottomOverlay}\n     */\n    _defineProperty(this, \"bottomOverlay\", null);\n    /**\n     * Refer to the InlineStartOverlay or instance.\n     *\n     * @protected\n     * @type {InlineStartOverlay}\n     */\n    _defineProperty(this, \"inlineStartOverlay\", null);\n    /**\n     * Refer to the TopInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {TopInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"topInlineStartCornerOverlay\", null);\n    /**\n     * Refer to the BottomInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {BottomInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"bottomInlineStartCornerOverlay\", null);\n    /**\n     * Browser line height for purposes of translating mouse wheel.\n     *\n     * @private\n     * @type {number}\n     */\n    _defineProperty(this, \"browserLineHeight\", undefined);\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    /**\n     * Indicates whether the rendering state has changed for one of the overlays.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hasRenderingStateChanged, false);\n    /**\n     * The amount of times the ResizeObserver callback was fired in direct succession.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _containerDomResizeCount, 0);\n    /**\n     * The timeout ID for the ResizeObserver endless-loop-blocking logic.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _containerDomResizeCountTimeout, null);\n    /**\n     * The instance of the ResizeObserver that observes the size of the Walkontable wrapper element.\n     * In case of the size change detection the `onContainerElementResize` is fired.\n     *\n     * @private\n     * @type {ResizeObserver}\n     */\n    _defineProperty(this, \"resizeObserver\", new ResizeObserver(entries => {\n      requestAnimationFrame(() => {\n        if (!Array.isArray(entries) || !entries.length) {\n          return;\n        }\n        _classPrivateFieldSet(_containerDomResizeCount, this, _classPrivateFieldGet(_containerDomResizeCount, this) + 1);\n        if (_classPrivateFieldGet(_containerDomResizeCount, this) === 100) {\n          warn('The ResizeObserver callback was fired too many times in direct succession.' + '\\nThis may be due to an infinite loop caused by setting a dynamic height/width (for example, ' + 'with the `dvh` units) to a Handsontable container\\'s parent. ' + '\\nThe observer will be disconnected.');\n          this.resizeObserver.disconnect();\n        }\n\n        // This logic is required to prevent an endless loop of the ResizeObserver callback.\n        // https://github.com/handsontable/dev-handsontable/issues/1898#issuecomment-2154794817\n        if (_classPrivateFieldGet(_containerDomResizeCountTimeout, this) !== null) {\n          clearTimeout(_classPrivateFieldGet(_containerDomResizeCountTimeout, this));\n        }\n        _classPrivateFieldSet(_containerDomResizeCountTimeout, this, setTimeout(() => {\n          _classPrivateFieldSet(_containerDomResizeCount, this, 0);\n        }, 100));\n        this.wtSettings.getSetting('onContainerElementResize');\n      });\n    }));\n    this.wot = wotInstance;\n    this.wtSettings = wtSettings;\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtTable = wtTable;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n\n    // legacy support\n    this.instance = this.wot; // todo refactoring: move to facade\n    this.eventManager = eventManager;\n\n    // TODO refactoring: probably invalid place to this logic\n    this.scrollbarSize = getScrollbarWidth(rootDocument);\n    const isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden';\n    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);\n    this.initOverlays();\n    this.hasScrollbarBottom = false;\n    this.hasScrollbarRight = false;\n    this.destroyed = false;\n    this.keyPressed = false;\n    this.spreaderLastSize = {\n      width: null,\n      height: null\n    };\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n    this.initBrowserLineHeight();\n    this.registerListeners();\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n  }\n\n  /**\n   * Get the list of references to all overlays.\n   *\n   * @param {boolean} [includeMaster = false] If set to `true`, the list will contain the master table as the last\n   * element.\n   * @returns {(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|BottomInlineStartCornerOverlay)[]}\n   */\n  getOverlays() {\n    let includeMaster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const overlays = [..._classPrivateFieldGet(_overlays, this)];\n    if (includeMaster) {\n      overlays.push(this.wtTable);\n    }\n    return overlays;\n  }\n\n  /**\n   * Retrieve browser line height and apply its value to `browserLineHeight`.\n   *\n   * @private\n   */\n  initBrowserLineHeight() {\n    const {\n      rootWindow,\n      rootDocument\n    } = this.domBindings;\n    const computedStyle = rootWindow.getComputedStyle(rootDocument.body);\n    /**\n     * Sometimes `line-height` might be set to 'normal'. In that case, a default `font-size` should be multiplied by roughly 1.2.\n     * Https://developer.mozilla.org/pl/docs/Web/CSS/line-height#Values.\n     */\n    const lineHeight = parseInt(computedStyle.lineHeight, 10);\n    const lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;\n    this.browserLineHeight = lineHeight || lineHeightFalback;\n  }\n\n  /**\n   * Prepare overlays based on user settings.\n   *\n   * @private\n   */\n  initOverlays() {\n    const args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];\n\n    // todo refactoring: IOC, collection or factories.\n    // TODO refactoring, conceive about using generic collection of overlays.\n    this.topOverlay = new TopOverlay(...args);\n    this.bottomOverlay = new BottomOverlay(...args);\n    this.inlineStartOverlay = new InlineStartOverlay(...args);\n\n    // TODO discuss, the controversial here would be removing the lazy creation mechanism for corners.\n    // TODO cond. Has no any visual impact. They're initially hidden in same way like left, top, and bottom overlays.\n    this.topInlineStartCornerOverlay = new TopInlineStartCornerOverlay(...args, this.topOverlay, this.inlineStartOverlay);\n    this.bottomInlineStartCornerOverlay = new BottomInlineStartCornerOverlay(...args, this.bottomOverlay, this.inlineStartOverlay);\n    _classPrivateFieldSet(_overlays, this, [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay]);\n  }\n\n  /**\n   * Runs logic for the overlays before the table is drawn.\n   */\n  beforeDraw() {\n    _classPrivateFieldSet(_hasRenderingStateChanged, this, _classPrivateFieldGet(_overlays, this).reduce((acc, overlay) => {\n      return overlay.hasRenderingStateChanged() || acc;\n    }, false));\n    _classPrivateFieldGet(_overlays, this).forEach(overlay => overlay.updateStateOfRendering('before'));\n  }\n\n  /**\n   * Runs logic for the overlays after the table is drawn.\n   */\n  afterDraw() {\n    this.syncScrollWithMaster();\n    _classPrivateFieldGet(_overlays, this).forEach(overlay => {\n      const hasRenderingStateChanged = overlay.hasRenderingStateChanged();\n      overlay.updateStateOfRendering('after');\n      if (hasRenderingStateChanged && !overlay.needFullRender) {\n        overlay.reset();\n      }\n    });\n  }\n\n  /**\n   * Refresh and redraw table.\n   */\n  refreshAll() {\n    if (!this.wot.drawn) {\n      return;\n    }\n    if (!this.wtTable.holder.parentNode) {\n      // Walkontable was detached from DOM, but this handler was not removed\n      this.destroy();\n      return;\n    }\n    this.wot.draw(true);\n    if (this.verticalScrolling) {\n      this.inlineStartOverlay.onScroll(); // todo the inlineStartOverlay.onScroll() fires hook. Why is it needed there, not in any another place?\n    }\n    if (this.horizontalScrolling) {\n      this.topOverlay.onScroll();\n    }\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n  }\n\n  /**\n   * Register all necessary event listeners.\n   */\n  registerListeners() {\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const {\n      mainTableScrollableElement: topOverlayScrollableElement\n    } = this.topOverlay;\n    const {\n      mainTableScrollableElement: inlineStartOverlayScrollableElement\n    } = this.inlineStartOverlay;\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keydown', event => this.onKeyDown(event));\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keyup', () => this.onKeyUp());\n    this.eventManager.addEventListener(rootDocument, 'visibilitychange', () => this.onKeyUp());\n    this.eventManager.addEventListener(topOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n      passive: true\n    });\n    if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {\n      this.eventManager.addEventListener(inlineStartOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n        passive: true\n      });\n    }\n    const isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;\n    const isScrollOnWindow = this.scrollableElement === rootWindow;\n    const preventWheel = this.wtSettings.getSetting('preventWheel');\n    const wheelEventOptions = {\n      passive: isScrollOnWindow\n    };\n    if (preventWheel || isHighPixelRatio || !isChrome()) {\n      this.eventManager.addEventListener(this.wtTable.wtRootElement, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n    }\n    const overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    overlays.forEach(overlay => {\n      if (overlay && overlay.needFullRender) {\n        const {\n          holder\n        } = overlay.clone.wtTable; // todo rethink, maybe: overlay.getHolder()\n\n        this.eventManager.addEventListener(holder, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n      }\n    });\n    let resizeTimeout;\n    this.eventManager.addEventListener(rootWindow, 'resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.wtSettings.getSetting('onWindowResize');\n\n        // Remove resizing the window from the ResizeObserver's endless-loop-blocking logic.\n        _classPrivateFieldSet(_containerDomResizeCount, this, 0);\n      }, 200);\n    });\n    if (!isScrollOnWindow) {\n      this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);\n    }\n  }\n\n  /**\n   * Deregister all previously registered listeners.\n   */\n  deregisterListeners() {\n    this.eventManager.clearEvents(true);\n  }\n\n  /**\n   * Scroll listener.\n   *\n   * @param {Event} event The mouse event object.\n   */\n  onTableScroll(event) {\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n    const rootWindow = this.domBindings.rootWindow;\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    if (this.keyPressed) {\n      if (masterVertical !== rootWindow && target !== rootWindow && !event.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event.target.contains(masterHorizontal)) {\n        return;\n      }\n    }\n    this.syncScrollPositions(event);\n  }\n\n  /**\n   * Wheel listener for cloned overlays.\n   *\n   * @param {Event} event The mouse event object.\n   * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.\n   */\n  onCloneWheel(event, preventDefault) {\n    const {\n      rootWindow\n    } = this.domBindings;\n\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    const shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);\n    const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);\n    if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally) || this.scrollableElement === rootWindow) {\n      return;\n    }\n    const isScrollPossible = this.translateMouseWheelToScroll(event);\n    if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Key down listener.\n   *\n   * @param {Event} event The keyboard event object.\n   */\n  onKeyDown(event) {\n    this.keyPressed = isKey(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');\n  }\n\n  /**\n   * Key up listener.\n   */\n  onKeyUp() {\n    this.keyPressed = false;\n  }\n\n  /**\n   * Translate wheel event into scroll event and sync scroll overlays position.\n   *\n   * @private\n   * @param {Event} event The mouse event object.\n   * @returns {boolean}\n   */\n  translateMouseWheelToScroll(event) {\n    let deltaY = isNaN(event.deltaY) ? -1 * event.wheelDeltaY : event.deltaY;\n    let deltaX = isNaN(event.deltaX) ? -1 * event.wheelDeltaX : event.deltaX;\n    if (event.deltaMode === 1) {\n      deltaX += deltaX * this.browserLineHeight;\n      deltaY += deltaY * this.browserLineHeight;\n    }\n    const isScrollVerticallyPossible = this.scrollVertically(deltaY);\n    const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);\n    return isScrollVerticallyPossible || isScrollHorizontallyPossible;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollVertically(delta) {\n    const previousScroll = this.scrollableElement.scrollTop;\n    this.scrollableElement.scrollTop += delta;\n    return previousScroll !== this.scrollableElement.scrollTop;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollHorizontally(delta) {\n    const previousScroll = this.scrollableElement.scrollLeft;\n    this.scrollableElement.scrollLeft += delta;\n    return previousScroll !== this.scrollableElement.scrollLeft;\n  }\n\n  /**\n   * Synchronize scroll position between master table and overlay table.\n   *\n   * @private\n   */\n  syncScrollPositions() {\n    if (this.destroyed) {\n      return;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const topHolder = this.topOverlay.clone.wtTable.holder; // todo rethink\n    const leftHolder = this.inlineStartOverlay.clone.wtTable.holder; // todo rethink\n\n    const [scrollLeft, scrollTop] = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop];\n    this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;\n    this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n    if (this.horizontalScrolling) {\n      topHolder.scrollLeft = scrollLeft;\n      const bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null; // todo rethink\n\n      if (bottomHolder) {\n        bottomHolder.scrollLeft = scrollLeft;\n      }\n    }\n    if (this.verticalScrolling) {\n      leftHolder.scrollTop = scrollTop;\n    }\n    this.refreshAll();\n  }\n\n  /**\n   * Synchronize overlay scrollbars with the master scrollbar.\n   */\n  syncScrollWithMaster() {\n    if (!_classPrivateFieldGet(_hasRenderingStateChanged, this)) {\n      return;\n    }\n    const master = this.topOverlay.mainTableScrollableElement;\n    const {\n      scrollLeft,\n      scrollTop\n    } = master;\n    if (this.topOverlay.needFullRender) {\n      this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n    if (this.inlineStartOverlay.needFullRender) {\n      this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop; // todo rethink, *overlay.setScroll*()\n    }\n    _classPrivateFieldSet(_hasRenderingStateChanged, this, false);\n  }\n\n  /**\n   * Update the main scrollable elements for all the overlays.\n   */\n  updateMainScrollableElements() {\n    this.deregisterListeners();\n    this.inlineStartOverlay.updateMainScrollableElement();\n    this.topOverlay.updateMainScrollableElement();\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.updateMainScrollableElement();\n    }\n    const {\n      wtTable\n    } = this;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.scrollableElement = wtTable.holder;\n    } else {\n      this.scrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n    this.registerListeners();\n  }\n\n  /**\n   *\n   */\n  destroy() {\n    this.resizeObserver.disconnect();\n    this.eventManager.destroy();\n    // todo, probably all below `destory` calls has no sense. To analyze\n    this.topOverlay.destroy();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.destroy();\n    }\n    this.inlineStartOverlay.destroy();\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.destroy();\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.destroy();\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const wasSpreaderSizeUpdated = this.updateLastSpreaderSize();\n    if (wasSpreaderSizeUpdated) {\n      this.adjustElementsSize();\n    }\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.refresh(fastDraw);\n    }\n    this.inlineStartOverlay.refresh(fastDraw);\n    this.topOverlay.refresh(fastDraw);\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.refresh(fastDraw);\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.refresh(fastDraw);\n    }\n  }\n\n  /**\n   * Update the last cached spreader size with the current size.\n   *\n   * @returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` otherwise.\n   */\n  updateLastSpreaderSize() {\n    const spreader = this.wtTable.spreader;\n    const width = spreader.clientWidth;\n    const height = spreader.clientHeight;\n    const needsUpdating = width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height;\n    if (needsUpdating) {\n      this.spreaderLastSize.width = width;\n      this.spreaderLastSize.height = height;\n    }\n    return needsUpdating;\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   */\n  adjustElementsSize() {\n    const {\n      wtViewport\n    } = this.wot;\n    const {\n      wtTable\n    } = this;\n    const {\n      rootWindow\n    } = this.domBindings;\n    const isWindowScrolled = this.scrollableElement === rootWindow;\n    const totalColumns = this.wtSettings.getSetting('totalColumns');\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const headerRowSize = wtViewport.getRowHeaderWidth();\n    const headerColumnSize = wtViewport.getColumnHeaderHeight();\n    const proposedHiderHeight = headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1;\n    const proposedHiderWidth = headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns);\n    const hiderElement = wtTable.hider;\n    const hiderStyle = hiderElement.style;\n    const isScrolledBeyondHiderHeight = () => {\n      return isWindowScrolled ? false : this.scrollableElement.scrollTop > Math.max(0, proposedHiderHeight - wtTable.holder.clientHeight);\n    };\n    const isScrolledBeyondHiderWidth = () => {\n      return isWindowScrolled ? false : this.scrollableElement.scrollLeft > Math.max(0, proposedHiderWidth - wtTable.holder.clientWidth);\n    };\n    const columnHeaderBorderCompensation = isScrolledBeyondHiderHeight() ? 1 : 0;\n    const rowHeaderBorderCompensation = isScrolledBeyondHiderWidth() ? 1 : 0;\n\n    // If the elements are being adjusted after scrolling the table from the very beginning to the very end,\n    // we need to adjust the hider dimensions by the header border size. (https://github.com/handsontable/dev-handsontable/issues/1772)\n    hiderStyle.width = `${proposedHiderWidth + rowHeaderBorderCompensation}px`;\n    hiderStyle.height = `${proposedHiderHeight + columnHeaderBorderCompensation}px`;\n    if (this.scrollbarSize > 0) {\n      // todo refactoring, looking as a part of logic which should be moved outside the class\n      const {\n        scrollHeight: rootElemScrollHeight,\n        scrollWidth: rootElemScrollWidth\n      } = wtTable.wtRootElement;\n      const {\n        scrollHeight: holderScrollHeight,\n        scrollWidth: holderScrollWidth\n      } = wtTable.holder;\n      this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;\n      this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;\n      if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {\n        this.hasScrollbarBottom = true;\n      } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {\n        this.hasScrollbarRight = true;\n      }\n    }\n    this.topOverlay.adjustElementsSize();\n    this.inlineStartOverlay.adjustElementsSize();\n    this.bottomOverlay.adjustElementsSize();\n  }\n\n  /**\n   * Expand the hider vertically element by the provided delta value.\n   *\n   * @param {number} heightDelta The delta value to expand the hider element by.\n   */\n  expandHiderVerticallyBy(heightDelta) {\n    const {\n      wtTable\n    } = this;\n    wtTable.hider.style.height = `${parseInt(wtTable.hider.style.height, 10) + heightDelta}px`;\n  }\n\n  /**\n   * Expand the hider horizontally element by the provided delta value.\n   *\n   * @param {number} widthDelta The delta value to expand the hider element by.\n   */\n  expandHiderHorizontallyBy(widthDelta) {\n    const {\n      wtTable\n    } = this;\n    wtTable.hider.style.width = `${parseInt(wtTable.hider.style.width, 10) + widthDelta}px`;\n  }\n\n  /**\n   *\n   */\n  applyToDOM() {\n    if (!this.wtTable.isVisible()) {\n      return;\n    }\n    this.topOverlay.applyToDOM();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.applyToDOM();\n    }\n    this.inlineStartOverlay.applyToDOM();\n  }\n\n  /**\n   * Get the parent overlay of the provided element.\n   *\n   * @param {HTMLElement} element An element to process.\n   * @returns {object|null}\n   */\n  getParentOverlay(element) {\n    if (!element) {\n      return null;\n    }\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    let result = null;\n    arrayEach(overlays, overlay => {\n      if (!overlay) {\n        return;\n      }\n      if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {\n        // todo demeter\n        result = overlay.clone;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Synchronize the class names between the main overlay table and the tables on the other overlays.\n   *\n   */\n  syncOverlayTableClassNames() {\n    const masterTable = this.wtTable.TABLE;\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    arrayEach(overlays, elem => {\n      if (!elem) {\n        return;\n      }\n      elem.clone.wtTable.TABLE.className = masterTable.className; // todo demeter\n    });\n  }\n}\nexport default Overlays;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}