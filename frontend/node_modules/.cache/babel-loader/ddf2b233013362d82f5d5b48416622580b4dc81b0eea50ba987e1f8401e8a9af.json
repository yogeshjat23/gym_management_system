{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { addClass, removeClass } from \"../../helpers/dom/element.mjs\";\nimport { isNumeric, clamp } from \"../../helpers/number.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { isLeftClick, isRightClick, isTouchEvent } from \"../../helpers/dom/event.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { ACTIVE_HEADER_TYPE, HEADER_TYPE } from \"../../selection/index.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport StateManager from \"./stateManager/index.mjs\";\nimport GhostTable from \"./utils/ghostTable.mjs\";\nexport const PLUGIN_KEY = 'nestedHeaders';\nexport const PLUGIN_PRIORITY = 280;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin NestedHeaders\n * @class NestedHeaders\n *\n * @description\n * The plugin allows to create a nested header structure, using the HTML's colspan attribute.\n *\n * To make any header wider (covering multiple table columns), it's corresponding configuration array element should be\n * provided as an object with `label` and `colspan` properties. The `label` property defines the header's label,\n * while the `colspan` property defines a number of columns that the header should cover.\n * You can also set custom class names to any of the headers by providing the `headerClassName` property.\n *\n * __Note__ that the plugin supports a *nested* structure, which means, any header cannot be wider than it's \"parent\". In\n * other words, headers cannot overlap each other.\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   nestedHeaders: [\n *     ['A', {label: 'B', colspan: 8, headerClassName: 'htRight'}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   nestedHeaders={[\n *     ['A', {label: 'B', colspan: 8, headerClassName: 'htRight'}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ]}\n * />\n * ```\n * :::\n */\nvar _stateManager = /*#__PURE__*/new WeakMap();\nvar _hidingIndexMapObserver = /*#__PURE__*/new WeakMap();\nvar _focusInitialCoords = /*#__PURE__*/new WeakMap();\nvar _isColumnsSelectionInProgress = /*#__PURE__*/new WeakMap();\nvar _NestedHeaders_brand = /*#__PURE__*/new WeakSet();\nexport class NestedHeaders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Updates the selection focus highlight position to point to the nested header root element (TH)\n     * even when the logical coordinates point in-between the header.\n     */\n    _classPrivateMethodInitSpec(this, _NestedHeaders_brand);\n    /**\n     * The state manager for the nested headers.\n     *\n     * @type {StateManager}\n     */\n    _classPrivateFieldInitSpec(this, _stateManager, new StateManager());\n    /**\n     * The instance of the ChangesObservable class that allows track the changes that happens in the\n     * column indexes.\n     *\n     * @type {ChangesObservable}\n     */\n    _classPrivateFieldInitSpec(this, _hidingIndexMapObserver, null);\n    /**\n     * Holds the coords that points to the place where the column selection starts.\n     *\n     * @type {number|null}\n     */\n    _classPrivateFieldInitSpec(this, _focusInitialCoords, null);\n    /**\n     * Determines if there is performed the column selection.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isColumnsSelectionInProgress, false);\n    /**\n     * Custom helper for getting widths of the nested headers.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    // @TODO This should be changed after refactor handsontable/utils/ghostTable.\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot, (row, column) => this.getHeaderSettings(row, column)));\n    /**\n     * The flag which determines that the nested header settings contains overlapping headers\n     * configuration.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"detectedOverlappedHeaders\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Check if plugin is enabled.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {\n      warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);\n    }\n    this.addHook('init', () => _assertClassBrand(_NestedHeaders_brand, this, _onInit).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('afterOnCellMouseDown', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseUp', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseUp).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeSelectionHighlightSet).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyTransformStart).call(_this, ...args);\n    });\n    this.addHook('afterSelection', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.addHook('afterSelectionFocusSet', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.addHook('beforeViewportScrollHorizontally', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeViewportScrollHorizontally).call(_this, ...args);\n    });\n    this.addHook('afterGetColumnHeaderRenderers', array => _assertClassBrand(_NestedHeaders_brand, this, _onAfterGetColumnHeaderRenderers).call(this, array));\n    this.addHook('modifyColWidth', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyColWidth).call(_this, ...args);\n    });\n    this.addHook('modifyColumnHeaderValue', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyColumnHeaderValue).call(_this, ...args);\n    });\n    this.addHook('beforeHighlightingColumnHeader', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeHighlightingColumnHeader).call(_this, ...args);\n    });\n    this.addHook('beforeCopy', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeCopy).call(_this, ...args);\n    });\n    this.addHook('beforeSelectColumns', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeSelectColumns).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterViewportColumnCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('modifyFocusedElement', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyFocusedElement).call(_this, ...args);\n    });\n    this.hot.columnIndexMapper.addLocalHook('cacheUpdated', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.hot.rowIndexMapper.addLocalHook('cacheUpdated', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    super.enablePlugin();\n    this.updatePlugin(); // @TODO: Workaround for broken plugin initialization abstraction.\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() {\n    if (!this.hot.view) {\n      // @TODO: Workaround for broken plugin initialization abstraction.\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    _classPrivateFieldGet(_stateManager, this).setColumnsLimit(this.hot.countCols());\n    if (Array.isArray(nestedHeaders)) {\n      this.detectedOverlappedHeaders = _classPrivateFieldGet(_stateManager, this).setState(nestedHeaders);\n    }\n    if (this.detectedOverlappedHeaders) {\n      warn(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported.`);\n    }\n    if (this.enabled) {\n      // This line covers the case when a developer uses the external hiding maps to manipulate\n      // the columns' visibility. The tree state built from the settings - which is always built\n      // as if all the columns are visible, needs to be modified to be in sync with a dataset.\n      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {\n        const actionName = isColumnHidden === true ? 'hide-column' : 'show-column';\n        _classPrivateFieldGet(_stateManager, this).triggerColumnModification(actionName, physicalColumnIndex);\n      });\n    }\n    if (!_classPrivateFieldGet(_hidingIndexMapObserver, this) && this.enabled) {\n      _classPrivateFieldSet(_hidingIndexMapObserver, this, this.hot.columnIndexMapper.createChangesObserver('hiding').subscribe(changes => {\n        changes.forEach(_ref => {\n          let {\n            op,\n            index: columnIndex,\n            newValue\n          } = _ref;\n          if (op === 'replace') {\n            const actionName = newValue === true ? 'hide-column' : 'show-column';\n            _classPrivateFieldGet(_stateManager, this).triggerColumnModification(actionName, columnIndex);\n          }\n        });\n        this.ghostTable.buildWidthsMap();\n      }));\n    }\n    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearColspans();\n    _classPrivateFieldGet(_stateManager, this).clear();\n    _classPrivateFieldGet(_hidingIndexMapObserver, this).unsubscribe();\n    _classPrivateFieldSet(_hidingIndexMapObserver, this, null);\n    this.ghostTable.clear();\n    super.disablePlugin();\n  }\n\n  /**\n   * Returns an instance of the internal state manager of the plugin.\n   *\n   * @private\n   * @returns {StateManager}\n   */\n  getStateManager() {\n    return _classPrivateFieldGet(_stateManager, this);\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @private\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_stateManager, this).getLayersCount();\n  }\n\n  /**\n   * Gets column settings for a specified header. The returned object contains\n   * information about the header label, its colspan length, or if it is hidden\n   * in the header renderers.\n   *\n   * @private\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    return _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, columnIndex);\n  }\n\n  /**\n   * Clear the colspans remaining after plugin usage.\n   *\n   * @private\n   */\n  clearColspans() {\n    if (!this.hot.view) {\n      return;\n    }\n    const {\n      _wt: wt\n    } = this.hot.view;\n    const headerLevels = wt.getSetting('columnHeaders').length;\n    const mainHeaders = wt.wtTable.THEAD;\n    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;\n    for (let i = 0; i < headerLevels; i++) {\n      const masterLevel = mainHeaders.childNodes[i];\n      if (!masterLevel) {\n        break;\n      }\n      const topLevel = topHeaders.childNodes[i];\n      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;\n      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {\n        masterLevel.childNodes[j].removeAttribute('colspan');\n        removeClass(masterLevel.childNodes[j], 'hiddenHeader');\n        if (topLevel && topLevel.childNodes[j]) {\n          topLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLevel.childNodes[j], 'hiddenHeader');\n        }\n        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {\n          topLeftCornerLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLeftCornerLevel.childNodes[j], 'hiddenHeader');\n        }\n      }\n    }\n  }\n\n  /**\n   * Generates the appropriate header renderer for a header row.\n   *\n   * @private\n   * @param {number} headerLevel The index of header level counting from the top (positive\n   *                             values counting from 0 to N).\n   * @returns {Function}\n   * @fires Hooks#afterGetColHeader\n   */\n  headerRendererFactory(headerLevel) {\n    var _this2 = this;\n    const fixedColumnsStart = this.hot.view._wt.getSetting('fixedColumnsStart');\n    return (renderedColumnIndex, TH) => {\n      var _classPrivateFieldGet2;\n      const {\n        columnIndexMapper,\n        view\n      } = this.hot;\n      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n      if (visualColumnIndex === null) {\n        visualColumnIndex = renderedColumnIndex;\n      }\n      TH.removeAttribute('colspan');\n      removeClass(TH, 'hiddenHeader');\n      const {\n        colspan,\n        isHidden,\n        isPlaceholder,\n        headerClassNames\n      } = (_classPrivateFieldGet2 = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {\n        label: ''\n      };\n      if (isPlaceholder || isHidden) {\n        addClass(TH, 'hiddenHeader');\n      } else if (colspan > 1) {\n        var _wtOverlays$topInline, _wtOverlays$inlineSta;\n        const {\n          wtOverlays\n        } = view._wt;\n        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);\n        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);\n\n        // Check if there is a fixed column enabled, if so then reduce colspan to fixed column width.\n        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;\n        if (correctedColspan > 1) {\n          TH.setAttribute('colspan', correctedColspan);\n        }\n      }\n      this.hot.view.appendColHeader(visualColumnIndex, TH, function () {\n        return _this2.getColumnHeaderValue(...arguments);\n      }, headerLevel);\n\n      // Replace the higher-order `headerClassName`s with the one provided in the plugin config, if it was provided.\n      if (!isPlaceholder && !isHidden) {\n        const innerHeaderDiv = TH.querySelector('div.relative');\n        if (innerHeaderDiv && headerClassNames && headerClassNames.length > 0) {\n          removeClass(innerHeaderDiv, this.hot.getColumnMeta(visualColumnIndex).headerClassName);\n          addClass(innerHeaderDiv, headerClassNames);\n        }\n      }\n    };\n  }\n\n  /**\n   * Returns the column header value for specified column and header level index.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n   *                             and negative (-1 to -N) values. For positive values, 0 points to the\n   *                             top most header, and for negative direction, -1 points to the most bottom\n   *                             header (the header closest to the cells).\n   * @returns {string} Returns the column header value to update.\n   */\n  getColumnHeaderValue(visualColumnIndex, headerLevel) {\n    var _classPrivateFieldGet3;\n    const {\n      isHidden,\n      isPlaceholder\n    } = (_classPrivateFieldGet3 = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : {};\n    if (isPlaceholder || isHidden) {\n      return '';\n    }\n    return this.hot.getColHeader(visualColumnIndex, headerLevel);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldSet(_stateManager, this, null);\n    if (_classPrivateFieldGet(_hidingIndexMapObserver, this) !== null) {\n      _classPrivateFieldGet(_hidingIndexMapObserver, this).unsubscribe();\n      _classPrivateFieldSet(_hidingIndexMapObserver, this, null);\n    }\n    super.destroy();\n  }\n\n  /**\n   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.\n   *\n   * @private\n   * @param {CellCoords} coords The CellCoords instance.\n   * @returns {object|undefined}\n   */\n  _getHeaderTreeNodeDataByCoords(coords) {\n    if (coords.row >= 0 || coords.col < 0) {\n      return;\n    }\n    return _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(coords.row, coords.col);\n  }\n}\nfunction _updateFocusHighlightPosition() {\n  var _this$hot;\n  const selection = (_this$hot = this.hot) === null || _this$hot === void 0 ? void 0 : _this$hot.getSelectedRangeLast();\n  if (!selection) {\n    return;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (isNestedHeadersRange) {\n    const columnIndex = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(highlight.row, highlight.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n\n    // Correct the highlight/focus selection to highlight the correct TH element\n    focusHighlight.visualCellRange.highlight.col = columnIndex;\n    focusHighlight.visualCellRange.from.col = columnIndex;\n    focusHighlight.visualCellRange.to.col = columnIndex;\n    focusHighlight.commit();\n  }\n}\n/**\n * Allows to control to which column index the viewport will be scrolled. To ensure that the viewport\n * is scrolled to the correct column for the nested header the most left and the most right visual column\n * indexes are used.\n *\n * @param {number} visualColumn A visual column index to which the viewport will be scrolled.\n * @returns {number}\n */\nfunction _onBeforeViewportScrollHorizontally(visualColumn) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection) {\n    return visualColumn;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (!isNestedHeadersRange) {\n    return visualColumn;\n  }\n  const firstColumn = this.hot.view.getFirstFullyVisibleColumn();\n  const lastColumn = this.hot.view.getLastFullyVisibleColumn();\n  const mostLeftColumnIndex = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(highlight.row, highlight.col);\n  const mostRightColumnIndex = _classPrivateFieldGet(_stateManager, this).findRightMostColumnIndex(highlight.row, highlight.col);\n\n  // do not scroll the viewport when the header is wider than the viewport\n  if (mostLeftColumnIndex < firstColumn && mostRightColumnIndex > lastColumn) {\n    return visualColumn;\n  }\n  return mostLeftColumnIndex < firstColumn ? mostLeftColumnIndex : mostRightColumnIndex;\n}\n/**\n * Allows to control which header DOM element will be used to highlight.\n *\n * @param {number} visualColumn A visual column index of the highlighted row header.\n * @param {number} headerLevel A row header level that is currently highlighted.\n * @param {object} highlightMeta An object with meta data that describes the highlight state.\n * @returns {number}\n */\nfunction _onBeforeHighlightingColumnHeader(visualColumn, headerLevel, highlightMeta) {\n  const headerNodeData = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(headerLevel, visualColumn);\n  if (!headerNodeData) {\n    return visualColumn;\n  }\n  const {\n    columnCursor,\n    selectionType,\n    selectionWidth\n  } = highlightMeta;\n  const {\n    isRoot,\n    colspan\n  } = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumn);\n  if (selectionType === HEADER_TYPE) {\n    if (!isRoot) {\n      return headerNodeData.columnIndex;\n    }\n  } else if (selectionType === ACTIVE_HEADER_TYPE) {\n    if (colspan > selectionWidth - columnCursor || !isRoot) {\n      // Prevents adding any CSS class names to the TH element\n      return null;\n    }\n  }\n  return visualColumn;\n}\n/**\n * Listens the `beforeCopy` hook that allows processing the copied column headers so that the\n * merged column headers do not propagate the value for each column but only once at the beginning\n * of the column.\n *\n * @private\n * @param {Array[]} data An array of arrays which contains data to copied.\n * @param {object[]} copyableRanges An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                                  which will copied.\n * @param {{ columnHeadersCount: number }} copiedHeadersCount An object with keys that holds information with\n *                                                            the number of copied headers.\n */\nfunction _onBeforeCopy(data, copyableRanges, _ref2) {\n  let {\n    columnHeadersCount\n  } = _ref2;\n  if (columnHeadersCount === 0) {\n    return;\n  }\n  for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {\n    const {\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    } = copyableRanges[rangeIndex];\n    const rowsCount = endRow - startRow + 1;\n    const columnsCount = startCol - endCol + 1;\n\n    // do not process dataset ranges and column headers where only one column is copied\n    if (startRow >= 0 || columnsCount === 1) {\n      break;\n    }\n    for (let column = startCol; column <= endCol; column++) {\n      for (let row = startRow; row <= endRow; row++) {\n        var _classPrivateFieldGet4;\n        const zeroBasedColumnHeaderLevel = rowsCount + row;\n        const zeroBasedColumnIndex = column - startCol;\n        if (zeroBasedColumnIndex === 0) {\n          continue; // eslint-disable-line no-continue\n        }\n        const isRoot = (_classPrivateFieldGet4 = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.isRoot;\n        if (isRoot === false) {\n          data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = '';\n        }\n      }\n    }\n  }\n}\n/**\n * Allows blocking the column selection that is controlled by the core Selection module.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {CellCoords} TD The table cell or header element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (headerNodeData) {\n    // Block the Selection module in controlling how the columns are selected. Pass the\n    // responsibility of the column selection to this plugin (see \"onAfterOnCellMouseDown\" hook).\n    controller.column = true;\n  }\n}\n/**\n * Allows to control how the column selection based on the coordinates and the nested headers is made.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n */\nfunction _onAfterOnCellMouseDown(event, coords) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  _classPrivateFieldSet(_focusInitialCoords, this, coords.clone());\n  _classPrivateFieldSet(_isColumnsSelectionInProgress, this, true);\n  const {\n    selection\n  } = this.hot;\n  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;\n  const columnsToSelect = [];\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n\n  // The Selection module doesn't allow it to extend its behavior easily. That's why here we need\n  // to re-implement the \"click\" and \"shift\" behavior. As a workaround, the logic for the nested\n  // headers must implement a similar logic as in the original Selection handler\n  // (see src/selection/mouseEventHandler.js).\n  const allowRightClickSelection = !selection.inInSelection(coords);\n  if (event.shiftKey && currentSelection) {\n    if (coords.col < currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);\n    } else if (coords.col > currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);\n    } else {\n      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n    }\n  } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection || isTouchEvent(event)) {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n  }\n\n  // The plugin takes control of how the columns are selected.\n  selection.selectColumns(...columnsToSelect);\n}\n/**\n * Makes the header-selection properly select the nested headers.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {HTMLElement} TD The cell element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  if (!this.hot.view.isMouseDown()) {\n    return;\n  }\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const topStartCoords = selectedRange.getTopStartCorner();\n  const bottomEndCoords = selectedRange.getBottomEndCorner();\n  const {\n    from\n  } = selectedRange;\n\n  // Block the Selection module in controlling how the columns and cells are selected.\n  // From now on, the plugin is responsible for the selection.\n  controller.column = true;\n  controller.cell = true;\n  const columnsToSelect = [];\n  const headerLevel = clamp(coords.row, -Infinity, -1);\n  if (coords.col < from.col) {\n    columnsToSelect.push(bottomEndCoords.col, columnIndex, headerLevel);\n  } else if (coords.col > from.col) {\n    columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1, headerLevel);\n  } else {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, headerLevel);\n  }\n  this.hot.selection.selectColumns(...columnsToSelect);\n}\n/**\n * Switches internal flag about selection progress to `false`.\n */\nfunction _onBeforeOnCellMouseUp() {\n  _classPrivateFieldSet(_isColumnsSelectionInProgress, this, false);\n}\n/**\n * The hook checks and ensures that the focus position that depends on the selected columns\n * range is always positioned within the range.\n */\nfunction _onBeforeSelectionHighlightSet() {\n  const {\n    navigableHeaders\n  } = this.hot.getSettings();\n  if (!this.hot.view.isMouseDown() || !_classPrivateFieldGet(_isColumnsSelectionInProgress, this) || !navigableHeaders) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const columnStart = selectedRange.getTopStartCorner().col;\n  const columnEnd = selectedRange.getBottomEndCorner().col;\n  const {\n    columnIndex,\n    origColspan\n  } = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(_classPrivateFieldGet(_focusInitialCoords, this).row, _classPrivateFieldGet(_focusInitialCoords, this).col);\n  selectedRange.setHighlight(_classPrivateFieldGet(_focusInitialCoords, this));\n  if (origColspan > selectedRange.getWidth() || columnIndex < columnStart || columnIndex + origColspan - 1 > columnEnd) {\n    const headerLevel = _classPrivateFieldGet(_stateManager, this).findTopMostEntireHeaderLevel(clamp(columnStart, columnIndex, columnIndex + origColspan - 1), clamp(columnEnd, columnIndex, columnIndex + origColspan - 1));\n    selectedRange.highlight.row = headerLevel;\n    selectedRange.highlight.col = selectedRange.from.col;\n  }\n}\n/**\n * `modifyTransformStart` hook is called every time the keyboard navigation is used.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformStart(delta) {\n  const {\n    highlight\n  } = this.hot.getSelectedRangeLast();\n  const nextCoords = this.hot._createCellCoords(highlight.row + delta.row, highlight.col + delta.col);\n  const isNestedHeadersRange = nextCoords.isHeader() && nextCoords.col >= 0;\n  if (!isNestedHeadersRange) {\n    return;\n  }\n  const visualColumnIndexStart = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(nextCoords.row, nextCoords.col);\n  const visualColumnIndexEnd = _classPrivateFieldGet(_stateManager, this).findRightMostColumnIndex(nextCoords.row, nextCoords.col);\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook observes the column selection from the Selection API and modifies the column range to\n * ensure that the whole nested column will be covered.\n *\n * @param {CellCoords} from The coords object where the selection starts.\n * @param {CellCoords} to The coords object where the selection ends.\n */\nfunction _onBeforeSelectColumns(from, to) {\n  const headerLevel = from.row;\n  const startNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: from.col\n  });\n  const endNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: to.col\n  });\n  if (to.col < from.col) {\n    // Column selection from right to left\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex + startNodeData.origColspan - 1;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex;\n    }\n  } else if (to.col >= from.col) {\n    // Column selection from left to right or a single column selection\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex + endNodeData.origColspan - 1;\n    }\n  }\n}\n/**\n * `afterGetColumnHeader` hook callback - prepares the header structure.\n *\n * @param {Array} renderersArray Array of renderers.\n */\nfunction _onAfterGetColumnHeaderRenderers(renderersArray) {\n  renderersArray.length = 0;\n  for (let headerLayer = 0; headerLayer < _classPrivateFieldGet(_stateManager, this).getLayersCount(); headerLayer++) {\n    renderersArray.push(this.headerRendererFactory(headerLayer));\n  }\n}\n/**\n * Make the renderer render the first nested column in its entirety.\n *\n * @param {object} calc Viewport column calculator.\n */\nfunction _onAfterViewportColumnCalculatorOverride(calc) {\n  const headerLayersCount = _classPrivateFieldGet(_stateManager, this).getLayersCount();\n  let newStartColumn = calc.startColumn;\n  let nonRenderable = !!headerLayersCount;\n  for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {\n    const startColumn = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(headerLayer, calc.startColumn);\n    const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);\n\n    // If any of the headers for that column index is rendered, all of them should be rendered properly, see\n    // comment below.\n    if (startColumn >= 0) {\n      nonRenderable = false;\n    }\n\n    // `renderedStartColumn` can be `null` if the leftmost columns are hidden. In that case -> ignore that header\n    // level, as it should be handled by the \"parent\" header\n    if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {\n      newStartColumn = renderedStartColumn;\n      break;\n    }\n  }\n\n  // If no headers for the provided column index are renderable, start rendering from the beginning of the upmost\n  // header for that position.\n  calc.startColumn = nonRenderable ? _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;\n}\n/**\n * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.\n *\n * @param {number} width Width from hook.\n * @param {number} column Visual index of an column.\n * @returns {number}\n */\nfunction _onModifyColWidth(width, column) {\n  const cachedWidth = this.ghostTable.getWidth(column);\n  return width > cachedWidth ? width : cachedWidth;\n}\n/**\n * Listens the `modifyColumnHeaderValue` hook that overwrites the column headers values based on\n * the internal state and settings of the plugin.\n *\n * @param {string} value The column header value.\n * @param {number} visualColumnIndex The visual column index.\n * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n *                             and negative (-1 to -N) values. For positive values, 0 points to the\n *                             top most header, and for negative direction, -1 points to the most bottom\n *                             header (the header closest to the cells).\n * @returns {string} Returns the column header value to update.\n */\nfunction _onModifyColumnHeaderValue(value, visualColumnIndex, headerLevel) {\n  var _classPrivateFieldGet5;\n  const {\n    label\n  } = (_classPrivateFieldGet5 = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : {\n    label: ''\n  };\n  return label;\n}\n/**\n * `modifyFocusedElement` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} column Column index.\n * @returns {HTMLTableCellElement} The `TH` element to be focused.\n */\nfunction _onModifyFocusedElement(row, column) {\n  if (row < 0) {\n    return this.hot.getCell(row, _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(row, column), true);\n  }\n}\n/**\n * Updates the plugin state after HoT initialization.\n */\nfunction _onInit() {\n  // @TODO: Workaround for broken plugin initialization abstraction.\n  this.updatePlugin();\n}\n/**\n * Updates the plugin state after new dataset load.\n *\n * @param {Array[]} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded\n *                              during the initialization.\n */\nfunction _onAfterLoadData(sourceData, initialLoad) {\n  if (!initialLoad) {\n    this.updatePlugin();\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_defineProperty","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","_classPrivateFieldInitSpec","set","has","_classPrivateFieldSet","s","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","addClass","removeClass","isNumeric","clamp","toSingleLine","isLeftClick","isRightClick","isTouchEvent","warn","ACTIVE_HEADER_TYPE","HEADER_TYPE","BasePlugin","StateManager","GhostTable","PLUGIN_KEY","PLUGIN_PRIORITY","_stateManager","WeakMap","_hidingIndexMapObserver","_focusInitialCoords","_isColumnsSelectionInProgress","_NestedHeaders_brand","WeakSet","NestedHeaders","constructor","hot","row","column","getHeaderSettings","isEnabled","getSettings","enablePlugin","_this","enabled","nestedHeaders","Array","isArray","addHook","_onInit","_len","args","_key","_onAfterLoadData","_len2","_key2","_onBeforeOnCellMouseDown","_len3","_key3","_onAfterOnCellMouseDown","_len4","_key4","_onBeforeOnCellMouseOver","_len5","_key5","_onBeforeOnCellMouseUp","_len6","_key6","_onBeforeSelectionHighlightSet","_len7","_key7","_onModifyTransformStart","_updateFocusHighlightPosition","_len8","_key8","_onBeforeViewportScrollHorizontally","array","_onAfterGetColumnHeaderRenderers","_len9","_key9","_onModifyColWidth","_len10","_key10","_onModifyColumnHeaderValue","_len11","_key11","_onBeforeHighlightingColumnHeader","_len12","_key12","_onBeforeCopy","_len13","_key13","_onBeforeSelectColumns","_len14","_key14","_onAfterViewportColumnCalculatorOverride","_len15","_key15","_onModifyFocusedElement","columnIndexMapper","addLocalHook","rowIndexMapper","updatePlugin","view","setColumnsLimit","countCols","detectedOverlappedHeaders","setState","hidingMapsCollection","getMergedValues","forEach","isColumnHidden","physicalColumnIndex","actionName","triggerColumnModification","createChangesObserver","subscribe","changes","_ref","op","index","columnIndex","newValue","ghostTable","buildWidthsMap","setLayersCount","getLayersCount","disablePlugin","clearColspans","clear","unsubscribe","getStateManager","headerLevel","_wt","wt","headerLevels","getSetting","mainHeaders","wtTable","THEAD","topHeaders","wtOverlays","topOverlay","clone","topLeftCornerHeaders","topInlineStartCornerOverlay","masterLevel","childNodes","topLevel","topLeftCornerLevel","j","masterNodes","removeAttribute","headerRendererFactory","_this2","fixedColumnsStart","renderedColumnIndex","TH","_classPrivateFieldGet2","visualColumnIndex","getVisualFromRenderableIndex","colspan","isHidden","isPlaceholder","headerClassNames","label","_wtOverlays$topInline","_wtOverlays$inlineSta","isTopInlineStartOverlay","contains","isInlineStartOverlay","inlineStartOverlay","correctedColspan","Math","min","setAttribute","appendColHeader","getColumnHeaderValue","innerHeaderDiv","querySelector","getColumnMeta","headerClassName","_classPrivateFieldGet3","getColHeader","destroy","_getHeaderTreeNodeDataByCoords","coords","col","getHeaderTreeNodeData","_this$hot","selection","getSelectedRangeLast","highlight","isNestedHeadersRange","isHeader","findLeftMostColumnIndex","focusHighlight","getFocus","visualCellRange","from","to","commit","visualColumn","firstColumn","getFirstFullyVisibleColumn","lastColumn","getLastFullyVisibleColumn","mostLeftColumnIndex","mostRightColumnIndex","findRightMostColumnIndex","highlightMeta","headerNodeData","columnCursor","selectionType","selectionWidth","isRoot","data","copyableRanges","_ref2","columnHeadersCount","rangeIndex","startRow","startCol","endRow","endCol","rowsCount","columnsCount","_classPrivateFieldGet4","zeroBasedColumnHeaderLevel","zeroBasedColumnIndex","event","TD","controller","currentSelection","isSelected","getSelectedRange","current","columnsToSelect","origColspan","allowRightClickSelection","inInSelection","shiftKey","push","getTopEndCorner","getTopStartCorner","selectColumns","isMouseDown","selectedRange","topStartCoords","bottomEndCoords","getBottomEndCorner","cell","Infinity","navigableHeaders","columnStart","columnEnd","setHighlight","getWidth","findTopMostEntireHeaderLevel","delta","nextCoords","_createCellCoords","visualColumnIndexStart","visualColumnIndexEnd","nextColumn","notHiddenColumnIndex","getNearestNotHiddenIndex","countRenderableColumnsInRange","max","startNodeData","endNodeData","renderersArray","headerLayer","calc","headerLayersCount","newStartColumn","startColumn","nonRenderable","renderedStartColumn","getRenderableFromVisualIndex","width","cachedWidth","_classPrivateFieldGet5","getCell","sourceData","initialLoad"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedHeaders/nestedHeaders.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { addClass, removeClass } from \"../../helpers/dom/element.mjs\";\nimport { isNumeric, clamp } from \"../../helpers/number.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { isLeftClick, isRightClick, isTouchEvent } from \"../../helpers/dom/event.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { ACTIVE_HEADER_TYPE, HEADER_TYPE } from \"../../selection/index.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport StateManager from \"./stateManager/index.mjs\";\nimport GhostTable from \"./utils/ghostTable.mjs\";\nexport const PLUGIN_KEY = 'nestedHeaders';\nexport const PLUGIN_PRIORITY = 280;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin NestedHeaders\n * @class NestedHeaders\n *\n * @description\n * The plugin allows to create a nested header structure, using the HTML's colspan attribute.\n *\n * To make any header wider (covering multiple table columns), it's corresponding configuration array element should be\n * provided as an object with `label` and `colspan` properties. The `label` property defines the header's label,\n * while the `colspan` property defines a number of columns that the header should cover.\n * You can also set custom class names to any of the headers by providing the `headerClassName` property.\n *\n * __Note__ that the plugin supports a *nested* structure, which means, any header cannot be wider than it's \"parent\". In\n * other words, headers cannot overlap each other.\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   nestedHeaders: [\n *     ['A', {label: 'B', colspan: 8, headerClassName: 'htRight'}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   nestedHeaders={[\n *     ['A', {label: 'B', colspan: 8, headerClassName: 'htRight'}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ]}\n * />\n * ```\n * :::\n */\nvar _stateManager = /*#__PURE__*/new WeakMap();\nvar _hidingIndexMapObserver = /*#__PURE__*/new WeakMap();\nvar _focusInitialCoords = /*#__PURE__*/new WeakMap();\nvar _isColumnsSelectionInProgress = /*#__PURE__*/new WeakMap();\nvar _NestedHeaders_brand = /*#__PURE__*/new WeakSet();\nexport class NestedHeaders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Updates the selection focus highlight position to point to the nested header root element (TH)\n     * even when the logical coordinates point in-between the header.\n     */\n    _classPrivateMethodInitSpec(this, _NestedHeaders_brand);\n    /**\n     * The state manager for the nested headers.\n     *\n     * @type {StateManager}\n     */\n    _classPrivateFieldInitSpec(this, _stateManager, new StateManager());\n    /**\n     * The instance of the ChangesObservable class that allows track the changes that happens in the\n     * column indexes.\n     *\n     * @type {ChangesObservable}\n     */\n    _classPrivateFieldInitSpec(this, _hidingIndexMapObserver, null);\n    /**\n     * Holds the coords that points to the place where the column selection starts.\n     *\n     * @type {number|null}\n     */\n    _classPrivateFieldInitSpec(this, _focusInitialCoords, null);\n    /**\n     * Determines if there is performed the column selection.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isColumnsSelectionInProgress, false);\n    /**\n     * Custom helper for getting widths of the nested headers.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    // @TODO This should be changed after refactor handsontable/utils/ghostTable.\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot, (row, column) => this.getHeaderSettings(row, column)));\n    /**\n     * The flag which determines that the nested header settings contains overlapping headers\n     * configuration.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"detectedOverlappedHeaders\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Check if plugin is enabled.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {\n      warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);\n    }\n    this.addHook('init', () => _assertClassBrand(_NestedHeaders_brand, this, _onInit).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('afterOnCellMouseDown', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseUp', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseUp).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeSelectionHighlightSet).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyTransformStart).call(_this, ...args);\n    });\n    this.addHook('afterSelection', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.addHook('afterSelectionFocusSet', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.addHook('beforeViewportScrollHorizontally', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeViewportScrollHorizontally).call(_this, ...args);\n    });\n    this.addHook('afterGetColumnHeaderRenderers', array => _assertClassBrand(_NestedHeaders_brand, this, _onAfterGetColumnHeaderRenderers).call(this, array));\n    this.addHook('modifyColWidth', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyColWidth).call(_this, ...args);\n    });\n    this.addHook('modifyColumnHeaderValue', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyColumnHeaderValue).call(_this, ...args);\n    });\n    this.addHook('beforeHighlightingColumnHeader', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeHighlightingColumnHeader).call(_this, ...args);\n    });\n    this.addHook('beforeCopy', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeCopy).call(_this, ...args);\n    });\n    this.addHook('beforeSelectColumns', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeSelectColumns).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterViewportColumnCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('modifyFocusedElement', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyFocusedElement).call(_this, ...args);\n    });\n    this.hot.columnIndexMapper.addLocalHook('cacheUpdated', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.hot.rowIndexMapper.addLocalHook('cacheUpdated', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    super.enablePlugin();\n    this.updatePlugin(); // @TODO: Workaround for broken plugin initialization abstraction.\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() {\n    if (!this.hot.view) {\n      // @TODO: Workaround for broken plugin initialization abstraction.\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    _classPrivateFieldGet(_stateManager, this).setColumnsLimit(this.hot.countCols());\n    if (Array.isArray(nestedHeaders)) {\n      this.detectedOverlappedHeaders = _classPrivateFieldGet(_stateManager, this).setState(nestedHeaders);\n    }\n    if (this.detectedOverlappedHeaders) {\n      warn(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported.`);\n    }\n    if (this.enabled) {\n      // This line covers the case when a developer uses the external hiding maps to manipulate\n      // the columns' visibility. The tree state built from the settings - which is always built\n      // as if all the columns are visible, needs to be modified to be in sync with a dataset.\n      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {\n        const actionName = isColumnHidden === true ? 'hide-column' : 'show-column';\n        _classPrivateFieldGet(_stateManager, this).triggerColumnModification(actionName, physicalColumnIndex);\n      });\n    }\n    if (!_classPrivateFieldGet(_hidingIndexMapObserver, this) && this.enabled) {\n      _classPrivateFieldSet(_hidingIndexMapObserver, this, this.hot.columnIndexMapper.createChangesObserver('hiding').subscribe(changes => {\n        changes.forEach(_ref => {\n          let {\n            op,\n            index: columnIndex,\n            newValue\n          } = _ref;\n          if (op === 'replace') {\n            const actionName = newValue === true ? 'hide-column' : 'show-column';\n            _classPrivateFieldGet(_stateManager, this).triggerColumnModification(actionName, columnIndex);\n          }\n        });\n        this.ghostTable.buildWidthsMap();\n      }));\n    }\n    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearColspans();\n    _classPrivateFieldGet(_stateManager, this).clear();\n    _classPrivateFieldGet(_hidingIndexMapObserver, this).unsubscribe();\n    _classPrivateFieldSet(_hidingIndexMapObserver, this, null);\n    this.ghostTable.clear();\n    super.disablePlugin();\n  }\n\n  /**\n   * Returns an instance of the internal state manager of the plugin.\n   *\n   * @private\n   * @returns {StateManager}\n   */\n  getStateManager() {\n    return _classPrivateFieldGet(_stateManager, this);\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @private\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_stateManager, this).getLayersCount();\n  }\n\n  /**\n   * Gets column settings for a specified header. The returned object contains\n   * information about the header label, its colspan length, or if it is hidden\n   * in the header renderers.\n   *\n   * @private\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    return _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, columnIndex);\n  }\n\n  /**\n   * Clear the colspans remaining after plugin usage.\n   *\n   * @private\n   */\n  clearColspans() {\n    if (!this.hot.view) {\n      return;\n    }\n    const {\n      _wt: wt\n    } = this.hot.view;\n    const headerLevels = wt.getSetting('columnHeaders').length;\n    const mainHeaders = wt.wtTable.THEAD;\n    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;\n    for (let i = 0; i < headerLevels; i++) {\n      const masterLevel = mainHeaders.childNodes[i];\n      if (!masterLevel) {\n        break;\n      }\n      const topLevel = topHeaders.childNodes[i];\n      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;\n      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {\n        masterLevel.childNodes[j].removeAttribute('colspan');\n        removeClass(masterLevel.childNodes[j], 'hiddenHeader');\n        if (topLevel && topLevel.childNodes[j]) {\n          topLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLevel.childNodes[j], 'hiddenHeader');\n        }\n        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {\n          topLeftCornerLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLeftCornerLevel.childNodes[j], 'hiddenHeader');\n        }\n      }\n    }\n  }\n\n  /**\n   * Generates the appropriate header renderer for a header row.\n   *\n   * @private\n   * @param {number} headerLevel The index of header level counting from the top (positive\n   *                             values counting from 0 to N).\n   * @returns {Function}\n   * @fires Hooks#afterGetColHeader\n   */\n  headerRendererFactory(headerLevel) {\n    var _this2 = this;\n    const fixedColumnsStart = this.hot.view._wt.getSetting('fixedColumnsStart');\n    return (renderedColumnIndex, TH) => {\n      var _classPrivateFieldGet2;\n      const {\n        columnIndexMapper,\n        view\n      } = this.hot;\n      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n      if (visualColumnIndex === null) {\n        visualColumnIndex = renderedColumnIndex;\n      }\n      TH.removeAttribute('colspan');\n      removeClass(TH, 'hiddenHeader');\n      const {\n        colspan,\n        isHidden,\n        isPlaceholder,\n        headerClassNames\n      } = (_classPrivateFieldGet2 = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {\n        label: ''\n      };\n      if (isPlaceholder || isHidden) {\n        addClass(TH, 'hiddenHeader');\n      } else if (colspan > 1) {\n        var _wtOverlays$topInline, _wtOverlays$inlineSta;\n        const {\n          wtOverlays\n        } = view._wt;\n        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);\n        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);\n\n        // Check if there is a fixed column enabled, if so then reduce colspan to fixed column width.\n        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;\n        if (correctedColspan > 1) {\n          TH.setAttribute('colspan', correctedColspan);\n        }\n      }\n      this.hot.view.appendColHeader(visualColumnIndex, TH, function () {\n        return _this2.getColumnHeaderValue(...arguments);\n      }, headerLevel);\n\n      // Replace the higher-order `headerClassName`s with the one provided in the plugin config, if it was provided.\n      if (!isPlaceholder && !isHidden) {\n        const innerHeaderDiv = TH.querySelector('div.relative');\n        if (innerHeaderDiv && headerClassNames && headerClassNames.length > 0) {\n          removeClass(innerHeaderDiv, this.hot.getColumnMeta(visualColumnIndex).headerClassName);\n          addClass(innerHeaderDiv, headerClassNames);\n        }\n      }\n    };\n  }\n\n  /**\n   * Returns the column header value for specified column and header level index.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n   *                             and negative (-1 to -N) values. For positive values, 0 points to the\n   *                             top most header, and for negative direction, -1 points to the most bottom\n   *                             header (the header closest to the cells).\n   * @returns {string} Returns the column header value to update.\n   */\n  getColumnHeaderValue(visualColumnIndex, headerLevel) {\n    var _classPrivateFieldGet3;\n    const {\n      isHidden,\n      isPlaceholder\n    } = (_classPrivateFieldGet3 = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : {};\n    if (isPlaceholder || isHidden) {\n      return '';\n    }\n    return this.hot.getColHeader(visualColumnIndex, headerLevel);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldSet(_stateManager, this, null);\n    if (_classPrivateFieldGet(_hidingIndexMapObserver, this) !== null) {\n      _classPrivateFieldGet(_hidingIndexMapObserver, this).unsubscribe();\n      _classPrivateFieldSet(_hidingIndexMapObserver, this, null);\n    }\n    super.destroy();\n  }\n\n  /**\n   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.\n   *\n   * @private\n   * @param {CellCoords} coords The CellCoords instance.\n   * @returns {object|undefined}\n   */\n  _getHeaderTreeNodeDataByCoords(coords) {\n    if (coords.row >= 0 || coords.col < 0) {\n      return;\n    }\n    return _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(coords.row, coords.col);\n  }\n}\nfunction _updateFocusHighlightPosition() {\n  var _this$hot;\n  const selection = (_this$hot = this.hot) === null || _this$hot === void 0 ? void 0 : _this$hot.getSelectedRangeLast();\n  if (!selection) {\n    return;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (isNestedHeadersRange) {\n    const columnIndex = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(highlight.row, highlight.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n\n    // Correct the highlight/focus selection to highlight the correct TH element\n    focusHighlight.visualCellRange.highlight.col = columnIndex;\n    focusHighlight.visualCellRange.from.col = columnIndex;\n    focusHighlight.visualCellRange.to.col = columnIndex;\n    focusHighlight.commit();\n  }\n}\n/**\n * Allows to control to which column index the viewport will be scrolled. To ensure that the viewport\n * is scrolled to the correct column for the nested header the most left and the most right visual column\n * indexes are used.\n *\n * @param {number} visualColumn A visual column index to which the viewport will be scrolled.\n * @returns {number}\n */\nfunction _onBeforeViewportScrollHorizontally(visualColumn) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection) {\n    return visualColumn;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (!isNestedHeadersRange) {\n    return visualColumn;\n  }\n  const firstColumn = this.hot.view.getFirstFullyVisibleColumn();\n  const lastColumn = this.hot.view.getLastFullyVisibleColumn();\n  const mostLeftColumnIndex = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(highlight.row, highlight.col);\n  const mostRightColumnIndex = _classPrivateFieldGet(_stateManager, this).findRightMostColumnIndex(highlight.row, highlight.col);\n\n  // do not scroll the viewport when the header is wider than the viewport\n  if (mostLeftColumnIndex < firstColumn && mostRightColumnIndex > lastColumn) {\n    return visualColumn;\n  }\n  return mostLeftColumnIndex < firstColumn ? mostLeftColumnIndex : mostRightColumnIndex;\n}\n/**\n * Allows to control which header DOM element will be used to highlight.\n *\n * @param {number} visualColumn A visual column index of the highlighted row header.\n * @param {number} headerLevel A row header level that is currently highlighted.\n * @param {object} highlightMeta An object with meta data that describes the highlight state.\n * @returns {number}\n */\nfunction _onBeforeHighlightingColumnHeader(visualColumn, headerLevel, highlightMeta) {\n  const headerNodeData = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(headerLevel, visualColumn);\n  if (!headerNodeData) {\n    return visualColumn;\n  }\n  const {\n    columnCursor,\n    selectionType,\n    selectionWidth\n  } = highlightMeta;\n  const {\n    isRoot,\n    colspan\n  } = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumn);\n  if (selectionType === HEADER_TYPE) {\n    if (!isRoot) {\n      return headerNodeData.columnIndex;\n    }\n  } else if (selectionType === ACTIVE_HEADER_TYPE) {\n    if (colspan > selectionWidth - columnCursor || !isRoot) {\n      // Prevents adding any CSS class names to the TH element\n      return null;\n    }\n  }\n  return visualColumn;\n}\n/**\n * Listens the `beforeCopy` hook that allows processing the copied column headers so that the\n * merged column headers do not propagate the value for each column but only once at the beginning\n * of the column.\n *\n * @private\n * @param {Array[]} data An array of arrays which contains data to copied.\n * @param {object[]} copyableRanges An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                                  which will copied.\n * @param {{ columnHeadersCount: number }} copiedHeadersCount An object with keys that holds information with\n *                                                            the number of copied headers.\n */\nfunction _onBeforeCopy(data, copyableRanges, _ref2) {\n  let {\n    columnHeadersCount\n  } = _ref2;\n  if (columnHeadersCount === 0) {\n    return;\n  }\n  for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {\n    const {\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    } = copyableRanges[rangeIndex];\n    const rowsCount = endRow - startRow + 1;\n    const columnsCount = startCol - endCol + 1;\n\n    // do not process dataset ranges and column headers where only one column is copied\n    if (startRow >= 0 || columnsCount === 1) {\n      break;\n    }\n    for (let column = startCol; column <= endCol; column++) {\n      for (let row = startRow; row <= endRow; row++) {\n        var _classPrivateFieldGet4;\n        const zeroBasedColumnHeaderLevel = rowsCount + row;\n        const zeroBasedColumnIndex = column - startCol;\n        if (zeroBasedColumnIndex === 0) {\n          continue; // eslint-disable-line no-continue\n        }\n        const isRoot = (_classPrivateFieldGet4 = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.isRoot;\n        if (isRoot === false) {\n          data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = '';\n        }\n      }\n    }\n  }\n}\n/**\n * Allows blocking the column selection that is controlled by the core Selection module.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {CellCoords} TD The table cell or header element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (headerNodeData) {\n    // Block the Selection module in controlling how the columns are selected. Pass the\n    // responsibility of the column selection to this plugin (see \"onAfterOnCellMouseDown\" hook).\n    controller.column = true;\n  }\n}\n/**\n * Allows to control how the column selection based on the coordinates and the nested headers is made.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n */\nfunction _onAfterOnCellMouseDown(event, coords) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  _classPrivateFieldSet(_focusInitialCoords, this, coords.clone());\n  _classPrivateFieldSet(_isColumnsSelectionInProgress, this, true);\n  const {\n    selection\n  } = this.hot;\n  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;\n  const columnsToSelect = [];\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n\n  // The Selection module doesn't allow it to extend its behavior easily. That's why here we need\n  // to re-implement the \"click\" and \"shift\" behavior. As a workaround, the logic for the nested\n  // headers must implement a similar logic as in the original Selection handler\n  // (see src/selection/mouseEventHandler.js).\n  const allowRightClickSelection = !selection.inInSelection(coords);\n  if (event.shiftKey && currentSelection) {\n    if (coords.col < currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);\n    } else if (coords.col > currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);\n    } else {\n      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n    }\n  } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection || isTouchEvent(event)) {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n  }\n\n  // The plugin takes control of how the columns are selected.\n  selection.selectColumns(...columnsToSelect);\n}\n/**\n * Makes the header-selection properly select the nested headers.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {HTMLElement} TD The cell element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  if (!this.hot.view.isMouseDown()) {\n    return;\n  }\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const topStartCoords = selectedRange.getTopStartCorner();\n  const bottomEndCoords = selectedRange.getBottomEndCorner();\n  const {\n    from\n  } = selectedRange;\n\n  // Block the Selection module in controlling how the columns and cells are selected.\n  // From now on, the plugin is responsible for the selection.\n  controller.column = true;\n  controller.cell = true;\n  const columnsToSelect = [];\n  const headerLevel = clamp(coords.row, -Infinity, -1);\n  if (coords.col < from.col) {\n    columnsToSelect.push(bottomEndCoords.col, columnIndex, headerLevel);\n  } else if (coords.col > from.col) {\n    columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1, headerLevel);\n  } else {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, headerLevel);\n  }\n  this.hot.selection.selectColumns(...columnsToSelect);\n}\n/**\n * Switches internal flag about selection progress to `false`.\n */\nfunction _onBeforeOnCellMouseUp() {\n  _classPrivateFieldSet(_isColumnsSelectionInProgress, this, false);\n}\n/**\n * The hook checks and ensures that the focus position that depends on the selected columns\n * range is always positioned within the range.\n */\nfunction _onBeforeSelectionHighlightSet() {\n  const {\n    navigableHeaders\n  } = this.hot.getSettings();\n  if (!this.hot.view.isMouseDown() || !_classPrivateFieldGet(_isColumnsSelectionInProgress, this) || !navigableHeaders) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const columnStart = selectedRange.getTopStartCorner().col;\n  const columnEnd = selectedRange.getBottomEndCorner().col;\n  const {\n    columnIndex,\n    origColspan\n  } = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(_classPrivateFieldGet(_focusInitialCoords, this).row, _classPrivateFieldGet(_focusInitialCoords, this).col);\n  selectedRange.setHighlight(_classPrivateFieldGet(_focusInitialCoords, this));\n  if (origColspan > selectedRange.getWidth() || columnIndex < columnStart || columnIndex + origColspan - 1 > columnEnd) {\n    const headerLevel = _classPrivateFieldGet(_stateManager, this).findTopMostEntireHeaderLevel(clamp(columnStart, columnIndex, columnIndex + origColspan - 1), clamp(columnEnd, columnIndex, columnIndex + origColspan - 1));\n    selectedRange.highlight.row = headerLevel;\n    selectedRange.highlight.col = selectedRange.from.col;\n  }\n}\n/**\n * `modifyTransformStart` hook is called every time the keyboard navigation is used.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformStart(delta) {\n  const {\n    highlight\n  } = this.hot.getSelectedRangeLast();\n  const nextCoords = this.hot._createCellCoords(highlight.row + delta.row, highlight.col + delta.col);\n  const isNestedHeadersRange = nextCoords.isHeader() && nextCoords.col >= 0;\n  if (!isNestedHeadersRange) {\n    return;\n  }\n  const visualColumnIndexStart = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(nextCoords.row, nextCoords.col);\n  const visualColumnIndexEnd = _classPrivateFieldGet(_stateManager, this).findRightMostColumnIndex(nextCoords.row, nextCoords.col);\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook observes the column selection from the Selection API and modifies the column range to\n * ensure that the whole nested column will be covered.\n *\n * @param {CellCoords} from The coords object where the selection starts.\n * @param {CellCoords} to The coords object where the selection ends.\n */\nfunction _onBeforeSelectColumns(from, to) {\n  const headerLevel = from.row;\n  const startNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: from.col\n  });\n  const endNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: to.col\n  });\n  if (to.col < from.col) {\n    // Column selection from right to left\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex + startNodeData.origColspan - 1;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex;\n    }\n  } else if (to.col >= from.col) {\n    // Column selection from left to right or a single column selection\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex + endNodeData.origColspan - 1;\n    }\n  }\n}\n/**\n * `afterGetColumnHeader` hook callback - prepares the header structure.\n *\n * @param {Array} renderersArray Array of renderers.\n */\nfunction _onAfterGetColumnHeaderRenderers(renderersArray) {\n  renderersArray.length = 0;\n  for (let headerLayer = 0; headerLayer < _classPrivateFieldGet(_stateManager, this).getLayersCount(); headerLayer++) {\n    renderersArray.push(this.headerRendererFactory(headerLayer));\n  }\n}\n/**\n * Make the renderer render the first nested column in its entirety.\n *\n * @param {object} calc Viewport column calculator.\n */\nfunction _onAfterViewportColumnCalculatorOverride(calc) {\n  const headerLayersCount = _classPrivateFieldGet(_stateManager, this).getLayersCount();\n  let newStartColumn = calc.startColumn;\n  let nonRenderable = !!headerLayersCount;\n  for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {\n    const startColumn = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(headerLayer, calc.startColumn);\n    const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);\n\n    // If any of the headers for that column index is rendered, all of them should be rendered properly, see\n    // comment below.\n    if (startColumn >= 0) {\n      nonRenderable = false;\n    }\n\n    // `renderedStartColumn` can be `null` if the leftmost columns are hidden. In that case -> ignore that header\n    // level, as it should be handled by the \"parent\" header\n    if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {\n      newStartColumn = renderedStartColumn;\n      break;\n    }\n  }\n\n  // If no headers for the provided column index are renderable, start rendering from the beginning of the upmost\n  // header for that position.\n  calc.startColumn = nonRenderable ? _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;\n}\n/**\n * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.\n *\n * @param {number} width Width from hook.\n * @param {number} column Visual index of an column.\n * @returns {number}\n */\nfunction _onModifyColWidth(width, column) {\n  const cachedWidth = this.ghostTable.getWidth(column);\n  return width > cachedWidth ? width : cachedWidth;\n}\n/**\n * Listens the `modifyColumnHeaderValue` hook that overwrites the column headers values based on\n * the internal state and settings of the plugin.\n *\n * @param {string} value The column header value.\n * @param {number} visualColumnIndex The visual column index.\n * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n *                             and negative (-1 to -N) values. For positive values, 0 points to the\n *                             top most header, and for negative direction, -1 points to the most bottom\n *                             header (the header closest to the cells).\n * @returns {string} Returns the column header value to update.\n */\nfunction _onModifyColumnHeaderValue(value, visualColumnIndex, headerLevel) {\n  var _classPrivateFieldGet5;\n  const {\n    label\n  } = (_classPrivateFieldGet5 = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : {\n    label: ''\n  };\n  return label;\n}\n/**\n * `modifyFocusedElement` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} column Column index.\n * @returns {HTMLTableCellElement} The `TH` element to be focused.\n */\nfunction _onModifyFocusedElement(row, column) {\n  if (row < 0) {\n    return this.hot.getCell(row, _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(row, column), true);\n  }\n}\n/**\n * Updates the plugin state after HoT initialization.\n */\nfunction _onInit() {\n  // @TODO: Workaround for broken plugin initialization abstraction.\n  this.updatePlugin();\n}\n/**\n * Updates the plugin state after new dataset load.\n *\n * @param {Array[]} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded\n *                              during the initialization.\n */\nfunction _onAfterLoadData(sourceData, initialLoad) {\n  if (!initialLoad) {\n    this.updatePlugin();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}