{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { warn } from \"./helpers/console.mjs\";\nimport { isOutsideInput } from \"./helpers/dom/element.mjs\";\nimport { debounce } from \"./helpers/function.mjs\";\n/**\n * Possible focus modes.\n * - CELL - The browser's focus stays on the lastly selected cell element.\n * - MIXED - The browser's focus switches from the lastly selected cell element to the currently active editor's\n * `TEXTAREA` element after a delay defined in the manager.\n *\n * @type {{CELL: string, MIXED: string}}\n */\nconst FOCUS_MODES = Object.freeze({\n  CELL: 'cell',\n  MIXED: 'mixed'\n});\n\n/**\n * Manages the browser's focus in the table.\n */\nvar _hot = /*#__PURE__*/new WeakMap();\nvar _focusMode = /*#__PURE__*/new WeakMap();\nvar _refocusDelay = /*#__PURE__*/new WeakMap();\nvar _refocusElementGetter = /*#__PURE__*/new WeakMap();\nvar _debouncedSelect = /*#__PURE__*/new WeakMap();\nvar _FocusManager_brand = /*#__PURE__*/new WeakSet();\nexport class FocusManager {\n  constructor(hotInstance) {\n    var _this = this;\n    /**\n     * Get and return the currently selected and highlighted cell/header element.\n     *\n     * @param {Function} callback Callback function to be called after the cell element is retrieved.\n     */\n    _classPrivateMethodInitSpec(this, _FocusManager_brand);\n    /**\n     * The Handsontable instance.\n     */\n    _classPrivateFieldInitSpec(this, _hot, void 0);\n    /**\n     * The currently enabled focus mode.\n     * Can be either:\n     *\n     * - 'cell' - The browser's focus stays on the lastly selected cell element.\n     * - 'mixed' - The browser's focus switches from the lastly selected cell element to the currently active editor's\n     * `TEXTAREA` element after a delay defined in the manager.\n     *\n     * @type {'cell' | 'mixed'}\n     */\n    _classPrivateFieldInitSpec(this, _focusMode, void 0);\n    /**\n     * The delay after which the focus switches from the lastly selected cell to the active editor's `TEXTAREA`\n     * element if the focus mode is set to 'mixed'.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _refocusDelay, 1);\n    /**\n     * Getter function for the element to be used when refocusing the browser after a delay. If `null`, the active\n     * editor's `TEXTAREA` element will be used.\n     *\n     * @type {null|Function}\n     */\n    _classPrivateFieldInitSpec(this, _refocusElementGetter, null);\n    /**\n     * Map of the debounced `select` functions.\n     *\n     * @type {Map<number, Function>}\n     */\n    _classPrivateFieldInitSpec(this, _debouncedSelect, new Map());\n    const hotSettings = hotInstance.getSettings();\n    _classPrivateFieldSet(_hot, this, hotInstance);\n    _classPrivateFieldSet(_focusMode, this, hotSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);\n    _classPrivateFieldGet(_hot, this).addHook('afterUpdateSettings', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _onUpdateSettings).call(_this, ...args);\n    });\n    _classPrivateFieldGet(_hot, this).addHook('afterSelection', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _focusCell).call(_this, ...args);\n    });\n    _classPrivateFieldGet(_hot, this).addHook('afterSelectionFocusSet', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _focusCell).call(_this, ...args);\n    });\n    _classPrivateFieldGet(_hot, this).addHook('afterSelectionEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _focusEditorElement).call(_this, ...args);\n    });\n  }\n\n  /**\n   * Get the current focus mode.\n   *\n   * @returns {'cell' | 'mixed'}\n   */\n  getFocusMode() {\n    return _classPrivateFieldGet(_focusMode, this);\n  }\n\n  /**\n   * Set the focus mode.\n   *\n   * @param {'cell' | 'mixed'} focusMode The new focus mode.\n   */\n  setFocusMode(focusMode) {\n    if (Object.values(FOCUS_MODES).includes(focusMode)) {\n      _classPrivateFieldSet(_focusMode, this, focusMode);\n    } else {\n      warn(`\"${focusMode}\" is not a valid focus mode.`);\n    }\n  }\n\n  /**\n   * Get the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @returns {number} Delay in milliseconds.\n   */\n  getRefocusDelay() {\n    return _classPrivateFieldGet(_refocusDelay, this);\n  }\n\n  /**\n   * Set the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @param {number} delay Delay in milliseconds.\n   */\n  setRefocusDelay(delay) {\n    _classPrivateFieldSet(_refocusDelay, this, delay);\n  }\n\n  /**\n   * Set the function to be used as the \"refocus element\" getter. It should return a focusable HTML element.\n   *\n   * @param {Function} getRefocusElementFunction The refocus element getter.\n   */\n  setRefocusElementGetter(getRefocusElementFunction) {\n    _classPrivateFieldSet(_refocusElementGetter, this, getRefocusElementFunction);\n  }\n\n  /**\n   * Get the element to be used when refocusing the browser after a delay in case of the focus mode being 'mixed'.\n   *\n   * @returns {HTMLTextAreaElement|HTMLElement|undefined}\n   */\n  getRefocusElement() {\n    if (typeof _classPrivateFieldGet(_refocusElementGetter, this) === 'function') {\n      return _classPrivateFieldGet(_refocusElementGetter, this).call(this);\n    } else {\n      var _classPrivateFieldGet2;\n      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_hot, this).getActiveEditor()) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.TEXTAREA;\n    }\n  }\n\n  /**\n   * Set the browser's focus to the highlighted cell of the last selection.\n   *\n   * @param {HTMLTableCellElement} [selectedCell] The highlighted cell/header element.\n   */\n  focusOnHighlightedCell(selectedCell) {\n    const focusElement = element => {\n      var _classPrivateFieldGet3, _classPrivateFieldGet4;\n      const currentHighlightCoords = (_classPrivateFieldGet3 = _classPrivateFieldGet(_hot, this).getSelectedRangeLast()) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.highlight;\n      if (!currentHighlightCoords) {\n        return;\n      }\n      let elementToBeFocused = _classPrivateFieldGet(_hot, this).runHooks('modifyFocusedElement', currentHighlightCoords.row, currentHighlightCoords.col, element);\n      if (!(elementToBeFocused instanceof HTMLElement)) {\n        elementToBeFocused = element;\n      }\n      if (elementToBeFocused && !((_classPrivateFieldGet4 = _classPrivateFieldGet(_hot, this).getActiveEditor()) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isOpened())) {\n        elementToBeFocused.focus({\n          preventScroll: true\n        });\n      }\n    };\n    if (selectedCell) {\n      focusElement(selectedCell);\n    } else {\n      _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, element => focusElement(element));\n    }\n  }\n\n  /**\n   * Set the focus to the active editor's `TEXTAREA` element after the provided delay. If no delay is provided, it\n   * will be taken from the manager's configuration.\n   *\n   * @param {number} [delay] Delay in milliseconds.\n   */\n  refocusToEditorTextarea() {\n    var _classPrivateFieldGet5;\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(_refocusDelay, this);\n    const refocusElement = this.getRefocusElement();\n\n    // Re-focus on the editor's `TEXTAREA` element (or a predefined element) if the `imeFastEdit` option is enabled.\n    if (_classPrivateFieldGet(_hot, this).getSettings().imeFastEdit && !((_classPrivateFieldGet5 = _classPrivateFieldGet(_hot, this).getActiveEditor()) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isOpened()) && !!refocusElement) {\n      if (!_classPrivateFieldGet(_debouncedSelect, this).has(delay)) {\n        _classPrivateFieldGet(_debouncedSelect, this).set(delay, debounce(() => {\n          refocusElement.select();\n        }, delay));\n      }\n      _classPrivateFieldGet(_debouncedSelect, this).get(delay)();\n    }\n  }\n}\nfunction _getSelectedCell(callback) {\n  var _classPrivateFieldGet6;\n  const highlight = (_classPrivateFieldGet6 = _classPrivateFieldGet(_hot, this).getSelectedRangeLast()) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.highlight;\n  if (!highlight || !_classPrivateFieldGet(_hot, this).selection.isCellVisible(highlight)) {\n    callback(null);\n    return;\n  }\n  const cell = _classPrivateFieldGet(_hot, this).getCell(highlight.row, highlight.col, true);\n  if (cell === null) {\n    _classPrivateFieldGet(_hot, this).addHookOnce('afterScroll', () => {\n      callback(_classPrivateFieldGet(_hot, this).getCell(highlight.row, highlight.col, true));\n    });\n  } else {\n    callback(cell);\n  }\n}\n/**\n * Manage the browser's focus after each cell selection change.\n */\nfunction _focusCell() {\n  _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, selectedCell => {\n    const {\n      activeElement\n    } = _classPrivateFieldGet(_hot, this).rootDocument;\n\n    // Blurring the `activeElement` removes the unwanted border around the focusable element (#6877)\n    // and resets the `document.activeElement` property. The blurring should happen only when the\n    // previously selected input element has not belonged to the Handsontable editor. If blurring is\n    // triggered for all elements, there is a problem with the disappearing IME editor (#9672).\n    if (activeElement && isOutsideInput(activeElement)) {\n      activeElement.blur();\n    }\n    this.focusOnHighlightedCell(selectedCell);\n  });\n}\n/**\n * Manage the browser's focus after cell selection end.\n */\nfunction _focusEditorElement() {\n  _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, selectedCell => {\n    if (this.getFocusMode() === FOCUS_MODES.MIXED && selectedCell.nodeName === 'TD') {\n      this.refocusToEditorTextarea();\n    }\n  });\n}\n/**\n * Update the manager configuration after calling `updateSettings`.\n *\n * @param {object} newSettings The new settings passed to the `updateSettings` method.\n */\nfunction _onUpdateSettings(newSettings) {\n  if (typeof newSettings.imeFastEdit === 'boolean') {\n    this.setFocusMode(newSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","warn","isOutsideInput","debounce","FOCUS_MODES","Object","freeze","CELL","MIXED","_hot","WeakMap","_focusMode","_refocusDelay","_refocusElementGetter","_debouncedSelect","_FocusManager_brand","WeakSet","FocusManager","constructor","hotInstance","_this","Map","hotSettings","getSettings","imeFastEdit","addHook","_len","args","Array","_key","_onUpdateSettings","call","_len2","_key2","_focusCell","_len3","_key3","_len4","_key4","_focusEditorElement","getFocusMode","setFocusMode","focusMode","values","includes","getRefocusDelay","setRefocusDelay","delay","setRefocusElementGetter","getRefocusElementFunction","getRefocusElement","_classPrivateFieldGet2","getActiveEditor","TEXTAREA","focusOnHighlightedCell","selectedCell","focusElement","element","_classPrivateFieldGet3","_classPrivateFieldGet4","currentHighlightCoords","getSelectedRangeLast","highlight","elementToBeFocused","runHooks","row","col","HTMLElement","isOpened","focus","preventScroll","_getSelectedCell","refocusToEditorTextarea","_classPrivateFieldGet5","undefined","refocusElement","select","callback","_classPrivateFieldGet6","selection","isCellVisible","cell","getCell","addHookOnce","activeElement","rootDocument","blur","nodeName","newSettings"],"sources":["D:/gym-project/frontend/node_modules/handsontable/focusManager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { warn } from \"./helpers/console.mjs\";\nimport { isOutsideInput } from \"./helpers/dom/element.mjs\";\nimport { debounce } from \"./helpers/function.mjs\";\n/**\n * Possible focus modes.\n * - CELL - The browser's focus stays on the lastly selected cell element.\n * - MIXED - The browser's focus switches from the lastly selected cell element to the currently active editor's\n * `TEXTAREA` element after a delay defined in the manager.\n *\n * @type {{CELL: string, MIXED: string}}\n */\nconst FOCUS_MODES = Object.freeze({\n  CELL: 'cell',\n  MIXED: 'mixed'\n});\n\n/**\n * Manages the browser's focus in the table.\n */\nvar _hot = /*#__PURE__*/new WeakMap();\nvar _focusMode = /*#__PURE__*/new WeakMap();\nvar _refocusDelay = /*#__PURE__*/new WeakMap();\nvar _refocusElementGetter = /*#__PURE__*/new WeakMap();\nvar _debouncedSelect = /*#__PURE__*/new WeakMap();\nvar _FocusManager_brand = /*#__PURE__*/new WeakSet();\nexport class FocusManager {\n  constructor(hotInstance) {\n    var _this = this;\n    /**\n     * Get and return the currently selected and highlighted cell/header element.\n     *\n     * @param {Function} callback Callback function to be called after the cell element is retrieved.\n     */\n    _classPrivateMethodInitSpec(this, _FocusManager_brand);\n    /**\n     * The Handsontable instance.\n     */\n    _classPrivateFieldInitSpec(this, _hot, void 0);\n    /**\n     * The currently enabled focus mode.\n     * Can be either:\n     *\n     * - 'cell' - The browser's focus stays on the lastly selected cell element.\n     * - 'mixed' - The browser's focus switches from the lastly selected cell element to the currently active editor's\n     * `TEXTAREA` element after a delay defined in the manager.\n     *\n     * @type {'cell' | 'mixed'}\n     */\n    _classPrivateFieldInitSpec(this, _focusMode, void 0);\n    /**\n     * The delay after which the focus switches from the lastly selected cell to the active editor's `TEXTAREA`\n     * element if the focus mode is set to 'mixed'.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _refocusDelay, 1);\n    /**\n     * Getter function for the element to be used when refocusing the browser after a delay. If `null`, the active\n     * editor's `TEXTAREA` element will be used.\n     *\n     * @type {null|Function}\n     */\n    _classPrivateFieldInitSpec(this, _refocusElementGetter, null);\n    /**\n     * Map of the debounced `select` functions.\n     *\n     * @type {Map<number, Function>}\n     */\n    _classPrivateFieldInitSpec(this, _debouncedSelect, new Map());\n    const hotSettings = hotInstance.getSettings();\n    _classPrivateFieldSet(_hot, this, hotInstance);\n    _classPrivateFieldSet(_focusMode, this, hotSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);\n    _classPrivateFieldGet(_hot, this).addHook('afterUpdateSettings', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _onUpdateSettings).call(_this, ...args);\n    });\n    _classPrivateFieldGet(_hot, this).addHook('afterSelection', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _focusCell).call(_this, ...args);\n    });\n    _classPrivateFieldGet(_hot, this).addHook('afterSelectionFocusSet', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _focusCell).call(_this, ...args);\n    });\n    _classPrivateFieldGet(_hot, this).addHook('afterSelectionEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_FocusManager_brand, _this, _focusEditorElement).call(_this, ...args);\n    });\n  }\n\n  /**\n   * Get the current focus mode.\n   *\n   * @returns {'cell' | 'mixed'}\n   */\n  getFocusMode() {\n    return _classPrivateFieldGet(_focusMode, this);\n  }\n\n  /**\n   * Set the focus mode.\n   *\n   * @param {'cell' | 'mixed'} focusMode The new focus mode.\n   */\n  setFocusMode(focusMode) {\n    if (Object.values(FOCUS_MODES).includes(focusMode)) {\n      _classPrivateFieldSet(_focusMode, this, focusMode);\n    } else {\n      warn(`\"${focusMode}\" is not a valid focus mode.`);\n    }\n  }\n\n  /**\n   * Get the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @returns {number} Delay in milliseconds.\n   */\n  getRefocusDelay() {\n    return _classPrivateFieldGet(_refocusDelay, this);\n  }\n\n  /**\n   * Set the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @param {number} delay Delay in milliseconds.\n   */\n  setRefocusDelay(delay) {\n    _classPrivateFieldSet(_refocusDelay, this, delay);\n  }\n\n  /**\n   * Set the function to be used as the \"refocus element\" getter. It should return a focusable HTML element.\n   *\n   * @param {Function} getRefocusElementFunction The refocus element getter.\n   */\n  setRefocusElementGetter(getRefocusElementFunction) {\n    _classPrivateFieldSet(_refocusElementGetter, this, getRefocusElementFunction);\n  }\n\n  /**\n   * Get the element to be used when refocusing the browser after a delay in case of the focus mode being 'mixed'.\n   *\n   * @returns {HTMLTextAreaElement|HTMLElement|undefined}\n   */\n  getRefocusElement() {\n    if (typeof _classPrivateFieldGet(_refocusElementGetter, this) === 'function') {\n      return _classPrivateFieldGet(_refocusElementGetter, this).call(this);\n    } else {\n      var _classPrivateFieldGet2;\n      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_hot, this).getActiveEditor()) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.TEXTAREA;\n    }\n  }\n\n  /**\n   * Set the browser's focus to the highlighted cell of the last selection.\n   *\n   * @param {HTMLTableCellElement} [selectedCell] The highlighted cell/header element.\n   */\n  focusOnHighlightedCell(selectedCell) {\n    const focusElement = element => {\n      var _classPrivateFieldGet3, _classPrivateFieldGet4;\n      const currentHighlightCoords = (_classPrivateFieldGet3 = _classPrivateFieldGet(_hot, this).getSelectedRangeLast()) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.highlight;\n      if (!currentHighlightCoords) {\n        return;\n      }\n      let elementToBeFocused = _classPrivateFieldGet(_hot, this).runHooks('modifyFocusedElement', currentHighlightCoords.row, currentHighlightCoords.col, element);\n      if (!(elementToBeFocused instanceof HTMLElement)) {\n        elementToBeFocused = element;\n      }\n      if (elementToBeFocused && !((_classPrivateFieldGet4 = _classPrivateFieldGet(_hot, this).getActiveEditor()) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isOpened())) {\n        elementToBeFocused.focus({\n          preventScroll: true\n        });\n      }\n    };\n    if (selectedCell) {\n      focusElement(selectedCell);\n    } else {\n      _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, element => focusElement(element));\n    }\n  }\n\n  /**\n   * Set the focus to the active editor's `TEXTAREA` element after the provided delay. If no delay is provided, it\n   * will be taken from the manager's configuration.\n   *\n   * @param {number} [delay] Delay in milliseconds.\n   */\n  refocusToEditorTextarea() {\n    var _classPrivateFieldGet5;\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(_refocusDelay, this);\n    const refocusElement = this.getRefocusElement();\n\n    // Re-focus on the editor's `TEXTAREA` element (or a predefined element) if the `imeFastEdit` option is enabled.\n    if (_classPrivateFieldGet(_hot, this).getSettings().imeFastEdit && !((_classPrivateFieldGet5 = _classPrivateFieldGet(_hot, this).getActiveEditor()) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isOpened()) && !!refocusElement) {\n      if (!_classPrivateFieldGet(_debouncedSelect, this).has(delay)) {\n        _classPrivateFieldGet(_debouncedSelect, this).set(delay, debounce(() => {\n          refocusElement.select();\n        }, delay));\n      }\n      _classPrivateFieldGet(_debouncedSelect, this).get(delay)();\n    }\n  }\n}\nfunction _getSelectedCell(callback) {\n  var _classPrivateFieldGet6;\n  const highlight = (_classPrivateFieldGet6 = _classPrivateFieldGet(_hot, this).getSelectedRangeLast()) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.highlight;\n  if (!highlight || !_classPrivateFieldGet(_hot, this).selection.isCellVisible(highlight)) {\n    callback(null);\n    return;\n  }\n  const cell = _classPrivateFieldGet(_hot, this).getCell(highlight.row, highlight.col, true);\n  if (cell === null) {\n    _classPrivateFieldGet(_hot, this).addHookOnce('afterScroll', () => {\n      callback(_classPrivateFieldGet(_hot, this).getCell(highlight.row, highlight.col, true));\n    });\n  } else {\n    callback(cell);\n  }\n}\n/**\n * Manage the browser's focus after each cell selection change.\n */\nfunction _focusCell() {\n  _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, selectedCell => {\n    const {\n      activeElement\n    } = _classPrivateFieldGet(_hot, this).rootDocument;\n\n    // Blurring the `activeElement` removes the unwanted border around the focusable element (#6877)\n    // and resets the `document.activeElement` property. The blurring should happen only when the\n    // previously selected input element has not belonged to the Handsontable editor. If blurring is\n    // triggered for all elements, there is a problem with the disappearing IME editor (#9672).\n    if (activeElement && isOutsideInput(activeElement)) {\n      activeElement.blur();\n    }\n    this.focusOnHighlightedCell(selectedCell);\n  });\n}\n/**\n * Manage the browser's focus after cell selection end.\n */\nfunction _focusEditorElement() {\n  _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, selectedCell => {\n    if (this.getFocusMode() === FOCUS_MODES.MIXED && selectedCell.nodeName === 'TD') {\n      this.refocusToEditorTextarea();\n    }\n  });\n}\n/**\n * Update the manager configuration after calling `updateSettings`.\n *\n * @param {object} newSettings The new settings passed to the `updateSettings` method.\n */\nfunction _onUpdateSettings(newSettings) {\n  if (typeof newSettings.imeFastEdit === 'boolean') {\n    this.setFocusMode(newSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}