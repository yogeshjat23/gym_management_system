{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { toUpperCaseFirst } from \"../../../helpers/string.mjs\";\nimport { getMoves } from \"../../../helpers/moves.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for particular axis. It respects an idea to represent trimmed\n * elements in HF's engine to perform formulas calculations on them. It also provides method for translation from visual\n * row/column indexes to HF's row/column indexes.\n */\nvar _axis = /*#__PURE__*/new WeakMap();\nvar _indexMapper = /*#__PURE__*/new WeakMap();\nvar _indexSyncer = /*#__PURE__*/new WeakMap();\nvar _indexesSequence = /*#__PURE__*/new WeakMap();\nvar _movedIndexes = /*#__PURE__*/new WeakMap();\nvar _finalIndex = /*#__PURE__*/new WeakMap();\nvar _removedIndexes = /*#__PURE__*/new WeakMap();\nclass AxisSyncer {\n  constructor(axis, indexMapper, indexSyncer) {\n    /**\n     * The axis for which the actions are performed.\n     *\n     * @private\n     * @type {'row'|'column'}\n     */\n    _classPrivateFieldInitSpec(this, _axis, void 0);\n    /**\n     * Reference to index mapper.\n     *\n     * @private\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _indexMapper, void 0);\n    /**\n     * The index synchronizer for both axis (is storing some more general information).\n     *\n     * @private\n     * @type {IndexSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _indexSyncer, void 0);\n    /**\n     * Sequence of physical indexes stored for watching changes and calculating some transformations.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _indexesSequence, []);\n    /**\n     * List of moved HF indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _movedIndexes, []);\n    /**\n     * Final HF's place where to move indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {number|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _finalIndex, void 0);\n    /**\n     * List of removed HF indexes, stored before performing removal on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _removedIndexes, []);\n    _classPrivateFieldSet(_axis, this, axis);\n    _classPrivateFieldSet(_indexMapper, this, indexMapper);\n    _classPrivateFieldSet(_indexSyncer, this, indexSyncer);\n  }\n\n  /**\n   * Sets removed HF indexes (it should be done right before performing move on HOT).\n   *\n   * @param {Array<number>} removedIndexes List of removed physical indexes.\n   * @returns {Array<number>} List of removed visual indexes.\n   */\n  setRemovedHfIndexes(removedIndexes) {\n    _classPrivateFieldSet(_removedIndexes, this, removedIndexes.map(physicalIndex => {\n      const visualIndex = _classPrivateFieldGet(_indexMapper, this).getVisualFromPhysicalIndex(physicalIndex);\n      return this.getHfIndexFromVisualIndex(visualIndex);\n    }));\n    return _classPrivateFieldGet(_removedIndexes, this);\n  }\n\n  /**\n   * Gets removed HF indexes (right before performing removal on HOT).\n   *\n   * @returns {Array<number>} List of removed HF indexes.\n   */\n  getRemovedHfIndexes() {\n    return _classPrivateFieldGet(_removedIndexes, this);\n  }\n\n  /**\n   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine\n   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {number}\n   */\n  getHfIndexFromVisualIndex(visualIndex) {\n    const indexesSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n    const notTrimmedIndexes = _classPrivateFieldGet(_indexMapper, this).getNotTrimmedIndexes();\n    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n  }\n\n  /**\n   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.\n   */\n  syncMoves(moves) {\n    const NUMBER_OF_MOVED_INDEXES = 1;\n    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet(_axis, this))}s`;\n    _classPrivateFieldGet(_indexSyncer, this).getEngine().batch(() => {\n      moves.forEach(move => {\n        const moveToTheSamePosition = move.from !== move.to;\n        // Moving from left to right (or top to bottom) to a line (drop index) right after already moved element.\n        const anotherMoveWithoutEffect = move.from + 1 !== move.to;\n        if (moveToTheSamePosition && anotherMoveWithoutEffect) {\n          _classPrivateFieldGet(_indexSyncer, this).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, this).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n        }\n      });\n    });\n  }\n\n  /**\n   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.\n   *\n   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.\n   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.\n   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.\n   */\n  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {\n    if (movePossible === false) {\n      return;\n    }\n    _classPrivateFieldSet(_movedIndexes, this, movedVisualIndexes.map(index => this.getHfIndexFromVisualIndex(index)));\n    _classPrivateFieldSet(_finalIndex, this, this.getHfIndexFromVisualIndex(visualFinalIndex));\n  }\n\n  /**\n   * Calculating where to move HF elements and performing already calculated moves.\n   *\n   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.\n   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.\n   */\n  calculateAndSyncMoves(movePossible, orderChanged) {\n    if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n      return;\n    }\n    if (movePossible === false || orderChanged === false) {\n      return;\n    }\n    const calculatedMoves = getMoves(_classPrivateFieldGet(_movedIndexes, this), _classPrivateFieldGet(_finalIndex, this), _classPrivateFieldGet(_indexMapper, this).getNumberOfIndexes());\n    if (_classPrivateFieldGet(_indexSyncer, this).getSheetId() === null) {\n      _classPrivateFieldGet(_indexSyncer, this).getPostponeAction(() => this.syncMoves(calculatedMoves));\n    } else {\n      this.syncMoves(calculatedMoves);\n    }\n  }\n\n  /**\n   * Gets callback for hook triggered after performing change of indexes order.\n   *\n   * @returns {Function}\n   */\n  getIndexesChangeSyncMethod() {\n    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet(_axis, this))}Order`;\n    return source => {\n      if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n        return;\n      }\n      const newSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n      if (source === 'update' && newSequence.length > 0) {\n        const relativeTransformation = _classPrivateFieldGet(_indexesSequence, this).map(index => newSequence.indexOf(index));\n        const sheetDimensions = _classPrivateFieldGet(_indexSyncer, this).getEngine().getSheetDimensions(_classPrivateFieldGet(_indexSyncer, this).getSheetId());\n        let sizeForAxis;\n        if (_classPrivateFieldGet(_axis, this) === 'row') {\n          sizeForAxis = sheetDimensions.height;\n        } else {\n          sizeForAxis = sheetDimensions.width;\n        }\n        const numberOfReorganisedIndexes = relativeTransformation.length;\n\n        // Sheet dimension can be changed by HF's engine for purpose of calculating values. It extends dependency\n        // graph to calculate values outside of a defined dataset. This part of code could be removed after resolving\n        // feature request from HF issue board (handsontable/hyperformula#1179).\n        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n          relativeTransformation.push(i);\n        }\n        _classPrivateFieldGet(_indexSyncer, this).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, this).getSheetId(), relativeTransformation);\n      }\n      _classPrivateFieldSet(_indexesSequence, this, newSequence);\n    };\n  }\n\n  /**\n   * Initialize the AxisSyncer.\n   */\n  init() {\n    _classPrivateFieldSet(_indexesSequence, this, _classPrivateFieldGet(_indexMapper, this).getIndexesSequence());\n  }\n}\nexport default AxisSyncer;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","toUpperCaseFirst","getMoves","_axis","WeakMap","_indexMapper","_indexSyncer","_indexesSequence","_movedIndexes","_finalIndex","_removedIndexes","AxisSyncer","constructor","axis","indexMapper","indexSyncer","setRemovedHfIndexes","removedIndexes","map","physicalIndex","visualIndex","getVisualFromPhysicalIndex","getHfIndexFromVisualIndex","getRemovedHfIndexes","indexesSequence","getIndexesSequence","notTrimmedIndexes","getNotTrimmedIndexes","indexOf","syncMoves","moves","NUMBER_OF_MOVED_INDEXES","SYNC_MOVE_METHOD_NAME","getEngine","batch","forEach","move","moveToTheSamePosition","from","to","anotherMoveWithoutEffect","getSheetId","storeMovesInformation","movedVisualIndexes","visualFinalIndex","movePossible","index","calculateAndSyncMoves","orderChanged","isPerformingUndoRedo","calculatedMoves","getNumberOfIndexes","getPostponeAction","getIndexesChangeSyncMethod","SYNC_ORDER_CHANGE_METHOD_NAME","source","newSequence","relativeTransformation","sheetDimensions","getSheetDimensions","sizeForAxis","height","width","numberOfReorganisedIndexes","i","push","init"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/formulas/indexSyncer/axisSyncer.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { toUpperCaseFirst } from \"../../../helpers/string.mjs\";\nimport { getMoves } from \"../../../helpers/moves.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for particular axis. It respects an idea to represent trimmed\n * elements in HF's engine to perform formulas calculations on them. It also provides method for translation from visual\n * row/column indexes to HF's row/column indexes.\n */\nvar _axis = /*#__PURE__*/new WeakMap();\nvar _indexMapper = /*#__PURE__*/new WeakMap();\nvar _indexSyncer = /*#__PURE__*/new WeakMap();\nvar _indexesSequence = /*#__PURE__*/new WeakMap();\nvar _movedIndexes = /*#__PURE__*/new WeakMap();\nvar _finalIndex = /*#__PURE__*/new WeakMap();\nvar _removedIndexes = /*#__PURE__*/new WeakMap();\nclass AxisSyncer {\n  constructor(axis, indexMapper, indexSyncer) {\n    /**\n     * The axis for which the actions are performed.\n     *\n     * @private\n     * @type {'row'|'column'}\n     */\n    _classPrivateFieldInitSpec(this, _axis, void 0);\n    /**\n     * Reference to index mapper.\n     *\n     * @private\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _indexMapper, void 0);\n    /**\n     * The index synchronizer for both axis (is storing some more general information).\n     *\n     * @private\n     * @type {IndexSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _indexSyncer, void 0);\n    /**\n     * Sequence of physical indexes stored for watching changes and calculating some transformations.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _indexesSequence, []);\n    /**\n     * List of moved HF indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _movedIndexes, []);\n    /**\n     * Final HF's place where to move indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {number|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _finalIndex, void 0);\n    /**\n     * List of removed HF indexes, stored before performing removal on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _removedIndexes, []);\n    _classPrivateFieldSet(_axis, this, axis);\n    _classPrivateFieldSet(_indexMapper, this, indexMapper);\n    _classPrivateFieldSet(_indexSyncer, this, indexSyncer);\n  }\n\n  /**\n   * Sets removed HF indexes (it should be done right before performing move on HOT).\n   *\n   * @param {Array<number>} removedIndexes List of removed physical indexes.\n   * @returns {Array<number>} List of removed visual indexes.\n   */\n  setRemovedHfIndexes(removedIndexes) {\n    _classPrivateFieldSet(_removedIndexes, this, removedIndexes.map(physicalIndex => {\n      const visualIndex = _classPrivateFieldGet(_indexMapper, this).getVisualFromPhysicalIndex(physicalIndex);\n      return this.getHfIndexFromVisualIndex(visualIndex);\n    }));\n    return _classPrivateFieldGet(_removedIndexes, this);\n  }\n\n  /**\n   * Gets removed HF indexes (right before performing removal on HOT).\n   *\n   * @returns {Array<number>} List of removed HF indexes.\n   */\n  getRemovedHfIndexes() {\n    return _classPrivateFieldGet(_removedIndexes, this);\n  }\n\n  /**\n   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine\n   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {number}\n   */\n  getHfIndexFromVisualIndex(visualIndex) {\n    const indexesSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n    const notTrimmedIndexes = _classPrivateFieldGet(_indexMapper, this).getNotTrimmedIndexes();\n    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n  }\n\n  /**\n   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.\n   */\n  syncMoves(moves) {\n    const NUMBER_OF_MOVED_INDEXES = 1;\n    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet(_axis, this))}s`;\n    _classPrivateFieldGet(_indexSyncer, this).getEngine().batch(() => {\n      moves.forEach(move => {\n        const moveToTheSamePosition = move.from !== move.to;\n        // Moving from left to right (or top to bottom) to a line (drop index) right after already moved element.\n        const anotherMoveWithoutEffect = move.from + 1 !== move.to;\n        if (moveToTheSamePosition && anotherMoveWithoutEffect) {\n          _classPrivateFieldGet(_indexSyncer, this).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, this).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n        }\n      });\n    });\n  }\n\n  /**\n   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.\n   *\n   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.\n   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.\n   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.\n   */\n  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {\n    if (movePossible === false) {\n      return;\n    }\n    _classPrivateFieldSet(_movedIndexes, this, movedVisualIndexes.map(index => this.getHfIndexFromVisualIndex(index)));\n    _classPrivateFieldSet(_finalIndex, this, this.getHfIndexFromVisualIndex(visualFinalIndex));\n  }\n\n  /**\n   * Calculating where to move HF elements and performing already calculated moves.\n   *\n   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.\n   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.\n   */\n  calculateAndSyncMoves(movePossible, orderChanged) {\n    if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n      return;\n    }\n    if (movePossible === false || orderChanged === false) {\n      return;\n    }\n    const calculatedMoves = getMoves(_classPrivateFieldGet(_movedIndexes, this), _classPrivateFieldGet(_finalIndex, this), _classPrivateFieldGet(_indexMapper, this).getNumberOfIndexes());\n    if (_classPrivateFieldGet(_indexSyncer, this).getSheetId() === null) {\n      _classPrivateFieldGet(_indexSyncer, this).getPostponeAction(() => this.syncMoves(calculatedMoves));\n    } else {\n      this.syncMoves(calculatedMoves);\n    }\n  }\n\n  /**\n   * Gets callback for hook triggered after performing change of indexes order.\n   *\n   * @returns {Function}\n   */\n  getIndexesChangeSyncMethod() {\n    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet(_axis, this))}Order`;\n    return source => {\n      if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n        return;\n      }\n      const newSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n      if (source === 'update' && newSequence.length > 0) {\n        const relativeTransformation = _classPrivateFieldGet(_indexesSequence, this).map(index => newSequence.indexOf(index));\n        const sheetDimensions = _classPrivateFieldGet(_indexSyncer, this).getEngine().getSheetDimensions(_classPrivateFieldGet(_indexSyncer, this).getSheetId());\n        let sizeForAxis;\n        if (_classPrivateFieldGet(_axis, this) === 'row') {\n          sizeForAxis = sheetDimensions.height;\n        } else {\n          sizeForAxis = sheetDimensions.width;\n        }\n        const numberOfReorganisedIndexes = relativeTransformation.length;\n\n        // Sheet dimension can be changed by HF's engine for purpose of calculating values. It extends dependency\n        // graph to calculate values outside of a defined dataset. This part of code could be removed after resolving\n        // feature request from HF issue board (handsontable/hyperformula#1179).\n        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n          relativeTransformation.push(i);\n        }\n        _classPrivateFieldGet(_indexSyncer, this).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, this).getSheetId(), relativeTransformation);\n      }\n      _classPrivateFieldSet(_indexesSequence, this, newSequence);\n    };\n  }\n\n  /**\n   * Initialize the AxisSyncer.\n   */\n  init() {\n    _classPrivateFieldSet(_indexesSequence, this, _classPrivateFieldGet(_indexMapper, this).getIndexesSequence());\n  }\n}\nexport default AxisSyncer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}