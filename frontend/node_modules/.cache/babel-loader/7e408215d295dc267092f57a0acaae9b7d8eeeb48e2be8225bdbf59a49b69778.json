{"ast":null,"code":"import { columnHeaderScrollStrategy } from \"./scrollStrategies/columnHeaderScroll.mjs\";\nimport { cornerHeaderScrollStrategy } from \"./scrollStrategies/cornerHeaderScroll.mjs\";\nimport { focusScrollStrategy } from \"./scrollStrategies/focusScroll.mjs\";\nimport { multipleScrollStrategy } from \"./scrollStrategies/multipleScroll.mjs\";\nimport { noncontiguousScrollStrategy } from \"./scrollStrategies/noncontiguousScroll.mjs\";\nimport { rowHeaderScrollStrategy } from \"./scrollStrategies/rowHeaderScroll.mjs\";\nimport { singleScrollStrategy } from \"./scrollStrategies/singleScroll.mjs\";\n/**\n * @typedef ViewportScroller\n * @property {function(): void} resume Resumes the viewport scroller.\n * @property {function(): void} suspend Suspends the viewport scroller until the `resume` method is called.\n * @property {function(): void} skipNextScrollCycle Skip the next scroll cycle.\n * @property {function(CellCoords): void} scrollTo Scroll the viewport to a given cell.\n */\n/**\n * Installs a viewport scroller module. The module is responsible for scrolling the viewport to a given cell\n * based on the selection type (single cell selection, multiple cells selection, header selection etc.).\n * It's triggered by the selection module via the `afterSetRangeEnd` hook every time the selection changes.\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {ViewportScroller} The viewport scroller module.\n */\nexport function createViewportScroller(hot) {\n  const {\n    selection\n  } = hot;\n  let skipNextCall = false;\n  let isSuspended = false;\n  return {\n    resume() {\n      isSuspended = false;\n    },\n    suspend() {\n      isSuspended = true;\n    },\n    skipNextScrollCycle() {\n      skipNextCall = true;\n    },\n    scrollTo(cellCoords) {\n      var _scrollStrategy;\n      if (skipNextCall || isSuspended) {\n        skipNextCall = false;\n        return;\n      }\n      let scrollStrategy;\n      if (selection.isFocusSelectionChanged()) {\n        scrollStrategy = focusScrollStrategy(hot);\n      } else if (selection.isSelectedByCorner()) {\n        scrollStrategy = cornerHeaderScrollStrategy(hot);\n      } else if (selection.isSelectedByRowHeader()) {\n        scrollStrategy = rowHeaderScrollStrategy(hot);\n      } else if (selection.isSelectedByColumnHeader()) {\n        scrollStrategy = columnHeaderScrollStrategy(hot);\n      } else if (selection.getSelectedRange().size() === 1 && selection.isMultiple()) {\n        scrollStrategy = multipleScrollStrategy(hot);\n      } else if (selection.getSelectedRange().size() === 1 && !selection.isMultiple()) {\n        scrollStrategy = singleScrollStrategy(hot);\n      } else if (selection.getSelectedRange().size() > 1) {\n        scrollStrategy = noncontiguousScrollStrategy(hot);\n      }\n      (_scrollStrategy = scrollStrategy) === null || _scrollStrategy === void 0 || _scrollStrategy(cellCoords);\n    }\n  };\n}","map":{"version":3,"names":["columnHeaderScrollStrategy","cornerHeaderScrollStrategy","focusScrollStrategy","multipleScrollStrategy","noncontiguousScrollStrategy","rowHeaderScrollStrategy","singleScrollStrategy","createViewportScroller","hot","selection","skipNextCall","isSuspended","resume","suspend","skipNextScrollCycle","scrollTo","cellCoords","_scrollStrategy","scrollStrategy","isFocusSelectionChanged","isSelectedByCorner","isSelectedByRowHeader","isSelectedByColumnHeader","getSelectedRange","size","isMultiple"],"sources":["D:/gym-project/frontend/node_modules/handsontable/core/viewportScroll/index.mjs"],"sourcesContent":["import { columnHeaderScrollStrategy } from \"./scrollStrategies/columnHeaderScroll.mjs\";\nimport { cornerHeaderScrollStrategy } from \"./scrollStrategies/cornerHeaderScroll.mjs\";\nimport { focusScrollStrategy } from \"./scrollStrategies/focusScroll.mjs\";\nimport { multipleScrollStrategy } from \"./scrollStrategies/multipleScroll.mjs\";\nimport { noncontiguousScrollStrategy } from \"./scrollStrategies/noncontiguousScroll.mjs\";\nimport { rowHeaderScrollStrategy } from \"./scrollStrategies/rowHeaderScroll.mjs\";\nimport { singleScrollStrategy } from \"./scrollStrategies/singleScroll.mjs\";\n/**\n * @typedef ViewportScroller\n * @property {function(): void} resume Resumes the viewport scroller.\n * @property {function(): void} suspend Suspends the viewport scroller until the `resume` method is called.\n * @property {function(): void} skipNextScrollCycle Skip the next scroll cycle.\n * @property {function(CellCoords): void} scrollTo Scroll the viewport to a given cell.\n */\n/**\n * Installs a viewport scroller module. The module is responsible for scrolling the viewport to a given cell\n * based on the selection type (single cell selection, multiple cells selection, header selection etc.).\n * It's triggered by the selection module via the `afterSetRangeEnd` hook every time the selection changes.\n *\n * @param {Core} hot The Handsontable instance.\n * @returns {ViewportScroller} The viewport scroller module.\n */\nexport function createViewportScroller(hot) {\n  const {\n    selection\n  } = hot;\n  let skipNextCall = false;\n  let isSuspended = false;\n  return {\n    resume() {\n      isSuspended = false;\n    },\n    suspend() {\n      isSuspended = true;\n    },\n    skipNextScrollCycle() {\n      skipNextCall = true;\n    },\n    scrollTo(cellCoords) {\n      var _scrollStrategy;\n      if (skipNextCall || isSuspended) {\n        skipNextCall = false;\n        return;\n      }\n      let scrollStrategy;\n      if (selection.isFocusSelectionChanged()) {\n        scrollStrategy = focusScrollStrategy(hot);\n      } else if (selection.isSelectedByCorner()) {\n        scrollStrategy = cornerHeaderScrollStrategy(hot);\n      } else if (selection.isSelectedByRowHeader()) {\n        scrollStrategy = rowHeaderScrollStrategy(hot);\n      } else if (selection.isSelectedByColumnHeader()) {\n        scrollStrategy = columnHeaderScrollStrategy(hot);\n      } else if (selection.getSelectedRange().size() === 1 && selection.isMultiple()) {\n        scrollStrategy = multipleScrollStrategy(hot);\n      } else if (selection.getSelectedRange().size() === 1 && !selection.isMultiple()) {\n        scrollStrategy = singleScrollStrategy(hot);\n      } else if (selection.getSelectedRange().size() > 1) {\n        scrollStrategy = noncontiguousScrollStrategy(hot);\n      }\n      (_scrollStrategy = scrollStrategy) === null || _scrollStrategy === void 0 || _scrollStrategy(cellCoords);\n    }\n  };\n}"],"mappings":"AAAA,SAASA,0BAA0B,QAAQ,2CAA2C;AACtF,SAASC,0BAA0B,QAAQ,2CAA2C;AACtF,SAASC,mBAAmB,QAAQ,oCAAoC;AACxE,SAASC,sBAAsB,QAAQ,uCAAuC;AAC9E,SAASC,2BAA2B,QAAQ,4CAA4C;AACxF,SAASC,uBAAuB,QAAQ,wCAAwC;AAChF,SAASC,oBAAoB,QAAQ,qCAAqC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sBAAsBA,CAACC,GAAG,EAAE;EAC1C,MAAM;IACJC;EACF,CAAC,GAAGD,GAAG;EACP,IAAIE,YAAY,GAAG,KAAK;EACxB,IAAIC,WAAW,GAAG,KAAK;EACvB,OAAO;IACLC,MAAMA,CAAA,EAAG;MACPD,WAAW,GAAG,KAAK;IACrB,CAAC;IACDE,OAAOA,CAAA,EAAG;MACRF,WAAW,GAAG,IAAI;IACpB,CAAC;IACDG,mBAAmBA,CAAA,EAAG;MACpBJ,YAAY,GAAG,IAAI;IACrB,CAAC;IACDK,QAAQA,CAACC,UAAU,EAAE;MACnB,IAAIC,eAAe;MACnB,IAAIP,YAAY,IAAIC,WAAW,EAAE;QAC/BD,YAAY,GAAG,KAAK;QACpB;MACF;MACA,IAAIQ,cAAc;MAClB,IAAIT,SAAS,CAACU,uBAAuB,CAAC,CAAC,EAAE;QACvCD,cAAc,GAAGhB,mBAAmB,CAACM,GAAG,CAAC;MAC3C,CAAC,MAAM,IAAIC,SAAS,CAACW,kBAAkB,CAAC,CAAC,EAAE;QACzCF,cAAc,GAAGjB,0BAA0B,CAACO,GAAG,CAAC;MAClD,CAAC,MAAM,IAAIC,SAAS,CAACY,qBAAqB,CAAC,CAAC,EAAE;QAC5CH,cAAc,GAAGb,uBAAuB,CAACG,GAAG,CAAC;MAC/C,CAAC,MAAM,IAAIC,SAAS,CAACa,wBAAwB,CAAC,CAAC,EAAE;QAC/CJ,cAAc,GAAGlB,0BAA0B,CAACQ,GAAG,CAAC;MAClD,CAAC,MAAM,IAAIC,SAAS,CAACc,gBAAgB,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAIf,SAAS,CAACgB,UAAU,CAAC,CAAC,EAAE;QAC9EP,cAAc,GAAGf,sBAAsB,CAACK,GAAG,CAAC;MAC9C,CAAC,MAAM,IAAIC,SAAS,CAACc,gBAAgB,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAACf,SAAS,CAACgB,UAAU,CAAC,CAAC,EAAE;QAC/EP,cAAc,GAAGZ,oBAAoB,CAACE,GAAG,CAAC;MAC5C,CAAC,MAAM,IAAIC,SAAS,CAACc,gBAAgB,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;QAClDN,cAAc,GAAGd,2BAA2B,CAACI,GAAG,CAAC;MACnD;MACA,CAACS,eAAe,GAAGC,cAAc,MAAM,IAAI,IAAID,eAAe,KAAK,KAAK,CAAC,IAAIA,eAAe,CAACD,UAAU,CAAC;IAC1G;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}