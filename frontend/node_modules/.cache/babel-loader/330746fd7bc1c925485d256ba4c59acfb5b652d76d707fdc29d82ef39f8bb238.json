{"ast":null,"code":"import moment from 'moment';\nimport { isObject } from \"../../helpers/object.mjs\";\nimport { isRightClick } from \"../../helpers/dom/event.mjs\";\nimport { isEmpty } from \"../../helpers/mixed.mjs\";\nimport { DO_NOT_SWAP, FIRST_BEFORE_SECOND, FIRST_AFTER_SECOND } from \"./sortService/index.mjs\";\nexport const ASC_SORT_STATE = 'asc';\nexport const DESC_SORT_STATE = 'desc';\nexport const HEADER_SPAN_CLASS = 'colHeader';\n\n/**\n * Get if column state is valid.\n *\n * @param {number} columnState Particular column state.\n * @returns {boolean}\n */\nfunction isValidColumnState(columnState) {\n  if (isObject(columnState) === false) {\n    return false;\n  }\n  const {\n    column,\n    sortOrder\n  } = columnState;\n  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);\n}\n\n/**\n * Get if all sorted columns states are valid.\n *\n * @param {Array} sortStates The sort state collection.\n * @returns {boolean}\n */\nexport function areValidSortStates(sortStates) {\n  if (sortStates.some(columnState => isValidColumnState(columnState) === false)) {\n    return false;\n  }\n  const sortedColumns = sortStates.map(_ref => {\n    let {\n      column\n    } = _ref;\n    return column;\n  });\n\n  // Indexes occurs only once.\n  return new Set(sortedColumns).size === sortedColumns.length;\n}\n\n/**\n * Get next sort order for particular column. The order sequence looks as follows: 'asc' -> 'desc' -> undefined -> 'asc'.\n *\n * @param {string|undefined} sortOrder Sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).\n * @returns {string|undefined} Next sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).\n */\nexport function getNextSortOrder(sortOrder) {\n  if (sortOrder === DESC_SORT_STATE) {\n    return;\n  } else if (sortOrder === ASC_SORT_STATE) {\n    return DESC_SORT_STATE;\n  }\n  return ASC_SORT_STATE;\n}\n\n/**\n * Get `span` DOM element inside `th` DOM element.\n *\n * @param {Element} TH Th HTML element.\n * @returns {Element | null}\n */\nexport function getHeaderSpanElement(TH) {\n  const headerSpanElement = TH.querySelector(`.${HEADER_SPAN_CLASS}`);\n  return headerSpanElement;\n}\n\n/**\n *\n * Get if handled header is first level column header.\n *\n * @param {number} column Visual column index.\n * @param {Element} TH Th HTML element.\n * @returns {boolean}\n */\nexport function isFirstLevelColumnHeader(column, TH) {\n  if (column < 0 || !TH.parentNode) {\n    return false;\n  }\n  const TRs = TH.parentNode.parentNode.childNodes;\n  const headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;\n  if (headerLevel !== -1) {\n    return false;\n  }\n  return true;\n}\n\n/**\n *  Get if header was clicked properly. Click on column header and NOT done by right click return `true`.\n *\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {Event} clickEvent Click event.\n * @returns {boolean}\n */\nexport function wasHeaderClickedProperly(row, column, clickEvent) {\n  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;\n}\n\n/**\n * Creates date or time sorting compare function.\n *\n * @param {string} sortOrder Sort order (`asc` for ascending, `desc` for descending).\n * @param {string} format Date or time format.\n * @param {object} columnPluginSettings Plugin settings for the column.\n * @returns {Function} The compare function.\n */\nexport function createDateTimeCompareFunction(sortOrder, format, columnPluginSettings) {\n  return function (value, nextValue) {\n    const {\n      sortEmptyCells\n    } = columnPluginSettings;\n    if (value === nextValue) {\n      return DO_NOT_SWAP;\n    }\n    if (isEmpty(value)) {\n      if (isEmpty(nextValue)) {\n        return DO_NOT_SWAP;\n      }\n\n      // Just fist value is empty and `sortEmptyCells` option was set\n      if (sortEmptyCells) {\n        return sortOrder === 'asc' ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n      }\n      return FIRST_AFTER_SECOND;\n    }\n    if (isEmpty(nextValue)) {\n      // Just second value is empty and `sortEmptyCells` option was set\n      if (sortEmptyCells) {\n        return sortOrder === 'asc' ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n      }\n      return FIRST_BEFORE_SECOND;\n    }\n    const firstDate = moment(value, format);\n    const nextDate = moment(nextValue, format);\n    if (!firstDate.isValid()) {\n      return FIRST_AFTER_SECOND;\n    }\n    if (!nextDate.isValid()) {\n      return FIRST_BEFORE_SECOND;\n    }\n    if (nextDate.isAfter(firstDate)) {\n      return sortOrder === 'asc' ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    }\n    if (nextDate.isBefore(firstDate)) {\n      return sortOrder === 'asc' ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    }\n    return DO_NOT_SWAP;\n  };\n}","map":{"version":3,"names":["moment","isObject","isRightClick","isEmpty","DO_NOT_SWAP","FIRST_BEFORE_SECOND","FIRST_AFTER_SECOND","ASC_SORT_STATE","DESC_SORT_STATE","HEADER_SPAN_CLASS","isValidColumnState","columnState","column","sortOrder","Number","isInteger","includes","areValidSortStates","sortStates","some","sortedColumns","map","_ref","Set","size","length","getNextSortOrder","getHeaderSpanElement","TH","headerSpanElement","querySelector","isFirstLevelColumnHeader","parentNode","TRs","childNodes","headerLevel","Array","from","indexOf","wasHeaderClickedProperly","row","clickEvent","createDateTimeCompareFunction","format","columnPluginSettings","value","nextValue","sortEmptyCells","firstDate","nextDate","isValid","isAfter","isBefore"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/columnSorting/utils.mjs"],"sourcesContent":["import \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport moment from 'moment';\nimport { isObject } from \"../../helpers/object.mjs\";\nimport { isRightClick } from \"../../helpers/dom/event.mjs\";\nimport { isEmpty } from \"../../helpers/mixed.mjs\";\nimport { DO_NOT_SWAP, FIRST_BEFORE_SECOND, FIRST_AFTER_SECOND } from \"./sortService/index.mjs\";\nexport const ASC_SORT_STATE = 'asc';\nexport const DESC_SORT_STATE = 'desc';\nexport const HEADER_SPAN_CLASS = 'colHeader';\n\n/**\n * Get if column state is valid.\n *\n * @param {number} columnState Particular column state.\n * @returns {boolean}\n */\nfunction isValidColumnState(columnState) {\n  if (isObject(columnState) === false) {\n    return false;\n  }\n  const {\n    column,\n    sortOrder\n  } = columnState;\n  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);\n}\n\n/**\n * Get if all sorted columns states are valid.\n *\n * @param {Array} sortStates The sort state collection.\n * @returns {boolean}\n */\nexport function areValidSortStates(sortStates) {\n  if (sortStates.some(columnState => isValidColumnState(columnState) === false)) {\n    return false;\n  }\n  const sortedColumns = sortStates.map(_ref => {\n    let {\n      column\n    } = _ref;\n    return column;\n  });\n\n  // Indexes occurs only once.\n  return new Set(sortedColumns).size === sortedColumns.length;\n}\n\n/**\n * Get next sort order for particular column. The order sequence looks as follows: 'asc' -> 'desc' -> undefined -> 'asc'.\n *\n * @param {string|undefined} sortOrder Sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).\n * @returns {string|undefined} Next sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).\n */\nexport function getNextSortOrder(sortOrder) {\n  if (sortOrder === DESC_SORT_STATE) {\n    return;\n  } else if (sortOrder === ASC_SORT_STATE) {\n    return DESC_SORT_STATE;\n  }\n  return ASC_SORT_STATE;\n}\n\n/**\n * Get `span` DOM element inside `th` DOM element.\n *\n * @param {Element} TH Th HTML element.\n * @returns {Element | null}\n */\nexport function getHeaderSpanElement(TH) {\n  const headerSpanElement = TH.querySelector(`.${HEADER_SPAN_CLASS}`);\n  return headerSpanElement;\n}\n\n/**\n *\n * Get if handled header is first level column header.\n *\n * @param {number} column Visual column index.\n * @param {Element} TH Th HTML element.\n * @returns {boolean}\n */\nexport function isFirstLevelColumnHeader(column, TH) {\n  if (column < 0 || !TH.parentNode) {\n    return false;\n  }\n  const TRs = TH.parentNode.parentNode.childNodes;\n  const headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;\n  if (headerLevel !== -1) {\n    return false;\n  }\n  return true;\n}\n\n/**\n *  Get if header was clicked properly. Click on column header and NOT done by right click return `true`.\n *\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {Event} clickEvent Click event.\n * @returns {boolean}\n */\nexport function wasHeaderClickedProperly(row, column, clickEvent) {\n  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;\n}\n\n/**\n * Creates date or time sorting compare function.\n *\n * @param {string} sortOrder Sort order (`asc` for ascending, `desc` for descending).\n * @param {string} format Date or time format.\n * @param {object} columnPluginSettings Plugin settings for the column.\n * @returns {Function} The compare function.\n */\nexport function createDateTimeCompareFunction(sortOrder, format, columnPluginSettings) {\n  return function (value, nextValue) {\n    const {\n      sortEmptyCells\n    } = columnPluginSettings;\n    if (value === nextValue) {\n      return DO_NOT_SWAP;\n    }\n    if (isEmpty(value)) {\n      if (isEmpty(nextValue)) {\n        return DO_NOT_SWAP;\n      }\n\n      // Just fist value is empty and `sortEmptyCells` option was set\n      if (sortEmptyCells) {\n        return sortOrder === 'asc' ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n      }\n      return FIRST_AFTER_SECOND;\n    }\n    if (isEmpty(nextValue)) {\n      // Just second value is empty and `sortEmptyCells` option was set\n      if (sortEmptyCells) {\n        return sortOrder === 'asc' ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n      }\n      return FIRST_BEFORE_SECOND;\n    }\n    const firstDate = moment(value, format);\n    const nextDate = moment(nextValue, format);\n    if (!firstDate.isValid()) {\n      return FIRST_AFTER_SECOND;\n    }\n    if (!nextDate.isValid()) {\n      return FIRST_BEFORE_SECOND;\n    }\n    if (nextDate.isAfter(firstDate)) {\n      return sortOrder === 'asc' ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    }\n    if (nextDate.isBefore(firstDate)) {\n      return sortOrder === 'asc' ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    }\n    return DO_NOT_SWAP;\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}