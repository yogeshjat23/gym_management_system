{"ast":null,"code":"import { addClass, hasClass, removeClass, getComputedStyle, getTrimmingContainer, innerWidth, innerHeight, offset, outerHeight, outerWidth } from \"../../../../../helpers/dom/element.mjs\";\nimport { stopImmediatePropagation } from \"../../../../../helpers/dom/event.mjs\";\nimport { objectEach } from \"../../../../../helpers/object.mjs\";\nimport { isMobileBrowser } from \"../../../../../helpers/browser.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"./constants.mjs\";\n/**\n *\n */\nclass Border {\n  // TODO As this is an internal class, should be designed for using {Walkontable}. It uses the facade,\n  // TODO Con. Because the class is created on place where the instance reference comes from external origin.\n  // TODO Imho, the discrimination for handling both, facade and non-facade should be handled.\n  /**\n   * @param {WalkontableFacade} wotInstance The Walkontable instance.\n   * @param {object} settings The border settings.\n   */\n  constructor(wotInstance, settings) {\n    if (!settings) {\n      return;\n    }\n    this.eventManager = wotInstance.eventManager;\n    this.instance = wotInstance;\n    this.wot = wotInstance;\n    this.settings = settings;\n    this.mouseDown = false;\n    this.main = null;\n    this.top = null;\n    this.bottom = null;\n    this.start = null;\n    this.end = null;\n    this.topStyle = null;\n    this.bottomStyle = null;\n    this.startStyle = null;\n    this.endStyle = null;\n    this.cornerDefaultStyle = CORNER_DEFAULT_STYLE;\n    // Offset to moving the corner to be centered relative to the grid.\n    this.cornerCenterPointOffset = -(parseInt(this.cornerDefaultStyle.width, 10) / 2);\n    this.corner = null;\n    this.cornerStyle = null;\n    this.createBorders(settings);\n    this.registerListeners();\n  }\n\n  /**\n   * Register all necessary events.\n   */\n  registerListeners() {\n    const documentBody = this.wot.rootDocument.body;\n    this.eventManager.addEventListener(documentBody, 'mousedown', () => this.onMouseDown());\n    this.eventManager.addEventListener(documentBody, 'mouseup', () => this.onMouseUp());\n    for (let c = 0, len = this.main.childNodes.length; c < len; c++) {\n      const element = this.main.childNodes[c];\n      this.eventManager.addEventListener(element, 'mouseenter', event => this.onMouseEnter(event, this.main.childNodes[c]));\n    }\n  }\n\n  /**\n   * Mouse down listener.\n   *\n   * @private\n   */\n  onMouseDown() {\n    this.mouseDown = true;\n  }\n\n  /**\n   * Mouse up listener.\n   *\n   * @private\n   */\n  onMouseUp() {\n    this.mouseDown = false;\n  }\n\n  /**\n   * Mouse enter listener for fragment selection functionality.\n   *\n   * @private\n   * @param {Event} event Dom event.\n   * @param {HTMLElement} parentElement Part of border element.\n   */\n  onMouseEnter(event, parentElement) {\n    if (!this.mouseDown || !this.wot.getSetting('hideBorderOnMouseDownOver')) {\n      return;\n    }\n    event.preventDefault();\n    stopImmediatePropagation(event);\n    const _this = this;\n    const documentBody = this.wot.rootDocument.body;\n    const bounds = parentElement.getBoundingClientRect();\n\n    // Hide border to prevents selection jumping when fragmentSelection is enabled.\n    parentElement.style.display = 'none';\n\n    /**\n     * @param {Event} mouseEvent The mouse event object.\n     * @returns {boolean}\n     */\n    function isOutside(mouseEvent) {\n      if (mouseEvent.clientY < Math.floor(bounds.top)) {\n        return true;\n      }\n      if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {\n        return true;\n      }\n      if (mouseEvent.clientX < Math.floor(bounds.left)) {\n        return true;\n      }\n      if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {\n        return true;\n      }\n    }\n\n    /**\n     * @param {Event} handlerEvent The mouse event object.\n     */\n    function handler(handlerEvent) {\n      if (isOutside(handlerEvent)) {\n        _this.eventManager.removeEventListener(documentBody, 'mousemove', handler);\n        parentElement.style.display = 'block';\n      }\n    }\n    this.eventManager.addEventListener(documentBody, 'mousemove', handler);\n  }\n\n  /**\n   * Create border elements.\n   *\n   * @param {object} settings The border settings.\n   */\n  createBorders(settings) {\n    const {\n      rootDocument\n    } = this.wot;\n    this.main = rootDocument.createElement('div');\n    const borderDivs = ['top', 'start', 'bottom', 'end', 'corner'];\n    let style = this.main.style;\n    style.position = 'absolute';\n    style.top = 0;\n    style.left = 0;\n    for (let i = 0; i < 5; i++) {\n      const position = borderDivs[i];\n      const div = rootDocument.createElement('div');\n      div.className = `wtBorder ${this.settings.className || ''}`; // + borderDivs[i];\n\n      if (this.settings[position] && this.settings[position].hide) {\n        div.className += ' hidden';\n      }\n      style = div.style;\n      style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;\n      style.height = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;\n      style.width = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;\n      this.main.appendChild(div);\n    }\n    this.top = this.main.childNodes[0];\n    this.start = this.main.childNodes[1];\n    this.bottom = this.main.childNodes[2];\n    this.end = this.main.childNodes[3];\n    this.topStyle = this.top.style;\n    this.startStyle = this.start.style;\n    this.bottomStyle = this.bottom.style;\n    this.endStyle = this.end.style;\n    this.corner = this.main.childNodes[4];\n    this.corner.className += ' corner';\n    this.cornerStyle = this.corner.style;\n    this.cornerStyle.width = this.cornerDefaultStyle.width;\n    this.cornerStyle.height = this.cornerDefaultStyle.height;\n    this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(' ');\n    if (isMobileBrowser() && this.instance.getSetting('isDataViewInstance')) {\n      this.createMultipleSelectorHandles();\n    }\n    this.disappear();\n    const {\n      wtTable\n    } = this.wot;\n    let bordersHolder = wtTable.bordersHolder;\n    if (!bordersHolder) {\n      bordersHolder = rootDocument.createElement('div');\n      bordersHolder.className = 'htBorders';\n      wtTable.bordersHolder = bordersHolder;\n      wtTable.spreader.appendChild(bordersHolder);\n    }\n    bordersHolder.appendChild(this.main);\n  }\n\n  /**\n   * Create multiple selector handler for mobile devices.\n   */\n  createMultipleSelectorHandles() {\n    const {\n      rootDocument\n    } = this.wot;\n    this.selectionHandles = {\n      top: rootDocument.createElement('DIV'),\n      topHitArea: rootDocument.createElement('DIV'),\n      bottom: rootDocument.createElement('DIV'),\n      bottomHitArea: rootDocument.createElement('DIV')\n    };\n    const width = 10;\n    const hitAreaWidth = 40;\n    this.selectionHandles.top.className = 'topSelectionHandle topLeftSelectionHandle';\n    this.selectionHandles.topHitArea.className = 'topSelectionHandle-HitArea topLeftSelectionHandle-HitArea';\n    this.selectionHandles.bottom.className = 'bottomSelectionHandle bottomRightSelectionHandle';\n    this.selectionHandles.bottomHitArea.className = 'bottomSelectionHandle-HitArea bottomRightSelectionHandle-HitArea';\n    this.selectionHandles.styles = {\n      top: this.selectionHandles.top.style,\n      topHitArea: this.selectionHandles.topHitArea.style,\n      bottom: this.selectionHandles.bottom.style,\n      bottomHitArea: this.selectionHandles.bottomHitArea.style\n    };\n    const hitAreaStyle = {\n      position: 'absolute',\n      height: `${hitAreaWidth}px`,\n      width: `${hitAreaWidth}px`,\n      'border-radius': `${parseInt(hitAreaWidth / 1.5, 10)}px`\n    };\n    objectEach(hitAreaStyle, (value, key) => {\n      this.selectionHandles.styles.bottomHitArea[key] = value;\n      this.selectionHandles.styles.topHitArea[key] = value;\n    });\n    const handleStyle = {\n      position: 'absolute',\n      height: `${width}px`,\n      width: `${width}px`,\n      'border-radius': `${parseInt(width / 1.5, 10)}px`,\n      background: '#F5F5FF',\n      border: '1px solid #4285c8'\n    };\n    objectEach(handleStyle, (value, key) => {\n      this.selectionHandles.styles.bottom[key] = value;\n      this.selectionHandles.styles.top[key] = value;\n    });\n    this.main.appendChild(this.selectionHandles.top);\n    this.main.appendChild(this.selectionHandles.bottom);\n    this.main.appendChild(this.selectionHandles.topHitArea);\n    this.main.appendChild(this.selectionHandles.bottomHitArea);\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @returns {boolean}\n   */\n  isPartRange(row, col) {\n    const areaSelection = this.wot.selectionManager.getAreaSelection();\n    if (areaSelection.cellRange) {\n      if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number} top The top position of the handler.\n   * @param {number} left The left position of the handler.\n   * @param {number} width The width of the handler.\n   * @param {number} height The height of the handler.\n   */\n  updateMultipleSelectionHandlesPosition(row, col, top, left, width, height) {\n    const isRtl = this.wot.wtSettings.getSetting('rtlMode');\n    const inlinePosProperty = isRtl ? 'right' : 'left';\n    const {\n      top: topStyles,\n      topHitArea: topHitAreaStyles,\n      bottom: bottomStyles,\n      bottomHitArea: bottomHitAreaStyles\n    } = this.selectionHandles.styles;\n    const handleBorderSize = parseInt(topStyles.borderWidth, 10);\n    const handleSize = parseInt(topStyles.width, 10);\n    const hitAreaSize = parseInt(topHitAreaStyles.width, 10);\n    const totalTableWidth = this.wot.wtTable.getWidth();\n    const totalTableHeight = this.wot.wtTable.getHeight();\n    topStyles.top = `${parseInt(top - handleSize - 1, 10)}px`;\n    topStyles[inlinePosProperty] = `${parseInt(left - handleSize - 1, 10)}px`;\n    topHitAreaStyles.top = `${parseInt(top - hitAreaSize / 4 * 3, 10)}px`;\n    topHitAreaStyles[inlinePosProperty] = `${parseInt(left - hitAreaSize / 4 * 3, 10)}px`;\n    const bottomHandlerInline = Math.min(parseInt(left + width, 10), totalTableWidth - handleSize - handleBorderSize * 2);\n    const bottomHandlerAreaInline = Math.min(parseInt(left + width - hitAreaSize / 4, 10), totalTableWidth - hitAreaSize - handleBorderSize * 2);\n    bottomStyles[inlinePosProperty] = `${bottomHandlerInline}px`;\n    bottomHitAreaStyles[inlinePosProperty] = `${bottomHandlerAreaInline}px`;\n    const bottomHandlerTop = Math.min(parseInt(top + height, 10), totalTableHeight - handleSize - handleBorderSize * 2);\n    const bottomHandlerAreaTop = Math.min(parseInt(top + height - hitAreaSize / 4, 10), totalTableHeight - hitAreaSize - handleBorderSize * 2);\n    bottomStyles.top = `${bottomHandlerTop}px`;\n    bottomHitAreaStyles.top = `${bottomHandlerAreaTop}px`;\n    if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {\n      topStyles.display = 'block';\n      topHitAreaStyles.display = 'block';\n      if (this.isPartRange(row, col)) {\n        bottomStyles.display = 'none';\n        bottomHitAreaStyles.display = 'none';\n      } else {\n        bottomStyles.display = 'block';\n        bottomHitAreaStyles.display = 'block';\n      }\n    } else {\n      topStyles.display = 'none';\n      bottomStyles.display = 'none';\n      topHitAreaStyles.display = 'none';\n      bottomHitAreaStyles.display = 'none';\n    }\n    if (row === this.wot.wtSettings.getSetting('fixedRowsTop') || col === this.wot.wtSettings.getSetting('fixedColumnsStart')) {\n      topStyles.zIndex = '9999';\n      topHitAreaStyles.zIndex = '9999';\n    } else {\n      topStyles.zIndex = '';\n      topHitAreaStyles.zIndex = '';\n    }\n  }\n\n  /**\n   * Show border around one or many cells.\n   *\n   * @param {Array} corners The corner coordinates.\n   */\n  appear(corners) {\n    if (this.disabled) {\n      return;\n    }\n    const {\n      wtTable,\n      rootDocument,\n      rootWindow\n    } = this.wot; // todo refactoring: consider about using internal facade (it is given by external code)\n    let fromRow;\n    let toRow;\n    let fromColumn;\n    let toColumn;\n    let rowHeader;\n    let columnHeader;\n    const rowsCount = wtTable.getRenderedRowsCount();\n    for (let i = 0; i < rowsCount; i += 1) {\n      const s = wtTable.rowFilter.renderedToSource(i);\n      if (s >= corners[0] && s <= corners[2]) {\n        fromRow = s;\n        rowHeader = corners[0];\n        break;\n      }\n    }\n    for (let i = rowsCount - 1; i >= 0; i -= 1) {\n      const s = wtTable.rowFilter.renderedToSource(i);\n      if (s >= corners[0] && s <= corners[2]) {\n        toRow = s;\n        break;\n      }\n    }\n    const columnsCount = wtTable.getRenderedColumnsCount();\n    for (let i = 0; i < columnsCount; i += 1) {\n      const s = wtTable.columnFilter.renderedToSource(i);\n      if (s >= corners[1] && s <= corners[3]) {\n        fromColumn = s;\n        columnHeader = corners[1];\n        break;\n      }\n    }\n    for (let i = columnsCount - 1; i >= 0; i -= 1) {\n      const s = wtTable.columnFilter.renderedToSource(i);\n      if (s >= corners[1] && s <= corners[3]) {\n        toColumn = s;\n        break;\n      }\n    }\n    if (fromRow === undefined || fromColumn === undefined) {\n      this.disappear();\n      return;\n    }\n    let fromTD = wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));\n    const isMultiple = fromRow !== toRow || fromColumn !== toColumn;\n    const toTD = isMultiple ? wtTable.getCell(this.wot.createCellCoords(toRow, toColumn)) : fromTD;\n    const fromOffset = offset(fromTD);\n    const toOffset = isMultiple ? offset(toTD) : fromOffset;\n    const containerOffset = offset(wtTable.TABLE);\n    const containerWidth = outerWidth(wtTable.TABLE);\n    const minTop = fromOffset.top;\n    const minLeft = fromOffset.left;\n    const isRtl = this.wot.wtSettings.getSetting('rtlMode');\n    let inlineStartPos = 0;\n    let width = 0;\n    if (isRtl) {\n      const fromWidth = outerWidth(fromTD);\n      const gridRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n      width = minLeft + fromWidth - toOffset.left;\n      inlineStartPos = rootWindow.innerWidth - minLeft - fromWidth - gridRightPos - 1;\n    } else {\n      width = toOffset.left + outerWidth(toTD) - minLeft;\n      inlineStartPos = minLeft - containerOffset.left - 1;\n    }\n    if (this.isEntireColumnSelected(fromRow, toRow)) {\n      const modifiedValues = this.getDimensionsFromHeader('columns', fromColumn, toColumn, rowHeader, containerOffset);\n      let fromTH = null;\n      if (modifiedValues) {\n        [fromTH, inlineStartPos, width] = modifiedValues;\n      }\n      if (fromTH) {\n        fromTD = fromTH;\n      }\n    }\n    let top = minTop - containerOffset.top - 1;\n    let height = toOffset.top + outerHeight(toTD) - minTop;\n    if (this.isEntireRowSelected(fromColumn, toColumn)) {\n      const modifiedValues = this.getDimensionsFromHeader('rows', fromRow, toRow, columnHeader, containerOffset);\n      let fromTH = null;\n      if (modifiedValues) {\n        [fromTH, top, height] = modifiedValues;\n      }\n      if (fromTH) {\n        fromTD = fromTH;\n      }\n    }\n    const style = getComputedStyle(fromTD, rootWindow);\n    if (parseInt(style.borderTopWidth, 10) > 0) {\n      top += 1;\n      height = height > 0 ? height - 1 : 0;\n    }\n    if (parseInt(style[isRtl ? 'borderRightWidth' : 'borderLeftWidth'], 10) > 0) {\n      inlineStartPos += 1;\n      width = width > 0 ? width - 1 : 0;\n    }\n    const inlinePosProperty = isRtl ? 'right' : 'left';\n    this.topStyle.top = `${top}px`;\n    this.topStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    this.topStyle.width = `${width}px`;\n    this.topStyle.display = 'block';\n    this.startStyle.top = `${top}px`;\n    this.startStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    this.startStyle.height = `${height}px`;\n    this.startStyle.display = 'block';\n    const delta = Math.floor(this.settings.border.width / 2);\n    this.bottomStyle.top = `${top + height - delta}px`;\n    this.bottomStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    this.bottomStyle.width = `${width}px`;\n    this.bottomStyle.display = 'block';\n    this.endStyle.top = `${top}px`;\n    this.endStyle[inlinePosProperty] = `${inlineStartPos + width - delta}px`;\n    this.endStyle.height = `${height + 1}px`;\n    this.endStyle.display = 'block';\n    let cornerVisibleSetting = this.settings.border.cornerVisible;\n    cornerVisibleSetting = typeof cornerVisibleSetting === 'function' ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;\n    const hookResult = this.wot.getSetting('onModifyGetCellCoords', toRow, toColumn);\n    let [checkRow, checkCol] = [toRow, toColumn];\n    if (hookResult && Array.isArray(hookResult)) {\n      [,, checkRow, checkCol] = hookResult;\n    }\n    if (isMobileBrowser() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {\n      this.cornerStyle.display = 'none';\n    } else {\n      this.cornerStyle.top = `${top + height + this.cornerCenterPointOffset - 1}px`;\n      this.cornerStyle[inlinePosProperty] = `${inlineStartPos + width + this.cornerCenterPointOffset - 1}px`;\n      this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;\n      this.cornerStyle.width = this.cornerDefaultStyle.width;\n\n      // Hide the fill handle, so the possible further adjustments won't force unneeded scrollbars.\n      this.cornerStyle.display = 'none';\n      let trimmingContainer = getTrimmingContainer(wtTable.TABLE);\n      const trimToWindow = trimmingContainer === rootWindow;\n      if (trimToWindow) {\n        trimmingContainer = rootDocument.documentElement;\n      }\n      const cornerHalfWidth = parseInt(this.cornerDefaultStyle.width, 10) / 2;\n      const cornerHalfHeight = parseInt(this.cornerDefaultStyle.height, 10) / 2;\n      if (toColumn === this.wot.getSetting('totalColumns') - 1) {\n        const toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;\n        let cornerOverlappingContainer = false;\n        let cornerEdge = 0;\n        if (isRtl) {\n          cornerEdge = toTdOffsetLeft - parseInt(this.cornerDefaultStyle.width, 10) / 2;\n          cornerOverlappingContainer = cornerEdge < 0;\n        } else {\n          cornerEdge = toTdOffsetLeft + outerWidth(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;\n          cornerOverlappingContainer = cornerEdge >= innerWidth(trimmingContainer);\n        }\n        if (cornerOverlappingContainer) {\n          this.cornerStyle[inlinePosProperty] = `${Math.floor(inlineStartPos + width + this.cornerCenterPointOffset - cornerHalfWidth)}px`;\n          this.cornerStyle[isRtl ? 'borderLeftWidth' : 'borderRightWidth'] = 0;\n        }\n      }\n      if (toRow === this.wot.getSetting('totalRows') - 1) {\n        const toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;\n        const cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;\n        const cornerOverlappingContainer = cornerBottomEdge >= innerHeight(trimmingContainer);\n        if (cornerOverlappingContainer) {\n          this.cornerStyle.top = `${Math.floor(top + height + this.cornerCenterPointOffset - cornerHalfHeight)}px`;\n          this.cornerStyle.borderBottomWidth = 0;\n        }\n      }\n      this.cornerStyle.display = 'block';\n    }\n    if (isMobileBrowser() && this.instance.getSetting('isDataViewInstance')) {\n      this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top, inlineStartPos, width, height);\n    }\n  }\n\n  /**\n   * Check whether an entire column of cells is selected.\n   *\n   * @private\n   * @param {number} startRowIndex Start row index.\n   * @param {number} endRowIndex End row index.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected(startRowIndex, endRowIndex) {\n    return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();\n  }\n\n  /**\n   * Check whether an entire row of cells is selected.\n   *\n   * @private\n   * @param {number} startColumnIndex Start column index.\n   * @param {number} endColumnIndex End column index.\n   * @returns {boolean}\n   */\n  isEntireRowSelected(startColumnIndex, endColumnIndex) {\n    return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();\n  }\n\n  /**\n   * Get left/top index and width/height depending on the `direction` provided.\n   *\n   * @private\n   * @param {string} direction `rows` or `columns`, defines if an entire column or row is selected.\n   * @param {number} fromIndex Start index of the selection.\n   * @param {number} toIndex End index of the selection.\n   * @param {number} headerIndex The header index as negative value.\n   * @param {number} containerOffset Offset of the container.\n   * @returns {Array|boolean} Returns an array of [headerElement, left, width] or [headerElement, top, height], depending on `direction` (`false` in case of an error getting the headers).\n   */\n  getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, containerOffset) {\n    const {\n      wtTable\n    } = this.wot;\n    const rootHotElement = wtTable.wtRootElement.parentNode;\n    let getHeaderFn = null;\n    let dimensionFn = null;\n    let entireSelectionClassname = null;\n    let index = null;\n    let dimension = null;\n    let dimensionProperty = null;\n    let startHeader = null;\n    let endHeader = null;\n    switch (direction) {\n      case 'rows':\n        getHeaderFn = function () {\n          return wtTable.getRowHeader(...arguments);\n        };\n        dimensionFn = function () {\n          return outerHeight(...arguments);\n        };\n        entireSelectionClassname = 'ht__selection--rows';\n        dimensionProperty = 'top';\n        break;\n      case 'columns':\n        getHeaderFn = function () {\n          return wtTable.getColumnHeader(...arguments);\n        };\n        dimensionFn = function () {\n          return outerWidth(...arguments);\n        };\n        entireSelectionClassname = 'ht__selection--columns';\n        dimensionProperty = 'left';\n        break;\n      default:\n    }\n    if (rootHotElement.classList.contains(entireSelectionClassname)) {\n      const columnHeaderLevelCount = this.wot.getSetting('columnHeaders').length;\n      startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - headerIndex);\n      endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - headerIndex);\n      if (!startHeader || !endHeader) {\n        return false;\n      }\n      const startHeaderOffset = offset(startHeader);\n      const endOffset = offset(endHeader);\n      if (startHeader && endHeader) {\n        index = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;\n        dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];\n      }\n      return [startHeader, index, dimension];\n    }\n    return false;\n  }\n\n  /**\n   * Change border style.\n   *\n   * @private\n   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.\n   * @param {object} border The border object descriptor.\n   */\n  changeBorderStyle(borderElement, border) {\n    const style = this[borderElement].style;\n    const borderStyle = border[borderElement];\n    if (!borderStyle || borderStyle.hide) {\n      addClass(this[borderElement], 'hidden');\n    } else {\n      if (hasClass(this[borderElement], 'hidden')) {\n        removeClass(this[borderElement], 'hidden');\n      }\n      style.backgroundColor = borderStyle.color;\n      if (borderElement === 'top' || borderElement === 'bottom') {\n        style.height = `${borderStyle.width}px`;\n      }\n      if (borderElement === 'start' || borderElement === 'end') {\n        style.width = `${borderStyle.width}px`;\n      }\n    }\n  }\n\n  /**\n   * Change border style to default.\n   *\n   * @private\n   * @param {string} position The position type (\"top\", \"bottom\", \"start\", \"end\") to change.\n   */\n  changeBorderToDefaultStyle(position) {\n    const defaultBorder = {\n      width: 1,\n      color: '#000'\n    };\n    const style = this[position].style;\n    style.backgroundColor = defaultBorder.color;\n    style.width = `${defaultBorder.width}px`;\n    style.height = `${defaultBorder.width}px`;\n  }\n\n  /**\n   * Toggle class 'hidden' to element.\n   *\n   * @private\n   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.\n   * @param {boolean} [remove] Defines type of the action to perform.\n   */\n  toggleHiddenClass(borderElement, remove) {\n    this.changeBorderToDefaultStyle(borderElement);\n    if (remove) {\n      addClass(this[borderElement], 'hidden');\n    } else {\n      removeClass(this[borderElement], 'hidden');\n    }\n  }\n\n  /**\n   * Hide border.\n   */\n  disappear() {\n    this.topStyle.display = 'none';\n    this.bottomStyle.display = 'none';\n    this.startStyle.display = 'none';\n    this.endStyle.display = 'none';\n    this.cornerStyle.display = 'none';\n    if (isMobileBrowser() && this.instance.getSetting('isDataViewInstance')) {\n      this.selectionHandles.styles.top.display = 'none';\n      this.selectionHandles.styles.topHitArea.display = 'none';\n      this.selectionHandles.styles.bottom.display = 'none';\n      this.selectionHandles.styles.bottomHitArea.display = 'none';\n    }\n  }\n\n  /**\n   * Cleans up all the DOM state related to a Border instance. Call this prior to deleting a Border instance.\n   */\n  destroy() {\n    this.eventManager.destroyWithOwnEventsOnly();\n    this.main.parentNode.removeChild(this.main);\n  }\n}\nexport default Border;","map":{"version":3,"names":["addClass","hasClass","removeClass","getComputedStyle","getTrimmingContainer","innerWidth","innerHeight","offset","outerHeight","outerWidth","stopImmediatePropagation","objectEach","isMobileBrowser","CORNER_DEFAULT_STYLE","Border","constructor","wotInstance","settings","eventManager","instance","wot","mouseDown","main","top","bottom","start","end","topStyle","bottomStyle","startStyle","endStyle","cornerDefaultStyle","cornerCenterPointOffset","parseInt","width","corner","cornerStyle","createBorders","registerListeners","documentBody","rootDocument","body","addEventListener","onMouseDown","onMouseUp","c","len","childNodes","length","element","event","onMouseEnter","parentElement","getSetting","preventDefault","_this","bounds","getBoundingClientRect","style","display","isOutside","mouseEvent","clientY","Math","floor","ceil","height","clientX","left","handler","handlerEvent","removeEventListener","createElement","borderDivs","position","i","div","className","hide","backgroundColor","color","border","appendChild","borderWidth","borderStyle","borderColor","join","createMultipleSelectorHandles","disappear","wtTable","bordersHolder","spreader","selectionHandles","topHitArea","bottomHitArea","hitAreaWidth","styles","hitAreaStyle","value","key","handleStyle","background","isPartRange","row","col","areaSelection","selectionManager","getAreaSelection","cellRange","to","updateMultipleSelectionHandlesPosition","isRtl","wtSettings","inlinePosProperty","topStyles","topHitAreaStyles","bottomStyles","bottomHitAreaStyles","handleBorderSize","handleSize","hitAreaSize","totalTableWidth","getWidth","totalTableHeight","getHeight","bottomHandlerInline","min","bottomHandlerAreaInline","bottomHandlerTop","bottomHandlerAreaTop","cornerVisible","zIndex","appear","corners","disabled","rootWindow","fromRow","toRow","fromColumn","toColumn","rowHeader","columnHeader","rowsCount","getRenderedRowsCount","s","rowFilter","renderedToSource","columnsCount","getRenderedColumnsCount","columnFilter","undefined","fromTD","getCell","createCellCoords","isMultiple","toTD","fromOffset","toOffset","containerOffset","TABLE","containerWidth","minTop","minLeft","inlineStartPos","fromWidth","gridRightPos","isEntireColumnSelected","modifiedValues","getDimensionsFromHeader","fromTH","isEntireRowSelected","borderTopWidth","delta","cornerVisibleSetting","layerLevel","hookResult","checkRow","checkCol","Array","isArray","borderRightWidth","trimmingContainer","trimToWindow","documentElement","cornerHalfWidth","cornerHalfHeight","toTdOffsetLeft","offsetLeft","cornerOverlappingContainer","cornerEdge","toTdOffsetTop","offsetTop","cornerBottomEdge","borderBottomWidth","startRowIndex","endRowIndex","getFirstRenderedRow","getLastRenderedRow","startColumnIndex","endColumnIndex","getFirstRenderedColumn","getLastRenderedColumn","direction","fromIndex","toIndex","headerIndex","rootHotElement","wtRootElement","parentNode","getHeaderFn","dimensionFn","entireSelectionClassname","index","dimension","dimensionProperty","startHeader","endHeader","getRowHeader","arguments","getColumnHeader","classList","contains","columnHeaderLevelCount","startHeaderOffset","endOffset","changeBorderStyle","borderElement","changeBorderToDefaultStyle","defaultBorder","toggleHiddenClass","remove","destroy","destroyWithOwnEventsOnly","removeChild"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/selection/border/border.mjs"],"sourcesContent":["import { addClass, hasClass, removeClass, getComputedStyle, getTrimmingContainer, innerWidth, innerHeight, offset, outerHeight, outerWidth } from \"../../../../../helpers/dom/element.mjs\";\nimport { stopImmediatePropagation } from \"../../../../../helpers/dom/event.mjs\";\nimport { objectEach } from \"../../../../../helpers/object.mjs\";\nimport { isMobileBrowser } from \"../../../../../helpers/browser.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"./constants.mjs\";\n/**\n *\n */\nclass Border {\n  // TODO As this is an internal class, should be designed for using {Walkontable}. It uses the facade,\n  // TODO Con. Because the class is created on place where the instance reference comes from external origin.\n  // TODO Imho, the discrimination for handling both, facade and non-facade should be handled.\n  /**\n   * @param {WalkontableFacade} wotInstance The Walkontable instance.\n   * @param {object} settings The border settings.\n   */\n  constructor(wotInstance, settings) {\n    if (!settings) {\n      return;\n    }\n    this.eventManager = wotInstance.eventManager;\n    this.instance = wotInstance;\n    this.wot = wotInstance;\n    this.settings = settings;\n    this.mouseDown = false;\n    this.main = null;\n    this.top = null;\n    this.bottom = null;\n    this.start = null;\n    this.end = null;\n    this.topStyle = null;\n    this.bottomStyle = null;\n    this.startStyle = null;\n    this.endStyle = null;\n    this.cornerDefaultStyle = CORNER_DEFAULT_STYLE;\n    // Offset to moving the corner to be centered relative to the grid.\n    this.cornerCenterPointOffset = -(parseInt(this.cornerDefaultStyle.width, 10) / 2);\n    this.corner = null;\n    this.cornerStyle = null;\n    this.createBorders(settings);\n    this.registerListeners();\n  }\n\n  /**\n   * Register all necessary events.\n   */\n  registerListeners() {\n    const documentBody = this.wot.rootDocument.body;\n    this.eventManager.addEventListener(documentBody, 'mousedown', () => this.onMouseDown());\n    this.eventManager.addEventListener(documentBody, 'mouseup', () => this.onMouseUp());\n    for (let c = 0, len = this.main.childNodes.length; c < len; c++) {\n      const element = this.main.childNodes[c];\n      this.eventManager.addEventListener(element, 'mouseenter', event => this.onMouseEnter(event, this.main.childNodes[c]));\n    }\n  }\n\n  /**\n   * Mouse down listener.\n   *\n   * @private\n   */\n  onMouseDown() {\n    this.mouseDown = true;\n  }\n\n  /**\n   * Mouse up listener.\n   *\n   * @private\n   */\n  onMouseUp() {\n    this.mouseDown = false;\n  }\n\n  /**\n   * Mouse enter listener for fragment selection functionality.\n   *\n   * @private\n   * @param {Event} event Dom event.\n   * @param {HTMLElement} parentElement Part of border element.\n   */\n  onMouseEnter(event, parentElement) {\n    if (!this.mouseDown || !this.wot.getSetting('hideBorderOnMouseDownOver')) {\n      return;\n    }\n    event.preventDefault();\n    stopImmediatePropagation(event);\n    const _this = this;\n    const documentBody = this.wot.rootDocument.body;\n    const bounds = parentElement.getBoundingClientRect();\n\n    // Hide border to prevents selection jumping when fragmentSelection is enabled.\n    parentElement.style.display = 'none';\n\n    /**\n     * @param {Event} mouseEvent The mouse event object.\n     * @returns {boolean}\n     */\n    function isOutside(mouseEvent) {\n      if (mouseEvent.clientY < Math.floor(bounds.top)) {\n        return true;\n      }\n      if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {\n        return true;\n      }\n      if (mouseEvent.clientX < Math.floor(bounds.left)) {\n        return true;\n      }\n      if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {\n        return true;\n      }\n    }\n\n    /**\n     * @param {Event} handlerEvent The mouse event object.\n     */\n    function handler(handlerEvent) {\n      if (isOutside(handlerEvent)) {\n        _this.eventManager.removeEventListener(documentBody, 'mousemove', handler);\n        parentElement.style.display = 'block';\n      }\n    }\n    this.eventManager.addEventListener(documentBody, 'mousemove', handler);\n  }\n\n  /**\n   * Create border elements.\n   *\n   * @param {object} settings The border settings.\n   */\n  createBorders(settings) {\n    const {\n      rootDocument\n    } = this.wot;\n    this.main = rootDocument.createElement('div');\n    const borderDivs = ['top', 'start', 'bottom', 'end', 'corner'];\n    let style = this.main.style;\n    style.position = 'absolute';\n    style.top = 0;\n    style.left = 0;\n    for (let i = 0; i < 5; i++) {\n      const position = borderDivs[i];\n      const div = rootDocument.createElement('div');\n      div.className = `wtBorder ${this.settings.className || ''}`; // + borderDivs[i];\n\n      if (this.settings[position] && this.settings[position].hide) {\n        div.className += ' hidden';\n      }\n      style = div.style;\n      style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;\n      style.height = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;\n      style.width = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;\n      this.main.appendChild(div);\n    }\n    this.top = this.main.childNodes[0];\n    this.start = this.main.childNodes[1];\n    this.bottom = this.main.childNodes[2];\n    this.end = this.main.childNodes[3];\n    this.topStyle = this.top.style;\n    this.startStyle = this.start.style;\n    this.bottomStyle = this.bottom.style;\n    this.endStyle = this.end.style;\n    this.corner = this.main.childNodes[4];\n    this.corner.className += ' corner';\n    this.cornerStyle = this.corner.style;\n    this.cornerStyle.width = this.cornerDefaultStyle.width;\n    this.cornerStyle.height = this.cornerDefaultStyle.height;\n    this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(' ');\n    if (isMobileBrowser() && this.instance.getSetting('isDataViewInstance')) {\n      this.createMultipleSelectorHandles();\n    }\n    this.disappear();\n    const {\n      wtTable\n    } = this.wot;\n    let bordersHolder = wtTable.bordersHolder;\n    if (!bordersHolder) {\n      bordersHolder = rootDocument.createElement('div');\n      bordersHolder.className = 'htBorders';\n      wtTable.bordersHolder = bordersHolder;\n      wtTable.spreader.appendChild(bordersHolder);\n    }\n    bordersHolder.appendChild(this.main);\n  }\n\n  /**\n   * Create multiple selector handler for mobile devices.\n   */\n  createMultipleSelectorHandles() {\n    const {\n      rootDocument\n    } = this.wot;\n    this.selectionHandles = {\n      top: rootDocument.createElement('DIV'),\n      topHitArea: rootDocument.createElement('DIV'),\n      bottom: rootDocument.createElement('DIV'),\n      bottomHitArea: rootDocument.createElement('DIV')\n    };\n    const width = 10;\n    const hitAreaWidth = 40;\n    this.selectionHandles.top.className = 'topSelectionHandle topLeftSelectionHandle';\n    this.selectionHandles.topHitArea.className = 'topSelectionHandle-HitArea topLeftSelectionHandle-HitArea';\n    this.selectionHandles.bottom.className = 'bottomSelectionHandle bottomRightSelectionHandle';\n    this.selectionHandles.bottomHitArea.className = 'bottomSelectionHandle-HitArea bottomRightSelectionHandle-HitArea';\n    this.selectionHandles.styles = {\n      top: this.selectionHandles.top.style,\n      topHitArea: this.selectionHandles.topHitArea.style,\n      bottom: this.selectionHandles.bottom.style,\n      bottomHitArea: this.selectionHandles.bottomHitArea.style\n    };\n    const hitAreaStyle = {\n      position: 'absolute',\n      height: `${hitAreaWidth}px`,\n      width: `${hitAreaWidth}px`,\n      'border-radius': `${parseInt(hitAreaWidth / 1.5, 10)}px`\n    };\n    objectEach(hitAreaStyle, (value, key) => {\n      this.selectionHandles.styles.bottomHitArea[key] = value;\n      this.selectionHandles.styles.topHitArea[key] = value;\n    });\n    const handleStyle = {\n      position: 'absolute',\n      height: `${width}px`,\n      width: `${width}px`,\n      'border-radius': `${parseInt(width / 1.5, 10)}px`,\n      background: '#F5F5FF',\n      border: '1px solid #4285c8'\n    };\n    objectEach(handleStyle, (value, key) => {\n      this.selectionHandles.styles.bottom[key] = value;\n      this.selectionHandles.styles.top[key] = value;\n    });\n    this.main.appendChild(this.selectionHandles.top);\n    this.main.appendChild(this.selectionHandles.bottom);\n    this.main.appendChild(this.selectionHandles.topHitArea);\n    this.main.appendChild(this.selectionHandles.bottomHitArea);\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @returns {boolean}\n   */\n  isPartRange(row, col) {\n    const areaSelection = this.wot.selectionManager.getAreaSelection();\n    if (areaSelection.cellRange) {\n      if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number} top The top position of the handler.\n   * @param {number} left The left position of the handler.\n   * @param {number} width The width of the handler.\n   * @param {number} height The height of the handler.\n   */\n  updateMultipleSelectionHandlesPosition(row, col, top, left, width, height) {\n    const isRtl = this.wot.wtSettings.getSetting('rtlMode');\n    const inlinePosProperty = isRtl ? 'right' : 'left';\n    const {\n      top: topStyles,\n      topHitArea: topHitAreaStyles,\n      bottom: bottomStyles,\n      bottomHitArea: bottomHitAreaStyles\n    } = this.selectionHandles.styles;\n    const handleBorderSize = parseInt(topStyles.borderWidth, 10);\n    const handleSize = parseInt(topStyles.width, 10);\n    const hitAreaSize = parseInt(topHitAreaStyles.width, 10);\n    const totalTableWidth = this.wot.wtTable.getWidth();\n    const totalTableHeight = this.wot.wtTable.getHeight();\n    topStyles.top = `${parseInt(top - handleSize - 1, 10)}px`;\n    topStyles[inlinePosProperty] = `${parseInt(left - handleSize - 1, 10)}px`;\n    topHitAreaStyles.top = `${parseInt(top - hitAreaSize / 4 * 3, 10)}px`;\n    topHitAreaStyles[inlinePosProperty] = `${parseInt(left - hitAreaSize / 4 * 3, 10)}px`;\n    const bottomHandlerInline = Math.min(parseInt(left + width, 10), totalTableWidth - handleSize - handleBorderSize * 2);\n    const bottomHandlerAreaInline = Math.min(parseInt(left + width - hitAreaSize / 4, 10), totalTableWidth - hitAreaSize - handleBorderSize * 2);\n    bottomStyles[inlinePosProperty] = `${bottomHandlerInline}px`;\n    bottomHitAreaStyles[inlinePosProperty] = `${bottomHandlerAreaInline}px`;\n    const bottomHandlerTop = Math.min(parseInt(top + height, 10), totalTableHeight - handleSize - handleBorderSize * 2);\n    const bottomHandlerAreaTop = Math.min(parseInt(top + height - hitAreaSize / 4, 10), totalTableHeight - hitAreaSize - handleBorderSize * 2);\n    bottomStyles.top = `${bottomHandlerTop}px`;\n    bottomHitAreaStyles.top = `${bottomHandlerAreaTop}px`;\n    if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {\n      topStyles.display = 'block';\n      topHitAreaStyles.display = 'block';\n      if (this.isPartRange(row, col)) {\n        bottomStyles.display = 'none';\n        bottomHitAreaStyles.display = 'none';\n      } else {\n        bottomStyles.display = 'block';\n        bottomHitAreaStyles.display = 'block';\n      }\n    } else {\n      topStyles.display = 'none';\n      bottomStyles.display = 'none';\n      topHitAreaStyles.display = 'none';\n      bottomHitAreaStyles.display = 'none';\n    }\n    if (row === this.wot.wtSettings.getSetting('fixedRowsTop') || col === this.wot.wtSettings.getSetting('fixedColumnsStart')) {\n      topStyles.zIndex = '9999';\n      topHitAreaStyles.zIndex = '9999';\n    } else {\n      topStyles.zIndex = '';\n      topHitAreaStyles.zIndex = '';\n    }\n  }\n\n  /**\n   * Show border around one or many cells.\n   *\n   * @param {Array} corners The corner coordinates.\n   */\n  appear(corners) {\n    if (this.disabled) {\n      return;\n    }\n    const {\n      wtTable,\n      rootDocument,\n      rootWindow\n    } = this.wot; // todo refactoring: consider about using internal facade (it is given by external code)\n    let fromRow;\n    let toRow;\n    let fromColumn;\n    let toColumn;\n    let rowHeader;\n    let columnHeader;\n    const rowsCount = wtTable.getRenderedRowsCount();\n    for (let i = 0; i < rowsCount; i += 1) {\n      const s = wtTable.rowFilter.renderedToSource(i);\n      if (s >= corners[0] && s <= corners[2]) {\n        fromRow = s;\n        rowHeader = corners[0];\n        break;\n      }\n    }\n    for (let i = rowsCount - 1; i >= 0; i -= 1) {\n      const s = wtTable.rowFilter.renderedToSource(i);\n      if (s >= corners[0] && s <= corners[2]) {\n        toRow = s;\n        break;\n      }\n    }\n    const columnsCount = wtTable.getRenderedColumnsCount();\n    for (let i = 0; i < columnsCount; i += 1) {\n      const s = wtTable.columnFilter.renderedToSource(i);\n      if (s >= corners[1] && s <= corners[3]) {\n        fromColumn = s;\n        columnHeader = corners[1];\n        break;\n      }\n    }\n    for (let i = columnsCount - 1; i >= 0; i -= 1) {\n      const s = wtTable.columnFilter.renderedToSource(i);\n      if (s >= corners[1] && s <= corners[3]) {\n        toColumn = s;\n        break;\n      }\n    }\n    if (fromRow === undefined || fromColumn === undefined) {\n      this.disappear();\n      return;\n    }\n    let fromTD = wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));\n    const isMultiple = fromRow !== toRow || fromColumn !== toColumn;\n    const toTD = isMultiple ? wtTable.getCell(this.wot.createCellCoords(toRow, toColumn)) : fromTD;\n    const fromOffset = offset(fromTD);\n    const toOffset = isMultiple ? offset(toTD) : fromOffset;\n    const containerOffset = offset(wtTable.TABLE);\n    const containerWidth = outerWidth(wtTable.TABLE);\n    const minTop = fromOffset.top;\n    const minLeft = fromOffset.left;\n    const isRtl = this.wot.wtSettings.getSetting('rtlMode');\n    let inlineStartPos = 0;\n    let width = 0;\n    if (isRtl) {\n      const fromWidth = outerWidth(fromTD);\n      const gridRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n      width = minLeft + fromWidth - toOffset.left;\n      inlineStartPos = rootWindow.innerWidth - minLeft - fromWidth - gridRightPos - 1;\n    } else {\n      width = toOffset.left + outerWidth(toTD) - minLeft;\n      inlineStartPos = minLeft - containerOffset.left - 1;\n    }\n    if (this.isEntireColumnSelected(fromRow, toRow)) {\n      const modifiedValues = this.getDimensionsFromHeader('columns', fromColumn, toColumn, rowHeader, containerOffset);\n      let fromTH = null;\n      if (modifiedValues) {\n        [fromTH, inlineStartPos, width] = modifiedValues;\n      }\n      if (fromTH) {\n        fromTD = fromTH;\n      }\n    }\n    let top = minTop - containerOffset.top - 1;\n    let height = toOffset.top + outerHeight(toTD) - minTop;\n    if (this.isEntireRowSelected(fromColumn, toColumn)) {\n      const modifiedValues = this.getDimensionsFromHeader('rows', fromRow, toRow, columnHeader, containerOffset);\n      let fromTH = null;\n      if (modifiedValues) {\n        [fromTH, top, height] = modifiedValues;\n      }\n      if (fromTH) {\n        fromTD = fromTH;\n      }\n    }\n    const style = getComputedStyle(fromTD, rootWindow);\n    if (parseInt(style.borderTopWidth, 10) > 0) {\n      top += 1;\n      height = height > 0 ? height - 1 : 0;\n    }\n    if (parseInt(style[isRtl ? 'borderRightWidth' : 'borderLeftWidth'], 10) > 0) {\n      inlineStartPos += 1;\n      width = width > 0 ? width - 1 : 0;\n    }\n    const inlinePosProperty = isRtl ? 'right' : 'left';\n    this.topStyle.top = `${top}px`;\n    this.topStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    this.topStyle.width = `${width}px`;\n    this.topStyle.display = 'block';\n    this.startStyle.top = `${top}px`;\n    this.startStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    this.startStyle.height = `${height}px`;\n    this.startStyle.display = 'block';\n    const delta = Math.floor(this.settings.border.width / 2);\n    this.bottomStyle.top = `${top + height - delta}px`;\n    this.bottomStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    this.bottomStyle.width = `${width}px`;\n    this.bottomStyle.display = 'block';\n    this.endStyle.top = `${top}px`;\n    this.endStyle[inlinePosProperty] = `${inlineStartPos + width - delta}px`;\n    this.endStyle.height = `${height + 1}px`;\n    this.endStyle.display = 'block';\n    let cornerVisibleSetting = this.settings.border.cornerVisible;\n    cornerVisibleSetting = typeof cornerVisibleSetting === 'function' ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;\n    const hookResult = this.wot.getSetting('onModifyGetCellCoords', toRow, toColumn);\n    let [checkRow, checkCol] = [toRow, toColumn];\n    if (hookResult && Array.isArray(hookResult)) {\n      [,, checkRow, checkCol] = hookResult;\n    }\n    if (isMobileBrowser() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {\n      this.cornerStyle.display = 'none';\n    } else {\n      this.cornerStyle.top = `${top + height + this.cornerCenterPointOffset - 1}px`;\n      this.cornerStyle[inlinePosProperty] = `${inlineStartPos + width + this.cornerCenterPointOffset - 1}px`;\n      this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;\n      this.cornerStyle.width = this.cornerDefaultStyle.width;\n\n      // Hide the fill handle, so the possible further adjustments won't force unneeded scrollbars.\n      this.cornerStyle.display = 'none';\n      let trimmingContainer = getTrimmingContainer(wtTable.TABLE);\n      const trimToWindow = trimmingContainer === rootWindow;\n      if (trimToWindow) {\n        trimmingContainer = rootDocument.documentElement;\n      }\n      const cornerHalfWidth = parseInt(this.cornerDefaultStyle.width, 10) / 2;\n      const cornerHalfHeight = parseInt(this.cornerDefaultStyle.height, 10) / 2;\n      if (toColumn === this.wot.getSetting('totalColumns') - 1) {\n        const toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;\n        let cornerOverlappingContainer = false;\n        let cornerEdge = 0;\n        if (isRtl) {\n          cornerEdge = toTdOffsetLeft - parseInt(this.cornerDefaultStyle.width, 10) / 2;\n          cornerOverlappingContainer = cornerEdge < 0;\n        } else {\n          cornerEdge = toTdOffsetLeft + outerWidth(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;\n          cornerOverlappingContainer = cornerEdge >= innerWidth(trimmingContainer);\n        }\n        if (cornerOverlappingContainer) {\n          this.cornerStyle[inlinePosProperty] = `${Math.floor(inlineStartPos + width + this.cornerCenterPointOffset - cornerHalfWidth)}px`;\n          this.cornerStyle[isRtl ? 'borderLeftWidth' : 'borderRightWidth'] = 0;\n        }\n      }\n      if (toRow === this.wot.getSetting('totalRows') - 1) {\n        const toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;\n        const cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;\n        const cornerOverlappingContainer = cornerBottomEdge >= innerHeight(trimmingContainer);\n        if (cornerOverlappingContainer) {\n          this.cornerStyle.top = `${Math.floor(top + height + this.cornerCenterPointOffset - cornerHalfHeight)}px`;\n          this.cornerStyle.borderBottomWidth = 0;\n        }\n      }\n      this.cornerStyle.display = 'block';\n    }\n    if (isMobileBrowser() && this.instance.getSetting('isDataViewInstance')) {\n      this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top, inlineStartPos, width, height);\n    }\n  }\n\n  /**\n   * Check whether an entire column of cells is selected.\n   *\n   * @private\n   * @param {number} startRowIndex Start row index.\n   * @param {number} endRowIndex End row index.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected(startRowIndex, endRowIndex) {\n    return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();\n  }\n\n  /**\n   * Check whether an entire row of cells is selected.\n   *\n   * @private\n   * @param {number} startColumnIndex Start column index.\n   * @param {number} endColumnIndex End column index.\n   * @returns {boolean}\n   */\n  isEntireRowSelected(startColumnIndex, endColumnIndex) {\n    return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();\n  }\n\n  /**\n   * Get left/top index and width/height depending on the `direction` provided.\n   *\n   * @private\n   * @param {string} direction `rows` or `columns`, defines if an entire column or row is selected.\n   * @param {number} fromIndex Start index of the selection.\n   * @param {number} toIndex End index of the selection.\n   * @param {number} headerIndex The header index as negative value.\n   * @param {number} containerOffset Offset of the container.\n   * @returns {Array|boolean} Returns an array of [headerElement, left, width] or [headerElement, top, height], depending on `direction` (`false` in case of an error getting the headers).\n   */\n  getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, containerOffset) {\n    const {\n      wtTable\n    } = this.wot;\n    const rootHotElement = wtTable.wtRootElement.parentNode;\n    let getHeaderFn = null;\n    let dimensionFn = null;\n    let entireSelectionClassname = null;\n    let index = null;\n    let dimension = null;\n    let dimensionProperty = null;\n    let startHeader = null;\n    let endHeader = null;\n    switch (direction) {\n      case 'rows':\n        getHeaderFn = function () {\n          return wtTable.getRowHeader(...arguments);\n        };\n        dimensionFn = function () {\n          return outerHeight(...arguments);\n        };\n        entireSelectionClassname = 'ht__selection--rows';\n        dimensionProperty = 'top';\n        break;\n      case 'columns':\n        getHeaderFn = function () {\n          return wtTable.getColumnHeader(...arguments);\n        };\n        dimensionFn = function () {\n          return outerWidth(...arguments);\n        };\n        entireSelectionClassname = 'ht__selection--columns';\n        dimensionProperty = 'left';\n        break;\n      default:\n    }\n    if (rootHotElement.classList.contains(entireSelectionClassname)) {\n      const columnHeaderLevelCount = this.wot.getSetting('columnHeaders').length;\n      startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - headerIndex);\n      endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - headerIndex);\n      if (!startHeader || !endHeader) {\n        return false;\n      }\n      const startHeaderOffset = offset(startHeader);\n      const endOffset = offset(endHeader);\n      if (startHeader && endHeader) {\n        index = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;\n        dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];\n      }\n      return [startHeader, index, dimension];\n    }\n    return false;\n  }\n\n  /**\n   * Change border style.\n   *\n   * @private\n   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.\n   * @param {object} border The border object descriptor.\n   */\n  changeBorderStyle(borderElement, border) {\n    const style = this[borderElement].style;\n    const borderStyle = border[borderElement];\n    if (!borderStyle || borderStyle.hide) {\n      addClass(this[borderElement], 'hidden');\n    } else {\n      if (hasClass(this[borderElement], 'hidden')) {\n        removeClass(this[borderElement], 'hidden');\n      }\n      style.backgroundColor = borderStyle.color;\n      if (borderElement === 'top' || borderElement === 'bottom') {\n        style.height = `${borderStyle.width}px`;\n      }\n      if (borderElement === 'start' || borderElement === 'end') {\n        style.width = `${borderStyle.width}px`;\n      }\n    }\n  }\n\n  /**\n   * Change border style to default.\n   *\n   * @private\n   * @param {string} position The position type (\"top\", \"bottom\", \"start\", \"end\") to change.\n   */\n  changeBorderToDefaultStyle(position) {\n    const defaultBorder = {\n      width: 1,\n      color: '#000'\n    };\n    const style = this[position].style;\n    style.backgroundColor = defaultBorder.color;\n    style.width = `${defaultBorder.width}px`;\n    style.height = `${defaultBorder.width}px`;\n  }\n\n  /**\n   * Toggle class 'hidden' to element.\n   *\n   * @private\n   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.\n   * @param {boolean} [remove] Defines type of the action to perform.\n   */\n  toggleHiddenClass(borderElement, remove) {\n    this.changeBorderToDefaultStyle(borderElement);\n    if (remove) {\n      addClass(this[borderElement], 'hidden');\n    } else {\n      removeClass(this[borderElement], 'hidden');\n    }\n  }\n\n  /**\n   * Hide border.\n   */\n  disappear() {\n    this.topStyle.display = 'none';\n    this.bottomStyle.display = 'none';\n    this.startStyle.display = 'none';\n    this.endStyle.display = 'none';\n    this.cornerStyle.display = 'none';\n    if (isMobileBrowser() && this.instance.getSetting('isDataViewInstance')) {\n      this.selectionHandles.styles.top.display = 'none';\n      this.selectionHandles.styles.topHitArea.display = 'none';\n      this.selectionHandles.styles.bottom.display = 'none';\n      this.selectionHandles.styles.bottomHitArea.display = 'none';\n    }\n  }\n\n  /**\n   * Cleans up all the DOM state related to a Border instance. Call this prior to deleting a Border instance.\n   */\n  destroy() {\n    this.eventManager.destroyWithOwnEventsOnly();\n    this.main.parentNode.removeChild(this.main);\n  }\n}\nexport default Border;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}