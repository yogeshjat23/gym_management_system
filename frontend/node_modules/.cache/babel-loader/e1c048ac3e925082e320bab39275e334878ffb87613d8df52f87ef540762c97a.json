{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nvar _cellRange = /*#__PURE__*/new WeakMap();\nclass MergedCellCoords {\n  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", void 0);\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", void 0);\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"rowspan\", void 0);\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"colspan\", void 0);\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"removed\", false);\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellCoordsFactory\", void 0);\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellRangeFactory\", void 0);\n    /**\n     * The cached range coordinates of the merged cell.\n     *\n     * @type {CellRange}\n     */\n    _classPrivateFieldInitSpec(this, _cellRange, null);\n    this.row = row;\n    this.col = column;\n    this.rowspan = rowspan;\n    this.colspan = colspan;\n    this.cellCoordsFactory = cellCoordsFactory;\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static NEGATIVE_VALUES_WARNING(_ref) {\n    let {\n      row,\n      col,\n      rowspan,\n      colspan\n    } = _ref;\n    return toSingleLine`The merged cell declared with {row: ${row}, col: ${col},\\x20\n      rowspan: ${rowspan}, colspan: ${colspan}} contains negative values, which is\\x20\n      not supported. It will not be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OUT_OF_BOUNDS_WARNING(_ref2) {\n    let {\n      row,\n      col\n    } = _ref2;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data represents a single cell.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_SINGLE_CELL(_ref3) {\n    let {\n      row,\n      col\n    } = _ref3;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] has both \"rowspan\"\\x20\n      and \"colspan\" declared as \"1\", which makes it a single cell. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static ZERO_SPAN_WARNING(_ref4) {\n    let {\n      row,\n      col\n    } = _ref4;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] has \"rowspan\"\\x20\n      or \"colspan\" declared as \"0\", which is not supported. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Check whether the values provided for a merged cell contain any negative values.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static containsNegativeValues(_ref5) {\n    let {\n      row,\n      col,\n      rowspan,\n      colspan\n    } = _ref5;\n    return row < 0 || col < 0 || rowspan < 0 || colspan < 0;\n  }\n\n  /**\n   * Check whether the provided merged cell information object represents a single cell.\n   *\n   * @private\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static isSingleCell(_ref6) {\n    let {\n      rowspan,\n      colspan\n    } = _ref6;\n    return colspan === 1 && rowspan === 1;\n  }\n\n  /**\n   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n   *\n   * @private\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static containsZeroSpan(_ref7) {\n    let {\n      rowspan,\n      colspan\n    } = _ref7;\n    return colspan === 0 || rowspan === 0;\n  }\n\n  /**\n   * Check whether the provided merged cell object is to be declared out of bounds of the table.\n   *\n   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @param {number} rowCount Number of rows in the table.\n   * @param {number} columnCount Number of rows in the table.\n   * @returns {boolean}\n   */\n  static isOutOfBounds(mergeCell, rowCount, columnCount) {\n    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n  }\n\n  /**\n   * Sanitize (prevent from going outside the boundaries) the merged cell.\n   *\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  normalize(hotInstance) {\n    const totalRows = hotInstance.countRows();\n    const totalColumns = hotInstance.countCols();\n    if (this.row < 0) {\n      this.row = 0;\n    } else if (this.row > totalRows - 1) {\n      this.row = totalRows - 1;\n    }\n    if (this.col < 0) {\n      this.col = 0;\n    } else if (this.col > totalColumns - 1) {\n      this.col = totalColumns - 1;\n    }\n    if (this.row + this.rowspan > totalRows - 1) {\n      this.rowspan = totalRows - this.row;\n    }\n    if (this.col + this.colspan > totalColumns - 1) {\n      this.colspan = totalColumns - this.col;\n    }\n    _classPrivateFieldSet(_cellRange, this, null);\n  }\n\n  /**\n   * Returns `true` if the provided coordinates are inside the merged cell.\n   *\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includes(row, column) {\n    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `column` property is within the column span of the merged cell.\n   *\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includesHorizontally(column) {\n    return this.col <= column && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `row` property is within the row span of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @returns {boolean}\n   */\n  includesVertically(row) {\n    return this.row <= row && this.row + this.rowspan - 1 >= row;\n  }\n\n  /**\n   * Shift (and possibly resize, if needed) the merged cell.\n   *\n   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n   * @param {number} indexOfChange Index of the preceding change.\n   * @returns {boolean} Returns `false` if the whole merged cell was removed.\n   */\n  shift(shiftVector, indexOfChange) {\n    const shiftValue = shiftVector[0] || shiftVector[1];\n    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n    const span = shiftVector[0] ? 'colspan' : 'rowspan';\n    const index = shiftVector[0] ? 'col' : 'row';\n    const changeStart = Math.min(indexOfChange, shiftedIndex);\n    const changeEnd = Math.max(indexOfChange, shiftedIndex);\n    const mergeStart = this[index];\n    const mergeEnd = this[index] + this[span] - 1;\n    if (mergeStart >= indexOfChange) {\n      this[index] += shiftValue;\n    }\n\n    // adding rows/columns\n    if (shiftValue > 0) {\n      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n        this[span] += shiftValue;\n      }\n\n      // removing rows/columns\n    } else if (shiftValue < 0) {\n      // removing the whole merge\n      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n        this.removed = true;\n        _classPrivateFieldSet(_cellRange, this, null);\n        return false;\n\n        // removing the merge partially, including the beginning\n      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n        const removedOffset = changeEnd - mergeStart + 1;\n        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n        this[index] -= preRemovedOffset + shiftValue;\n        this[span] -= removedOffset;\n\n        // removing the middle part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n        this[span] += shiftValue;\n\n        // removing the end part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n        const removedPart = mergeEnd - changeStart + 1;\n        this[span] -= removedPart;\n      }\n    }\n    _classPrivateFieldSet(_cellRange, this, null);\n    return true;\n  }\n\n  /**\n   * Check if the second provided merged cell is \"farther\" in the provided direction.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check.\n   * @param {string} direction Drag direction.\n   * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n   */\n  isFarther(mergedCell, direction) {\n    if (!mergedCell) {\n      return true;\n    }\n    if (direction === 'down') {\n      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n    } else if (direction === 'up') {\n      return mergedCell.row > this.row;\n    } else if (direction === 'right') {\n      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n    } else if (direction === 'left') {\n      return mergedCell.col > this.col;\n    }\n    return null;\n  }\n\n  /**\n   * Get the bottom row index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastRow() {\n    return this.row + this.rowspan - 1;\n  }\n\n  /**\n   * Get the rightmost column index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastColumn() {\n    return this.col + this.colspan - 1;\n  }\n\n  /**\n   * Get the range coordinates of the merged cell.\n   *\n   * @returns {CellRange}\n   */\n  getRange() {\n    if (!_classPrivateFieldGet(_cellRange, this)) {\n      _classPrivateFieldSet(_cellRange, this, this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn())));\n    }\n    return _classPrivateFieldGet(_cellRange, this);\n  }\n}\nexport default MergedCellCoords;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","n","arguments","length","toSingleLine","_cellRange","WeakMap","MergedCellCoords","constructor","row","column","rowspan","colspan","cellCoordsFactory","cellRangeFactory","col","NEGATIVE_VALUES_WARNING","_ref","IS_OUT_OF_BOUNDS_WARNING","_ref2","IS_SINGLE_CELL","_ref3","ZERO_SPAN_WARNING","_ref4","containsNegativeValues","_ref5","isSingleCell","_ref6","containsZeroSpan","_ref7","isOutOfBounds","mergeCell","rowCount","columnCount","normalize","hotInstance","totalRows","countRows","totalColumns","countCols","includes","includesHorizontally","includesVertically","shift","shiftVector","indexOfChange","shiftValue","shiftedIndex","Math","abs","span","index","changeStart","min","changeEnd","max","mergeStart","mergeEnd","removed","removedOffset","preRemovedOffset","removedPart","isFarther","mergedCell","direction","getLastRow","getLastColumn","getRange"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/mergeCells/cellCoords.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nvar _cellRange = /*#__PURE__*/new WeakMap();\nclass MergedCellCoords {\n  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", void 0);\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", void 0);\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"rowspan\", void 0);\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"colspan\", void 0);\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"removed\", false);\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellCoordsFactory\", void 0);\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellRangeFactory\", void 0);\n    /**\n     * The cached range coordinates of the merged cell.\n     *\n     * @type {CellRange}\n     */\n    _classPrivateFieldInitSpec(this, _cellRange, null);\n    this.row = row;\n    this.col = column;\n    this.rowspan = rowspan;\n    this.colspan = colspan;\n    this.cellCoordsFactory = cellCoordsFactory;\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static NEGATIVE_VALUES_WARNING(_ref) {\n    let {\n      row,\n      col,\n      rowspan,\n      colspan\n    } = _ref;\n    return toSingleLine`The merged cell declared with {row: ${row}, col: ${col},\\x20\n      rowspan: ${rowspan}, colspan: ${colspan}} contains negative values, which is\\x20\n      not supported. It will not be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OUT_OF_BOUNDS_WARNING(_ref2) {\n    let {\n      row,\n      col\n    } = _ref2;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data represents a single cell.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_SINGLE_CELL(_ref3) {\n    let {\n      row,\n      col\n    } = _ref3;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] has both \"rowspan\"\\x20\n      and \"colspan\" declared as \"1\", which makes it a single cell. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static ZERO_SPAN_WARNING(_ref4) {\n    let {\n      row,\n      col\n    } = _ref4;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] has \"rowspan\"\\x20\n      or \"colspan\" declared as \"0\", which is not supported. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Check whether the values provided for a merged cell contain any negative values.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static containsNegativeValues(_ref5) {\n    let {\n      row,\n      col,\n      rowspan,\n      colspan\n    } = _ref5;\n    return row < 0 || col < 0 || rowspan < 0 || colspan < 0;\n  }\n\n  /**\n   * Check whether the provided merged cell information object represents a single cell.\n   *\n   * @private\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static isSingleCell(_ref6) {\n    let {\n      rowspan,\n      colspan\n    } = _ref6;\n    return colspan === 1 && rowspan === 1;\n  }\n\n  /**\n   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n   *\n   * @private\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static containsZeroSpan(_ref7) {\n    let {\n      rowspan,\n      colspan\n    } = _ref7;\n    return colspan === 0 || rowspan === 0;\n  }\n\n  /**\n   * Check whether the provided merged cell object is to be declared out of bounds of the table.\n   *\n   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @param {number} rowCount Number of rows in the table.\n   * @param {number} columnCount Number of rows in the table.\n   * @returns {boolean}\n   */\n  static isOutOfBounds(mergeCell, rowCount, columnCount) {\n    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n  }\n\n  /**\n   * Sanitize (prevent from going outside the boundaries) the merged cell.\n   *\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  normalize(hotInstance) {\n    const totalRows = hotInstance.countRows();\n    const totalColumns = hotInstance.countCols();\n    if (this.row < 0) {\n      this.row = 0;\n    } else if (this.row > totalRows - 1) {\n      this.row = totalRows - 1;\n    }\n    if (this.col < 0) {\n      this.col = 0;\n    } else if (this.col > totalColumns - 1) {\n      this.col = totalColumns - 1;\n    }\n    if (this.row + this.rowspan > totalRows - 1) {\n      this.rowspan = totalRows - this.row;\n    }\n    if (this.col + this.colspan > totalColumns - 1) {\n      this.colspan = totalColumns - this.col;\n    }\n    _classPrivateFieldSet(_cellRange, this, null);\n  }\n\n  /**\n   * Returns `true` if the provided coordinates are inside the merged cell.\n   *\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includes(row, column) {\n    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `column` property is within the column span of the merged cell.\n   *\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includesHorizontally(column) {\n    return this.col <= column && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `row` property is within the row span of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @returns {boolean}\n   */\n  includesVertically(row) {\n    return this.row <= row && this.row + this.rowspan - 1 >= row;\n  }\n\n  /**\n   * Shift (and possibly resize, if needed) the merged cell.\n   *\n   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n   * @param {number} indexOfChange Index of the preceding change.\n   * @returns {boolean} Returns `false` if the whole merged cell was removed.\n   */\n  shift(shiftVector, indexOfChange) {\n    const shiftValue = shiftVector[0] || shiftVector[1];\n    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n    const span = shiftVector[0] ? 'colspan' : 'rowspan';\n    const index = shiftVector[0] ? 'col' : 'row';\n    const changeStart = Math.min(indexOfChange, shiftedIndex);\n    const changeEnd = Math.max(indexOfChange, shiftedIndex);\n    const mergeStart = this[index];\n    const mergeEnd = this[index] + this[span] - 1;\n    if (mergeStart >= indexOfChange) {\n      this[index] += shiftValue;\n    }\n\n    // adding rows/columns\n    if (shiftValue > 0) {\n      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n        this[span] += shiftValue;\n      }\n\n      // removing rows/columns\n    } else if (shiftValue < 0) {\n      // removing the whole merge\n      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n        this.removed = true;\n        _classPrivateFieldSet(_cellRange, this, null);\n        return false;\n\n        // removing the merge partially, including the beginning\n      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n        const removedOffset = changeEnd - mergeStart + 1;\n        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n        this[index] -= preRemovedOffset + shiftValue;\n        this[span] -= removedOffset;\n\n        // removing the middle part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n        this[span] += shiftValue;\n\n        // removing the end part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n        const removedPart = mergeEnd - changeStart + 1;\n        this[span] -= removedPart;\n      }\n    }\n    _classPrivateFieldSet(_cellRange, this, null);\n    return true;\n  }\n\n  /**\n   * Check if the second provided merged cell is \"farther\" in the provided direction.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check.\n   * @param {string} direction Drag direction.\n   * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n   */\n  isFarther(mergedCell, direction) {\n    if (!mergedCell) {\n      return true;\n    }\n    if (direction === 'down') {\n      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n    } else if (direction === 'up') {\n      return mergedCell.row > this.row;\n    } else if (direction === 'right') {\n      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n    } else if (direction === 'left') {\n      return mergedCell.col > this.col;\n    }\n    return null;\n  }\n\n  /**\n   * Get the bottom row index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastRow() {\n    return this.row + this.rowspan - 1;\n  }\n\n  /**\n   * Get the rightmost column index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastColumn() {\n    return this.col + this.colspan - 1;\n  }\n\n  /**\n   * Get the range coordinates of the merged cell.\n   *\n   * @returns {CellRange}\n   */\n  getRange() {\n    if (!_classPrivateFieldGet(_cellRange, this)) {\n      _classPrivateFieldSet(_cellRange, this, this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn())));\n    }\n    return _classPrivateFieldGet(_cellRange, this);\n  }\n}\nexport default MergedCellCoords;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}