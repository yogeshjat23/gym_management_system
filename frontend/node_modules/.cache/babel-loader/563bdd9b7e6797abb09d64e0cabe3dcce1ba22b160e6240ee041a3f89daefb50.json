{"ast":null,"code":"import { addClass, getScrollbarWidth, getScrollLeft, getMaximumScrollLeft, getWindowScrollTop, hasClass, outerWidth, removeClass, setOverlayPosition, resetCssTransform } from \"../../../../helpers/dom/element.mjs\";\nimport InlineStartOverlayTable from \"../table/inlineStart.mjs\";\nimport { Overlay } from \"./_base.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"../selection/index.mjs\";\nimport { CLONE_INLINE_START } from \"./constants.mjs\";\n/**\n * @class InlineStartOverlay\n */\nexport class InlineStartOverlay extends Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);\n  }\n\n  /**\n   * Factory method to create a subclass of `Table` that is relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.\n   * @returns {InlineStartOverlayTable}\n   */\n  createTable() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new InlineStartOverlayTable(...args);\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');\n  }\n\n  /**\n   * Updates the left overlay position.\n   *\n   * @returns {boolean}\n   */\n  resetFixedPosition() {\n    const {\n      wtTable\n    } = this.wot;\n    if (!this.needFullRender || !this.shouldBeRendered() || !wtTable.holder.parentNode) {\n      // removed from DOM\n      return false;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayPosition = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n      setOverlayPosition(overlayRoot, `${overlayPosition}px`, '0px');\n    } else {\n      overlayPosition = this.getScrollPosition();\n      resetCssTransform(overlayRoot);\n    }\n    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n    this.adjustElementsSize();\n    return positionChanged;\n  }\n\n  /**\n   * Sets the main overlay's horizontal scroll position.\n   *\n   * @param {number} pos The scroll position.\n   * @returns {boolean}\n   */\n  setScrollPosition(pos) {\n    const {\n      rootWindow\n    } = this.domBindings;\n    let result = false;\n    if (this.isRtl()) {\n      pos = -pos;\n    }\n    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {\n      rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));\n      result = true;\n    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {\n      this.mainTableScrollableElement.scrollLeft = pos;\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Triggers onScroll hook callback.\n   */\n  onScroll() {\n    this.wtSettings.getSetting('onScrollVertically');\n  }\n\n  /**\n   * Calculates total sum cells width.\n   *\n   * @param {number} from Column index which calculates started from.\n   * @param {number} to Column index where calculation is finished.\n   * @returns {number} Width sum.\n   */\n  sumCellSizes(from, to) {\n    const defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    let column = from;\n    let sum = 0;\n    while (column < to) {\n      sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * Adjust overlay root element, children and master table element sizes (width, height).\n   */\n  adjustElementsSize() {\n    this.updateTrimmingContainer();\n    if (this.needFullRender) {\n      this.adjustRootElementSize();\n      this.adjustRootChildrenSize();\n    }\n  }\n\n  /**\n   * Adjust overlay root element size (width and height).\n   */\n  adjustRootElementSize() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const scrollbarHeight = getScrollbarWidth(rootDocument);\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = overlayRoot.style;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {\n      let height = this.wot.wtViewport.getWorkspaceHeight();\n      if (this.wot.wtOverlays.hasScrollbarBottom) {\n        height -= scrollbarHeight;\n      }\n      height = Math.min(height, wtTable.wtRootElement.scrollHeight);\n      overlayRootStyle.height = `${height}px`;\n    } else {\n      overlayRootStyle.height = '';\n    }\n    this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n    const tableWidth = outerWidth(this.clone.wtTable.TABLE);\n    overlayRootStyle.width = `${tableWidth}px`;\n  }\n\n  /**\n   * Adjust overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    const {\n      holder\n    } = this.clone.wtTable;\n    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(CORNER_DEFAULT_STYLE.width, 10) / 2 : 0;\n    this.clone.wtTable.hider.style.height = this.hider.style.height;\n    holder.style.height = holder.parentNode.style.height;\n    // Add selection corner protruding part to the holder total width to make sure that\n    // borders' corner won't be cut after horizontal scroll (#6937).\n    holder.style.width = `${parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset}px`;\n  }\n\n  /**\n   * Adjust the overlay dimensions and position.\n   */\n  applyToDOM() {\n    const total = this.wtSettings.getSetting('totalColumns');\n    const styleProperty = this.isRtl() ? 'right' : 'left';\n    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {\n      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else if (total === 0) {\n      this.spreader.style[styleProperty] = '0';\n    } else {\n      throw new Error('Incorrect value of the columnsRenderCalculator');\n    }\n    if (this.isRtl()) {\n      this.spreader.style.left = '';\n    } else {\n      this.spreader.style.right = '';\n    }\n    if (this.needFullRender) {\n      this.syncOverlayOffset();\n    }\n  }\n\n  /**\n   * Synchronize calculated top position to an element.\n   */\n  syncOverlayOffset() {\n    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else {\n      this.clone.wtTable.spreader.style.top = '';\n    }\n  }\n\n  /**\n   * Scrolls horizontally to a column at the left edge of the viewport.\n   *\n   * @param {number} sourceCol  Column index which you want to scroll to.\n   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right\n   *                                    edge (left edge is by default).\n   * @returns {boolean}\n   */\n  scrollTo(sourceCol, beyondRendered) {\n    const {\n      wtSettings\n    } = this;\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n    const mainHolder = sourceInstance.wtTable.holder;\n    const rowHeaderBorderCompensation = fixedColumnsStart === 0 && rowHeaders.length > 0 && !hasClass(mainHolder.parentNode, 'innerBorderInlineStart') ? 1 : 0;\n    let newX = this.getTableParentOffset();\n    let scrollbarCompensation = 0;\n    if (beyondRendered) {\n      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n      const viewportWidth = this.wot.wtViewport.getViewportWidth();\n      if (columnWidth > viewportWidth) {\n        beyondRendered = false;\n      }\n    }\n    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if (beyondRendered) {\n      newX += this.sumCellSizes(0, sourceCol + 1);\n      newX -= this.wot.wtViewport.getViewportWidth();\n      // Compensate for the right header border if scrolled from the absolute left.\n      newX += rowHeaderBorderCompensation;\n    } else {\n      newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);\n    }\n    newX += scrollbarCompensation;\n\n    // If the table is scrolled all the way left when starting the scroll and going to be scrolled to the far right,\n    // we need to compensate for the potential header border width.\n    if (getMaximumScrollLeft(this.mainTableScrollableElement) === newX - rowHeaderBorderCompensation && rowHeaderBorderCompensation > 0) {\n      this.wot.wtOverlays.expandHiderHorizontallyBy(rowHeaderBorderCompensation);\n    }\n    return this.setScrollPosition(newX);\n  }\n\n  /**\n   * Gets table parent left position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let offset = 0;\n    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {\n      offset = this.wot.wtTable.holderOffset.left;\n    }\n    return offset;\n  }\n\n  /**\n   * Gets the main overlay's horizontal scroll position.\n   *\n   * @returns {number} Main table's horizontal scroll position.\n   */\n  getScrollPosition() {\n    return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));\n  }\n\n  /**\n   * Gets the main overlay's horizontal overlay offset.\n   *\n   * @returns {number} Main table's horizontal overlay offset.\n   */\n  getOverlayOffset() {\n    const {\n      rootWindow\n    } = this.domBindings;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayOffset = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      if (this.isRtl()) {\n        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));\n      } else {\n        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n      }\n      const rootWidth = this.wot.wtTable.getTotalWidth();\n      const overlayRootWidth = this.clone.wtTable.getTotalWidth();\n      const maxOffset = rootWidth - overlayRootWidth;\n      if (overlayOffset > maxOffset) {\n        overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n\n  /**\n   * Adds css classes to hide the header border's header (cell-selection border hiding issue).\n   *\n   * @param {number} position Header X position if trimming container is window or scroll top if not.\n   * @returns {boolean}\n   */\n  adjustHeaderBordersPosition(position) {\n    const {\n      wtSettings\n    } = this;\n    const masterParent = this.wot.wtTable.holder.parentNode;\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    const totalRows = wtSettings.getSetting('totalRows');\n    const preventVerticalOverflow = wtSettings.getSetting('preventOverflow') === 'vertical';\n    if (totalRows) {\n      removeClass(masterParent, 'emptyRows');\n    } else {\n      addClass(masterParent, 'emptyRows');\n    }\n    let positionChanged = false;\n    if (!preventVerticalOverflow) {\n      if (fixedColumnsStart && !rowHeaders.length) {\n        // \"innerBorderLeft\" is for backward compatibility\n        addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n      } else if (!fixedColumnsStart && rowHeaders.length) {\n        const previousState = hasClass(masterParent, 'innerBorderInlineStart');\n        if (position) {\n          addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n          positionChanged = !previousState;\n        } else {\n          removeClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n          positionChanged = previousState;\n        }\n      }\n    }\n    return positionChanged;\n  }\n}","map":{"version":3,"names":["addClass","getScrollbarWidth","getScrollLeft","getMaximumScrollLeft","getWindowScrollTop","hasClass","outerWidth","removeClass","setOverlayPosition","resetCssTransform","InlineStartOverlayTable","Overlay","CORNER_DEFAULT_STYLE","CLONE_INLINE_START","InlineStartOverlay","constructor","wotInstance","facadeGetter","wtSettings","domBindings","createTable","_len","arguments","length","args","Array","_key","shouldBeRendered","getSetting","resetFixedPosition","wtTable","wot","needFullRender","holder","parentNode","rootWindow","overlayRoot","clone","preventOverflow","overlayPosition","trimmingContainer","getOverlayOffset","isRtl","getScrollPosition","positionChanged","adjustHeaderBordersPosition","adjustElementsSize","setScrollPosition","pos","result","mainTableScrollableElement","scrollX","scrollTo","scrollLeft","onScroll","sumCellSizes","from","to","defaultColumnWidth","column","sum","getStretchedColumnWidth","updateTrimmingContainer","adjustRootElementSize","adjustRootChildrenSize","rootDocument","scrollbarHeight","overlayRootStyle","style","height","wtViewport","getWorkspaceHeight","wtOverlays","hasScrollbarBottom","Math","min","wtRootElement","scrollHeight","tableWidth","TABLE","width","selectionCornerOffset","selectionManager","getFocusSelection","parseInt","hider","applyToDOM","total","styleProperty","columnsRenderCalculator","startPosition","spreader","Error","left","right","syncOverlayOffset","rowsRenderCalculator","top","sourceCol","beyondRendered","rowHeaders","fixedColumnsStart","sourceInstance","cloneSource","mainHolder","rowHeaderBorderCompensation","newX","getTableParentOffset","scrollbarCompensation","columnWidth","getColumnWidth","viewportWidth","getViewportWidth","offsetWidth","clientWidth","expandHiderHorizontallyBy","offset","holderOffset","abs","overlayOffset","max","rootWidth","getTotalWidth","overlayRootWidth","maxOffset","position","masterParent","totalRows","preventVerticalOverflow","previousState"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/overlay/inlineStart.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport { addClass, getScrollbarWidth, getScrollLeft, getMaximumScrollLeft, getWindowScrollTop, hasClass, outerWidth, removeClass, setOverlayPosition, resetCssTransform } from \"../../../../helpers/dom/element.mjs\";\nimport InlineStartOverlayTable from \"../table/inlineStart.mjs\";\nimport { Overlay } from \"./_base.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"../selection/index.mjs\";\nimport { CLONE_INLINE_START } from \"./constants.mjs\";\n/**\n * @class InlineStartOverlay\n */\nexport class InlineStartOverlay extends Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);\n  }\n\n  /**\n   * Factory method to create a subclass of `Table` that is relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.\n   * @returns {InlineStartOverlayTable}\n   */\n  createTable() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new InlineStartOverlayTable(...args);\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');\n  }\n\n  /**\n   * Updates the left overlay position.\n   *\n   * @returns {boolean}\n   */\n  resetFixedPosition() {\n    const {\n      wtTable\n    } = this.wot;\n    if (!this.needFullRender || !this.shouldBeRendered() || !wtTable.holder.parentNode) {\n      // removed from DOM\n      return false;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayPosition = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n      setOverlayPosition(overlayRoot, `${overlayPosition}px`, '0px');\n    } else {\n      overlayPosition = this.getScrollPosition();\n      resetCssTransform(overlayRoot);\n    }\n    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n    this.adjustElementsSize();\n    return positionChanged;\n  }\n\n  /**\n   * Sets the main overlay's horizontal scroll position.\n   *\n   * @param {number} pos The scroll position.\n   * @returns {boolean}\n   */\n  setScrollPosition(pos) {\n    const {\n      rootWindow\n    } = this.domBindings;\n    let result = false;\n    if (this.isRtl()) {\n      pos = -pos;\n    }\n    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {\n      rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));\n      result = true;\n    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {\n      this.mainTableScrollableElement.scrollLeft = pos;\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Triggers onScroll hook callback.\n   */\n  onScroll() {\n    this.wtSettings.getSetting('onScrollVertically');\n  }\n\n  /**\n   * Calculates total sum cells width.\n   *\n   * @param {number} from Column index which calculates started from.\n   * @param {number} to Column index where calculation is finished.\n   * @returns {number} Width sum.\n   */\n  sumCellSizes(from, to) {\n    const defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    let column = from;\n    let sum = 0;\n    while (column < to) {\n      sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * Adjust overlay root element, children and master table element sizes (width, height).\n   */\n  adjustElementsSize() {\n    this.updateTrimmingContainer();\n    if (this.needFullRender) {\n      this.adjustRootElementSize();\n      this.adjustRootChildrenSize();\n    }\n  }\n\n  /**\n   * Adjust overlay root element size (width and height).\n   */\n  adjustRootElementSize() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const scrollbarHeight = getScrollbarWidth(rootDocument);\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = overlayRoot.style;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {\n      let height = this.wot.wtViewport.getWorkspaceHeight();\n      if (this.wot.wtOverlays.hasScrollbarBottom) {\n        height -= scrollbarHeight;\n      }\n      height = Math.min(height, wtTable.wtRootElement.scrollHeight);\n      overlayRootStyle.height = `${height}px`;\n    } else {\n      overlayRootStyle.height = '';\n    }\n    this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n    const tableWidth = outerWidth(this.clone.wtTable.TABLE);\n    overlayRootStyle.width = `${tableWidth}px`;\n  }\n\n  /**\n   * Adjust overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    const {\n      holder\n    } = this.clone.wtTable;\n    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(CORNER_DEFAULT_STYLE.width, 10) / 2 : 0;\n    this.clone.wtTable.hider.style.height = this.hider.style.height;\n    holder.style.height = holder.parentNode.style.height;\n    // Add selection corner protruding part to the holder total width to make sure that\n    // borders' corner won't be cut after horizontal scroll (#6937).\n    holder.style.width = `${parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset}px`;\n  }\n\n  /**\n   * Adjust the overlay dimensions and position.\n   */\n  applyToDOM() {\n    const total = this.wtSettings.getSetting('totalColumns');\n    const styleProperty = this.isRtl() ? 'right' : 'left';\n    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {\n      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else if (total === 0) {\n      this.spreader.style[styleProperty] = '0';\n    } else {\n      throw new Error('Incorrect value of the columnsRenderCalculator');\n    }\n    if (this.isRtl()) {\n      this.spreader.style.left = '';\n    } else {\n      this.spreader.style.right = '';\n    }\n    if (this.needFullRender) {\n      this.syncOverlayOffset();\n    }\n  }\n\n  /**\n   * Synchronize calculated top position to an element.\n   */\n  syncOverlayOffset() {\n    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else {\n      this.clone.wtTable.spreader.style.top = '';\n    }\n  }\n\n  /**\n   * Scrolls horizontally to a column at the left edge of the viewport.\n   *\n   * @param {number} sourceCol  Column index which you want to scroll to.\n   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right\n   *                                    edge (left edge is by default).\n   * @returns {boolean}\n   */\n  scrollTo(sourceCol, beyondRendered) {\n    const {\n      wtSettings\n    } = this;\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n    const mainHolder = sourceInstance.wtTable.holder;\n    const rowHeaderBorderCompensation = fixedColumnsStart === 0 && rowHeaders.length > 0 && !hasClass(mainHolder.parentNode, 'innerBorderInlineStart') ? 1 : 0;\n    let newX = this.getTableParentOffset();\n    let scrollbarCompensation = 0;\n    if (beyondRendered) {\n      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n      const viewportWidth = this.wot.wtViewport.getViewportWidth();\n      if (columnWidth > viewportWidth) {\n        beyondRendered = false;\n      }\n    }\n    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if (beyondRendered) {\n      newX += this.sumCellSizes(0, sourceCol + 1);\n      newX -= this.wot.wtViewport.getViewportWidth();\n      // Compensate for the right header border if scrolled from the absolute left.\n      newX += rowHeaderBorderCompensation;\n    } else {\n      newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);\n    }\n    newX += scrollbarCompensation;\n\n    // If the table is scrolled all the way left when starting the scroll and going to be scrolled to the far right,\n    // we need to compensate for the potential header border width.\n    if (getMaximumScrollLeft(this.mainTableScrollableElement) === newX - rowHeaderBorderCompensation && rowHeaderBorderCompensation > 0) {\n      this.wot.wtOverlays.expandHiderHorizontallyBy(rowHeaderBorderCompensation);\n    }\n    return this.setScrollPosition(newX);\n  }\n\n  /**\n   * Gets table parent left position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let offset = 0;\n    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {\n      offset = this.wot.wtTable.holderOffset.left;\n    }\n    return offset;\n  }\n\n  /**\n   * Gets the main overlay's horizontal scroll position.\n   *\n   * @returns {number} Main table's horizontal scroll position.\n   */\n  getScrollPosition() {\n    return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));\n  }\n\n  /**\n   * Gets the main overlay's horizontal overlay offset.\n   *\n   * @returns {number} Main table's horizontal overlay offset.\n   */\n  getOverlayOffset() {\n    const {\n      rootWindow\n    } = this.domBindings;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayOffset = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      if (this.isRtl()) {\n        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));\n      } else {\n        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n      }\n      const rootWidth = this.wot.wtTable.getTotalWidth();\n      const overlayRootWidth = this.clone.wtTable.getTotalWidth();\n      const maxOffset = rootWidth - overlayRootWidth;\n      if (overlayOffset > maxOffset) {\n        overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n\n  /**\n   * Adds css classes to hide the header border's header (cell-selection border hiding issue).\n   *\n   * @param {number} position Header X position if trimming container is window or scroll top if not.\n   * @returns {boolean}\n   */\n  adjustHeaderBordersPosition(position) {\n    const {\n      wtSettings\n    } = this;\n    const masterParent = this.wot.wtTable.holder.parentNode;\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    const totalRows = wtSettings.getSetting('totalRows');\n    const preventVerticalOverflow = wtSettings.getSetting('preventOverflow') === 'vertical';\n    if (totalRows) {\n      removeClass(masterParent, 'emptyRows');\n    } else {\n      addClass(masterParent, 'emptyRows');\n    }\n    let positionChanged = false;\n    if (!preventVerticalOverflow) {\n      if (fixedColumnsStart && !rowHeaders.length) {\n        // \"innerBorderLeft\" is for backward compatibility\n        addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n      } else if (!fixedColumnsStart && rowHeaders.length) {\n        const previousState = hasClass(masterParent, 'innerBorderInlineStart');\n        if (position) {\n          addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n          positionChanged = !previousState;\n        } else {\n          removeClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n          positionChanged = previousState;\n        }\n      }\n    }\n    return positionChanged;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}