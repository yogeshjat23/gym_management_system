{"ast":null,"code":"/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * Checks if the passed value is numeric one. For example these values (passed as string or number)\n * are considered as numeric values:\n *  - 0.001\n *  - .001\n *  - 10000\n *  - 1e+26\n *  - 22e-26\n *  - .45e+26\n *  - 0xabcdef (hex)\n *  - 0x1 (hex)\n *\n * these values are not considered as numeric:\n *  - - 1000\n *  - 100 000\n *\n * @param {*} value The value to check.\n * @param {string[]} additionalDelimiters An additional delimiters to be used while checking the numeric value.\n * @returns {boolean}\n */\nexport function isNumeric(value) {\n  let additionalDelimiters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const type = typeof value;\n  if (type === 'number') {\n    return !isNaN(value) && isFinite(value);\n  } else if (type === 'string') {\n    if (value.length === 0) {\n      return false;\n    } else if (value.length === 1) {\n      return /\\d/.test(value);\n    }\n    const delimiter = Array.from(new Set(['.', ...additionalDelimiters])).map(d => `\\\\${d}`).join('|');\n    return new RegExp(`^[+-]?(((${delimiter})?\\\\d+((${delimiter})\\\\d+)?(e[+-]?\\\\d+)?)|(0x[a-f\\\\d]+))$`, 'i').test(value.trim());\n  } else if (type === 'object') {\n    return !!value && typeof value.valueOf() === 'number' && !(value instanceof Date);\n  }\n  return false;\n}\n/* eslint-enable jsdoc/require-description-complete-sentence */\n\n/**\n * Checks if the passed value is numeric-like value. The helper returns `true` for the same\n * values as for the `isNumeric` function plus `true` for numbers delimited by comma.\n *\n * @param {*} value The value to check.\n * @returns {boolean}\n */\nexport function isNumericLike(value) {\n  return isNumeric(value, [',']);\n}\n\n/**\n * A specialized version of `.forEach` defined by ranges.\n *\n * @param {number} rangeFrom The number from start iterate.\n * @param {number|Function} rangeTo The number where finish iterate or function as a iteratee.\n * @param {Function} [iteratee] The function invoked per iteration.\n */\nexport function rangeEach(rangeFrom, rangeTo, iteratee) {\n  let index = -1;\n  if (typeof rangeTo === 'function') {\n    iteratee = rangeTo;\n    rangeTo = rangeFrom;\n  } else {\n    index = rangeFrom - 1;\n  }\n\n  /* eslint-disable-next-line no-plusplus */\n  while (++index <= rangeTo) {\n    if (iteratee(index) === false) {\n      break;\n    }\n  }\n}\n\n/**\n * A specialized version of `.forEach` defined by ranges iterable in reverse order.\n *\n * @param {number} rangeFrom The number from start iterate.\n * @param {number|Function} rangeTo The number where finish iterate or function as a iteratee.\n * @param {Function} [iteratee] The function invoked per iteration.\n */\nexport function rangeEachReverse(rangeFrom, rangeTo, iteratee) {\n  let index = rangeFrom + 1;\n  if (typeof rangeTo === 'function') {\n    iteratee = rangeTo;\n    rangeTo = 0;\n  }\n  /* eslint-disable-next-line no-plusplus */\n  while (--index >= rangeTo) {\n    if (iteratee(index) === false) {\n      break;\n    }\n  }\n}\n\n/**\n * Calculate value from percent.\n *\n * @param {number} value Base value from percent will be calculated.\n * @param {string|number} percent Can be number or string (eq. `'33%'`).\n * @returns {number}\n */\nexport function valueAccordingPercent(value, percent) {\n  percent = parseInt(percent.toString().replace('%', ''), 10);\n  percent = isNaN(percent) ? 0 : percent;\n  return parseInt(value * percent / 100, 10);\n}\n\n/**\n * Clamps the value between min and max.\n *\n * @param {number} value The base number value.\n * @param {number} minValue The max number value.\n * @param {number} maxValue The min number value.\n * @returns {number}\n */\nexport function clamp(value, minValue, maxValue) {\n  if (Math.min(value, minValue) === value) {\n    return minValue;\n  } else if (Math.max(value, maxValue) === value) {\n    return maxValue;\n  }\n  return value;\n}","map":{"version":3,"names":["isNumeric","value","additionalDelimiters","arguments","length","undefined","type","isNaN","isFinite","test","delimiter","Array","from","Set","map","d","join","RegExp","trim","valueOf","Date","isNumericLike","rangeEach","rangeFrom","rangeTo","iteratee","index","rangeEachReverse","valueAccordingPercent","percent","parseInt","toString","replace","clamp","minValue","maxValue","Math","min","max"],"sources":["D:/gym-project/frontend/node_modules/handsontable/helpers/number.mjs"],"sourcesContent":["import \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * Checks if the passed value is numeric one. For example these values (passed as string or number)\n * are considered as numeric values:\n *  - 0.001\n *  - .001\n *  - 10000\n *  - 1e+26\n *  - 22e-26\n *  - .45e+26\n *  - 0xabcdef (hex)\n *  - 0x1 (hex)\n *\n * these values are not considered as numeric:\n *  - - 1000\n *  - 100 000\n *\n * @param {*} value The value to check.\n * @param {string[]} additionalDelimiters An additional delimiters to be used while checking the numeric value.\n * @returns {boolean}\n */\nexport function isNumeric(value) {\n  let additionalDelimiters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const type = typeof value;\n  if (type === 'number') {\n    return !isNaN(value) && isFinite(value);\n  } else if (type === 'string') {\n    if (value.length === 0) {\n      return false;\n    } else if (value.length === 1) {\n      return /\\d/.test(value);\n    }\n    const delimiter = Array.from(new Set(['.', ...additionalDelimiters])).map(d => `\\\\${d}`).join('|');\n    return new RegExp(`^[+-]?(((${delimiter})?\\\\d+((${delimiter})\\\\d+)?(e[+-]?\\\\d+)?)|(0x[a-f\\\\d]+))$`, 'i').test(value.trim());\n  } else if (type === 'object') {\n    return !!value && typeof value.valueOf() === 'number' && !(value instanceof Date);\n  }\n  return false;\n}\n/* eslint-enable jsdoc/require-description-complete-sentence */\n\n/**\n * Checks if the passed value is numeric-like value. The helper returns `true` for the same\n * values as for the `isNumeric` function plus `true` for numbers delimited by comma.\n *\n * @param {*} value The value to check.\n * @returns {boolean}\n */\nexport function isNumericLike(value) {\n  return isNumeric(value, [',']);\n}\n\n/**\n * A specialized version of `.forEach` defined by ranges.\n *\n * @param {number} rangeFrom The number from start iterate.\n * @param {number|Function} rangeTo The number where finish iterate or function as a iteratee.\n * @param {Function} [iteratee] The function invoked per iteration.\n */\nexport function rangeEach(rangeFrom, rangeTo, iteratee) {\n  let index = -1;\n  if (typeof rangeTo === 'function') {\n    iteratee = rangeTo;\n    rangeTo = rangeFrom;\n  } else {\n    index = rangeFrom - 1;\n  }\n\n  /* eslint-disable-next-line no-plusplus */\n  while (++index <= rangeTo) {\n    if (iteratee(index) === false) {\n      break;\n    }\n  }\n}\n\n/**\n * A specialized version of `.forEach` defined by ranges iterable in reverse order.\n *\n * @param {number} rangeFrom The number from start iterate.\n * @param {number|Function} rangeTo The number where finish iterate or function as a iteratee.\n * @param {Function} [iteratee] The function invoked per iteration.\n */\nexport function rangeEachReverse(rangeFrom, rangeTo, iteratee) {\n  let index = rangeFrom + 1;\n  if (typeof rangeTo === 'function') {\n    iteratee = rangeTo;\n    rangeTo = 0;\n  }\n  /* eslint-disable-next-line no-plusplus */\n  while (--index >= rangeTo) {\n    if (iteratee(index) === false) {\n      break;\n    }\n  }\n}\n\n/**\n * Calculate value from percent.\n *\n * @param {number} value Base value from percent will be calculated.\n * @param {string|number} percent Can be number or string (eq. `'33%'`).\n * @returns {number}\n */\nexport function valueAccordingPercent(value, percent) {\n  percent = parseInt(percent.toString().replace('%', ''), 10);\n  percent = isNaN(percent) ? 0 : percent;\n  return parseInt(value * percent / 100, 10);\n}\n\n/**\n * Clamps the value between min and max.\n *\n * @param {number} value The base number value.\n * @param {number} minValue The max number value.\n * @param {number} maxValue The min number value.\n * @returns {number}\n */\nexport function clamp(value, minValue, maxValue) {\n  if (Math.min(value, minValue) === value) {\n    return minValue;\n  } else if (Math.max(value, maxValue) === value) {\n    return maxValue;\n  }\n  return value;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}