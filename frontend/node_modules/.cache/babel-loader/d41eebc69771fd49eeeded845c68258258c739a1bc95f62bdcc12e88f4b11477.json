{"ast":null,"code":"import { TextEditor } from \"../textEditor/index.mjs\";\nimport { setCaretPosition } from \"../../helpers/dom/element.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { extend } from \"../../helpers/object.mjs\";\nimport { EDITOR_EDIT_GROUP } from \"../../shortcutContexts/index.mjs\";\nconst SHORTCUTS_GROUP = 'handsontableEditor';\nexport const EDITOR_TYPE = 'handsontable';\n\n/**\n * @private\n * @class HandsontableEditor\n */\nexport class HandsontableEditor extends TextEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    super.open();\n    if (this.htEditor) {\n      this.htEditor.destroy();\n    }\n    if (this.htContainer.style.display === 'none') {\n      this.htContainer.style.display = '';\n    }\n\n    // Constructs and initializes a new Handsontable instance\n    this.htEditor = new this.hot.constructor(this.htContainer, this.htOptions);\n    this.htEditor.init();\n    this.htEditor.rootElement.style.display = '';\n    if (this.cellProperties.strict) {\n      this.htEditor.selectCell(0, 0);\n    } else {\n      this.htEditor.deselectCell();\n    }\n    setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    if (this.htEditor) {\n      this.htEditor.rootElement.style.display = 'none';\n    }\n    this.removeHooksByKey('beforeKeyDown');\n    super.close();\n  }\n\n  /**\n   * Prepares editor's meta data and configuration of the internal Handsontable's instance.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    super.prepare(row, col, prop, td, value, cellProperties);\n    const parent = this;\n    const options = {\n      startRows: 0,\n      startCols: 0,\n      minRows: 0,\n      minCols: 0,\n      className: 'listbox',\n      copyPaste: false,\n      autoColumnSize: false,\n      autoRowSize: false,\n      readOnly: true,\n      fillHandle: false,\n      autoWrapCol: false,\n      autoWrapRow: false,\n      ariaTags: false,\n      afterOnCellMouseDown(_, coords) {\n        const sourceValue = this.getSourceData(coords.row, coords.col);\n\n        // if the value is undefined then it means we don't want to set the value\n        if (sourceValue !== undefined) {\n          parent.setValue(sourceValue);\n        }\n        parent.hot.destroyEditor();\n      },\n      preventWheel: true,\n      layoutDirection: this.hot.isRtl() ? 'rtl' : 'ltr'\n    };\n    if (this.cellProperties.handsontable) {\n      extend(options, cellProperties.handsontable);\n    }\n    this.htOptions = options;\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {*} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    const onBeginEditing = this.hot.getSettings().onBeginEditing;\n    if (onBeginEditing && onBeginEditing() === false) {\n      return;\n    }\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    super.createElements();\n    const DIV = this.hot.rootDocument.createElement('DIV');\n    DIV.className = 'handsontableEditor';\n    this.TEXTAREA_PARENT.appendChild(DIV);\n    this.htContainer = DIV;\n    this.assignHooks();\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    if (this.htEditor && this.htEditor.isListening()) {\n      // if focus is still in the HOT editor\n      this.hot.listen(); // return the focus to the parent HOT instance\n    }\n    if (this.htEditor && this.htEditor.getSelectedLast()) {\n      const value = this.htEditor.getValue();\n      if (value !== undefined) {\n        // if the value is undefined then it means we don't want to set the value\n        this.setValue(value);\n      }\n    }\n    super.finishEditing(restoreOriginalValue, ctrlDown, callback);\n  }\n\n  /**\n   * Assigns afterDestroy callback to prevent memory leaks.\n   *\n   * @private\n   */\n  assignHooks() {\n    this.hot.addHook('afterDestroy', () => {\n      if (this.htEditor) {\n        this.htEditor.destroy();\n      }\n    });\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    super.registerShortcuts();\n    const contextConfig = {\n      group: SHORTCUTS_GROUP,\n      relativeToGroup: EDITOR_EDIT_GROUP,\n      position: 'before'\n    };\n    const action = (rowToSelect, event) => {\n      const innerHOT = this.htEditor;\n      if (rowToSelect !== undefined) {\n        if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {\n          innerHOT.deselectCell();\n        } else {\n          innerHOT.selectCell(rowToSelect, 0);\n        }\n        if (innerHOT.getData().length) {\n          event.preventDefault();\n          stopImmediatePropagation(event);\n          this.hot.listen();\n          this.TEXTAREA.focus();\n          return false;\n        }\n      }\n    };\n    editorContext.addShortcuts([{\n      keys: [['ArrowUp']],\n      callback: event => {\n        const innerHOT = this.htEditor;\n        let rowToSelect;\n        let selectedRow;\n        if (!innerHOT.getSelectedLast() && innerHOT.flipped) {\n          rowToSelect = innerHOT.countRows() - 1;\n        } else if (innerHOT.getSelectedLast()) {\n          if (innerHOT.flipped) {\n            selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = Math.max(0, selectedRow - 1);\n          } else {\n            selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = selectedRow - 1;\n          }\n        }\n        return action(rowToSelect, event);\n      },\n      preventDefault: false // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.\n    }, {\n      keys: [['ArrowDown']],\n      callback: event => {\n        const innerHOT = this.htEditor;\n        let rowToSelect;\n        let selectedRow;\n        if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {\n          rowToSelect = 0;\n        } else if (innerHOT.getSelectedLast()) {\n          if (innerHOT.flipped) {\n            rowToSelect = innerHOT.getSelectedLast()[0] + 1;\n          } else if (!innerHOT.flipped) {\n            const lastRow = innerHOT.countRows() - 1;\n            selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = Math.min(lastRow, selectedRow + 1);\n          }\n        }\n        return action(rowToSelect, event);\n      },\n      preventDefault: false // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    super.unregisterShortcuts();\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n}","map":{"version":3,"names":["TextEditor","setCaretPosition","stopImmediatePropagation","extend","EDITOR_EDIT_GROUP","SHORTCUTS_GROUP","EDITOR_TYPE","HandsontableEditor","open","htEditor","destroy","htContainer","style","display","hot","constructor","htOptions","init","rootElement","cellProperties","strict","selectCell","deselectCell","TEXTAREA","value","length","refreshDimensions","close","removeHooksByKey","prepare","row","col","prop","td","parent","options","startRows","startCols","minRows","minCols","className","copyPaste","autoColumnSize","autoRowSize","readOnly","fillHandle","autoWrapCol","autoWrapRow","ariaTags","afterOnCellMouseDown","_","coords","sourceValue","getSourceData","undefined","setValue","destroyEditor","preventWheel","layoutDirection","isRtl","handsontable","beginEditing","newInitialValue","event","onBeginEditing","getSettings","createElements","DIV","rootDocument","createElement","TEXTAREA_PARENT","appendChild","assignHooks","finishEditing","restoreOriginalValue","ctrlDown","callback","isListening","listen","getSelectedLast","getValue","addHook","registerShortcuts","shortcutManager","getShortcutManager","editorContext","getContext","contextConfig","group","relativeToGroup","position","action","rowToSelect","innerHOT","flipped","countRows","getData","preventDefault","focus","addShortcuts","keys","selectedRow","Math","max","lastRow","min","unregisterShortcuts","removeShortcutsByGroup"],"sources":["D:/gym-project/frontend/node_modules/handsontable/editors/handsontableEditor/handsontableEditor.mjs"],"sourcesContent":["import { TextEditor } from \"../textEditor/index.mjs\";\nimport { setCaretPosition } from \"../../helpers/dom/element.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { extend } from \"../../helpers/object.mjs\";\nimport { EDITOR_EDIT_GROUP } from \"../../shortcutContexts/index.mjs\";\nconst SHORTCUTS_GROUP = 'handsontableEditor';\nexport const EDITOR_TYPE = 'handsontable';\n\n/**\n * @private\n * @class HandsontableEditor\n */\nexport class HandsontableEditor extends TextEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    super.open();\n    if (this.htEditor) {\n      this.htEditor.destroy();\n    }\n    if (this.htContainer.style.display === 'none') {\n      this.htContainer.style.display = '';\n    }\n\n    // Constructs and initializes a new Handsontable instance\n    this.htEditor = new this.hot.constructor(this.htContainer, this.htOptions);\n    this.htEditor.init();\n    this.htEditor.rootElement.style.display = '';\n    if (this.cellProperties.strict) {\n      this.htEditor.selectCell(0, 0);\n    } else {\n      this.htEditor.deselectCell();\n    }\n    setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    if (this.htEditor) {\n      this.htEditor.rootElement.style.display = 'none';\n    }\n    this.removeHooksByKey('beforeKeyDown');\n    super.close();\n  }\n\n  /**\n   * Prepares editor's meta data and configuration of the internal Handsontable's instance.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    super.prepare(row, col, prop, td, value, cellProperties);\n    const parent = this;\n    const options = {\n      startRows: 0,\n      startCols: 0,\n      minRows: 0,\n      minCols: 0,\n      className: 'listbox',\n      copyPaste: false,\n      autoColumnSize: false,\n      autoRowSize: false,\n      readOnly: true,\n      fillHandle: false,\n      autoWrapCol: false,\n      autoWrapRow: false,\n      ariaTags: false,\n      afterOnCellMouseDown(_, coords) {\n        const sourceValue = this.getSourceData(coords.row, coords.col);\n\n        // if the value is undefined then it means we don't want to set the value\n        if (sourceValue !== undefined) {\n          parent.setValue(sourceValue);\n        }\n        parent.hot.destroyEditor();\n      },\n      preventWheel: true,\n      layoutDirection: this.hot.isRtl() ? 'rtl' : 'ltr'\n    };\n    if (this.cellProperties.handsontable) {\n      extend(options, cellProperties.handsontable);\n    }\n    this.htOptions = options;\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {*} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    const onBeginEditing = this.hot.getSettings().onBeginEditing;\n    if (onBeginEditing && onBeginEditing() === false) {\n      return;\n    }\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    super.createElements();\n    const DIV = this.hot.rootDocument.createElement('DIV');\n    DIV.className = 'handsontableEditor';\n    this.TEXTAREA_PARENT.appendChild(DIV);\n    this.htContainer = DIV;\n    this.assignHooks();\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    if (this.htEditor && this.htEditor.isListening()) {\n      // if focus is still in the HOT editor\n      this.hot.listen(); // return the focus to the parent HOT instance\n    }\n    if (this.htEditor && this.htEditor.getSelectedLast()) {\n      const value = this.htEditor.getValue();\n      if (value !== undefined) {\n        // if the value is undefined then it means we don't want to set the value\n        this.setValue(value);\n      }\n    }\n    super.finishEditing(restoreOriginalValue, ctrlDown, callback);\n  }\n\n  /**\n   * Assigns afterDestroy callback to prevent memory leaks.\n   *\n   * @private\n   */\n  assignHooks() {\n    this.hot.addHook('afterDestroy', () => {\n      if (this.htEditor) {\n        this.htEditor.destroy();\n      }\n    });\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    super.registerShortcuts();\n    const contextConfig = {\n      group: SHORTCUTS_GROUP,\n      relativeToGroup: EDITOR_EDIT_GROUP,\n      position: 'before'\n    };\n    const action = (rowToSelect, event) => {\n      const innerHOT = this.htEditor;\n      if (rowToSelect !== undefined) {\n        if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {\n          innerHOT.deselectCell();\n        } else {\n          innerHOT.selectCell(rowToSelect, 0);\n        }\n        if (innerHOT.getData().length) {\n          event.preventDefault();\n          stopImmediatePropagation(event);\n          this.hot.listen();\n          this.TEXTAREA.focus();\n          return false;\n        }\n      }\n    };\n    editorContext.addShortcuts([{\n      keys: [['ArrowUp']],\n      callback: event => {\n        const innerHOT = this.htEditor;\n        let rowToSelect;\n        let selectedRow;\n        if (!innerHOT.getSelectedLast() && innerHOT.flipped) {\n          rowToSelect = innerHOT.countRows() - 1;\n        } else if (innerHOT.getSelectedLast()) {\n          if (innerHOT.flipped) {\n            selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = Math.max(0, selectedRow - 1);\n          } else {\n            selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = selectedRow - 1;\n          }\n        }\n        return action(rowToSelect, event);\n      },\n      preventDefault: false // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.\n    }, {\n      keys: [['ArrowDown']],\n      callback: event => {\n        const innerHOT = this.htEditor;\n        let rowToSelect;\n        let selectedRow;\n        if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {\n          rowToSelect = 0;\n        } else if (innerHOT.getSelectedLast()) {\n          if (innerHOT.flipped) {\n            rowToSelect = innerHOT.getSelectedLast()[0] + 1;\n          } else if (!innerHOT.flipped) {\n            const lastRow = innerHOT.countRows() - 1;\n            selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = Math.min(lastRow, selectedRow + 1);\n          }\n        }\n        return action(rowToSelect, event);\n      },\n      preventDefault: false // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    super.unregisterShortcuts();\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}