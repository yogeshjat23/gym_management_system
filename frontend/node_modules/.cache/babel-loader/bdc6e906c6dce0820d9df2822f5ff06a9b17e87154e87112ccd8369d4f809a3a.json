{"ast":null,"code":"import moment from 'moment';\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\nexport const VALIDATOR_TYPE = 'date';\n\n/**\n * The Date cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function dateValidator(value, callback) {\n  const dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\n  let valueToValidate = value;\n  let valid = true;\n  if (valueToValidate === null || valueToValidate === undefined) {\n    valueToValidate = '';\n  }\n  let isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\n  let isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidDate = true;\n    isValidFormat = true;\n  }\n  if (!isValidDate) {\n    valid = false;\n  }\n  if (!isValidDate && isValidFormat) {\n    valid = true;\n  }\n  if (isValidDate && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      const correctedValue = correctFormat(valueToValidate, this.dateFormat);\n      this.instance.setDataAtCell(this.visualRow, this.visualCol, correctedValue, 'dateValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n\n/**\n * Format the given string using moment.js' format feature.\n *\n * @param {string} value The value to format.\n * @param {string} dateFormat The date pattern to format to.\n * @returns {string}\n */\nexport function correctFormat(value, dateFormat) {\n  const dateFromDate = moment(getNormalizedDate(value));\n  const dateFromMoment = moment(value, dateFormat);\n  const isAlphanumeric = value.search(/[A-z]/g) > -1;\n  let date;\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n  return date.format(dateFormat);\n}","map":{"version":3,"names":["moment","getEditorInstance","EDITOR_TYPE","DATE_EDITOR_TYPE","getNormalizedDate","VALIDATOR_TYPE","dateValidator","value","callback","dateEditor","instance","valueToValidate","valid","undefined","isValidFormat","dateFormat","defaultDateFormat","isValid","isValidDate","Date","allowEmpty","correctFormat","correctedValue","setDataAtCell","visualRow","visualCol","dateFromDate","dateFromMoment","isAlphanumeric","search","date","format"],"sources":["D:/gym-project/frontend/node_modules/handsontable/validators/dateValidator/dateValidator.mjs"],"sourcesContent":["import moment from 'moment';\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\nexport const VALIDATOR_TYPE = 'date';\n\n/**\n * The Date cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function dateValidator(value, callback) {\n  const dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\n  let valueToValidate = value;\n  let valid = true;\n  if (valueToValidate === null || valueToValidate === undefined) {\n    valueToValidate = '';\n  }\n  let isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\n  let isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidDate = true;\n    isValidFormat = true;\n  }\n  if (!isValidDate) {\n    valid = false;\n  }\n  if (!isValidDate && isValidFormat) {\n    valid = true;\n  }\n  if (isValidDate && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      const correctedValue = correctFormat(valueToValidate, this.dateFormat);\n      this.instance.setDataAtCell(this.visualRow, this.visualCol, correctedValue, 'dateValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n\n/**\n * Format the given string using moment.js' format feature.\n *\n * @param {string} value The value to format.\n * @param {string} dateFormat The date pattern to format to.\n * @returns {string}\n */\nexport function correctFormat(value, dateFormat) {\n  const dateFromDate = moment(getNormalizedDate(value));\n  const dateFromMoment = moment(value, dateFormat);\n  const isAlphanumeric = value.search(/[A-z]/g) > -1;\n  let date;\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n  return date.format(dateFormat);\n}"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,iBAAiB,QAAQ,4BAA4B;AAC9D,SAASC,WAAW,IAAIC,gBAAgB,QAAQ,oCAAoC;AACpF,SAASC,iBAAiB,QAAQ,wBAAwB;AAC1D,OAAO,MAAMC,cAAc,GAAG,MAAM;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC7C,MAAMC,UAAU,GAAGR,iBAAiB,CAACE,gBAAgB,EAAE,IAAI,CAACO,QAAQ,CAAC;EACrE,IAAIC,eAAe,GAAGJ,KAAK;EAC3B,IAAIK,KAAK,GAAG,IAAI;EAChB,IAAID,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAKE,SAAS,EAAE;IAC7DF,eAAe,GAAG,EAAE;EACtB;EACA,IAAIG,aAAa,GAAGd,MAAM,CAACW,eAAe,EAAE,IAAI,CAACI,UAAU,IAAIN,UAAU,CAACO,iBAAiB,EAAE,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC;EAC5G,IAAIC,WAAW,GAAGlB,MAAM,CAAC,IAAImB,IAAI,CAACR,eAAe,CAAC,CAAC,CAACM,OAAO,CAAC,CAAC,IAAIH,aAAa;EAC9E,IAAI,IAAI,CAACM,UAAU,IAAIT,eAAe,KAAK,EAAE,EAAE;IAC7CO,WAAW,GAAG,IAAI;IAClBJ,aAAa,GAAG,IAAI;EACtB;EACA,IAAI,CAACI,WAAW,EAAE;IAChBN,KAAK,GAAG,KAAK;EACf;EACA,IAAI,CAACM,WAAW,IAAIJ,aAAa,EAAE;IACjCF,KAAK,GAAG,IAAI;EACd;EACA,IAAIM,WAAW,IAAI,CAACJ,aAAa,EAAE;IACjC,IAAI,IAAI,CAACO,aAAa,KAAK,IAAI,EAAE;MAC/B;MACA,MAAMC,cAAc,GAAGD,aAAa,CAACV,eAAe,EAAE,IAAI,CAACI,UAAU,CAAC;MACtE,IAAI,CAACL,QAAQ,CAACa,aAAa,CAAC,IAAI,CAACC,SAAS,EAAE,IAAI,CAACC,SAAS,EAAEH,cAAc,EAAE,eAAe,CAAC;MAC5FV,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACLA,KAAK,GAAG,KAAK;IACf;EACF;EACAJ,QAAQ,CAACI,KAAK,CAAC;AACjB;AACAN,aAAa,CAACD,cAAc,GAAGA,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgB,aAAaA,CAACd,KAAK,EAAEQ,UAAU,EAAE;EAC/C,MAAMW,YAAY,GAAG1B,MAAM,CAACI,iBAAiB,CAACG,KAAK,CAAC,CAAC;EACrD,MAAMoB,cAAc,GAAG3B,MAAM,CAACO,KAAK,EAAEQ,UAAU,CAAC;EAChD,MAAMa,cAAc,GAAGrB,KAAK,CAACsB,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;EAClD,IAAIC,IAAI;EACR,IAAIJ,YAAY,CAACT,OAAO,CAAC,CAAC,IAAIS,YAAY,CAACK,MAAM,CAAC,GAAG,CAAC,KAAKJ,cAAc,CAACI,MAAM,CAAC,GAAG,CAAC,IAAI,CAACJ,cAAc,CAACV,OAAO,CAAC,CAAC,IAAIW,cAAc,EAAE;IACpIE,IAAI,GAAGJ,YAAY;EACrB,CAAC,MAAM;IACLI,IAAI,GAAGH,cAAc;EACvB;EACA,OAAOG,IAAI,CAACC,MAAM,CAAChB,UAAU,CAAC;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}