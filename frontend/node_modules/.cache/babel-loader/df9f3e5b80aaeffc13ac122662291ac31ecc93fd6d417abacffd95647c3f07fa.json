{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\nvar _Scroll_brand = /*#__PURE__*/new WeakSet();\nclass Scroll {\n  /**\n   * @param {ScrollDao} dataAccessObject Tha data access object.\n   */\n  constructor(dataAccessObject) {\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @param {number} lastColumnIndex The last visible column index.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _Scroll_brand);\n    /**\n     * The data access object.\n     *\n     * @protected\n     * @type {ScrollDao}\n     */\n    _defineProperty(this, \"dataAccessObject\", void 0);\n    this.dataAccessObject = dataAccessObject;\n  }\n\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n    const scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n    return scrolledHorizontally || scrolledVertically;\n  }\n\n  /**\n   * Scrolls viewport to a column.\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    const {\n      drawn,\n      totalColumns\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the column points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {\n      return false;\n    }\n    const autoSnapping = snapToRight === undefined && snapToLeft === undefined;\n    const {\n      fixedColumnsStart,\n      inlineStartOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the columns points to the overlays\n    if (autoSnapping && column < fixedColumnsStart) {\n      return false;\n    }\n    column = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollHorizontally', column);\n    if (!Number.isInteger(column) || column < 0 || column > totalColumns) {\n      return false;\n    }\n    const firstColumn = this.getFirstVisibleColumn();\n    const lastColumn = this.getLastVisibleColumn();\n    let result = false;\n    if (autoSnapping && (column < firstColumn || column > lastColumn) || !autoSnapping) {\n      // if there is at least one fully visible column determine the snapping direction based on\n      // that columns or by snapToRight/snapToLeft flags, if provided.\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column >= this.getLastPartiallyVisibleColumn() : snapToRight);\n    }\n    return result;\n  }\n\n  /**\n   * Scrolls viewport to a row.\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    const {\n      drawn,\n      totalRows\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the row points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {\n      return false;\n    }\n    const autoSnapping = snapToTop === undefined && snapToBottom === undefined;\n    const {\n      fixedRowsBottom,\n      fixedRowsTop,\n      topOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the rows points to the overlays\n    if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {\n      return false;\n    }\n    row = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollVertically', row);\n    if (!Number.isInteger(row) || row < 0 || row > totalRows) {\n      return false;\n    }\n    const firstRow = this.getFirstVisibleRow();\n    const lastRow = this.getLastVisibleRow();\n    let result = false;\n    if (autoSnapping && (row < firstRow || row > lastRow) || !autoSnapping) {\n      // if there is at least one fully visible row determine the snapping direction based on\n      // that rows or by snapToTop/snapToBottom flags, if provided.\n      result = topOverlay.scrollTo(row, autoSnapping ? row >= this.getLastPartiallyVisibleRow() : snapToBottom);\n    }\n    return result;\n  }\n\n  /**\n   * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleRow() {\n    return this.dataAccessObject.wtTable.getFirstVisibleRow();\n  }\n\n  /**\n   * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleRow() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastRowIndex).call(this, this.dataAccessObject.wtTable.getLastVisibleRow());\n  }\n\n  /**\n   * Get first partially visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleRow() {\n    return this.dataAccessObject.wtTable.getFirstPartiallyVisibleRow();\n  }\n\n  /**\n   * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleRow() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastRowIndex).call(this, this.dataAccessObject.wtTable.getLastPartiallyVisibleRow());\n  }\n\n  /**\n   * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleColumn() {\n    return this.dataAccessObject.wtTable.getFirstVisibleColumn();\n  }\n\n  /**\n   * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleColumn() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastColumnIndex).call(this, this.dataAccessObject.wtTable.getLastVisibleColumn());\n  }\n\n  /**\n   * Get first partially visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleColumn() {\n    return this.dataAccessObject.wtTable.getFirstPartiallyVisibleColumn();\n  }\n\n  /**\n   * Get last partially visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleColumn() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastColumnIndex).call(this, this.dataAccessObject.wtTable.getLastPartiallyVisibleColumn());\n  }\n}\nfunction _getLastColumnIndex(lastColumnIndex) {\n  const {\n    wtSettings,\n    inlineStartOverlay,\n    wtTable,\n    wtViewport,\n    totalColumns,\n    rootWindow\n  } = this.dataAccessObject;\n  if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n    const isRtl = wtSettings.getSetting('rtlMode');\n    let inlineStartRootElementOffset = null;\n    if (isRtl) {\n      const tableRect = wtTable.TABLE.getBoundingClientRect();\n      const rootDocument = this.dataAccessObject.rootWindow.document;\n      const docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);\n    } else {\n      const rootElementOffset = offset(wtTable.wtRootElement);\n      inlineStartRootElementOffset = rootElementOffset.left;\n    }\n    const windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n    // Only calculate lastColumnIndex when table didn't filled (from right) whole viewport space\n    if (inlineStartRootElementOffset > windowScrollLeft) {\n      const windowWidth = innerWidth(rootWindow);\n      let columnsWidth = wtViewport.getRowHeaderWidth();\n      for (let column = 1; column <= totalColumns; column++) {\n        columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n        if (inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= windowWidth) {\n          // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n          lastColumnIndex = column - 2;\n          break;\n        }\n      }\n    }\n  }\n  return lastColumnIndex;\n}\n/**\n * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n *\n * @param {number} lastRowIndex The last visible row index.\n * @returns {number}\n */\nfunction _getLastRowIndex(lastRowIndex) {\n  const {\n    topOverlay,\n    wtTable,\n    wtViewport,\n    totalRows,\n    rootWindow\n  } = this.dataAccessObject;\n  if (topOverlay.mainTableScrollableElement === rootWindow) {\n    const rootElementOffset = offset(wtTable.wtRootElement);\n    const windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n    // Only calculate lastRowIndex when table didn't filled (from bottom) whole viewport space\n    if (rootElementOffset.top > windowScrollTop) {\n      const windowHeight = innerHeight(rootWindow);\n      let rowsHeight = wtViewport.getColumnHeaderHeight();\n      for (let row = 1; row <= totalRows; row++) {\n        rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n        if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n          // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n          lastRowIndex = row - 2;\n          break;\n        }\n      }\n    }\n  }\n  return lastRowIndex;\n}\nexport default Scroll;","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","t","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_assertClassBrand","n","arguments","length","innerHeight","innerWidth","getScrollLeft","getScrollTop","offset","_Scroll_brand","WeakSet","Scroll","constructor","dataAccessObject","scrollViewport","coords","snapToTop","snapToRight","snapToBottom","snapToLeft","scrolledHorizontally","scrollViewportHorizontally","col","scrolledVertically","scrollViewportVertically","row","column","drawn","totalColumns","isInteger","autoSnapping","undefined","fixedColumnsStart","inlineStartOverlay","wtSettings","getSetting","firstColumn","getFirstVisibleColumn","lastColumn","getLastVisibleColumn","result","scrollTo","getLastPartiallyVisibleColumn","totalRows","fixedRowsBottom","fixedRowsTop","topOverlay","firstRow","getFirstVisibleRow","lastRow","getLastVisibleRow","getLastPartiallyVisibleRow","wtTable","_getLastRowIndex","getFirstPartiallyVisibleRow","_getLastColumnIndex","getFirstPartiallyVisibleColumn","lastColumnIndex","wtViewport","rootWindow","mainTableScrollableElement","isRtl","inlineStartRootElementOffset","tableRect","TABLE","getBoundingClientRect","rootDocument","document","docOffsetWidth","documentElement","offsetWidth","Math","abs","right","rootElementOffset","wtRootElement","left","windowScrollLeft","windowWidth","columnsWidth","getRowHeaderWidth","sumCellSizes","lastRowIndex","windowScrollTop","top","windowHeight","rowsHeight","getColumnHeaderHeight"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\nvar _Scroll_brand = /*#__PURE__*/new WeakSet();\nclass Scroll {\n  /**\n   * @param {ScrollDao} dataAccessObject Tha data access object.\n   */\n  constructor(dataAccessObject) {\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @param {number} lastColumnIndex The last visible column index.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _Scroll_brand);\n    /**\n     * The data access object.\n     *\n     * @protected\n     * @type {ScrollDao}\n     */\n    _defineProperty(this, \"dataAccessObject\", void 0);\n    this.dataAccessObject = dataAccessObject;\n  }\n\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n    const scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n    return scrolledHorizontally || scrolledVertically;\n  }\n\n  /**\n   * Scrolls viewport to a column.\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    const {\n      drawn,\n      totalColumns\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the column points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {\n      return false;\n    }\n    const autoSnapping = snapToRight === undefined && snapToLeft === undefined;\n    const {\n      fixedColumnsStart,\n      inlineStartOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the columns points to the overlays\n    if (autoSnapping && column < fixedColumnsStart) {\n      return false;\n    }\n    column = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollHorizontally', column);\n    if (!Number.isInteger(column) || column < 0 || column > totalColumns) {\n      return false;\n    }\n    const firstColumn = this.getFirstVisibleColumn();\n    const lastColumn = this.getLastVisibleColumn();\n    let result = false;\n    if (autoSnapping && (column < firstColumn || column > lastColumn) || !autoSnapping) {\n      // if there is at least one fully visible column determine the snapping direction based on\n      // that columns or by snapToRight/snapToLeft flags, if provided.\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column >= this.getLastPartiallyVisibleColumn() : snapToRight);\n    }\n    return result;\n  }\n\n  /**\n   * Scrolls viewport to a row.\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    const {\n      drawn,\n      totalRows\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the row points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {\n      return false;\n    }\n    const autoSnapping = snapToTop === undefined && snapToBottom === undefined;\n    const {\n      fixedRowsBottom,\n      fixedRowsTop,\n      topOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the rows points to the overlays\n    if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {\n      return false;\n    }\n    row = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollVertically', row);\n    if (!Number.isInteger(row) || row < 0 || row > totalRows) {\n      return false;\n    }\n    const firstRow = this.getFirstVisibleRow();\n    const lastRow = this.getLastVisibleRow();\n    let result = false;\n    if (autoSnapping && (row < firstRow || row > lastRow) || !autoSnapping) {\n      // if there is at least one fully visible row determine the snapping direction based on\n      // that rows or by snapToTop/snapToBottom flags, if provided.\n      result = topOverlay.scrollTo(row, autoSnapping ? row >= this.getLastPartiallyVisibleRow() : snapToBottom);\n    }\n    return result;\n  }\n\n  /**\n   * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleRow() {\n    return this.dataAccessObject.wtTable.getFirstVisibleRow();\n  }\n\n  /**\n   * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleRow() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastRowIndex).call(this, this.dataAccessObject.wtTable.getLastVisibleRow());\n  }\n\n  /**\n   * Get first partially visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleRow() {\n    return this.dataAccessObject.wtTable.getFirstPartiallyVisibleRow();\n  }\n\n  /**\n   * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleRow() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastRowIndex).call(this, this.dataAccessObject.wtTable.getLastPartiallyVisibleRow());\n  }\n\n  /**\n   * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleColumn() {\n    return this.dataAccessObject.wtTable.getFirstVisibleColumn();\n  }\n\n  /**\n   * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleColumn() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastColumnIndex).call(this, this.dataAccessObject.wtTable.getLastVisibleColumn());\n  }\n\n  /**\n   * Get first partially visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstPartiallyVisibleColumn() {\n    return this.dataAccessObject.wtTable.getFirstPartiallyVisibleColumn();\n  }\n\n  /**\n   * Get last partially visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastPartiallyVisibleColumn() {\n    return _assertClassBrand(_Scroll_brand, this, _getLastColumnIndex).call(this, this.dataAccessObject.wtTable.getLastPartiallyVisibleColumn());\n  }\n}\nfunction _getLastColumnIndex(lastColumnIndex) {\n  const {\n    wtSettings,\n    inlineStartOverlay,\n    wtTable,\n    wtViewport,\n    totalColumns,\n    rootWindow\n  } = this.dataAccessObject;\n  if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n    const isRtl = wtSettings.getSetting('rtlMode');\n    let inlineStartRootElementOffset = null;\n    if (isRtl) {\n      const tableRect = wtTable.TABLE.getBoundingClientRect();\n      const rootDocument = this.dataAccessObject.rootWindow.document;\n      const docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);\n    } else {\n      const rootElementOffset = offset(wtTable.wtRootElement);\n      inlineStartRootElementOffset = rootElementOffset.left;\n    }\n    const windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n    // Only calculate lastColumnIndex when table didn't filled (from right) whole viewport space\n    if (inlineStartRootElementOffset > windowScrollLeft) {\n      const windowWidth = innerWidth(rootWindow);\n      let columnsWidth = wtViewport.getRowHeaderWidth();\n      for (let column = 1; column <= totalColumns; column++) {\n        columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n        if (inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= windowWidth) {\n          // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n          lastColumnIndex = column - 2;\n          break;\n        }\n      }\n    }\n  }\n  return lastColumnIndex;\n}\n/**\n * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n *\n * @param {number} lastRowIndex The last visible row index.\n * @returns {number}\n */\nfunction _getLastRowIndex(lastRowIndex) {\n  const {\n    topOverlay,\n    wtTable,\n    wtViewport,\n    totalRows,\n    rootWindow\n  } = this.dataAccessObject;\n  if (topOverlay.mainTableScrollableElement === rootWindow) {\n    const rootElementOffset = offset(wtTable.wtRootElement);\n    const windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n    // Only calculate lastRowIndex when table didn't filled (from bottom) whole viewport space\n    if (rootElementOffset.top > windowScrollTop) {\n      const windowHeight = innerHeight(rootWindow);\n      let rowsHeight = wtViewport.getColumnHeaderHeight();\n      for (let row = 1; row <= totalRows; row++) {\n        rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n        if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n          // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n          lastRowIndex = row - 2;\n          break;\n        }\n      }\n    }\n  }\n  return lastRowIndex;\n}\nexport default Scroll;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}