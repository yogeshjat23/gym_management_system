{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @class PartiallyVisibleRowsCalculationType\n */\nexport class PartiallyVisibleRowsCalculationType {\n  constructor() {\n    /**\n     * Total number of partially visible rows in the viewport.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"count\", 0);\n    /**\n     * The row index of the first partially visible row in the viewport.\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startRow\", null);\n    /**\n     * The row index of the last partially visible row in the viewport.\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"endRow\", null);\n    /**\n     * Position of the first partially visible row (in px).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startPosition\", null);\n    /**\n     * Determines if the viewport is visible in the trimming container.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isVisibleInTrimmingContainer\", false);\n  }\n  /**\n   * Initializes the calculation.\n   */\n  initialize() {}\n\n  /**\n   * Processes the row.\n   *\n   * @param {number} row The row index.\n   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.\n   */\n  process(row, viewportCalculator) {\n    const {\n      totalCalculatedHeight,\n      zeroBasedScrollOffset,\n      innerViewportHeight\n    } = viewportCalculator;\n    if (totalCalculatedHeight <= zeroBasedScrollOffset) {\n      this.startRow = row;\n    }\n    if (totalCalculatedHeight >= zeroBasedScrollOffset && totalCalculatedHeight <= innerViewportHeight) {\n      if (this.startRow === null) {\n        this.startRow = row;\n      }\n    }\n    this.endRow = row;\n  }\n\n  /**\n   * Finalizes the calculation.\n   *\n   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.\n   */\n  finalize(viewportCalculator) {\n    var _startPositions$this$;\n    const {\n      scrollOffset,\n      viewportHeight,\n      horizontalScrollbarHeight,\n      totalRows,\n      needReverse,\n      startPositions,\n      rowHeight\n    } = viewportCalculator;\n\n    // If the estimation has reached the last row and there is still some space available in the viewport,\n    // we need to render in reverse in order to fill the whole viewport with rows\n    if (this.endRow === totalRows - 1 && needReverse) {\n      this.startRow = this.endRow;\n      while (this.startRow > 0) {\n        const calculatedViewportHeight = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n        this.startRow -= 1;\n        if (calculatedViewportHeight >= viewportHeight - horizontalScrollbarHeight) {\n          break;\n        }\n      }\n    }\n    this.startPosition = (_startPositions$this$ = startPositions[this.startRow]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;\n    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;\n    if (mostBottomScrollOffset < 0 || scrollOffset > startPositions.at(-1) + rowHeight) {\n      this.isVisibleInTrimmingContainer = false;\n    } else {\n      this.isVisibleInTrimmingContainer = true;\n    }\n    if (totalRows < this.endRow) {\n      this.endRow = totalRows - 1;\n    }\n    if (this.startRow !== null) {\n      this.count = this.endRow - this.startRow + 1;\n    }\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","PartiallyVisibleRowsCalculationType","constructor","initialize","process","row","viewportCalculator","totalCalculatedHeight","zeroBasedScrollOffset","innerViewportHeight","startRow","endRow","finalize","_startPositions$this$","scrollOffset","viewportHeight","horizontalScrollbarHeight","totalRows","needReverse","startPositions","rowHeight","calculatedViewportHeight","startPosition","mostBottomScrollOffset","at","isVisibleInTrimmingContainer","count"],"sources":["D:/gym-project/frontend/node_modules/handsontable/3rdparty/walkontable/src/calculator/calculationType/partiallyVisibleRows.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * @class PartiallyVisibleRowsCalculationType\n */\nexport class PartiallyVisibleRowsCalculationType {\n  constructor() {\n    /**\n     * Total number of partially visible rows in the viewport.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"count\", 0);\n    /**\n     * The row index of the first partially visible row in the viewport.\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startRow\", null);\n    /**\n     * The row index of the last partially visible row in the viewport.\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"endRow\", null);\n    /**\n     * Position of the first partially visible row (in px).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startPosition\", null);\n    /**\n     * Determines if the viewport is visible in the trimming container.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isVisibleInTrimmingContainer\", false);\n  }\n  /**\n   * Initializes the calculation.\n   */\n  initialize() {}\n\n  /**\n   * Processes the row.\n   *\n   * @param {number} row The row index.\n   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.\n   */\n  process(row, viewportCalculator) {\n    const {\n      totalCalculatedHeight,\n      zeroBasedScrollOffset,\n      innerViewportHeight\n    } = viewportCalculator;\n    if (totalCalculatedHeight <= zeroBasedScrollOffset) {\n      this.startRow = row;\n    }\n    if (totalCalculatedHeight >= zeroBasedScrollOffset && totalCalculatedHeight <= innerViewportHeight) {\n      if (this.startRow === null) {\n        this.startRow = row;\n      }\n    }\n    this.endRow = row;\n  }\n\n  /**\n   * Finalizes the calculation.\n   *\n   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.\n   */\n  finalize(viewportCalculator) {\n    var _startPositions$this$;\n    const {\n      scrollOffset,\n      viewportHeight,\n      horizontalScrollbarHeight,\n      totalRows,\n      needReverse,\n      startPositions,\n      rowHeight\n    } = viewportCalculator;\n\n    // If the estimation has reached the last row and there is still some space available in the viewport,\n    // we need to render in reverse in order to fill the whole viewport with rows\n    if (this.endRow === totalRows - 1 && needReverse) {\n      this.startRow = this.endRow;\n      while (this.startRow > 0) {\n        const calculatedViewportHeight = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n        this.startRow -= 1;\n        if (calculatedViewportHeight >= viewportHeight - horizontalScrollbarHeight) {\n          break;\n        }\n      }\n    }\n    this.startPosition = (_startPositions$this$ = startPositions[this.startRow]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;\n    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;\n    if (mostBottomScrollOffset < 0 || scrollOffset > startPositions.at(-1) + rowHeight) {\n      this.isVisibleInTrimmingContainer = false;\n    } else {\n      this.isVisibleInTrimmingContainer = true;\n    }\n    if (totalRows < this.endRow) {\n      this.endRow = totalRows - 1;\n    }\n    if (this.startRow !== null) {\n      this.count = this.endRow - this.startRow + 1;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}