{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { addClass, outerHeight } from \"./../helpers/dom/element.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\n/**\n * @class GhostTable\n */\nclass GhostTable {\n  constructor(hotInstance) {\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    _defineProperty(this, \"hot\", null);\n    /**\n     * Container element where every table will be injected.\n     *\n     * @type {HTMLElement|null}\n     */\n    _defineProperty(this, \"container\", null);\n    /**\n     * Flag which determine is table was injected to DOM.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"injected\", false);\n    /**\n     * Added rows collection.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"rows\", []);\n    /**\n     * Added columns collection.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"columns\", []);\n    /**\n     * Samples prepared for calculations.\n     *\n     * @type {Map}\n     * @default {null}\n     */\n    _defineProperty(this, \"samples\", null);\n    /**\n     * Ghost table settings.\n     *\n     * @type {object}\n     * @default {Object}\n     */\n    _defineProperty(this, \"settings\", {\n      useHeaders: true\n    });\n    this.hot = hotInstance;\n  }\n\n  /**\n   * Add row.\n   *\n   * @param {number} row Visual row index.\n   * @param {Map} samples Samples Map object.\n   */\n  addRow(row, samples) {\n    if (this.columns.length) {\n      throw new Error('Doesn\\'t support multi-dimensional table');\n    }\n    if (!this.rows.length) {\n      this.container = this.createContainer(this.hot.rootElement.className);\n    }\n    const rowObject = {\n      row\n    };\n    this.rows.push(rowObject);\n    this.samples = samples;\n    this.table = this.createTable(this.hot.table.className);\n    this.table.colGroup.appendChild(this.createColGroupsCol(row));\n    this.table.tr.appendChild(this.createRow(row));\n    this.container.container.appendChild(this.table.fragment);\n    rowObject.table = this.table.table;\n  }\n\n  /**\n   * Add a row consisting of the column headers.\n   *\n   * @param {Map} samples A map with sampled table values.\n   */\n  addColumnHeadersRow(samples) {\n    const colHeader = this.hot.getColHeader(0);\n    if (colHeader !== null && colHeader !== undefined) {\n      const rowObject = {\n        row: -1\n      };\n      this.rows.push(rowObject);\n      this.container = this.createContainer(this.hot.rootElement.className);\n      this.samples = samples;\n      this.table = this.createTable(this.hot.table.className);\n      this.table.colGroup.appendChild(this.createColGroupsCol());\n      this.appendColumnHeadersRow();\n      this.container.container.appendChild(this.table.fragment);\n      rowObject.table = this.table.table;\n    }\n  }\n\n  /**\n   * Add column.\n   *\n   * @param {number} column Visual column index.\n   * @param {Map} samples A map with sampled table values.\n   */\n  addColumn(column, samples) {\n    if (this.rows.length) {\n      throw new Error('Doesn\\'t support multi-dimensional table');\n    }\n    if (!this.columns.length) {\n      this.container = this.createContainer(this.hot.rootElement.className);\n    }\n    const columnObject = {\n      col: column\n    };\n    this.columns.push(columnObject);\n    this.samples = samples;\n    this.table = this.createTable(this.hot.table.className);\n    if (this.getSetting('useHeaders') && this.hot.getColHeader(column) !== null) {\n      // Please keep in mind that the renderable column index equal to the visual columns index for the GhostTable.\n      // We render all columns.\n      this.hot.view.appendColHeader(column, this.table.th);\n    }\n    this.table.tBody.appendChild(this.createCol(column));\n    this.container.container.appendChild(this.table.fragment);\n    columnObject.table = this.table.table;\n  }\n\n  /**\n   * Get calculated heights.\n   *\n   * @param {Function} callback Callback which will be fired for each calculated row.\n   */\n  getHeights(callback) {\n    if (!this.injected) {\n      this.injectTable();\n    }\n    arrayEach(this.rows, row => {\n      // -1 <- reduce border-top from table\n      callback(row.row, outerHeight(row.table) - 1);\n    });\n  }\n\n  /**\n   * Get calculated widths.\n   *\n   * @param {Function} callback Callback which will be fired for each calculated column.\n   */\n  getWidths(callback) {\n    if (!this.injected) {\n      this.injectTable();\n    }\n    arrayEach(this.columns, column => {\n      // The GhostTable class is responsible for calculating the columns' width based on the\n      // contents rendered in the cells. In some cases, when the column's width calculated by\n      // the browser is a decimal point with a fractional component. For example, 35.32px.\n      // The usage of the `.offsetWidth` (or our helper `outerWidth`) is incorrect.\n      // The `outerWidth` in the mentioned example (35.32px) would return 35 pixels that\n      // would cause the text to not fit in the cell, thus increasing the row height.\n      // That's why the `getBoundingClientRect` method is used. The method returns the number\n      // that is rounded up to make sure that there will be a space for the cell's content.\n      const {\n        width\n      } = column.table.getBoundingClientRect();\n      callback(column.col, Math.ceil(width));\n    });\n  }\n\n  /**\n   * Set the Ghost Table settings to the provided object.\n   *\n   * @param {object} settings New Ghost Table Settings.\n   */\n  setSettings(settings) {\n    this.settings = settings;\n  }\n\n  /**\n   * Set a single setting of the Ghost Table.\n   *\n   * @param {string} name Setting name.\n   * @param {*} value Setting value.\n   */\n  setSetting(name, value) {\n    if (!this.settings) {\n      this.settings = {};\n    }\n    this.settings[name] = value;\n  }\n\n  /**\n   * Get the Ghost Table settings.\n   *\n   * @returns {object|null}\n   */\n  getSettings() {\n    return this.settings;\n  }\n\n  /**\n   * Get a single Ghost Table setting.\n   *\n   * @param {string} name The setting name to get.\n   * @returns {boolean|null}\n   */\n  getSetting(name) {\n    if (this.settings) {\n      return this.settings[name];\n    }\n    return null;\n  }\n\n  /**\n   * Create colgroup col elements.\n   *\n   * @param {number} row Visual row index.\n   * @returns {DocumentFragment}\n   */\n  createColGroupsCol(row) {\n    const fragment = this.hot.rootDocument.createDocumentFragment();\n    if (this.hot.hasRowHeaders()) {\n      fragment.appendChild(this.createColElement(-1, -1));\n    }\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        fragment.appendChild(this.createColElement(string.col, row));\n      });\n    });\n    return fragment;\n  }\n\n  /**\n   * Create table row element.\n   *\n   * @param {number} row Visual row index.\n   * @returns {DocumentFragment} Returns created table row elements.\n   */\n  createRow(row) {\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    const th = rootDocument.createElement('th');\n    if (this.hot.hasRowHeaders()) {\n      this.hot.view.appendRowHeader(row, th);\n      fragment.appendChild(th);\n    }\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        const column = string.col;\n        const cellProperties = this.hot.getCellMeta(row, column);\n        const renderer = this.hot.getCellRenderer(cellProperties);\n        const td = rootDocument.createElement('td');\n\n        // Indicate that this element is created and supported by GhostTable. It can be useful to\n        // exclude rendering performance costly logic or exclude logic which doesn't work within a hidden table.\n        td.setAttribute('ghost-table', 1);\n        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);\n        fragment.appendChild(td);\n      });\n    });\n    return fragment;\n  }\n\n  /**\n   * Creates DOM elements for headers and appends them to the THEAD element of the table.\n   */\n  appendColumnHeadersRow() {\n    const {\n      rootDocument\n    } = this.hot;\n    const domFragment = rootDocument.createDocumentFragment();\n    const columnHeaders = [];\n    if (this.hot.hasRowHeaders()) {\n      const th = rootDocument.createElement('th');\n      columnHeaders.push([-1, th]);\n      domFragment.appendChild(th);\n    }\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        const column = string.col;\n        const th = rootDocument.createElement('th');\n        columnHeaders.push([column, th]);\n        domFragment.appendChild(th);\n      });\n    });\n\n    // Appending DOM elements for headers\n    this.table.tHead.appendChild(domFragment);\n    arrayEach(columnHeaders, columnHeader => {\n      const [column, th] = columnHeader;\n\n      // Using source method for filling a header with value.\n      this.hot.view.appendColHeader(column, th);\n    });\n  }\n\n  /**\n   * Create table column elements.\n   *\n   * @param {number} column Visual column index.\n   * @returns {DocumentFragment} Returns created column table column elements.\n   */\n  createCol(column) {\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        const row = string.row;\n        const cellProperties = this.hot.getCellMeta(row, column);\n        const renderer = this.hot.getCellRenderer(cellProperties);\n        const td = rootDocument.createElement('td');\n        const tr = rootDocument.createElement('tr');\n\n        // Indicate that this element is created and supported by GhostTable. It can be useful to\n        // exclude rendering performance costly logic or exclude logic which doesn't work within a hidden table.\n        td.setAttribute('ghost-table', 1);\n        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);\n        tr.appendChild(td);\n        fragment.appendChild(tr);\n      });\n    });\n    return fragment;\n  }\n\n  /**\n   * Remove table from document and reset internal state.\n   */\n  clean() {\n    this.rows.length = 0;\n    this.rows[-1] = undefined;\n    this.columns.length = 0;\n    if (this.samples) {\n      this.samples.clear();\n    }\n    this.samples = null;\n    this.removeTable();\n  }\n\n  /**\n   * Inject generated table into document.\n   *\n   * @param {HTMLElement} [parent=null] The element to which the ghost table is injected.\n   */\n  injectTable() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (!this.injected) {\n      (parent || this.hot.rootElement).appendChild(this.container.fragment);\n      this.injected = true;\n    }\n  }\n\n  /**\n   * Remove table from document.\n   */\n  removeTable() {\n    if (this.injected && this.container.container.parentNode) {\n      this.container.container.parentNode.removeChild(this.container.container);\n      this.container = null;\n      this.injected = false;\n    }\n  }\n\n  /**\n   * Create col element.\n   *\n   * @param {number} column Visual column index.\n   * @param {number} row Visual row index.\n   * @returns {HTMLElement}\n   */\n  createColElement(column, row) {\n    const col = this.hot.rootDocument.createElement('col');\n    let colspan = 0;\n    if (row >= 0 && column >= 0) {\n      colspan = this.hot.getCellMeta(row, column).colspan;\n    }\n    let width = this.hot.getColWidth(column);\n    if (colspan > 1) {\n      for (let nextColumn = column + 1; nextColumn < column + colspan; nextColumn++) {\n        width += this.hot.getColWidth(nextColumn);\n      }\n    }\n    col.style.width = `${width}px`;\n    return col;\n  }\n\n  /**\n   * Create table element.\n   *\n   * @param {string} className The CSS classes to add.\n   * @returns {object}\n   */\n  createTable() {\n    let className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    const table = rootDocument.createElement('table');\n    const tHead = rootDocument.createElement('thead');\n    const tBody = rootDocument.createElement('tbody');\n    const colGroup = rootDocument.createElement('colgroup');\n    const tr = rootDocument.createElement('tr');\n    const th = rootDocument.createElement('th');\n    if (this.isVertical()) {\n      table.appendChild(colGroup);\n    }\n    if (this.isHorizontal()) {\n      tr.appendChild(th);\n      tHead.appendChild(tr);\n      table.style.tableLayout = 'auto';\n      table.style.width = 'auto';\n    }\n    table.appendChild(tHead);\n    if (this.isVertical()) {\n      tBody.appendChild(tr);\n    }\n    table.appendChild(tBody);\n    addClass(table, className);\n    fragment.appendChild(table);\n    return {\n      fragment,\n      table,\n      tHead,\n      tBody,\n      colGroup,\n      tr,\n      th\n    };\n  }\n\n  /**\n   * Create container for tables.\n   *\n   * @param {string} className The CSS classes to add.\n   * @returns {object}\n   */\n  createContainer() {\n    let className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    const container = rootDocument.createElement('div');\n    const containerClassName = `htGhostTable htAutoSize ${className.trim()}`;\n    addClass(container, containerClassName);\n    fragment.appendChild(container);\n    return {\n      fragment,\n      container\n    };\n  }\n\n  /**\n   * Checks if table is raised vertically (checking rows).\n   *\n   * @returns {boolean}\n   */\n  isVertical() {\n    return !!(this.rows.length && !this.columns.length);\n  }\n\n  /**\n   * Checks if table is raised horizontally (checking columns).\n   *\n   * @returns {boolean}\n   */\n  isHorizontal() {\n    return !!(this.columns.length && !this.rows.length);\n  }\n}\nexport default GhostTable;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","addClass","outerHeight","arrayEach","GhostTable","constructor","hotInstance","useHeaders","hot","addRow","row","samples","columns","length","Error","rows","container","createContainer","rootElement","className","rowObject","push","table","createTable","colGroup","appendChild","createColGroupsCol","tr","createRow","fragment","addColumnHeadersRow","colHeader","getColHeader","undefined","appendColumnHeadersRow","addColumn","column","columnObject","col","getSetting","view","appendColHeader","th","tBody","createCol","getHeights","callback","injected","injectTable","getWidths","width","getBoundingClientRect","Math","ceil","setSettings","settings","setSetting","name","getSettings","rootDocument","createDocumentFragment","hasRowHeaders","createColElement","forEach","sample","strings","string","createElement","appendRowHeader","cellProperties","getCellMeta","renderer","getCellRenderer","td","setAttribute","colToProp","domFragment","columnHeaders","tHead","columnHeader","clean","clear","removeTable","parent","arguments","parentNode","removeChild","colspan","getColWidth","nextColumn","style","isVertical","isHorizontal","tableLayout","containerClassName","trim"],"sources":["D:/gym-project/frontend/node_modules/handsontable/utils/ghostTable.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { addClass, outerHeight } from \"./../helpers/dom/element.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\n/**\n * @class GhostTable\n */\nclass GhostTable {\n  constructor(hotInstance) {\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    _defineProperty(this, \"hot\", null);\n    /**\n     * Container element where every table will be injected.\n     *\n     * @type {HTMLElement|null}\n     */\n    _defineProperty(this, \"container\", null);\n    /**\n     * Flag which determine is table was injected to DOM.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"injected\", false);\n    /**\n     * Added rows collection.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"rows\", []);\n    /**\n     * Added columns collection.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"columns\", []);\n    /**\n     * Samples prepared for calculations.\n     *\n     * @type {Map}\n     * @default {null}\n     */\n    _defineProperty(this, \"samples\", null);\n    /**\n     * Ghost table settings.\n     *\n     * @type {object}\n     * @default {Object}\n     */\n    _defineProperty(this, \"settings\", {\n      useHeaders: true\n    });\n    this.hot = hotInstance;\n  }\n\n  /**\n   * Add row.\n   *\n   * @param {number} row Visual row index.\n   * @param {Map} samples Samples Map object.\n   */\n  addRow(row, samples) {\n    if (this.columns.length) {\n      throw new Error('Doesn\\'t support multi-dimensional table');\n    }\n    if (!this.rows.length) {\n      this.container = this.createContainer(this.hot.rootElement.className);\n    }\n    const rowObject = {\n      row\n    };\n    this.rows.push(rowObject);\n    this.samples = samples;\n    this.table = this.createTable(this.hot.table.className);\n    this.table.colGroup.appendChild(this.createColGroupsCol(row));\n    this.table.tr.appendChild(this.createRow(row));\n    this.container.container.appendChild(this.table.fragment);\n    rowObject.table = this.table.table;\n  }\n\n  /**\n   * Add a row consisting of the column headers.\n   *\n   * @param {Map} samples A map with sampled table values.\n   */\n  addColumnHeadersRow(samples) {\n    const colHeader = this.hot.getColHeader(0);\n    if (colHeader !== null && colHeader !== undefined) {\n      const rowObject = {\n        row: -1\n      };\n      this.rows.push(rowObject);\n      this.container = this.createContainer(this.hot.rootElement.className);\n      this.samples = samples;\n      this.table = this.createTable(this.hot.table.className);\n      this.table.colGroup.appendChild(this.createColGroupsCol());\n      this.appendColumnHeadersRow();\n      this.container.container.appendChild(this.table.fragment);\n      rowObject.table = this.table.table;\n    }\n  }\n\n  /**\n   * Add column.\n   *\n   * @param {number} column Visual column index.\n   * @param {Map} samples A map with sampled table values.\n   */\n  addColumn(column, samples) {\n    if (this.rows.length) {\n      throw new Error('Doesn\\'t support multi-dimensional table');\n    }\n    if (!this.columns.length) {\n      this.container = this.createContainer(this.hot.rootElement.className);\n    }\n    const columnObject = {\n      col: column\n    };\n    this.columns.push(columnObject);\n    this.samples = samples;\n    this.table = this.createTable(this.hot.table.className);\n    if (this.getSetting('useHeaders') && this.hot.getColHeader(column) !== null) {\n      // Please keep in mind that the renderable column index equal to the visual columns index for the GhostTable.\n      // We render all columns.\n      this.hot.view.appendColHeader(column, this.table.th);\n    }\n    this.table.tBody.appendChild(this.createCol(column));\n    this.container.container.appendChild(this.table.fragment);\n    columnObject.table = this.table.table;\n  }\n\n  /**\n   * Get calculated heights.\n   *\n   * @param {Function} callback Callback which will be fired for each calculated row.\n   */\n  getHeights(callback) {\n    if (!this.injected) {\n      this.injectTable();\n    }\n    arrayEach(this.rows, row => {\n      // -1 <- reduce border-top from table\n      callback(row.row, outerHeight(row.table) - 1);\n    });\n  }\n\n  /**\n   * Get calculated widths.\n   *\n   * @param {Function} callback Callback which will be fired for each calculated column.\n   */\n  getWidths(callback) {\n    if (!this.injected) {\n      this.injectTable();\n    }\n    arrayEach(this.columns, column => {\n      // The GhostTable class is responsible for calculating the columns' width based on the\n      // contents rendered in the cells. In some cases, when the column's width calculated by\n      // the browser is a decimal point with a fractional component. For example, 35.32px.\n      // The usage of the `.offsetWidth` (or our helper `outerWidth`) is incorrect.\n      // The `outerWidth` in the mentioned example (35.32px) would return 35 pixels that\n      // would cause the text to not fit in the cell, thus increasing the row height.\n      // That's why the `getBoundingClientRect` method is used. The method returns the number\n      // that is rounded up to make sure that there will be a space for the cell's content.\n      const {\n        width\n      } = column.table.getBoundingClientRect();\n      callback(column.col, Math.ceil(width));\n    });\n  }\n\n  /**\n   * Set the Ghost Table settings to the provided object.\n   *\n   * @param {object} settings New Ghost Table Settings.\n   */\n  setSettings(settings) {\n    this.settings = settings;\n  }\n\n  /**\n   * Set a single setting of the Ghost Table.\n   *\n   * @param {string} name Setting name.\n   * @param {*} value Setting value.\n   */\n  setSetting(name, value) {\n    if (!this.settings) {\n      this.settings = {};\n    }\n    this.settings[name] = value;\n  }\n\n  /**\n   * Get the Ghost Table settings.\n   *\n   * @returns {object|null}\n   */\n  getSettings() {\n    return this.settings;\n  }\n\n  /**\n   * Get a single Ghost Table setting.\n   *\n   * @param {string} name The setting name to get.\n   * @returns {boolean|null}\n   */\n  getSetting(name) {\n    if (this.settings) {\n      return this.settings[name];\n    }\n    return null;\n  }\n\n  /**\n   * Create colgroup col elements.\n   *\n   * @param {number} row Visual row index.\n   * @returns {DocumentFragment}\n   */\n  createColGroupsCol(row) {\n    const fragment = this.hot.rootDocument.createDocumentFragment();\n    if (this.hot.hasRowHeaders()) {\n      fragment.appendChild(this.createColElement(-1, -1));\n    }\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        fragment.appendChild(this.createColElement(string.col, row));\n      });\n    });\n    return fragment;\n  }\n\n  /**\n   * Create table row element.\n   *\n   * @param {number} row Visual row index.\n   * @returns {DocumentFragment} Returns created table row elements.\n   */\n  createRow(row) {\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    const th = rootDocument.createElement('th');\n    if (this.hot.hasRowHeaders()) {\n      this.hot.view.appendRowHeader(row, th);\n      fragment.appendChild(th);\n    }\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        const column = string.col;\n        const cellProperties = this.hot.getCellMeta(row, column);\n        const renderer = this.hot.getCellRenderer(cellProperties);\n        const td = rootDocument.createElement('td');\n\n        // Indicate that this element is created and supported by GhostTable. It can be useful to\n        // exclude rendering performance costly logic or exclude logic which doesn't work within a hidden table.\n        td.setAttribute('ghost-table', 1);\n        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);\n        fragment.appendChild(td);\n      });\n    });\n    return fragment;\n  }\n\n  /**\n   * Creates DOM elements for headers and appends them to the THEAD element of the table.\n   */\n  appendColumnHeadersRow() {\n    const {\n      rootDocument\n    } = this.hot;\n    const domFragment = rootDocument.createDocumentFragment();\n    const columnHeaders = [];\n    if (this.hot.hasRowHeaders()) {\n      const th = rootDocument.createElement('th');\n      columnHeaders.push([-1, th]);\n      domFragment.appendChild(th);\n    }\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        const column = string.col;\n        const th = rootDocument.createElement('th');\n        columnHeaders.push([column, th]);\n        domFragment.appendChild(th);\n      });\n    });\n\n    // Appending DOM elements for headers\n    this.table.tHead.appendChild(domFragment);\n    arrayEach(columnHeaders, columnHeader => {\n      const [column, th] = columnHeader;\n\n      // Using source method for filling a header with value.\n      this.hot.view.appendColHeader(column, th);\n    });\n  }\n\n  /**\n   * Create table column elements.\n   *\n   * @param {number} column Visual column index.\n   * @returns {DocumentFragment} Returns created column table column elements.\n   */\n  createCol(column) {\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    this.samples.forEach(sample => {\n      arrayEach(sample.strings, string => {\n        const row = string.row;\n        const cellProperties = this.hot.getCellMeta(row, column);\n        const renderer = this.hot.getCellRenderer(cellProperties);\n        const td = rootDocument.createElement('td');\n        const tr = rootDocument.createElement('tr');\n\n        // Indicate that this element is created and supported by GhostTable. It can be useful to\n        // exclude rendering performance costly logic or exclude logic which doesn't work within a hidden table.\n        td.setAttribute('ghost-table', 1);\n        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);\n        tr.appendChild(td);\n        fragment.appendChild(tr);\n      });\n    });\n    return fragment;\n  }\n\n  /**\n   * Remove table from document and reset internal state.\n   */\n  clean() {\n    this.rows.length = 0;\n    this.rows[-1] = undefined;\n    this.columns.length = 0;\n    if (this.samples) {\n      this.samples.clear();\n    }\n    this.samples = null;\n    this.removeTable();\n  }\n\n  /**\n   * Inject generated table into document.\n   *\n   * @param {HTMLElement} [parent=null] The element to which the ghost table is injected.\n   */\n  injectTable() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (!this.injected) {\n      (parent || this.hot.rootElement).appendChild(this.container.fragment);\n      this.injected = true;\n    }\n  }\n\n  /**\n   * Remove table from document.\n   */\n  removeTable() {\n    if (this.injected && this.container.container.parentNode) {\n      this.container.container.parentNode.removeChild(this.container.container);\n      this.container = null;\n      this.injected = false;\n    }\n  }\n\n  /**\n   * Create col element.\n   *\n   * @param {number} column Visual column index.\n   * @param {number} row Visual row index.\n   * @returns {HTMLElement}\n   */\n  createColElement(column, row) {\n    const col = this.hot.rootDocument.createElement('col');\n    let colspan = 0;\n    if (row >= 0 && column >= 0) {\n      colspan = this.hot.getCellMeta(row, column).colspan;\n    }\n    let width = this.hot.getColWidth(column);\n    if (colspan > 1) {\n      for (let nextColumn = column + 1; nextColumn < column + colspan; nextColumn++) {\n        width += this.hot.getColWidth(nextColumn);\n      }\n    }\n    col.style.width = `${width}px`;\n    return col;\n  }\n\n  /**\n   * Create table element.\n   *\n   * @param {string} className The CSS classes to add.\n   * @returns {object}\n   */\n  createTable() {\n    let className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    const table = rootDocument.createElement('table');\n    const tHead = rootDocument.createElement('thead');\n    const tBody = rootDocument.createElement('tbody');\n    const colGroup = rootDocument.createElement('colgroup');\n    const tr = rootDocument.createElement('tr');\n    const th = rootDocument.createElement('th');\n    if (this.isVertical()) {\n      table.appendChild(colGroup);\n    }\n    if (this.isHorizontal()) {\n      tr.appendChild(th);\n      tHead.appendChild(tr);\n      table.style.tableLayout = 'auto';\n      table.style.width = 'auto';\n    }\n    table.appendChild(tHead);\n    if (this.isVertical()) {\n      tBody.appendChild(tr);\n    }\n    table.appendChild(tBody);\n    addClass(table, className);\n    fragment.appendChild(table);\n    return {\n      fragment,\n      table,\n      tHead,\n      tBody,\n      colGroup,\n      tr,\n      th\n    };\n  }\n\n  /**\n   * Create container for tables.\n   *\n   * @param {string} className The CSS classes to add.\n   * @returns {object}\n   */\n  createContainer() {\n    let className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    const {\n      rootDocument\n    } = this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    const container = rootDocument.createElement('div');\n    const containerClassName = `htGhostTable htAutoSize ${className.trim()}`;\n    addClass(container, containerClassName);\n    fragment.appendChild(container);\n    return {\n      fragment,\n      container\n    };\n  }\n\n  /**\n   * Checks if table is raised vertically (checking rows).\n   *\n   * @returns {boolean}\n   */\n  isVertical() {\n    return !!(this.rows.length && !this.columns.length);\n  }\n\n  /**\n   * Checks if table is raised horizontally (checking columns).\n   *\n   * @returns {boolean}\n   */\n  isHorizontal() {\n    return !!(this.columns.length && !this.rows.length);\n  }\n}\nexport default GhostTable;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}