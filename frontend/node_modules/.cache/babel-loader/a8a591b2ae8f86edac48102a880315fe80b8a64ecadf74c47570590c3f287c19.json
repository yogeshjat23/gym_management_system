{"ast":null,"code":"import { htmlRenderer } from \"../htmlRenderer/index.mjs\";\nimport { textRenderer } from \"../textRenderer/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { addClass, hasClass } from \"../../helpers/dom/element.mjs\";\nimport { A11Y_HIDDEN } from \"../../helpers/a11y.mjs\";\nexport const RENDERER_TYPE = 'autocomplete';\n\n/**\n * Autocomplete renderer.\n *\n * @private\n * @param {Core} hotInstance The Handsontable instance.\n * @param {HTMLTableCellElement} TD The rendered cell element.\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\n * @param {*} value The rendered value.\n * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n */\nexport function autocompleteRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = hotInstance;\n  const rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;\n  const ARROW = rootDocument.createElement('DIV');\n  const isAriaEnabled = hotInstance.getSettings().ariaTags;\n  ARROW.className = 'htAutocompleteArrow';\n  if (isAriaEnabled) {\n    ARROW.setAttribute(...A11Y_HIDDEN());\n  }\n  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));\n  rendererFunc.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);\n  if (!TD.firstChild) {\n    // http://jsperf.com/empty-node-if-needed\n    // otherwise empty fields appear borderless in demo/renderers.html (IE)\n    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160))); // workaround for https://github.com/handsontable/handsontable/issues/1946\n    // this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n  }\n  TD.insertBefore(ARROW, TD.firstChild);\n  addClass(TD, 'htAutocomplete');\n  if (!hotInstance.acArrowListener) {\n    const eventManager = new EventManager(hotInstance);\n\n    // not very elegant but easy and fast\n    hotInstance.acArrowListener = function (event) {\n      if (hasClass(event.target, 'htAutocompleteArrow')) {\n        hotInstance.view._wt.getSetting('onCellDblClick', null, hotInstance._createCellCoords(row, col), TD);\n      }\n    };\n    eventManager.addEventListener(hotInstance.rootElement, 'mousedown', hotInstance.acArrowListener);\n\n    // We need to unbind the listener after the table has been destroyed\n    hotInstance.addHookOnce('afterDestroy', () => {\n      eventManager.destroy();\n    });\n  }\n}\nautocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE;","map":{"version":3,"names":["htmlRenderer","textRenderer","EventManager","addClass","hasClass","A11Y_HIDDEN","RENDERER_TYPE","autocompleteRenderer","hotInstance","TD","row","col","prop","value","cellProperties","rootDocument","rendererFunc","allowHtml","ARROW","createElement","isAriaEnabled","getSettings","ariaTags","className","setAttribute","appendChild","createTextNode","String","fromCharCode","apply","firstChild","insertBefore","acArrowListener","eventManager","event","target","view","_wt","getSetting","_createCellCoords","addEventListener","rootElement","addHookOnce","destroy"],"sources":["D:/gym-project/frontend/node_modules/handsontable/renderers/autocompleteRenderer/autocompleteRenderer.mjs"],"sourcesContent":["import { htmlRenderer } from \"../htmlRenderer/index.mjs\";\nimport { textRenderer } from \"../textRenderer/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { addClass, hasClass } from \"../../helpers/dom/element.mjs\";\nimport { A11Y_HIDDEN } from \"../../helpers/a11y.mjs\";\nexport const RENDERER_TYPE = 'autocomplete';\n\n/**\n * Autocomplete renderer.\n *\n * @private\n * @param {Core} hotInstance The Handsontable instance.\n * @param {HTMLTableCellElement} TD The rendered cell element.\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\n * @param {*} value The rendered value.\n * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n */\nexport function autocompleteRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = hotInstance;\n  const rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;\n  const ARROW = rootDocument.createElement('DIV');\n  const isAriaEnabled = hotInstance.getSettings().ariaTags;\n  ARROW.className = 'htAutocompleteArrow';\n  if (isAriaEnabled) {\n    ARROW.setAttribute(...A11Y_HIDDEN());\n  }\n  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));\n  rendererFunc.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);\n  if (!TD.firstChild) {\n    // http://jsperf.com/empty-node-if-needed\n    // otherwise empty fields appear borderless in demo/renderers.html (IE)\n    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160))); // workaround for https://github.com/handsontable/handsontable/issues/1946\n    // this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n  }\n  TD.insertBefore(ARROW, TD.firstChild);\n  addClass(TD, 'htAutocomplete');\n  if (!hotInstance.acArrowListener) {\n    const eventManager = new EventManager(hotInstance);\n\n    // not very elegant but easy and fast\n    hotInstance.acArrowListener = function (event) {\n      if (hasClass(event.target, 'htAutocompleteArrow')) {\n        hotInstance.view._wt.getSetting('onCellDblClick', null, hotInstance._createCellCoords(row, col), TD);\n      }\n    };\n    eventManager.addEventListener(hotInstance.rootElement, 'mousedown', hotInstance.acArrowListener);\n\n    // We need to unbind the listener after the table has been destroyed\n    hotInstance.addHookOnce('afterDestroy', () => {\n      eventManager.destroy();\n    });\n  }\n}\nautocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE;"],"mappings":"AAAA,SAASA,YAAY,QAAQ,2BAA2B;AACxD,SAASC,YAAY,QAAQ,2BAA2B;AACxD,OAAOC,YAAY,MAAM,wBAAwB;AACjD,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,+BAA+B;AAClE,SAASC,WAAW,QAAQ,wBAAwB;AACpD,OAAO,MAAMC,aAAa,GAAG,cAAc;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACC,WAAW,EAAEC,EAAE,EAAEC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,KAAK,EAAEC,cAAc,EAAE;EAC3F,MAAM;IACJC;EACF,CAAC,GAAGP,WAAW;EACf,MAAMQ,YAAY,GAAGF,cAAc,CAACG,SAAS,GAAGjB,YAAY,GAAGC,YAAY;EAC3E,MAAMiB,KAAK,GAAGH,YAAY,CAACI,aAAa,CAAC,KAAK,CAAC;EAC/C,MAAMC,aAAa,GAAGZ,WAAW,CAACa,WAAW,CAAC,CAAC,CAACC,QAAQ;EACxDJ,KAAK,CAACK,SAAS,GAAG,qBAAqB;EACvC,IAAIH,aAAa,EAAE;IACjBF,KAAK,CAACM,YAAY,CAAC,GAAGnB,WAAW,CAAC,CAAC,CAAC;EACtC;EACAa,KAAK,CAACO,WAAW,CAACV,YAAY,CAACW,cAAc,CAACC,MAAM,CAACC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;EACzEZ,YAAY,CAACa,KAAK,CAAC,IAAI,EAAE,CAACrB,WAAW,EAAEC,EAAE,EAAEC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,KAAK,EAAEC,cAAc,CAAC,CAAC;EAClF,IAAI,CAACL,EAAE,CAACqB,UAAU,EAAE;IAClB;IACA;IACArB,EAAE,CAACgB,WAAW,CAACV,YAAY,CAACW,cAAc,CAACC,MAAM,CAACC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACvE;EACF;EACAnB,EAAE,CAACsB,YAAY,CAACb,KAAK,EAAET,EAAE,CAACqB,UAAU,CAAC;EACrC3B,QAAQ,CAACM,EAAE,EAAE,gBAAgB,CAAC;EAC9B,IAAI,CAACD,WAAW,CAACwB,eAAe,EAAE;IAChC,MAAMC,YAAY,GAAG,IAAI/B,YAAY,CAACM,WAAW,CAAC;;IAElD;IACAA,WAAW,CAACwB,eAAe,GAAG,UAAUE,KAAK,EAAE;MAC7C,IAAI9B,QAAQ,CAAC8B,KAAK,CAACC,MAAM,EAAE,qBAAqB,CAAC,EAAE;QACjD3B,WAAW,CAAC4B,IAAI,CAACC,GAAG,CAACC,UAAU,CAAC,gBAAgB,EAAE,IAAI,EAAE9B,WAAW,CAAC+B,iBAAiB,CAAC7B,GAAG,EAAEC,GAAG,CAAC,EAAEF,EAAE,CAAC;MACtG;IACF,CAAC;IACDwB,YAAY,CAACO,gBAAgB,CAAChC,WAAW,CAACiC,WAAW,EAAE,WAAW,EAAEjC,WAAW,CAACwB,eAAe,CAAC;;IAEhG;IACAxB,WAAW,CAACkC,WAAW,CAAC,cAAc,EAAE,MAAM;MAC5CT,YAAY,CAACU,OAAO,CAAC,CAAC;IACxB,CAAC,CAAC;EACJ;AACF;AACApC,oBAAoB,CAACD,aAAa,GAAGA,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}