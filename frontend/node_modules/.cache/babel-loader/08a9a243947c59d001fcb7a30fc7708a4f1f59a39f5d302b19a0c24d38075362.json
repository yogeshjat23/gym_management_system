{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nexport const PLUGIN_KEY = 'autoRowSize';\nexport const PLUGIN_PRIORITY = 40;\nconst ROW_WIDTHS_MAP_NAME = 'autoRowSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoRowSize\n * @class AutoRowSize\n * @description\n * The `AutoRowSize` plugin allows you to set row heights based on their highest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it disabled (same as if it was declared as `false`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the heights of all cells to\n * resize the rows accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the row heights manually.\n *\n * But, to display Handsontable's [scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)\n * in a proper size, you need to enable the `AutoRowSize` plugin,\n * by setting the [`autoRowSize`](@/api/options.md#autoRowSize) option to `true`.\n *\n * Row height calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of rows) or a percentage value to a config object:\n * ```js\n * // as a number (300 rows in sync, rest async)\n * autoRowSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoRowSize: {syncLimit: '40%'},\n *\n * // allow sample duplication\n * autoRowSize: {syncLimit: '40%', allowSampleDuplicates: true},\n * ```\n *\n * You can also use the `allowSampleDuplicates` option to allow sampling duplicate values when calculating the row\n * height. __Note__, that this might have a negative impact on performance.\n *\n * To configure this plugin see {@link Options#autoRowSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoRowSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoRowSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _visualRowsToRefresh = /*#__PURE__*/new WeakMap();\nvar _AutoRowSize_brand = /*#__PURE__*/new WeakSet();\nexport class AutoRowSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 500;\n  }\n\n  /**\n   * Columns header's height cache.\n   *\n   * @private\n   * @type {number}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * Calculates specific rows height (overwrite cache values).\n     *\n     * @param {number[]} visualRows List of visual rows to calculate.\n     */\n    _classPrivateMethodInitSpec(this, _AutoRowSize_brand);\n    _defineProperty(this, \"headerHeight\", null);\n    /**\n     * Instance of {@link GhostTable} for rows and columns size calculations.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for rows height calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      const physicalRow = this.hot.toPhysicalRow(row);\n      const physicalColumn = this.hot.toPhysicalColumn(column);\n      if (this.hot.rowIndexMapper.isHidden(physicalRow) || this.hot.columnIndexMapper.isHidden(physicalColumn)) {\n        return false;\n      }\n      if (row >= 0 && column >= 0) {\n        const cellMeta = this.hot.getCellMeta(row, column);\n        if (cellMeta.hidden) {\n          // do not generate samples for cells that are covered by merged cell (null values)\n          return false;\n        }\n      }\n      let cellValue;\n      if (row >= 0) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      } else if (row === -1) {\n        cellValue = this.hot.getColHeader(column);\n      }\n      return {\n        value: cellValue\n      };\n    }));\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured rows (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredRows\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track heights for physical row indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"rowHeightsMap\", new IndexToValueMap());\n    /**\n     * An array of row indexes whose height will be recalculated.\n     *\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _visualRowsToRefresh, []);\n    this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, this.rowHeightsMap);\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necessary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _assertClassBrand(_AutoRowSize_brand, this, _onBeforeRowResize).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    return settings === true || isObject(settings);\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_AutoRowSize_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_AutoRowSize_brand, _this, _onBeforeChange).call(_this, ...args);\n    });\n    this.addHook('beforeColumnResize', () => this.recalculateAllRowsHeight());\n    this.addHook('afterFormulasValuesUpdate', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_AutoRowSize_brand, _this, _onAfterFormulasValuesUpdate).call(_this, ...args);\n    });\n    this.addHook('beforeRender', () => _assertClassBrand(_AutoRowSize_brand, this, _onBeforeRender).call(this));\n    this.addHook('modifyRowHeight', (height, row) => this.getRowHeight(row, height));\n    this.addHook('init', () => _assertClassBrand(_AutoRowSize_brand, this, _onInit).call(this));\n    this.addHook('modifyColumnHeaderHeight', () => this.getColumnHeaderHeight());\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.headerHeight = null;\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necessary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _assertClassBrand(_AutoRowSize_brand, this, _onBeforeRowResize).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Calculates heights for visible rows in the viewport only.\n   */\n  calculateVisibleRowsHeight() {\n    // Keep last row heights unchanged for situation when all columns was deleted or trimmed\n    if (!this.hot.countCols()) {\n      return;\n    }\n    const firstVisibleRow = this.getFirstVisibleRow();\n    const lastVisibleRow = this.getLastVisibleRow();\n    if (firstVisibleRow === -1 || lastVisibleRow === -1) {\n      return;\n    }\n    const overwriteCache = this.hot.renderCall;\n    this.calculateRowsHeight({\n      from: firstVisibleRow,\n      to: lastVisibleRow\n    }, undefined, overwriteCache);\n  }\n\n  /**\n   * Calculate a given rows height.\n   *\n   * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.\n   * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.\n   * @param {boolean} [overwriteCache=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateRowsHeight() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let colRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let overwriteCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    if (this.hot.getColHeader(0) !== null) {\n      const samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);\n      this.ghostTable.addColumnHeadersRow(samples.get(-1));\n    }\n    rangeEach(rowsRange.from, rowsRange.to, visualRow => {\n      let physicalRow = this.hot.toPhysicalRow(visualRow);\n      if (physicalRow === null) {\n        physicalRow = visualRow;\n      }\n\n      // For rows we must calculate row height even when user had set height value manually.\n      // We can shrink column but cannot shrink rows!\n      if (overwriteCache || this.rowHeightsMap.getValueAtIndex(physicalRow) === null) {\n        const samples = this.samplesGenerator.generateRowSamples(visualRow, columnsRange);\n        samples.forEach((sample, row) => this.ghostTable.addRow(row, sample));\n      }\n    });\n    if (this.ghostTable.rows.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getHeights((row, height) => {\n          if (row < 0) {\n            this.headerHeight = height;\n          } else {\n            this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);\n          }\n        });\n      }, true);\n      this.measuredRows = rowsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.\n   * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.\n   *\n   * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.\n   * @param {boolean} [overwriteCache] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateAllRowsHeight() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let overwriteCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let current = 0;\n    const length = this.hot.countRows() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateRowsHeight({\n        from: current,\n        to: Math.min(current + AutoRowSize.CALCULATION_STEP, length)\n      }, colRange, overwriteCache);\n      current = current + AutoRowSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize();\n\n        // tmp\n        if (this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {\n          this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();\n        }\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (syncLimit >= 0) {\n      this.calculateRowsHeight({\n        from: 0,\n        to: syncLimit\n      }, colRange, overwriteCache);\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n      this.hot.view.adjustElementsSize();\n    }\n  }\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all rows height (overwrite cache values).\n   */\n  recalculateAllRowsHeight() {\n    if (this.hot.view.isVisible()) {\n      this.calculateAllRowsHeight({\n        from: 0,\n        to: this.hot.countCols() - 1\n      }, true);\n    }\n  }\n\n  /**\n   * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoRowSize.SYNC_CALCULATION_LIMIT;\n    const rowsLimit = this.hot.countRows() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(rowsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, rowsLimit);\n  }\n\n  /**\n   * Get a row's height, as measured in the DOM.\n   *\n   * The height returned includes 1 px of the row's bottom border.\n   *\n   * Mind that this method is different from the\n   * [`getRowHeight()`](@/api/core.md#getrowheight) method\n   * of Handsontable's [Core](@/api/core.md).\n   *\n   * @param {number} row A visual row index.\n   * @param {number} [defaultHeight] If no height is found, `defaultHeight` is returned instead.\n   * @returns {number} The height of the specified row, in pixels.\n   */\n  getRowHeight(row, defaultHeight) {\n    const cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));\n    let height = defaultHeight;\n    if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {\n      height = cachedHeight;\n    }\n    return height;\n  }\n\n  /**\n   * Get the calculated column header height.\n   *\n   * @returns {number|undefined}\n   */\n  getColumnHeaderHeight() {\n    return this.headerHeight;\n  }\n\n  /**\n   * Get the first visible row.\n   *\n   * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.\n   */\n  getFirstVisibleRow() {\n    var _this$hot$view$getFir;\n    return (_this$hot$view$getFir = this.hot.view.getFirstRenderedVisibleRow()) !== null && _this$hot$view$getFir !== void 0 ? _this$hot$view$getFir : -1;\n  }\n\n  /**\n   * Gets the last visible row.\n   *\n   * @returns {number} Returns row index or -1 if table is not rendered.\n   */\n  getLastVisibleRow() {\n    var _this$hot$view$getLas;\n    return (_this$hot$view$getLas = this.hot.view.getLastRenderedVisibleRow()) !== null && _this$hot$view$getLas !== void 0 ? _this$hot$view$getLas : -1;\n  }\n\n  /**\n   * Clears cache of calculated row heights. If you want to clear only selected rows pass an array with their indexes.\n   * Otherwise whole cache will be cleared.\n   *\n   * @param {number[]} [physicalRows] List of physical row indexes to clear.\n   */\n  clearCache(physicalRows) {\n    this.headerHeight = null;\n    if (Array.isArray(physicalRows)) {\n      this.hot.batchExecution(() => {\n        physicalRows.forEach(physicalIndex => {\n          this.rowHeightsMap.setValueAtIndex(physicalIndex, null);\n        });\n      }, true);\n    } else {\n      this.rowHeightsMap.clear();\n    }\n  }\n\n  /**\n   * Clears cache by range.\n   *\n   * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.\n   */\n  clearCacheByRange(range) {\n    const {\n      from,\n      to\n    } = typeof range === 'number' ? {\n      from: range,\n      to: range\n    } : range;\n    this.hot.batchExecution(() => {\n      rangeEach(Math.min(from, to), Math.max(from, to), row => {\n        this.rowHeightsMap.setValueAtIndex(row, null);\n      });\n    }, true);\n  }\n\n  /**\n   * Checks if all heights were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!this.rowHeightsMap.getValues().slice(0, this.measuredRows).filter(item => item === null).length;\n  }\n\n  /**\n   * On before view render listener.\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _calculateSpecificRowsHeight(visualRows) {\n  const columnsRange = {\n    from: 0,\n    to: this.hot.countCols() - 1\n  };\n  visualRows.forEach(visualRow => {\n    // For rows we must calculate row height even when user had set height value manually.\n    // We can shrink column but cannot shrink rows!\n    const samples = this.samplesGenerator.generateRowSamples(visualRow, columnsRange);\n    samples.forEach((sample, row) => this.ghostTable.addRow(row, sample));\n  });\n  if (this.ghostTable.rows.length) {\n    this.hot.batchExecution(() => {\n      this.ghostTable.getHeights((visualRow, height) => {\n        const physicalRow = this.hot.toPhysicalRow(visualRow);\n        this.rowHeightsMap.setValueAtIndex(physicalRow, height);\n      });\n    }, true);\n    this.ghostTable.clean();\n  }\n}\nfunction _onBeforeRender() {\n  this.calculateVisibleRowsHeight();\n  if (!this.inProgress) {\n    _assertClassBrand(_AutoRowSize_brand, this, _calculateSpecificRowsHeight).call(this, _classPrivateFieldGet(_visualRowsToRefresh, this));\n    _classPrivateFieldSet(_visualRowsToRefresh, this, []);\n  }\n}\n/**\n * On before row resize listener.\n *\n * @param {number} size The size of the current row index.\n * @param {number} row Current row index.\n * @param {boolean} isDblClick Indicates if the resize was triggered by doubleclick.\n * @returns {number}\n */\nfunction _onBeforeRowResize(size, row, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateRowsHeight(row, undefined, true);\n    newSize = this.getRowHeight(row);\n  }\n  return newSize;\n}\n/**\n * On after load data listener.\n *\n * @param {Array} sourceData Source data.\n * @param {boolean} isFirstLoad `true` if this is the first load.\n */\nfunction _onAfterLoadData(sourceData, isFirstLoad) {\n  if (!isFirstLoad) {\n    this.recalculateAllRowsHeight();\n  }\n}\n/**\n * On before change listener.\n *\n * @param {Array} changes 2D array containing information about each of the edited cells.\n */\nfunction _onBeforeChange(changes) {\n  const changedRows = changes.reduce((acc, _ref) => {\n    let [row] = _ref;\n    if (acc.indexOf(row) === -1) {\n      acc.push(row);\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualRowsToRefresh, this).push(...changedRows);\n}\n/**\n * On after Handsontable init plugin with all necessary values.\n */\nfunction _onInit() {\n  this.recalculateAllRowsHeight();\n}\n/**\n * After formulas values updated listener.\n *\n * @param {Array} changes An array of modified data.\n */\nfunction _onAfterFormulasValuesUpdate(changes) {\n  const changedRows = changes.reduce((acc, change) => {\n    var _change$address;\n    const physicalRow = (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.row;\n    if (Number.isInteger(physicalRow)) {\n      const visualRow = this.hot.toVisualRow(physicalRow);\n      if (acc.indexOf(visualRow) === -1) {\n        acc.push(visualRow);\n      }\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualRowsToRefresh, this).push(...changedRows);\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldSet","s","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","BasePlugin","cancelAnimationFrame","requestAnimationFrame","GhostTable","isObject","hasOwnProperty","valueAccordingPercent","rangeEach","SamplesGenerator","isPercentValue","PhysicalIndexToValueMap","IndexToValueMap","PLUGIN_KEY","PLUGIN_PRIORITY","ROW_WIDTHS_MAP_NAME","_visualRowsToRefresh","WeakMap","_AutoRowSize_brand","WeakSet","AutoRowSize","SETTING_KEYS","CALCULATION_STEP","SYNC_CALCULATION_LIMIT","constructor","hotInstance","hot","row","column","physicalRow","toPhysicalRow","physicalColumn","toPhysicalColumn","rowIndexMapper","isHidden","columnIndexMapper","cellMeta","getCellMeta","hidden","cellValue","getDataAtCell","getColHeader","registerMap","rowHeightsMap","addHook","size","isDblClick","_onBeforeRowResize","isEnabled","settings","getSettings","enablePlugin","_this","enabled","setSamplingOptions","_len","args","Array","_key","_onAfterLoadData","_len2","_key2","_onBeforeChange","recalculateAllRowsHeight","_len3","_key3","_onAfterFormulasValuesUpdate","_onBeforeRender","height","getRowHeight","_onInit","getColumnHeaderHeight","disablePlugin","headerHeight","calculateVisibleRowsHeight","countCols","firstVisibleRow","getFirstVisibleRow","lastVisibleRow","getLastVisibleRow","overwriteCache","renderCall","calculateRowsHeight","from","to","undefined","rowRange","countRows","colRange","rowsRange","columnsRange","samples","samplesGenerator","generateRowSamples","ghostTable","addColumnHeadersRow","visualRow","getValueAtIndex","forEach","sample","addRow","rows","batchExecution","getHeights","setValueAtIndex","measuredRows","clean","calculateAllRowsHeight","current","timer","inProgress","loop","Math","min","view","adjustElementsSize","_wt","wtOverlays","inlineStartOverlay","needFullRender","clone","draw","syncLimit","getSyncCalculationLimit","setting","samplingRatio","allowSampleDuplicates","isNaN","setSampleCount","parseInt","setAllowDuplicates","isVisible","limit","rowsLimit","defaultHeight","cachedHeight","_this$hot$view$getFir","getFirstRenderedVisibleRow","_this$hot$view$getLas","getLastRenderedVisibleRow","clearCache","physicalRows","isArray","physicalIndex","clear","clearCacheByRange","range","max","isNeedRecalculate","getValues","slice","filter","item","destroy","_calculateSpecificRowsHeight","visualRows","newSize","sourceData","isFirstLoad","changes","changedRows","reduce","acc","_ref","indexOf","push","change","_change$address","address","isInteger","toVisualRow"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/autoRowSize/autoRowSize.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nexport const PLUGIN_KEY = 'autoRowSize';\nexport const PLUGIN_PRIORITY = 40;\nconst ROW_WIDTHS_MAP_NAME = 'autoRowSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoRowSize\n * @class AutoRowSize\n * @description\n * The `AutoRowSize` plugin allows you to set row heights based on their highest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it disabled (same as if it was declared as `false`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the heights of all cells to\n * resize the rows accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the row heights manually.\n *\n * But, to display Handsontable's [scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)\n * in a proper size, you need to enable the `AutoRowSize` plugin,\n * by setting the [`autoRowSize`](@/api/options.md#autoRowSize) option to `true`.\n *\n * Row height calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of rows) or a percentage value to a config object:\n * ```js\n * // as a number (300 rows in sync, rest async)\n * autoRowSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoRowSize: {syncLimit: '40%'},\n *\n * // allow sample duplication\n * autoRowSize: {syncLimit: '40%', allowSampleDuplicates: true},\n * ```\n *\n * You can also use the `allowSampleDuplicates` option to allow sampling duplicate values when calculating the row\n * height. __Note__, that this might have a negative impact on performance.\n *\n * To configure this plugin see {@link Options#autoRowSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoRowSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoRowSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _visualRowsToRefresh = /*#__PURE__*/new WeakMap();\nvar _AutoRowSize_brand = /*#__PURE__*/new WeakSet();\nexport class AutoRowSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 500;\n  }\n\n  /**\n   * Columns header's height cache.\n   *\n   * @private\n   * @type {number}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * Calculates specific rows height (overwrite cache values).\n     *\n     * @param {number[]} visualRows List of visual rows to calculate.\n     */\n    _classPrivateMethodInitSpec(this, _AutoRowSize_brand);\n    _defineProperty(this, \"headerHeight\", null);\n    /**\n     * Instance of {@link GhostTable} for rows and columns size calculations.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for rows height calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      const physicalRow = this.hot.toPhysicalRow(row);\n      const physicalColumn = this.hot.toPhysicalColumn(column);\n      if (this.hot.rowIndexMapper.isHidden(physicalRow) || this.hot.columnIndexMapper.isHidden(physicalColumn)) {\n        return false;\n      }\n      if (row >= 0 && column >= 0) {\n        const cellMeta = this.hot.getCellMeta(row, column);\n        if (cellMeta.hidden) {\n          // do not generate samples for cells that are covered by merged cell (null values)\n          return false;\n        }\n      }\n      let cellValue;\n      if (row >= 0) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      } else if (row === -1) {\n        cellValue = this.hot.getColHeader(column);\n      }\n      return {\n        value: cellValue\n      };\n    }));\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured rows (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredRows\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track heights for physical row indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"rowHeightsMap\", new IndexToValueMap());\n    /**\n     * An array of row indexes whose height will be recalculated.\n     *\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _visualRowsToRefresh, []);\n    this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, this.rowHeightsMap);\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necessary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _assertClassBrand(_AutoRowSize_brand, this, _onBeforeRowResize).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    return settings === true || isObject(settings);\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_AutoRowSize_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_AutoRowSize_brand, _this, _onBeforeChange).call(_this, ...args);\n    });\n    this.addHook('beforeColumnResize', () => this.recalculateAllRowsHeight());\n    this.addHook('afterFormulasValuesUpdate', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_AutoRowSize_brand, _this, _onAfterFormulasValuesUpdate).call(_this, ...args);\n    });\n    this.addHook('beforeRender', () => _assertClassBrand(_AutoRowSize_brand, this, _onBeforeRender).call(this));\n    this.addHook('modifyRowHeight', (height, row) => this.getRowHeight(row, height));\n    this.addHook('init', () => _assertClassBrand(_AutoRowSize_brand, this, _onInit).call(this));\n    this.addHook('modifyColumnHeaderHeight', () => this.getColumnHeaderHeight());\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.headerHeight = null;\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necessary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _assertClassBrand(_AutoRowSize_brand, this, _onBeforeRowResize).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Calculates heights for visible rows in the viewport only.\n   */\n  calculateVisibleRowsHeight() {\n    // Keep last row heights unchanged for situation when all columns was deleted or trimmed\n    if (!this.hot.countCols()) {\n      return;\n    }\n    const firstVisibleRow = this.getFirstVisibleRow();\n    const lastVisibleRow = this.getLastVisibleRow();\n    if (firstVisibleRow === -1 || lastVisibleRow === -1) {\n      return;\n    }\n    const overwriteCache = this.hot.renderCall;\n    this.calculateRowsHeight({\n      from: firstVisibleRow,\n      to: lastVisibleRow\n    }, undefined, overwriteCache);\n  }\n\n  /**\n   * Calculate a given rows height.\n   *\n   * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.\n   * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.\n   * @param {boolean} [overwriteCache=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateRowsHeight() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let colRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let overwriteCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    if (this.hot.getColHeader(0) !== null) {\n      const samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);\n      this.ghostTable.addColumnHeadersRow(samples.get(-1));\n    }\n    rangeEach(rowsRange.from, rowsRange.to, visualRow => {\n      let physicalRow = this.hot.toPhysicalRow(visualRow);\n      if (physicalRow === null) {\n        physicalRow = visualRow;\n      }\n\n      // For rows we must calculate row height even when user had set height value manually.\n      // We can shrink column but cannot shrink rows!\n      if (overwriteCache || this.rowHeightsMap.getValueAtIndex(physicalRow) === null) {\n        const samples = this.samplesGenerator.generateRowSamples(visualRow, columnsRange);\n        samples.forEach((sample, row) => this.ghostTable.addRow(row, sample));\n      }\n    });\n    if (this.ghostTable.rows.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getHeights((row, height) => {\n          if (row < 0) {\n            this.headerHeight = height;\n          } else {\n            this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);\n          }\n        });\n      }, true);\n      this.measuredRows = rowsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.\n   * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.\n   *\n   * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.\n   * @param {boolean} [overwriteCache] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateAllRowsHeight() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let overwriteCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let current = 0;\n    const length = this.hot.countRows() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateRowsHeight({\n        from: current,\n        to: Math.min(current + AutoRowSize.CALCULATION_STEP, length)\n      }, colRange, overwriteCache);\n      current = current + AutoRowSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize();\n\n        // tmp\n        if (this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {\n          this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();\n        }\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (syncLimit >= 0) {\n      this.calculateRowsHeight({\n        from: 0,\n        to: syncLimit\n      }, colRange, overwriteCache);\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n      this.hot.view.adjustElementsSize();\n    }\n  }\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all rows height (overwrite cache values).\n   */\n  recalculateAllRowsHeight() {\n    if (this.hot.view.isVisible()) {\n      this.calculateAllRowsHeight({\n        from: 0,\n        to: this.hot.countCols() - 1\n      }, true);\n    }\n  }\n\n  /**\n   * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoRowSize.SYNC_CALCULATION_LIMIT;\n    const rowsLimit = this.hot.countRows() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(rowsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, rowsLimit);\n  }\n\n  /**\n   * Get a row's height, as measured in the DOM.\n   *\n   * The height returned includes 1 px of the row's bottom border.\n   *\n   * Mind that this method is different from the\n   * [`getRowHeight()`](@/api/core.md#getrowheight) method\n   * of Handsontable's [Core](@/api/core.md).\n   *\n   * @param {number} row A visual row index.\n   * @param {number} [defaultHeight] If no height is found, `defaultHeight` is returned instead.\n   * @returns {number} The height of the specified row, in pixels.\n   */\n  getRowHeight(row, defaultHeight) {\n    const cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));\n    let height = defaultHeight;\n    if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {\n      height = cachedHeight;\n    }\n    return height;\n  }\n\n  /**\n   * Get the calculated column header height.\n   *\n   * @returns {number|undefined}\n   */\n  getColumnHeaderHeight() {\n    return this.headerHeight;\n  }\n\n  /**\n   * Get the first visible row.\n   *\n   * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.\n   */\n  getFirstVisibleRow() {\n    var _this$hot$view$getFir;\n    return (_this$hot$view$getFir = this.hot.view.getFirstRenderedVisibleRow()) !== null && _this$hot$view$getFir !== void 0 ? _this$hot$view$getFir : -1;\n  }\n\n  /**\n   * Gets the last visible row.\n   *\n   * @returns {number} Returns row index or -1 if table is not rendered.\n   */\n  getLastVisibleRow() {\n    var _this$hot$view$getLas;\n    return (_this$hot$view$getLas = this.hot.view.getLastRenderedVisibleRow()) !== null && _this$hot$view$getLas !== void 0 ? _this$hot$view$getLas : -1;\n  }\n\n  /**\n   * Clears cache of calculated row heights. If you want to clear only selected rows pass an array with their indexes.\n   * Otherwise whole cache will be cleared.\n   *\n   * @param {number[]} [physicalRows] List of physical row indexes to clear.\n   */\n  clearCache(physicalRows) {\n    this.headerHeight = null;\n    if (Array.isArray(physicalRows)) {\n      this.hot.batchExecution(() => {\n        physicalRows.forEach(physicalIndex => {\n          this.rowHeightsMap.setValueAtIndex(physicalIndex, null);\n        });\n      }, true);\n    } else {\n      this.rowHeightsMap.clear();\n    }\n  }\n\n  /**\n   * Clears cache by range.\n   *\n   * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.\n   */\n  clearCacheByRange(range) {\n    const {\n      from,\n      to\n    } = typeof range === 'number' ? {\n      from: range,\n      to: range\n    } : range;\n    this.hot.batchExecution(() => {\n      rangeEach(Math.min(from, to), Math.max(from, to), row => {\n        this.rowHeightsMap.setValueAtIndex(row, null);\n      });\n    }, true);\n  }\n\n  /**\n   * Checks if all heights were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!this.rowHeightsMap.getValues().slice(0, this.measuredRows).filter(item => item === null).length;\n  }\n\n  /**\n   * On before view render listener.\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _calculateSpecificRowsHeight(visualRows) {\n  const columnsRange = {\n    from: 0,\n    to: this.hot.countCols() - 1\n  };\n  visualRows.forEach(visualRow => {\n    // For rows we must calculate row height even when user had set height value manually.\n    // We can shrink column but cannot shrink rows!\n    const samples = this.samplesGenerator.generateRowSamples(visualRow, columnsRange);\n    samples.forEach((sample, row) => this.ghostTable.addRow(row, sample));\n  });\n  if (this.ghostTable.rows.length) {\n    this.hot.batchExecution(() => {\n      this.ghostTable.getHeights((visualRow, height) => {\n        const physicalRow = this.hot.toPhysicalRow(visualRow);\n        this.rowHeightsMap.setValueAtIndex(physicalRow, height);\n      });\n    }, true);\n    this.ghostTable.clean();\n  }\n}\nfunction _onBeforeRender() {\n  this.calculateVisibleRowsHeight();\n  if (!this.inProgress) {\n    _assertClassBrand(_AutoRowSize_brand, this, _calculateSpecificRowsHeight).call(this, _classPrivateFieldGet(_visualRowsToRefresh, this));\n    _classPrivateFieldSet(_visualRowsToRefresh, this, []);\n  }\n}\n/**\n * On before row resize listener.\n *\n * @param {number} size The size of the current row index.\n * @param {number} row Current row index.\n * @param {boolean} isDblClick Indicates if the resize was triggered by doubleclick.\n * @returns {number}\n */\nfunction _onBeforeRowResize(size, row, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateRowsHeight(row, undefined, true);\n    newSize = this.getRowHeight(row);\n  }\n  return newSize;\n}\n/**\n * On after load data listener.\n *\n * @param {Array} sourceData Source data.\n * @param {boolean} isFirstLoad `true` if this is the first load.\n */\nfunction _onAfterLoadData(sourceData, isFirstLoad) {\n  if (!isFirstLoad) {\n    this.recalculateAllRowsHeight();\n  }\n}\n/**\n * On before change listener.\n *\n * @param {Array} changes 2D array containing information about each of the edited cells.\n */\nfunction _onBeforeChange(changes) {\n  const changedRows = changes.reduce((acc, _ref) => {\n    let [row] = _ref;\n    if (acc.indexOf(row) === -1) {\n      acc.push(row);\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualRowsToRefresh, this).push(...changedRows);\n}\n/**\n * On after Handsontable init plugin with all necessary values.\n */\nfunction _onInit() {\n  this.recalculateAllRowsHeight();\n}\n/**\n * After formulas values updated listener.\n *\n * @param {Array} changes An array of modified data.\n */\nfunction _onAfterFormulasValuesUpdate(changes) {\n  const changedRows = changes.reduce((acc, change) => {\n    var _change$address;\n    const physicalRow = (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.row;\n    if (Number.isInteger(physicalRow)) {\n      const visualRow = this.hot.toVisualRow(physicalRow);\n      if (acc.indexOf(visualRow) === -1) {\n        acc.push(visualRow);\n      }\n    }\n    return acc;\n  }, []);\n  _classPrivateFieldGet(_visualRowsToRefresh, this).push(...changedRows);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}