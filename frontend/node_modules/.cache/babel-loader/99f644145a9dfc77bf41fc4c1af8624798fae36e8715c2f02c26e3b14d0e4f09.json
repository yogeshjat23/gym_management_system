{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { stringify } from \"../../helpers/mixed.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport hooksRefRegisterer from \"../../mixins/hooksRefRegisterer.mjs\";\nimport { getScrollbarWidth, offset, hasVerticalScrollbar, hasHorizontalScrollbar, outerWidth, outerHeight, getComputedStyle } from \"../../helpers/dom/element.mjs\";\nexport const EDITOR_TYPE = 'base';\nexport const EDITOR_STATE = Object.freeze({\n  VIRGIN: 'STATE_VIRGIN',\n  // before editing\n  EDITING: 'STATE_EDITING',\n  WAITING: 'STATE_WAITING',\n  // waiting for async validation\n  FINISHED: 'STATE_FINISHED'\n});\n\n/**\n * @class BaseEditor\n */\nexport class BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * A reference to the source instance of the Handsontable.\n   *\n   * @type {Handsontable}\n   */\n\n  /**\n   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.\n   */\n  constructor(hotInstance) {\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Editor's state.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"state\", EDITOR_STATE.VIRGIN);\n    /**\n     * Flag to store information about editor's opening status.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_opened\", false);\n    /**\n     * Defines the editor's editing mode. When false, then an editor works in fast editing mode.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_fullEditMode\", false);\n    /**\n     * Callback to call after closing editor.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"_closeCallback\", null);\n    /**\n     * Currently rendered cell's TD element.\n     *\n     * @type {HTMLTableCellElement}\n     */\n    _defineProperty(this, \"TD\", null);\n    /**\n     * Visual row index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", null);\n    /**\n     * Visual column index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", null);\n    /**\n     * Column property name or a column index, if datasource is an array of arrays.\n     *\n     * @type {number|string}\n     */\n    _defineProperty(this, \"prop\", null);\n    /**\n     * Original cell's value.\n     *\n     * @type {*}\n     */\n    _defineProperty(this, \"originalValue\", null);\n    /**\n     * Object containing the cell's properties.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", null);\n    this.hot = hotInstance;\n    this.init();\n  }\n\n  /**\n   * Fires callback after closing editor.\n   *\n   * @private\n   * @param {boolean} result The editor value.\n   */\n  _fireCallbacks(result) {\n    if (this._closeCallback) {\n      this._closeCallback(result);\n      this._closeCallback = null;\n    }\n  }\n\n  /**\n   * Initializes an editor's intance.\n   */\n  init() {}\n\n  /**\n   * Required method to get current value from editable element.\n   */\n  getValue() {\n    throw Error('Editor getValue() method unimplemented');\n  }\n\n  /**\n   * Required method to set new value into editable element.\n   */\n  setValue() {\n    throw Error('Editor setValue() method unimplemented');\n  }\n\n  /**\n   * Required method to open editor.\n   */\n  open() {\n    throw Error('Editor open() method unimplemented');\n  }\n\n  /**\n   * Required method to close editor.\n   */\n  close() {\n    throw Error('Editor close() method unimplemented');\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    this.TD = td;\n    this.row = row;\n    this.col = col;\n    this.prop = prop;\n    this.originalValue = value;\n    this.cellProperties = cellProperties;\n    this.state = this.isOpened() ? this.state : EDITOR_STATE.VIRGIN;\n  }\n\n  /**\n   * Fallback method to provide extendable editors in ES5.\n   *\n   * @returns {Function}\n   */\n  extend() {\n    return class Editor extends this.constructor {};\n  }\n\n  /**\n   * Saves value from editor into data storage.\n   *\n   * @param {*} value The editor value.\n   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.\n   */\n  saveValue(value, ctrlDown) {\n    let visualRowFrom;\n    let visualColumnFrom;\n    let visualRowTo;\n    let visualColumnTo;\n\n    // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)\n    if (ctrlDown) {\n      const selectedLast = this.hot.getSelectedLast();\n      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0); // Math.max eliminate headers coords.\n      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0); // Math.max eliminate headers coords.\n      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);\n      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);\n    } else {\n      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];\n    }\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowFrom, visualColumnFrom);\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;\n    }\n\n    // Saving values using the modified coordinates.\n    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, 'edit');\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The initial editor value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    const hotInstance = this.hot;\n    // We have to convert visual indexes into renderable indexes\n    // due to hidden columns don't participate in the rendering process\n    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));\n    this.state = EDITOR_STATE.EDITING;\n\n    // Set the editor value only in the full edit mode. In other mode the focusable element has to be empty,\n    // otherwise IME (editor for Asia users) doesn't work.\n    if (this.isInFullEditMode()) {\n      const stringifiedInitialValue = typeof newInitialValue === 'string' ? newInitialValue : stringify(this.originalValue);\n      this.setValue(stringifiedInitialValue);\n    }\n    this.open(event);\n    this._opened = true;\n    this.focus();\n\n    // only rerender the selections (FillHandle should disappear when beginEditing is triggered)\n    hotInstance.view.render();\n    hotInstance.runHooks('afterBeginEditing', this.row, this.col);\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    let val;\n    if (callback) {\n      const previousCloseCallback = this._closeCallback;\n      this._closeCallback = result => {\n        if (previousCloseCallback) {\n          previousCloseCallback(result);\n        }\n        callback(result);\n        this.hot.view.render();\n      };\n    }\n    if (this.isWaiting()) {\n      return;\n    }\n    if (this.state === EDITOR_STATE.VIRGIN) {\n      this.hot._registerTimeout(() => {\n        this._fireCallbacks(true);\n      });\n      return;\n    }\n    if (this.state === EDITOR_STATE.EDITING) {\n      if (restoreOriginalValue) {\n        this.cancelChanges();\n        this.hot.view.render();\n        return;\n      }\n      const value = this.getValue();\n      if (this.cellProperties.trimWhitespace) {\n        // We trim only string values\n        val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];\n      } else {\n        val = [[value]];\n      }\n      this.state = EDITOR_STATE.WAITING;\n      this.saveValue(val, ctrlDown);\n      if (this.hot.getCellValidator(this.cellProperties)) {\n        this.hot.addHookOnce('postAfterValidate', result => {\n          this.state = EDITOR_STATE.FINISHED;\n          this.discardEditor(result);\n        });\n      } else {\n        this.state = EDITOR_STATE.FINISHED;\n        this.discardEditor(true);\n      }\n    }\n  }\n\n  /**\n   * Finishes editing without singout saving value.\n   */\n  cancelChanges() {\n    this.state = EDITOR_STATE.FINISHED;\n    this.discardEditor();\n  }\n\n  /**\n   * Verifies result of validation or closes editor if user's cancelled changes.\n   *\n   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,\n   *                                   then an editor won't be closed until validation is passed.\n   */\n  discardEditor(result) {\n    if (this.state !== EDITOR_STATE.FINISHED) {\n      return;\n    }\n\n    // validator was defined and failed\n    if (result === false && this.cellProperties.allowInvalid !== true) {\n      this.hot.selectCell(this.row, this.col);\n      this.focus();\n      this.state = EDITOR_STATE.EDITING;\n      this._fireCallbacks(false);\n    } else {\n      this.close();\n      this._opened = false;\n      this._fullEditMode = false;\n      this.state = EDITOR_STATE.VIRGIN;\n      this._fireCallbacks(true);\n      const shortcutManager = this.hot.getShortcutManager();\n      shortcutManager.setActiveContextName('grid');\n    }\n  }\n\n  /**\n   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated\n   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.\n   */\n  enableFullEditMode() {\n    this._fullEditMode = true;\n  }\n\n  /**\n   * Checks if editor is in full edit mode.\n   *\n   * @returns {boolean}\n   */\n  isInFullEditMode() {\n    return this._fullEditMode;\n  }\n\n  /**\n   * Returns information whether the editor is open.\n   *\n   * @returns {boolean}\n   */\n  isOpened() {\n    return this._opened;\n  }\n\n  /**\n   * Returns information whether the editor is waiting, eg.: for async validation.\n   *\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.state === EDITOR_STATE.WAITING;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Gets the object that provides information about the edited cell size and its position\n   * relative to the table viewport.\n   *\n   * The rectangle has six integer properties:\n   *  - `top` The top position relative to the table viewport\n   *  - `start` The left (or right in RTL) position relative to the table viewport\n   *  - `width` The cell's current width;\n   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport\n   *  - `height` The cell's current height;\n   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport\n   *\n   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}\n   */\n  getEditedCellRect() {\n    var _wtOverlays$getParent;\n    const TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!TD) {\n      return;\n    }\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.hot.view._wt;\n    const rootWindow = this.hot.rootWindow;\n    const currentOffset = offset(TD);\n    const cellWidth = outerWidth(TD);\n    const containerOffset = offset(this.hot.rootElement);\n    const containerWidth = outerWidth(this.hot.rootElement);\n    const scrollableContainerTop = wtOverlays.topOverlay.holder;\n    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;\n    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;\n    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;\n    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n    const {\n      wtTable: overlayTable\n    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;\n    const overlayName = overlayTable.name;\n    const scrollTop = ['master', 'inline_start'].includes(overlayName) ? containerScrollTop : 0;\n    const scrollLeft = ['master', 'top', 'bottom'].includes(overlayName) ? containerScrollLeft : 0;\n\n    // If colHeaders is disabled, cells in the first row have border-top\n    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;\n    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;\n    let inlineStartPos = 0;\n    if (this.hot.isRtl()) {\n      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;\n    } else {\n      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;\n    }\n\n    // When the scrollable element is Window object then the editor position needs to be compensated\n    // by the overlays' position (position relative to the table viewport). In other cases, the overlay's\n    // position always returns 0.\n    if (['top', 'top_inline_start_corner'].includes(overlayName)) {\n      topPos += wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (['inline_start', 'top_inline_start_corner'].includes(overlayName)) {\n      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());\n    }\n    const hasColumnHeaders = this.hot.hasColHeaders();\n    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();\n    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting('fixedRowsBottom');\n    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {\n      topPos += 1;\n    }\n    if (renderableColumn <= 0) {\n      inlineStartPos += 1;\n    }\n    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;\n    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;\n    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());\n    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();\n    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);\n    let cellTopOffset = TD.offsetTop;\n    if (['inline_start', 'master'].includes(overlayName)) {\n      cellTopOffset += firstRowOffset - verticalScrollPosition;\n    }\n    if (['bottom', 'bottom_inline_start_corner'].includes(overlayName)) {\n      const {\n        wtViewport: bottomWtViewport,\n        wtTable: bottomWtTable\n      } = wtOverlays.bottomOverlay.clone;\n      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;\n    }\n    let cellStartOffset = TD.offsetLeft;\n    if (this.hot.isRtl()) {\n      if (cellStartOffset >= 0) {\n        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;\n      } else {\n        // The `offsetLeft` returns negative values when the parent offset element has position relative\n        // (it happens when on the cell the selection is applied - the `area` CSS class).\n        // When it happens the `offsetLeft` value is calculated from the right edge of the parent element.\n        cellStartOffset = Math.abs(cellStartOffset);\n      }\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;\n    } else if (['top', 'master', 'bottom'].includes(overlayName)) {\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition;\n    }\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    const borderPhysicalWidthProp = this.hot.isRtl() ? 'borderRightWidth' : 'borderLeftWidth';\n    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;\n    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;\n    const width = outerWidth(TD) + inlineStartBorderCompensation;\n    const height = outerHeight(TD) + topBorderCompensation;\n    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;\n    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;\n    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;\n    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);\n    return {\n      top: topPos,\n      start: inlineStartPos,\n      height,\n      maxHeight,\n      width,\n      maxWidth\n    };\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Gets className of the edited cell if exist.\n   *\n   * @returns {string}\n   */\n  getEditedCellsLayerClass() {\n    const editorSection = this.checkEditorSection();\n    switch (editorSection) {\n      case 'inline-start':\n        return 'ht_clone_left ht_clone_inline_start';\n      case 'bottom':\n        return 'ht_clone_bottom';\n      case 'bottom-inline-start-corner':\n        return 'ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner';\n      case 'top':\n        return 'ht_clone_top';\n      case 'top-inline-start-corner':\n        return 'ht_clone_top_left_corner ht_clone_top_inline_start_corner';\n      default:\n        return 'ht_clone_master';\n    }\n  }\n\n  /**\n   * Gets HTMLTableCellElement of the edited cell if exist.\n   *\n   * @returns {HTMLTableCellElement|null}\n   */\n  getEditedCell() {\n    return this.hot.getCell(this.row, this.col, true);\n  }\n\n  /**\n   * Returns name of the overlay, where editor is placed.\n   *\n   * @private\n   * @returns {string}\n   */\n  checkEditorSection() {\n    const totalRows = this.hot.countRows();\n    let section = '';\n    if (this.row < this.hot.getSettings().fixedRowsTop) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'top-inline-start-corner';\n      } else {\n        section = 'top';\n      }\n    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'bottom-inline-start-corner';\n      } else {\n        section = 'bottom';\n      }\n    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {\n      section = 'inline-start';\n    }\n    return section;\n  }\n}\nmixin(BaseEditor, hooksRefRegisterer);","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","stringify","mixin","hooksRefRegisterer","getScrollbarWidth","offset","hasVerticalScrollbar","hasHorizontalScrollbar","outerWidth","outerHeight","getComputedStyle","EDITOR_TYPE","EDITOR_STATE","freeze","VIRGIN","EDITING","WAITING","FINISHED","BaseEditor","constructor","hotInstance","hot","init","_fireCallbacks","result","_closeCallback","getValue","Error","setValue","open","close","prepare","row","col","prop","td","cellProperties","TD","originalValue","state","isOpened","extend","Editor","saveValue","ctrlDown","visualRowFrom","visualColumnFrom","visualRowTo","visualColumnTo","selectedLast","getSelectedLast","Math","max","min","modifiedCellCoords","runHooks","Array","isArray","populateFromArray","beginEditing","newInitialValue","event","renderableRowIndex","rowIndexMapper","getRenderableFromVisualIndex","renderableColumnIndex","columnIndexMapper","view","scrollViewport","_createCellCoords","isInFullEditMode","stringifiedInitialValue","_opened","focus","render","finishEditing","restoreOriginalValue","callback","val","previousCloseCallback","isWaiting","_registerTimeout","cancelChanges","trimWhitespace","prototype","trim","getCellValidator","addHookOnce","discardEditor","allowInvalid","selectCell","_fullEditMode","shortcutManager","getShortcutManager","setActiveContextName","enableFullEditMode","getEditedCellRect","_wtOverlays$getParent","getEditedCell","wtOverlays","wtViewport","_wt","rootWindow","currentOffset","cellWidth","containerOffset","rootElement","containerWidth","scrollableContainerTop","topOverlay","holder","scrollableContainerLeft","inlineStartOverlay","containerScrollTop","scrollTop","containerScrollLeft","scrollLeft","gridMostRightPos","innerWidth","left","wtTable","overlayTable","getParentOverlay","overlayName","name","includes","editTopModifier","top","topPos","inlineStartPos","isRtl","getOverlayOffset","abs","hasColumnHeaders","hasColHeaders","renderableRow","renderableColumn","nrOfRenderableRowIndexes","getRenderableIndexesLength","firstRowIndexOfTheBottomOverlay","getSetting","firstRowOffset","rowsRenderCalculator","startPosition","firstColumnOffset","columnsRenderCalculator","horizontalScrollPosition","getScrollPosition","verticalScrollPosition","scrollbarWidth","rootDocument","cellTopOffset","offsetTop","bottomWtViewport","bottomWtTable","bottomOverlay","clone","getWorkspaceHeight","getHeight","cellStartOffset","offsetLeft","getWidth","cellComputedStyle","borderPhysicalWidthProp","inlineStartBorderCompensation","parseInt","topBorderCompensation","borderTopWidth","width","height","actualVerticalScrollbarWidth","actualHorizontalScrollbarWidth","maxWidth","maximumVisibleElementWidth","maxHeight","maximumVisibleElementHeight","start","getEditedCellsLayerClass","editorSection","checkEditorSection","getCell","totalRows","countRows","section","getSettings","fixedRowsTop","fixedColumnsStart","fixedRowsBottom"],"sources":["D:/gym-project/frontend/node_modules/handsontable/editors/baseEditor/baseEditor.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { stringify } from \"../../helpers/mixed.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport hooksRefRegisterer from \"../../mixins/hooksRefRegisterer.mjs\";\nimport { getScrollbarWidth, offset, hasVerticalScrollbar, hasHorizontalScrollbar, outerWidth, outerHeight, getComputedStyle } from \"../../helpers/dom/element.mjs\";\nexport const EDITOR_TYPE = 'base';\nexport const EDITOR_STATE = Object.freeze({\n  VIRGIN: 'STATE_VIRGIN',\n  // before editing\n  EDITING: 'STATE_EDITING',\n  WAITING: 'STATE_WAITING',\n  // waiting for async validation\n  FINISHED: 'STATE_FINISHED'\n});\n\n/**\n * @class BaseEditor\n */\nexport class BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * A reference to the source instance of the Handsontable.\n   *\n   * @type {Handsontable}\n   */\n\n  /**\n   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.\n   */\n  constructor(hotInstance) {\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Editor's state.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"state\", EDITOR_STATE.VIRGIN);\n    /**\n     * Flag to store information about editor's opening status.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_opened\", false);\n    /**\n     * Defines the editor's editing mode. When false, then an editor works in fast editing mode.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_fullEditMode\", false);\n    /**\n     * Callback to call after closing editor.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"_closeCallback\", null);\n    /**\n     * Currently rendered cell's TD element.\n     *\n     * @type {HTMLTableCellElement}\n     */\n    _defineProperty(this, \"TD\", null);\n    /**\n     * Visual row index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", null);\n    /**\n     * Visual column index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", null);\n    /**\n     * Column property name or a column index, if datasource is an array of arrays.\n     *\n     * @type {number|string}\n     */\n    _defineProperty(this, \"prop\", null);\n    /**\n     * Original cell's value.\n     *\n     * @type {*}\n     */\n    _defineProperty(this, \"originalValue\", null);\n    /**\n     * Object containing the cell's properties.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", null);\n    this.hot = hotInstance;\n    this.init();\n  }\n\n  /**\n   * Fires callback after closing editor.\n   *\n   * @private\n   * @param {boolean} result The editor value.\n   */\n  _fireCallbacks(result) {\n    if (this._closeCallback) {\n      this._closeCallback(result);\n      this._closeCallback = null;\n    }\n  }\n\n  /**\n   * Initializes an editor's intance.\n   */\n  init() {}\n\n  /**\n   * Required method to get current value from editable element.\n   */\n  getValue() {\n    throw Error('Editor getValue() method unimplemented');\n  }\n\n  /**\n   * Required method to set new value into editable element.\n   */\n  setValue() {\n    throw Error('Editor setValue() method unimplemented');\n  }\n\n  /**\n   * Required method to open editor.\n   */\n  open() {\n    throw Error('Editor open() method unimplemented');\n  }\n\n  /**\n   * Required method to close editor.\n   */\n  close() {\n    throw Error('Editor close() method unimplemented');\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    this.TD = td;\n    this.row = row;\n    this.col = col;\n    this.prop = prop;\n    this.originalValue = value;\n    this.cellProperties = cellProperties;\n    this.state = this.isOpened() ? this.state : EDITOR_STATE.VIRGIN;\n  }\n\n  /**\n   * Fallback method to provide extendable editors in ES5.\n   *\n   * @returns {Function}\n   */\n  extend() {\n    return class Editor extends this.constructor {};\n  }\n\n  /**\n   * Saves value from editor into data storage.\n   *\n   * @param {*} value The editor value.\n   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.\n   */\n  saveValue(value, ctrlDown) {\n    let visualRowFrom;\n    let visualColumnFrom;\n    let visualRowTo;\n    let visualColumnTo;\n\n    // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)\n    if (ctrlDown) {\n      const selectedLast = this.hot.getSelectedLast();\n      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0); // Math.max eliminate headers coords.\n      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0); // Math.max eliminate headers coords.\n      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);\n      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);\n    } else {\n      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];\n    }\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowFrom, visualColumnFrom);\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;\n    }\n\n    // Saving values using the modified coordinates.\n    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, 'edit');\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The initial editor value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    const hotInstance = this.hot;\n    // We have to convert visual indexes into renderable indexes\n    // due to hidden columns don't participate in the rendering process\n    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));\n    this.state = EDITOR_STATE.EDITING;\n\n    // Set the editor value only in the full edit mode. In other mode the focusable element has to be empty,\n    // otherwise IME (editor for Asia users) doesn't work.\n    if (this.isInFullEditMode()) {\n      const stringifiedInitialValue = typeof newInitialValue === 'string' ? newInitialValue : stringify(this.originalValue);\n      this.setValue(stringifiedInitialValue);\n    }\n    this.open(event);\n    this._opened = true;\n    this.focus();\n\n    // only rerender the selections (FillHandle should disappear when beginEditing is triggered)\n    hotInstance.view.render();\n    hotInstance.runHooks('afterBeginEditing', this.row, this.col);\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    let val;\n    if (callback) {\n      const previousCloseCallback = this._closeCallback;\n      this._closeCallback = result => {\n        if (previousCloseCallback) {\n          previousCloseCallback(result);\n        }\n        callback(result);\n        this.hot.view.render();\n      };\n    }\n    if (this.isWaiting()) {\n      return;\n    }\n    if (this.state === EDITOR_STATE.VIRGIN) {\n      this.hot._registerTimeout(() => {\n        this._fireCallbacks(true);\n      });\n      return;\n    }\n    if (this.state === EDITOR_STATE.EDITING) {\n      if (restoreOriginalValue) {\n        this.cancelChanges();\n        this.hot.view.render();\n        return;\n      }\n      const value = this.getValue();\n      if (this.cellProperties.trimWhitespace) {\n        // We trim only string values\n        val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];\n      } else {\n        val = [[value]];\n      }\n      this.state = EDITOR_STATE.WAITING;\n      this.saveValue(val, ctrlDown);\n      if (this.hot.getCellValidator(this.cellProperties)) {\n        this.hot.addHookOnce('postAfterValidate', result => {\n          this.state = EDITOR_STATE.FINISHED;\n          this.discardEditor(result);\n        });\n      } else {\n        this.state = EDITOR_STATE.FINISHED;\n        this.discardEditor(true);\n      }\n    }\n  }\n\n  /**\n   * Finishes editing without singout saving value.\n   */\n  cancelChanges() {\n    this.state = EDITOR_STATE.FINISHED;\n    this.discardEditor();\n  }\n\n  /**\n   * Verifies result of validation or closes editor if user's cancelled changes.\n   *\n   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,\n   *                                   then an editor won't be closed until validation is passed.\n   */\n  discardEditor(result) {\n    if (this.state !== EDITOR_STATE.FINISHED) {\n      return;\n    }\n\n    // validator was defined and failed\n    if (result === false && this.cellProperties.allowInvalid !== true) {\n      this.hot.selectCell(this.row, this.col);\n      this.focus();\n      this.state = EDITOR_STATE.EDITING;\n      this._fireCallbacks(false);\n    } else {\n      this.close();\n      this._opened = false;\n      this._fullEditMode = false;\n      this.state = EDITOR_STATE.VIRGIN;\n      this._fireCallbacks(true);\n      const shortcutManager = this.hot.getShortcutManager();\n      shortcutManager.setActiveContextName('grid');\n    }\n  }\n\n  /**\n   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated\n   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.\n   */\n  enableFullEditMode() {\n    this._fullEditMode = true;\n  }\n\n  /**\n   * Checks if editor is in full edit mode.\n   *\n   * @returns {boolean}\n   */\n  isInFullEditMode() {\n    return this._fullEditMode;\n  }\n\n  /**\n   * Returns information whether the editor is open.\n   *\n   * @returns {boolean}\n   */\n  isOpened() {\n    return this._opened;\n  }\n\n  /**\n   * Returns information whether the editor is waiting, eg.: for async validation.\n   *\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.state === EDITOR_STATE.WAITING;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Gets the object that provides information about the edited cell size and its position\n   * relative to the table viewport.\n   *\n   * The rectangle has six integer properties:\n   *  - `top` The top position relative to the table viewport\n   *  - `start` The left (or right in RTL) position relative to the table viewport\n   *  - `width` The cell's current width;\n   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport\n   *  - `height` The cell's current height;\n   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport\n   *\n   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}\n   */\n  getEditedCellRect() {\n    var _wtOverlays$getParent;\n    const TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!TD) {\n      return;\n    }\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.hot.view._wt;\n    const rootWindow = this.hot.rootWindow;\n    const currentOffset = offset(TD);\n    const cellWidth = outerWidth(TD);\n    const containerOffset = offset(this.hot.rootElement);\n    const containerWidth = outerWidth(this.hot.rootElement);\n    const scrollableContainerTop = wtOverlays.topOverlay.holder;\n    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;\n    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;\n    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;\n    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n    const {\n      wtTable: overlayTable\n    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;\n    const overlayName = overlayTable.name;\n    const scrollTop = ['master', 'inline_start'].includes(overlayName) ? containerScrollTop : 0;\n    const scrollLeft = ['master', 'top', 'bottom'].includes(overlayName) ? containerScrollLeft : 0;\n\n    // If colHeaders is disabled, cells in the first row have border-top\n    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;\n    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;\n    let inlineStartPos = 0;\n    if (this.hot.isRtl()) {\n      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;\n    } else {\n      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;\n    }\n\n    // When the scrollable element is Window object then the editor position needs to be compensated\n    // by the overlays' position (position relative to the table viewport). In other cases, the overlay's\n    // position always returns 0.\n    if (['top', 'top_inline_start_corner'].includes(overlayName)) {\n      topPos += wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (['inline_start', 'top_inline_start_corner'].includes(overlayName)) {\n      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());\n    }\n    const hasColumnHeaders = this.hot.hasColHeaders();\n    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();\n    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting('fixedRowsBottom');\n    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {\n      topPos += 1;\n    }\n    if (renderableColumn <= 0) {\n      inlineStartPos += 1;\n    }\n    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;\n    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;\n    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());\n    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();\n    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);\n    let cellTopOffset = TD.offsetTop;\n    if (['inline_start', 'master'].includes(overlayName)) {\n      cellTopOffset += firstRowOffset - verticalScrollPosition;\n    }\n    if (['bottom', 'bottom_inline_start_corner'].includes(overlayName)) {\n      const {\n        wtViewport: bottomWtViewport,\n        wtTable: bottomWtTable\n      } = wtOverlays.bottomOverlay.clone;\n      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;\n    }\n    let cellStartOffset = TD.offsetLeft;\n    if (this.hot.isRtl()) {\n      if (cellStartOffset >= 0) {\n        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;\n      } else {\n        // The `offsetLeft` returns negative values when the parent offset element has position relative\n        // (it happens when on the cell the selection is applied - the `area` CSS class).\n        // When it happens the `offsetLeft` value is calculated from the right edge of the parent element.\n        cellStartOffset = Math.abs(cellStartOffset);\n      }\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;\n    } else if (['top', 'master', 'bottom'].includes(overlayName)) {\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition;\n    }\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    const borderPhysicalWidthProp = this.hot.isRtl() ? 'borderRightWidth' : 'borderLeftWidth';\n    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;\n    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;\n    const width = outerWidth(TD) + inlineStartBorderCompensation;\n    const height = outerHeight(TD) + topBorderCompensation;\n    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;\n    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;\n    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;\n    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);\n    return {\n      top: topPos,\n      start: inlineStartPos,\n      height,\n      maxHeight,\n      width,\n      maxWidth\n    };\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Gets className of the edited cell if exist.\n   *\n   * @returns {string}\n   */\n  getEditedCellsLayerClass() {\n    const editorSection = this.checkEditorSection();\n    switch (editorSection) {\n      case 'inline-start':\n        return 'ht_clone_left ht_clone_inline_start';\n      case 'bottom':\n        return 'ht_clone_bottom';\n      case 'bottom-inline-start-corner':\n        return 'ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner';\n      case 'top':\n        return 'ht_clone_top';\n      case 'top-inline-start-corner':\n        return 'ht_clone_top_left_corner ht_clone_top_inline_start_corner';\n      default:\n        return 'ht_clone_master';\n    }\n  }\n\n  /**\n   * Gets HTMLTableCellElement of the edited cell if exist.\n   *\n   * @returns {HTMLTableCellElement|null}\n   */\n  getEditedCell() {\n    return this.hot.getCell(this.row, this.col, true);\n  }\n\n  /**\n   * Returns name of the overlay, where editor is placed.\n   *\n   * @private\n   * @returns {string}\n   */\n  checkEditorSection() {\n    const totalRows = this.hot.countRows();\n    let section = '';\n    if (this.row < this.hot.getSettings().fixedRowsTop) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'top-inline-start-corner';\n      } else {\n        section = 'top';\n      }\n    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'bottom-inline-start-corner';\n      } else {\n        section = 'bottom';\n      }\n    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {\n      section = 'inline-start';\n    }\n    return section;\n  }\n}\nmixin(BaseEditor, hooksRefRegisterer);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}