{"ast":null,"code":"import { isObject, deepClone } from \"../helpers/object.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport { isUndefined } from \"../helpers/mixed.mjs\";\nimport { extendNotExistingKeys, normalizeLanguageCode, warnUserAboutLanguageRegistration } from \"./utils.mjs\";\nimport staticRegister from \"../utils/staticRegister.mjs\";\nimport { getPhraseFormatters } from \"./phraseFormatters/index.mjs\";\nimport DEFAULT_DICTIONARY from \"./languages/en-US.mjs\";\nimport * as _dictionaryKeys from \"./constants.mjs\";\nexport const dictionaryKeys = _dictionaryKeys;\nexport const DEFAULT_LANGUAGE_CODE = DEFAULT_DICTIONARY.languageCode;\nconst {\n  register: registerGloballyLanguageDictionary,\n  getItem: getGlobalLanguageDictionary,\n  hasItem: hasGlobalLanguageDictionary,\n  getValues: getGlobalLanguagesDictionaries\n} = staticRegister('languagesDictionaries');\n\n/**\n * Register automatically the default language dictionary.\n */\nregisterLanguageDictionary(DEFAULT_DICTIONARY);\n\n/**\n * Register language dictionary for specific language code.\n *\n * @param {string|object} languageCodeOrDictionary Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE' or object representing dictionary.\n * @param {object} dictionary Dictionary for specific language (optional if first parameter has already dictionary).\n * @returns {object}\n */\nexport function registerLanguageDictionary(languageCodeOrDictionary, dictionary) {\n  let languageCode = languageCodeOrDictionary;\n  let dictionaryObject = dictionary;\n\n  // Dictionary passed as first argument.\n  if (isObject(languageCodeOrDictionary)) {\n    dictionaryObject = languageCodeOrDictionary;\n    languageCode = dictionaryObject.languageCode;\n  }\n  extendLanguageDictionary(languageCode, dictionaryObject);\n  registerGloballyLanguageDictionary(languageCode, deepClone(dictionaryObject));\n\n  // We do not allow user to work with dictionary by reference, it can cause lot of bugs.\n  return deepClone(dictionaryObject);\n}\n\n/**\n * Extend handled dictionary by default language dictionary. As result, if any dictionary key isn't defined for specific language, it will be filled with default language value (\"dictionary gaps\" are supplemented).\n *\n * @private\n * @param {string} languageCode Language code.\n * @param {object} dictionary Dictionary which is extended.\n */\nfunction extendLanguageDictionary(languageCode, dictionary) {\n  if (languageCode !== DEFAULT_LANGUAGE_CODE) {\n    extendNotExistingKeys(dictionary, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));\n  }\n}\n\n/**\n * Get language dictionary for specific language code.\n *\n * @param {string} languageCode Language code.\n * @returns {object} Object with constants representing identifiers for translation (as keys) and corresponding translation phrases (as values).\n */\nexport function getLanguageDictionary(languageCode) {\n  if (!hasLanguageDictionary(languageCode)) {\n    return null;\n  }\n  return deepClone(getGlobalLanguageDictionary(languageCode));\n}\n\n/**\n *\n * Get if language with specified language code was registered.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @returns {boolean}\n */\nexport function hasLanguageDictionary(languageCode) {\n  return hasGlobalLanguageDictionary(languageCode);\n}\n\n/**\n * Get default language dictionary.\n *\n * @returns {object} Object with constants representing identifiers for translation (as keys) and corresponding translation phrases (as values).\n */\nexport function getDefaultLanguageDictionary() {\n  return DEFAULT_DICTIONARY;\n}\n\n/**\n * Get registered language dictionaries.\n *\n * @returns {Array}\n */\nexport function getLanguagesDictionaries() {\n  return getGlobalLanguagesDictionaries();\n}\n\n/**\n * Get phrase for specified dictionary key.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @param {string} dictionaryKey Constant which is dictionary key.\n * @param {*} argumentsForFormatters Arguments which will be handled by formatters.\n *\n * @returns {string}\n */\nexport function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {\n  const languageDictionary = getLanguageDictionary(languageCode);\n  if (languageDictionary === null) {\n    return null;\n  }\n  const phrasePropositions = languageDictionary[dictionaryKey];\n  if (isUndefined(phrasePropositions)) {\n    return null;\n  }\n  const formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);\n  if (Array.isArray(formattedPhrase)) {\n    return formattedPhrase[0];\n  }\n  return formattedPhrase;\n}\n\n/**\n * Get formatted phrase from phrases propositions for specified dictionary key.\n *\n * @private\n * @param {Array|string} phrasePropositions List of phrase propositions.\n * @param {*} argumentsForFormatters Arguments which will be handled by formatters.\n *\n * @returns {Array|string}\n */\nfunction getFormattedPhrase(phrasePropositions, argumentsForFormatters) {\n  let formattedPhrasePropositions = phrasePropositions;\n  arrayEach(getPhraseFormatters(), formatter => {\n    formattedPhrasePropositions = formatter(phrasePropositions, argumentsForFormatters);\n  });\n  return formattedPhrasePropositions;\n}\n\n/**\n * Returns valid language code. If the passed language code doesn't exist default one will be used.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @returns {string}\n */\nexport function getValidLanguageCode(languageCode) {\n  let normalizedLanguageCode = normalizeLanguageCode(languageCode);\n  if (!hasLanguageDictionary(normalizedLanguageCode)) {\n    normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;\n    warnUserAboutLanguageRegistration(languageCode);\n  }\n  return normalizedLanguageCode;\n}","map":{"version":3,"names":["isObject","deepClone","arrayEach","isUndefined","extendNotExistingKeys","normalizeLanguageCode","warnUserAboutLanguageRegistration","staticRegister","getPhraseFormatters","DEFAULT_DICTIONARY","_dictionaryKeys","dictionaryKeys","DEFAULT_LANGUAGE_CODE","languageCode","register","registerGloballyLanguageDictionary","getItem","getGlobalLanguageDictionary","hasItem","hasGlobalLanguageDictionary","getValues","getGlobalLanguagesDictionaries","registerLanguageDictionary","languageCodeOrDictionary","dictionary","dictionaryObject","extendLanguageDictionary","getLanguageDictionary","hasLanguageDictionary","getDefaultLanguageDictionary","getLanguagesDictionaries","getTranslatedPhrase","dictionaryKey","argumentsForFormatters","languageDictionary","phrasePropositions","formattedPhrase","getFormattedPhrase","Array","isArray","formattedPhrasePropositions","formatter","getValidLanguageCode","normalizedLanguageCode"],"sources":["D:/gym-project/frontend/node_modules/handsontable/i18n/registry.mjs"],"sourcesContent":["import { isObject, deepClone } from \"../helpers/object.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport { isUndefined } from \"../helpers/mixed.mjs\";\nimport { extendNotExistingKeys, normalizeLanguageCode, warnUserAboutLanguageRegistration } from \"./utils.mjs\";\nimport staticRegister from \"../utils/staticRegister.mjs\";\nimport { getPhraseFormatters } from \"./phraseFormatters/index.mjs\";\nimport DEFAULT_DICTIONARY from \"./languages/en-US.mjs\";\nimport * as _dictionaryKeys from \"./constants.mjs\";\nexport const dictionaryKeys = _dictionaryKeys;\nexport const DEFAULT_LANGUAGE_CODE = DEFAULT_DICTIONARY.languageCode;\nconst {\n  register: registerGloballyLanguageDictionary,\n  getItem: getGlobalLanguageDictionary,\n  hasItem: hasGlobalLanguageDictionary,\n  getValues: getGlobalLanguagesDictionaries\n} = staticRegister('languagesDictionaries');\n\n/**\n * Register automatically the default language dictionary.\n */\nregisterLanguageDictionary(DEFAULT_DICTIONARY);\n\n/**\n * Register language dictionary for specific language code.\n *\n * @param {string|object} languageCodeOrDictionary Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE' or object representing dictionary.\n * @param {object} dictionary Dictionary for specific language (optional if first parameter has already dictionary).\n * @returns {object}\n */\nexport function registerLanguageDictionary(languageCodeOrDictionary, dictionary) {\n  let languageCode = languageCodeOrDictionary;\n  let dictionaryObject = dictionary;\n\n  // Dictionary passed as first argument.\n  if (isObject(languageCodeOrDictionary)) {\n    dictionaryObject = languageCodeOrDictionary;\n    languageCode = dictionaryObject.languageCode;\n  }\n  extendLanguageDictionary(languageCode, dictionaryObject);\n  registerGloballyLanguageDictionary(languageCode, deepClone(dictionaryObject));\n\n  // We do not allow user to work with dictionary by reference, it can cause lot of bugs.\n  return deepClone(dictionaryObject);\n}\n\n/**\n * Extend handled dictionary by default language dictionary. As result, if any dictionary key isn't defined for specific language, it will be filled with default language value (\"dictionary gaps\" are supplemented).\n *\n * @private\n * @param {string} languageCode Language code.\n * @param {object} dictionary Dictionary which is extended.\n */\nfunction extendLanguageDictionary(languageCode, dictionary) {\n  if (languageCode !== DEFAULT_LANGUAGE_CODE) {\n    extendNotExistingKeys(dictionary, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));\n  }\n}\n\n/**\n * Get language dictionary for specific language code.\n *\n * @param {string} languageCode Language code.\n * @returns {object} Object with constants representing identifiers for translation (as keys) and corresponding translation phrases (as values).\n */\nexport function getLanguageDictionary(languageCode) {\n  if (!hasLanguageDictionary(languageCode)) {\n    return null;\n  }\n  return deepClone(getGlobalLanguageDictionary(languageCode));\n}\n\n/**\n *\n * Get if language with specified language code was registered.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @returns {boolean}\n */\nexport function hasLanguageDictionary(languageCode) {\n  return hasGlobalLanguageDictionary(languageCode);\n}\n\n/**\n * Get default language dictionary.\n *\n * @returns {object} Object with constants representing identifiers for translation (as keys) and corresponding translation phrases (as values).\n */\nexport function getDefaultLanguageDictionary() {\n  return DEFAULT_DICTIONARY;\n}\n\n/**\n * Get registered language dictionaries.\n *\n * @returns {Array}\n */\nexport function getLanguagesDictionaries() {\n  return getGlobalLanguagesDictionaries();\n}\n\n/**\n * Get phrase for specified dictionary key.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @param {string} dictionaryKey Constant which is dictionary key.\n * @param {*} argumentsForFormatters Arguments which will be handled by formatters.\n *\n * @returns {string}\n */\nexport function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {\n  const languageDictionary = getLanguageDictionary(languageCode);\n  if (languageDictionary === null) {\n    return null;\n  }\n  const phrasePropositions = languageDictionary[dictionaryKey];\n  if (isUndefined(phrasePropositions)) {\n    return null;\n  }\n  const formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);\n  if (Array.isArray(formattedPhrase)) {\n    return formattedPhrase[0];\n  }\n  return formattedPhrase;\n}\n\n/**\n * Get formatted phrase from phrases propositions for specified dictionary key.\n *\n * @private\n * @param {Array|string} phrasePropositions List of phrase propositions.\n * @param {*} argumentsForFormatters Arguments which will be handled by formatters.\n *\n * @returns {Array|string}\n */\nfunction getFormattedPhrase(phrasePropositions, argumentsForFormatters) {\n  let formattedPhrasePropositions = phrasePropositions;\n  arrayEach(getPhraseFormatters(), formatter => {\n    formattedPhrasePropositions = formatter(phrasePropositions, argumentsForFormatters);\n  });\n  return formattedPhrasePropositions;\n}\n\n/**\n * Returns valid language code. If the passed language code doesn't exist default one will be used.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @returns {string}\n */\nexport function getValidLanguageCode(languageCode) {\n  let normalizedLanguageCode = normalizeLanguageCode(languageCode);\n  if (!hasLanguageDictionary(normalizedLanguageCode)) {\n    normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;\n    warnUserAboutLanguageRegistration(languageCode);\n  }\n  return normalizedLanguageCode;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}