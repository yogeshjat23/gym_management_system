{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport Hooks from \"../../../pluginHooks.mjs\";\nimport { hasOwnProperty } from \"../../../helpers/object.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\n/**\n * @class DynamicCellMetaMod\n *\n * The `DynamicCellMetaMod` modifier allows for extending cell meta objects\n * (returned by `getCellMeta()` from `MetaManager`)\n * by user-specific properties.\n *\n * The user-specific properties can be added and changed dynamically,\n * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n * or by Handsontable's `cells` option.\n *\n * The `getCellMeta()` method is used widely throughout the source code.\n * To boost the method's execution time,\n * the logic is triggered only once per one Handsontable slow render cycle.\n */\nexport class DynamicCellMetaMod {\n  constructor(metaManager) {\n    /**\n     * @type {MetaManager}\n     */\n    _defineProperty(this, \"metaManager\", void 0);\n    /**\n     * @type {Map}\n     */\n    _defineProperty(this, \"metaSyncMemo\", new Map());\n    this.metaManager = metaManager;\n    metaManager.addLocalHook('afterGetCellMeta', cellMeta => this.extendCellMeta(cellMeta));\n    Hooks.getSingleton().add('beforeRender', forceFullRender => {\n      if (forceFullRender) {\n        this.metaSyncMemo.clear();\n      }\n    }, this.metaManager.hot);\n  }\n\n  /**\n   * Extends the cell meta object by user-specific properties.\n   *\n   * The cell meta object can be extended dynamically,\n   * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n   * or by Handsontable's `cells` option.\n   *\n   * To boost performance, the extending process is triggered only once per one slow Handsontable render cycle.\n   *\n   * @param {object} cellMeta The cell meta object.\n   */\n  extendCellMeta(cellMeta) {\n    var _this$metaSyncMemo$ge;\n    const {\n      row: physicalRow,\n      col: physicalColumn\n    } = cellMeta;\n    if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {\n      return;\n    }\n    const {\n      visualRow,\n      visualCol\n    } = cellMeta;\n    const hot = this.metaManager.hot;\n    const prop = hot.colToProp(visualCol);\n    cellMeta.prop = prop;\n    hot.runHooks('beforeGetCellMeta', visualRow, visualCol, cellMeta);\n\n    // extend a `type` value, added or changed in the `beforeGetCellMeta` hook\n    const cellType = hasOwnProperty(cellMeta, 'type') ? cellMeta.type : null;\n    let cellSettings = isFunction(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;\n    if (cellType) {\n      if (cellSettings) {\n        var _cellSettings$type;\n        cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;\n      } else {\n        cellSettings = {\n          type: cellType\n        };\n      }\n    }\n    if (cellSettings) {\n      this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);\n    }\n    hot.runHooks('afterGetCellMeta', visualRow, visualCol, cellMeta);\n    if (!this.metaSyncMemo.has(physicalRow)) {\n      this.metaSyncMemo.set(physicalRow, new Set());\n    }\n    this.metaSyncMemo.get(physicalRow).add(physicalColumn);\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","Hooks","hasOwnProperty","isFunction","DynamicCellMetaMod","constructor","metaManager","Map","addLocalHook","cellMeta","extendCellMeta","getSingleton","add","forceFullRender","metaSyncMemo","clear","hot","_this$metaSyncMemo$ge","row","physicalRow","col","physicalColumn","get","has","visualRow","visualCol","prop","colToProp","runHooks","cellType","type","cellSettings","cells","_cellSettings$type","updateCellMeta","set","Set"],"sources":["D:/gym-project/frontend/node_modules/handsontable/dataMap/metaManager/mods/dynamicCellMeta.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport Hooks from \"../../../pluginHooks.mjs\";\nimport { hasOwnProperty } from \"../../../helpers/object.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\n/**\n * @class DynamicCellMetaMod\n *\n * The `DynamicCellMetaMod` modifier allows for extending cell meta objects\n * (returned by `getCellMeta()` from `MetaManager`)\n * by user-specific properties.\n *\n * The user-specific properties can be added and changed dynamically,\n * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n * or by Handsontable's `cells` option.\n *\n * The `getCellMeta()` method is used widely throughout the source code.\n * To boost the method's execution time,\n * the logic is triggered only once per one Handsontable slow render cycle.\n */\nexport class DynamicCellMetaMod {\n  constructor(metaManager) {\n    /**\n     * @type {MetaManager}\n     */\n    _defineProperty(this, \"metaManager\", void 0);\n    /**\n     * @type {Map}\n     */\n    _defineProperty(this, \"metaSyncMemo\", new Map());\n    this.metaManager = metaManager;\n    metaManager.addLocalHook('afterGetCellMeta', cellMeta => this.extendCellMeta(cellMeta));\n    Hooks.getSingleton().add('beforeRender', forceFullRender => {\n      if (forceFullRender) {\n        this.metaSyncMemo.clear();\n      }\n    }, this.metaManager.hot);\n  }\n\n  /**\n   * Extends the cell meta object by user-specific properties.\n   *\n   * The cell meta object can be extended dynamically,\n   * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n   * or by Handsontable's `cells` option.\n   *\n   * To boost performance, the extending process is triggered only once per one slow Handsontable render cycle.\n   *\n   * @param {object} cellMeta The cell meta object.\n   */\n  extendCellMeta(cellMeta) {\n    var _this$metaSyncMemo$ge;\n    const {\n      row: physicalRow,\n      col: physicalColumn\n    } = cellMeta;\n    if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {\n      return;\n    }\n    const {\n      visualRow,\n      visualCol\n    } = cellMeta;\n    const hot = this.metaManager.hot;\n    const prop = hot.colToProp(visualCol);\n    cellMeta.prop = prop;\n    hot.runHooks('beforeGetCellMeta', visualRow, visualCol, cellMeta);\n\n    // extend a `type` value, added or changed in the `beforeGetCellMeta` hook\n    const cellType = hasOwnProperty(cellMeta, 'type') ? cellMeta.type : null;\n    let cellSettings = isFunction(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;\n    if (cellType) {\n      if (cellSettings) {\n        var _cellSettings$type;\n        cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;\n      } else {\n        cellSettings = {\n          type: cellType\n        };\n      }\n    }\n    if (cellSettings) {\n      this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);\n    }\n    hot.runHooks('afterGetCellMeta', visualRow, visualCol, cellMeta);\n    if (!this.metaSyncMemo.has(physicalRow)) {\n      this.metaSyncMemo.set(physicalRow, new Set());\n    }\n    this.metaSyncMemo.get(physicalRow).add(physicalColumn);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}