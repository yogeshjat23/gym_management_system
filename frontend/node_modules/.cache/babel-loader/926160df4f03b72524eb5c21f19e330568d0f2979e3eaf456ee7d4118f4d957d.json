{"ast":null,"code":"import { arrayEach } from \"../../helpers/array.mjs\";\n/**\n * @param {string} className The full element class name to process.\n * @param {string} alignment The alignment class name to compare with.\n * @returns {string}\n */\nexport function prepareVerticalAlignClass(className, alignment) {\n  if (className.indexOf(alignment) !== -1) {\n    return className;\n  }\n  const replacedClassName = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '').replace('  ', '');\n  return `${replacedClassName} ${alignment}`;\n}\n\n/**\n * @param {string} className The full element class name to process.\n * @param {string} alignment The alignment class name to compare with.\n * @returns {string}\n */\nexport function prepareHorizontalAlignClass(className, alignment) {\n  if (className.indexOf(alignment) !== -1) {\n    return className;\n  }\n  const replacedClassName = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '').replace('  ', '');\n  return `${replacedClassName} ${alignment}`;\n}\n\n/**\n * @param {CellRange[]} ranges An array of the cell ranges.\n * @param {Function} callback The callback function.\n * @returns {object}\n */\nexport function getAlignmentClasses(ranges, callback) {\n  const classes = {};\n  arrayEach(ranges, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        if (!classes[row]) {\n          classes[row] = [];\n        }\n        classes[row][col] = callback(row, col);\n      }\n    });\n  });\n  return classes;\n}\n\n/**\n * @param {CellRange[]} ranges An array of the cell ranges.\n * @param {string} type The type of the alignment axis ('horizontal' or 'vertical').\n * @param {string} alignment CSS class name to add.\n * @param {Function} cellDescriptor The function which fetches the cell meta object based in passed coordinates.\n * @param {Function} propertySetter The function which contains logic for added/removed alignment.\n */\nexport function align(ranges, type, alignment, cellDescriptor, propertySetter) {\n  arrayEach(ranges, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);\n      }\n    });\n  });\n}\n\n/**\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {string} type The type of the alignment axis ('horizontal' or 'vertical').\n * @param {string} alignment CSS class name to add.\n * @param {Function} cellDescriptor The function which fetches the cell meta object based in passed coordinates.\n * @param {Function} propertySetter The function which contains logic for added/removed alignment.\n */\nfunction applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {\n  const cellMeta = cellDescriptor(row, col);\n  let className = alignment;\n  if (cellMeta.className) {\n    if (type === 'vertical') {\n      className = prepareVerticalAlignClass(cellMeta.className, alignment);\n    } else {\n      className = prepareHorizontalAlignClass(cellMeta.className, alignment);\n    }\n  }\n  propertySetter(row, col, 'className', className);\n}\n\n/**\n * @param {string} label The label text.\n * @returns {string}\n */\nexport function markLabelAsSelected(label) {\n  // workaround for https://github.com/handsontable/handsontable/issues/1946\n  return `<span class=\"selected\">${String.fromCharCode(10003)}</span>${label}`;\n}\n\n/**\n * @param {CellRange[]} ranges An array of the cell ranges.\n * @param {Function} comparator The comparator function.\n * @returns {boolean}\n */\nexport function checkSelectionConsistency(ranges, comparator) {\n  let result = false;\n  if (Array.isArray(ranges)) {\n    arrayEach(ranges, range => {\n      range.forAll((row, col) => {\n        // Selection consistency should only check within cell ranges. We skip header coordinates.\n        if (row >= 0 && col >= 0 && comparator(row, col)) {\n          result = true;\n          return false;\n        }\n      });\n      return result;\n    });\n  }\n  return result;\n}\n\n/**\n * Returns document offset based on the passed element. If the document objects between element and the\n * base document are not the same the offset as top and left properties will be returned.\n *\n * @param {Element} elementToCheck The element to compare with Document object.\n * @param {Document} baseDocument The base Document object.\n * @returns {{ top: number, left: number }}\n */\nexport function getDocumentOffsetByElement(elementToCheck, baseDocument) {\n  const offset = {\n    top: 0,\n    left: 0\n  };\n  if (baseDocument !== elementToCheck.ownerDocument) {\n    const {\n      frameElement\n    } = baseDocument.defaultView;\n    const {\n      top,\n      left\n    } = frameElement.getBoundingClientRect();\n    offset.top = top;\n    offset.left = left;\n  }\n  return offset;\n}","map":{"version":3,"names":["arrayEach","prepareVerticalAlignClass","className","alignment","indexOf","replacedClassName","replace","prepareHorizontalAlignClass","getAlignmentClasses","ranges","callback","classes","range","forAll","row","col","align","type","cellDescriptor","propertySetter","applyAlignClassName","cellMeta","markLabelAsSelected","label","String","fromCharCode","checkSelectionConsistency","comparator","result","Array","isArray","getDocumentOffsetByElement","elementToCheck","baseDocument","offset","top","left","ownerDocument","frameElement","defaultView","getBoundingClientRect"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/contextMenu/utils.mjs"],"sourcesContent":["import { arrayEach } from \"../../helpers/array.mjs\";\n/**\n * @param {string} className The full element class name to process.\n * @param {string} alignment The alignment class name to compare with.\n * @returns {string}\n */\nexport function prepareVerticalAlignClass(className, alignment) {\n  if (className.indexOf(alignment) !== -1) {\n    return className;\n  }\n  const replacedClassName = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '').replace('  ', '');\n  return `${replacedClassName} ${alignment}`;\n}\n\n/**\n * @param {string} className The full element class name to process.\n * @param {string} alignment The alignment class name to compare with.\n * @returns {string}\n */\nexport function prepareHorizontalAlignClass(className, alignment) {\n  if (className.indexOf(alignment) !== -1) {\n    return className;\n  }\n  const replacedClassName = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '').replace('  ', '');\n  return `${replacedClassName} ${alignment}`;\n}\n\n/**\n * @param {CellRange[]} ranges An array of the cell ranges.\n * @param {Function} callback The callback function.\n * @returns {object}\n */\nexport function getAlignmentClasses(ranges, callback) {\n  const classes = {};\n  arrayEach(ranges, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        if (!classes[row]) {\n          classes[row] = [];\n        }\n        classes[row][col] = callback(row, col);\n      }\n    });\n  });\n  return classes;\n}\n\n/**\n * @param {CellRange[]} ranges An array of the cell ranges.\n * @param {string} type The type of the alignment axis ('horizontal' or 'vertical').\n * @param {string} alignment CSS class name to add.\n * @param {Function} cellDescriptor The function which fetches the cell meta object based in passed coordinates.\n * @param {Function} propertySetter The function which contains logic for added/removed alignment.\n */\nexport function align(ranges, type, alignment, cellDescriptor, propertySetter) {\n  arrayEach(ranges, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);\n      }\n    });\n  });\n}\n\n/**\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {string} type The type of the alignment axis ('horizontal' or 'vertical').\n * @param {string} alignment CSS class name to add.\n * @param {Function} cellDescriptor The function which fetches the cell meta object based in passed coordinates.\n * @param {Function} propertySetter The function which contains logic for added/removed alignment.\n */\nfunction applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {\n  const cellMeta = cellDescriptor(row, col);\n  let className = alignment;\n  if (cellMeta.className) {\n    if (type === 'vertical') {\n      className = prepareVerticalAlignClass(cellMeta.className, alignment);\n    } else {\n      className = prepareHorizontalAlignClass(cellMeta.className, alignment);\n    }\n  }\n  propertySetter(row, col, 'className', className);\n}\n\n/**\n * @param {string} label The label text.\n * @returns {string}\n */\nexport function markLabelAsSelected(label) {\n  // workaround for https://github.com/handsontable/handsontable/issues/1946\n  return `<span class=\"selected\">${String.fromCharCode(10003)}</span>${label}`;\n}\n\n/**\n * @param {CellRange[]} ranges An array of the cell ranges.\n * @param {Function} comparator The comparator function.\n * @returns {boolean}\n */\nexport function checkSelectionConsistency(ranges, comparator) {\n  let result = false;\n  if (Array.isArray(ranges)) {\n    arrayEach(ranges, range => {\n      range.forAll((row, col) => {\n        // Selection consistency should only check within cell ranges. We skip header coordinates.\n        if (row >= 0 && col >= 0 && comparator(row, col)) {\n          result = true;\n          return false;\n        }\n      });\n      return result;\n    });\n  }\n  return result;\n}\n\n/**\n * Returns document offset based on the passed element. If the document objects between element and the\n * base document are not the same the offset as top and left properties will be returned.\n *\n * @param {Element} elementToCheck The element to compare with Document object.\n * @param {Document} baseDocument The base Document object.\n * @returns {{ top: number, left: number }}\n */\nexport function getDocumentOffsetByElement(elementToCheck, baseDocument) {\n  const offset = {\n    top: 0,\n    left: 0\n  };\n  if (baseDocument !== elementToCheck.ownerDocument) {\n    const {\n      frameElement\n    } = baseDocument.defaultView;\n    const {\n      top,\n      left\n    } = frameElement.getBoundingClientRect();\n    offset.top = top;\n    offset.left = left;\n  }\n  return offset;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}