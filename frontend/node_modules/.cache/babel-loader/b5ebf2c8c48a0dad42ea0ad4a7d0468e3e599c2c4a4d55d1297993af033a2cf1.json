{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\n * Class used to make all endpoint-related operations.\n *\n * @private\n * @class Endpoints\n */\nclass Endpoints {\n  constructor(plugin, settings) {\n    /**\n     * The main plugin instance.\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Handsontable instance.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n    _defineProperty(this, \"endpoints\", []);\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {object|Function}\n     * @default null\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * Settings type. Can be either 'array' or 'function'.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n    _defineProperty(this, \"settingsType\", 'array');\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {object}\n     * @default null\n     */\n    _defineProperty(this, \"currentEndpoint\", null);\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n    _defineProperty(this, \"cellsToSetCache\", []);\n    this.plugin = plugin;\n    this.hot = this.plugin.hot;\n    this.settings = settings;\n  }\n\n  /**\n   * Initialize the endpoints provided in the settings.\n   */\n  initEndpoints() {\n    this.endpoints = this.parseSettings();\n    this.refreshAllEndpoints();\n  }\n\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {number} index Index of the endpoint.\n   * @returns {object}\n   */\n  getEndpoint(index) {\n    if (this.settingsType === 'function') {\n      return this.fillMissingEndpointData(this.settings)[index];\n    }\n    return this.endpoints[index];\n  }\n\n  /**\n   * Get an array with all the endpoints.\n   *\n   * @returns {Array}\n   */\n  getAllEndpoints() {\n    if (this.settingsType === 'function') {\n      return this.fillMissingEndpointData(this.settings);\n    }\n    return this.endpoints;\n  }\n\n  /**\n   * Used to fill the blanks in the endpoint data provided by a settings function.\n   *\n   * @private\n   * @param {Function} func Function provided in the HOT settings.\n   * @returns {Array} An array of endpoints.\n   */\n  fillMissingEndpointData(func) {\n    return this.parseSettings(func.call(this));\n  }\n\n  /**\n   * Parse plugin's settings.\n   *\n   * @param {Array} settings The settings array.\n   * @returns {object[]}\n   */\n  parseSettings(settings) {\n    const endpointsArray = [];\n    let settingsArray = settings;\n    if (!settingsArray && typeof this.settings === 'function') {\n      this.settingsType = 'function';\n      return;\n    }\n    if (!settingsArray) {\n      settingsArray = this.settings;\n    }\n    arrayEach(settingsArray, val => {\n      const newEndpoint = {};\n      this.assignSetting(val, newEndpoint, 'ranges', [[0, this.hot.countRows() - 1]]);\n      this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n      this.assignSetting(val, newEndpoint, 'destinationRow', new Error(`\n        You must provide a destination row for the Column Summary plugin in order to work properly!\n      `));\n      this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(`\n        You must provide a destination column for the Column Summary plugin in order to work properly!\n      `));\n      this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n      this.assignSetting(val, newEndpoint, 'type', 'sum');\n      this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n      this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n      this.assignSetting(val, newEndpoint, 'customFunction', null);\n      this.assignSetting(val, newEndpoint, 'readOnly', true);\n      this.assignSetting(val, newEndpoint, 'roundFloat', false);\n      endpointsArray.push(newEndpoint);\n    });\n    return endpointsArray;\n  }\n\n  /**\n   * Setter for the internal setting objects.\n   *\n   * @param {object} settings Object with the settings.\n   * @param {object} endpoint Contains information about the endpoint for the the calculation.\n   * @param {string} name Settings name.\n   * @param {object} defaultValue Default value for the settings.\n   */\n  assignSetting(settings, endpoint, name, defaultValue) {\n    if (name === 'ranges' && settings[name] === undefined) {\n      endpoint[name] = defaultValue;\n      return;\n    } else if (name === 'ranges' && settings[name].length === 0) {\n      return;\n    }\n    if (settings[name] === undefined) {\n      if (defaultValue instanceof Error) {\n        throw defaultValue;\n      }\n      endpoint[name] = defaultValue;\n    } else {\n      /* eslint-disable no-lonely-if */\n      if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n        endpoint[name] = this.hot.countRows() - settings[name] - 1;\n      } else {\n        endpoint[name] = settings[name];\n      }\n    }\n  }\n\n  /**\n   * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n   *\n   * @private\n   * @param {string} action Type of the action performed.\n   * @param {number} index Row/column index.\n   * @param {number} number Number of rows/columns added/removed.\n   */\n  resetSetupBeforeStructureAlteration(action, index, number) {\n    if (this.settingsType !== 'function') {\n      return;\n    }\n    const type = action.indexOf('row') > -1 ? 'row' : 'col';\n    const endpoints = this.getAllEndpoints();\n    arrayEach(endpoints, val => {\n      if (type === 'row' && val.destinationRow >= index) {\n        if (action === 'insert_row') {\n          val.alterRowOffset = number;\n        } else if (action === 'remove_row') {\n          val.alterRowOffset = -1 * number;\n        }\n      }\n      if (type === 'col' && val.destinationColumn >= index) {\n        if (action === 'insert_col') {\n          val.alterColumnOffset = number;\n        } else if (action === 'remove_col') {\n          val.alterColumnOffset = -1 * number;\n        }\n      }\n    });\n    this.resetAllEndpoints(endpoints, false);\n  }\n\n  /**\n   * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n   * after changing the table structure.\n   *\n   * @private\n   * @param {string} action Type of the action performed.\n   * @param {number} index Row/column index.\n   * @param {number} number Number of rows/columns added/removed.\n   * @param {Array} [logicRows] Array of the logical indexes.\n   * @param {string} [source] Source of change.\n   * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n   */\n  resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n    let forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (this.settingsType === 'function') {\n      // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n      // and it needs to be run to properly calculate the endpoint value.\n      const beforeViewRenderCallback = () => {\n        this.hot.removeHook('beforeViewRender', beforeViewRenderCallback);\n        return this.refreshAllEndpoints();\n      };\n      this.hot.addHookOnce('beforeViewRender', beforeViewRenderCallback);\n      return;\n    }\n    const type = action.indexOf('row') > -1 ? 'row' : 'col';\n    const multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n    const endpoints = this.getAllEndpoints();\n    const rowMoving = action.indexOf('move_row') === 0;\n    const placeOfAlteration = index;\n    arrayEach(endpoints, val => {\n      if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n        val.alterRowOffset = multiplier * number;\n      }\n      if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n        val.alterColumnOffset = multiplier * number;\n      }\n    });\n    this.resetAllEndpoints(endpoints, !rowMoving);\n    if (rowMoving) {\n      arrayEach(endpoints, endpoint => {\n        this.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n        this.recreatePhysicalRanges(endpoint);\n        this.clearOffsetInformation(endpoint);\n      });\n    } else {\n      arrayEach(endpoints, endpoint => {\n        this.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n      });\n    }\n    if (forceRefresh) {\n      this.refreshAllEndpoints();\n    }\n  }\n\n  /**\n   * Clear the offset information from the endpoint object.\n   *\n   * @private\n   * @param {object} endpoint And endpoint object.\n   */\n  clearOffsetInformation(endpoint) {\n    endpoint.alterRowOffset = undefined;\n    endpoint.alterColumnOffset = undefined;\n  }\n\n  /**\n   * Extend the row ranges for the provided endpoint.\n   *\n   * @private\n   * @param {object} endpoint The endpoint object.\n   * @param {number} placeOfAlteration Index of the row where the alteration takes place.\n   * @param {number} previousPosition Previous endpoint result position.\n   * @param {number} offset Offset generated by the alteration.\n   */\n  extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n    arrayEach(endpoint.ranges, range => {\n      // is a range, not a single row\n      if (range[1]) {\n        if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n          if (previousPosition > range[1]) {\n            range[1] += offset;\n          } else if (previousPosition < range[0]) {\n            range[0] -= offset;\n          }\n        } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n          range[1] -= offset;\n          if (placeOfAlteration <= range[0]) {\n            range[0] += 1;\n            range[1] += 1;\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n   *\n   * @private\n   * @param {object} endpoint An endpoint object.\n   */\n  recreatePhysicalRanges(endpoint) {\n    const ranges = endpoint.ranges;\n    const newRanges = [];\n    const allIndexes = [];\n    arrayEach(ranges, range => {\n      const newRange = [];\n      if (range[1]) {\n        for (let i = range[0]; i <= range[1]; i++) {\n          newRange.push(this.hot.toPhysicalRow(i));\n        }\n      } else {\n        newRange.push(this.hot.toPhysicalRow(range[0]));\n      }\n      allIndexes.push(newRange);\n    });\n    arrayEach(allIndexes, range => {\n      let newRange = [];\n      arrayEach(range, (coord, index) => {\n        if (index === 0) {\n          newRange.push(coord);\n        } else if (range[index] !== range[index - 1] + 1) {\n          newRange.push(range[index - 1]);\n          newRanges.push(newRange);\n          newRange = [];\n          newRange.push(coord);\n        }\n        if (index === range.length - 1) {\n          newRange.push(coord);\n          newRanges.push(newRange);\n        }\n      });\n    });\n    endpoint.ranges = newRanges;\n  }\n\n  /**\n   * Shifts the endpoint coordinates by the defined offset.\n   *\n   * @private\n   * @param {object} endpoint Endpoint object.\n   * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n   */\n  shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n    if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n      endpoint.destinationRow += endpoint.alterRowOffset || 0;\n      arrayEach(endpoint.ranges, element => {\n        arrayEach(element, (subElement, j) => {\n          if (subElement >= offsetStartIndex) {\n            element[j] += endpoint.alterRowOffset || 0;\n          }\n        });\n      });\n    } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n      endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n      endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n    }\n  }\n\n  /**\n   * Resets (removes) the endpoints from the table.\n   *\n   * @param {Array} [endpoints] Array containing the endpoints.\n   * @param {boolean} [useOffset=true] Use the cell offset value.\n   */\n  resetAllEndpoints() {\n    let endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n    let useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const anyEndpointOutOfRange = endpoints.some(endpoint => {\n      const alterRowOffset = endpoint.alterRowOffset || 0;\n      const alterColOffset = endpoint.alterColumnOffset || 0;\n      if (endpoint.destinationRow + alterRowOffset >= this.hot.countRows() || endpoint.destinationColumn + alterColOffset >= this.hot.countCols()) {\n        return true;\n      }\n      return false;\n    });\n    if (anyEndpointOutOfRange) {\n      return;\n    }\n    this.cellsToSetCache = [];\n    arrayEach(endpoints, endpoint => {\n      this.resetEndpointValue(endpoint, useOffset);\n    });\n    this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Calculate and refresh all defined endpoints.\n   */\n  refreshAllEndpoints() {\n    this.cellsToSetCache = [];\n    arrayEach(this.getAllEndpoints(), value => {\n      this.currentEndpoint = value;\n      this.plugin.calculate(value);\n      this.setEndpointValue(value, 'init');\n    });\n    this.currentEndpoint = null;\n    this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Calculate and refresh endpoints only in the changed columns.\n   *\n   * @param {Array} changes Array of changes from the `afterChange` hook.\n   */\n  refreshChangedEndpoints(changes) {\n    const needToRefresh = [];\n    this.cellsToSetCache = [];\n    arrayEach(changes, (value, key, changesObj) => {\n      // if nothing changed, dont update anything\n      if (`${value[2] || ''}` === `${value[3]}`) {\n        return;\n      }\n      arrayEach(this.getAllEndpoints(), (endpoint, j) => {\n        if (this.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n          needToRefresh.push(j);\n        }\n      });\n    });\n    arrayEach(needToRefresh, value => {\n      this.refreshEndpoint(this.getEndpoint(value));\n    });\n    this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Refreshes the cell meta information for the all endpoints after the `updateSettings` method call which in some\n   * cases (call with `columns` option) can reset the cell metas to the initial state.\n   */\n  refreshCellMetas() {\n    this.endpoints.forEach(endpoint => {\n      const destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n      if (destinationVisualRow !== null) {\n        const cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n    });\n  }\n\n  /**\n   * Calculate and refresh a single endpoint.\n   *\n   * @param {object} endpoint Contains the endpoint information.\n   */\n  refreshEndpoint(endpoint) {\n    this.currentEndpoint = endpoint;\n    this.plugin.calculate(endpoint);\n    this.setEndpointValue(endpoint);\n    this.currentEndpoint = null;\n  }\n\n  /**\n   * Reset the endpoint value.\n   *\n   * @param {object} endpoint Contains the endpoint information.\n   * @param {boolean} [useOffset=true] Use the cell offset value.\n   */\n  resetEndpointValue(endpoint) {\n    let useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const alterRowOffset = endpoint.alterRowOffset || 0;\n    const alterColOffset = endpoint.alterColumnOffset || 0;\n    this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n  }\n\n  /**\n   * Set the endpoint value.\n   *\n   * @param {object} endpoint Contains the endpoint information.\n   * @param {string} [source] Source of the call information.\n   * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\n   */\n  setEndpointValue(endpoint, source) {\n    let render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n    if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n      this.throwOutOfBoundsWarning();\n      return;\n    }\n    const destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n    if (destinationVisualRow !== null) {\n      const cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n      if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n    }\n    if ((endpoint.roundFloat === true || Number.isInteger(endpoint.roundFloat)) && !isNaN(endpoint.result)) {\n      const roundFloatValue = endpoint.roundFloat;\n      let decimalPlacesCount = 0;\n\n      // `toFixed` method accepts only values between 0 and 100\n      if (Number.isInteger(roundFloatValue)) {\n        decimalPlacesCount = Math.min(Math.max(0, roundFloatValue), 100);\n      }\n      endpoint.result = endpoint.result.toFixed(decimalPlacesCount);\n    }\n    if (render) {\n      this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n    } else {\n      this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n    }\n    endpoint.alterRowOffset = undefined;\n    endpoint.alterColumnOffset = undefined;\n  }\n\n  /**\n   * Throw an error for the calculation range being out of boundaries.\n   *\n   * @private\n   */\n  throwOutOfBoundsWarning() {\n    warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n  }\n}\nexport default Endpoints;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","arrayEach","warn","Endpoints","constructor","plugin","settings","hot","initEndpoints","endpoints","parseSettings","refreshAllEndpoints","getEndpoint","index","settingsType","fillMissingEndpointData","getAllEndpoints","func","endpointsArray","settingsArray","val","newEndpoint","assignSetting","countRows","Error","destinationColumn","push","endpoint","name","defaultValue","undefined","length","reversedRowCoords","resetSetupBeforeStructureAlteration","action","number","type","indexOf","destinationRow","alterRowOffset","alterColumnOffset","resetAllEndpoints","resetSetupAfterStructureAlteration","logicRows","source","forceRefresh","arguments","beforeViewRenderCallback","removeHook","addHookOnce","multiplier","rowMoving","placeOfAlteration","extendEndpointRanges","recreatePhysicalRanges","clearOffsetInformation","shiftEndpointCoordinates","previousPosition","offset","ranges","range","newRanges","allIndexes","newRange","toPhysicalRow","coord","offsetStartIndex","element","subElement","j","sourceColumn","useOffset","anyEndpointOutOfRange","some","alterColOffset","countCols","cellsToSetCache","resetEndpointValue","setDataAtCell","currentEndpoint","calculate","setEndpointValue","refreshChangedEndpoints","changes","needToRefresh","key","changesObj","propToCol","refreshEndpoint","refreshCellMetas","forEach","destinationVisualRow","toVisualRow","cellMeta","getCellMeta","readOnly","className","toVisualColumn","render","visualEndpointRowIndex","throwOutOfBoundsWarning","roundFloat","isInteger","isNaN","result","roundFloatValue","decimalPlacesCount","Math","min","max","toFixed"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/columnSummary/endpoints.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\n * Class used to make all endpoint-related operations.\n *\n * @private\n * @class Endpoints\n */\nclass Endpoints {\n  constructor(plugin, settings) {\n    /**\n     * The main plugin instance.\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Handsontable instance.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n    _defineProperty(this, \"endpoints\", []);\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {object|Function}\n     * @default null\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * Settings type. Can be either 'array' or 'function'.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n    _defineProperty(this, \"settingsType\", 'array');\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {object}\n     * @default null\n     */\n    _defineProperty(this, \"currentEndpoint\", null);\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n    _defineProperty(this, \"cellsToSetCache\", []);\n    this.plugin = plugin;\n    this.hot = this.plugin.hot;\n    this.settings = settings;\n  }\n\n  /**\n   * Initialize the endpoints provided in the settings.\n   */\n  initEndpoints() {\n    this.endpoints = this.parseSettings();\n    this.refreshAllEndpoints();\n  }\n\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {number} index Index of the endpoint.\n   * @returns {object}\n   */\n  getEndpoint(index) {\n    if (this.settingsType === 'function') {\n      return this.fillMissingEndpointData(this.settings)[index];\n    }\n    return this.endpoints[index];\n  }\n\n  /**\n   * Get an array with all the endpoints.\n   *\n   * @returns {Array}\n   */\n  getAllEndpoints() {\n    if (this.settingsType === 'function') {\n      return this.fillMissingEndpointData(this.settings);\n    }\n    return this.endpoints;\n  }\n\n  /**\n   * Used to fill the blanks in the endpoint data provided by a settings function.\n   *\n   * @private\n   * @param {Function} func Function provided in the HOT settings.\n   * @returns {Array} An array of endpoints.\n   */\n  fillMissingEndpointData(func) {\n    return this.parseSettings(func.call(this));\n  }\n\n  /**\n   * Parse plugin's settings.\n   *\n   * @param {Array} settings The settings array.\n   * @returns {object[]}\n   */\n  parseSettings(settings) {\n    const endpointsArray = [];\n    let settingsArray = settings;\n    if (!settingsArray && typeof this.settings === 'function') {\n      this.settingsType = 'function';\n      return;\n    }\n    if (!settingsArray) {\n      settingsArray = this.settings;\n    }\n    arrayEach(settingsArray, val => {\n      const newEndpoint = {};\n      this.assignSetting(val, newEndpoint, 'ranges', [[0, this.hot.countRows() - 1]]);\n      this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n      this.assignSetting(val, newEndpoint, 'destinationRow', new Error(`\n        You must provide a destination row for the Column Summary plugin in order to work properly!\n      `));\n      this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(`\n        You must provide a destination column for the Column Summary plugin in order to work properly!\n      `));\n      this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n      this.assignSetting(val, newEndpoint, 'type', 'sum');\n      this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n      this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n      this.assignSetting(val, newEndpoint, 'customFunction', null);\n      this.assignSetting(val, newEndpoint, 'readOnly', true);\n      this.assignSetting(val, newEndpoint, 'roundFloat', false);\n      endpointsArray.push(newEndpoint);\n    });\n    return endpointsArray;\n  }\n\n  /**\n   * Setter for the internal setting objects.\n   *\n   * @param {object} settings Object with the settings.\n   * @param {object} endpoint Contains information about the endpoint for the the calculation.\n   * @param {string} name Settings name.\n   * @param {object} defaultValue Default value for the settings.\n   */\n  assignSetting(settings, endpoint, name, defaultValue) {\n    if (name === 'ranges' && settings[name] === undefined) {\n      endpoint[name] = defaultValue;\n      return;\n    } else if (name === 'ranges' && settings[name].length === 0) {\n      return;\n    }\n    if (settings[name] === undefined) {\n      if (defaultValue instanceof Error) {\n        throw defaultValue;\n      }\n      endpoint[name] = defaultValue;\n    } else {\n      /* eslint-disable no-lonely-if */\n      if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n        endpoint[name] = this.hot.countRows() - settings[name] - 1;\n      } else {\n        endpoint[name] = settings[name];\n      }\n    }\n  }\n\n  /**\n   * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n   *\n   * @private\n   * @param {string} action Type of the action performed.\n   * @param {number} index Row/column index.\n   * @param {number} number Number of rows/columns added/removed.\n   */\n  resetSetupBeforeStructureAlteration(action, index, number) {\n    if (this.settingsType !== 'function') {\n      return;\n    }\n    const type = action.indexOf('row') > -1 ? 'row' : 'col';\n    const endpoints = this.getAllEndpoints();\n    arrayEach(endpoints, val => {\n      if (type === 'row' && val.destinationRow >= index) {\n        if (action === 'insert_row') {\n          val.alterRowOffset = number;\n        } else if (action === 'remove_row') {\n          val.alterRowOffset = -1 * number;\n        }\n      }\n      if (type === 'col' && val.destinationColumn >= index) {\n        if (action === 'insert_col') {\n          val.alterColumnOffset = number;\n        } else if (action === 'remove_col') {\n          val.alterColumnOffset = -1 * number;\n        }\n      }\n    });\n    this.resetAllEndpoints(endpoints, false);\n  }\n\n  /**\n   * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n   * after changing the table structure.\n   *\n   * @private\n   * @param {string} action Type of the action performed.\n   * @param {number} index Row/column index.\n   * @param {number} number Number of rows/columns added/removed.\n   * @param {Array} [logicRows] Array of the logical indexes.\n   * @param {string} [source] Source of change.\n   * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n   */\n  resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n    let forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (this.settingsType === 'function') {\n      // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n      // and it needs to be run to properly calculate the endpoint value.\n      const beforeViewRenderCallback = () => {\n        this.hot.removeHook('beforeViewRender', beforeViewRenderCallback);\n        return this.refreshAllEndpoints();\n      };\n      this.hot.addHookOnce('beforeViewRender', beforeViewRenderCallback);\n      return;\n    }\n    const type = action.indexOf('row') > -1 ? 'row' : 'col';\n    const multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n    const endpoints = this.getAllEndpoints();\n    const rowMoving = action.indexOf('move_row') === 0;\n    const placeOfAlteration = index;\n    arrayEach(endpoints, val => {\n      if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n        val.alterRowOffset = multiplier * number;\n      }\n      if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n        val.alterColumnOffset = multiplier * number;\n      }\n    });\n    this.resetAllEndpoints(endpoints, !rowMoving);\n    if (rowMoving) {\n      arrayEach(endpoints, endpoint => {\n        this.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n        this.recreatePhysicalRanges(endpoint);\n        this.clearOffsetInformation(endpoint);\n      });\n    } else {\n      arrayEach(endpoints, endpoint => {\n        this.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n      });\n    }\n    if (forceRefresh) {\n      this.refreshAllEndpoints();\n    }\n  }\n\n  /**\n   * Clear the offset information from the endpoint object.\n   *\n   * @private\n   * @param {object} endpoint And endpoint object.\n   */\n  clearOffsetInformation(endpoint) {\n    endpoint.alterRowOffset = undefined;\n    endpoint.alterColumnOffset = undefined;\n  }\n\n  /**\n   * Extend the row ranges for the provided endpoint.\n   *\n   * @private\n   * @param {object} endpoint The endpoint object.\n   * @param {number} placeOfAlteration Index of the row where the alteration takes place.\n   * @param {number} previousPosition Previous endpoint result position.\n   * @param {number} offset Offset generated by the alteration.\n   */\n  extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n    arrayEach(endpoint.ranges, range => {\n      // is a range, not a single row\n      if (range[1]) {\n        if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n          if (previousPosition > range[1]) {\n            range[1] += offset;\n          } else if (previousPosition < range[0]) {\n            range[0] -= offset;\n          }\n        } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n          range[1] -= offset;\n          if (placeOfAlteration <= range[0]) {\n            range[0] += 1;\n            range[1] += 1;\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n   *\n   * @private\n   * @param {object} endpoint An endpoint object.\n   */\n  recreatePhysicalRanges(endpoint) {\n    const ranges = endpoint.ranges;\n    const newRanges = [];\n    const allIndexes = [];\n    arrayEach(ranges, range => {\n      const newRange = [];\n      if (range[1]) {\n        for (let i = range[0]; i <= range[1]; i++) {\n          newRange.push(this.hot.toPhysicalRow(i));\n        }\n      } else {\n        newRange.push(this.hot.toPhysicalRow(range[0]));\n      }\n      allIndexes.push(newRange);\n    });\n    arrayEach(allIndexes, range => {\n      let newRange = [];\n      arrayEach(range, (coord, index) => {\n        if (index === 0) {\n          newRange.push(coord);\n        } else if (range[index] !== range[index - 1] + 1) {\n          newRange.push(range[index - 1]);\n          newRanges.push(newRange);\n          newRange = [];\n          newRange.push(coord);\n        }\n        if (index === range.length - 1) {\n          newRange.push(coord);\n          newRanges.push(newRange);\n        }\n      });\n    });\n    endpoint.ranges = newRanges;\n  }\n\n  /**\n   * Shifts the endpoint coordinates by the defined offset.\n   *\n   * @private\n   * @param {object} endpoint Endpoint object.\n   * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n   */\n  shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n    if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n      endpoint.destinationRow += endpoint.alterRowOffset || 0;\n      arrayEach(endpoint.ranges, element => {\n        arrayEach(element, (subElement, j) => {\n          if (subElement >= offsetStartIndex) {\n            element[j] += endpoint.alterRowOffset || 0;\n          }\n        });\n      });\n    } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n      endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n      endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n    }\n  }\n\n  /**\n   * Resets (removes) the endpoints from the table.\n   *\n   * @param {Array} [endpoints] Array containing the endpoints.\n   * @param {boolean} [useOffset=true] Use the cell offset value.\n   */\n  resetAllEndpoints() {\n    let endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n    let useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const anyEndpointOutOfRange = endpoints.some(endpoint => {\n      const alterRowOffset = endpoint.alterRowOffset || 0;\n      const alterColOffset = endpoint.alterColumnOffset || 0;\n      if (endpoint.destinationRow + alterRowOffset >= this.hot.countRows() || endpoint.destinationColumn + alterColOffset >= this.hot.countCols()) {\n        return true;\n      }\n      return false;\n    });\n    if (anyEndpointOutOfRange) {\n      return;\n    }\n    this.cellsToSetCache = [];\n    arrayEach(endpoints, endpoint => {\n      this.resetEndpointValue(endpoint, useOffset);\n    });\n    this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Calculate and refresh all defined endpoints.\n   */\n  refreshAllEndpoints() {\n    this.cellsToSetCache = [];\n    arrayEach(this.getAllEndpoints(), value => {\n      this.currentEndpoint = value;\n      this.plugin.calculate(value);\n      this.setEndpointValue(value, 'init');\n    });\n    this.currentEndpoint = null;\n    this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Calculate and refresh endpoints only in the changed columns.\n   *\n   * @param {Array} changes Array of changes from the `afterChange` hook.\n   */\n  refreshChangedEndpoints(changes) {\n    const needToRefresh = [];\n    this.cellsToSetCache = [];\n    arrayEach(changes, (value, key, changesObj) => {\n      // if nothing changed, dont update anything\n      if (`${value[2] || ''}` === `${value[3]}`) {\n        return;\n      }\n      arrayEach(this.getAllEndpoints(), (endpoint, j) => {\n        if (this.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n          needToRefresh.push(j);\n        }\n      });\n    });\n    arrayEach(needToRefresh, value => {\n      this.refreshEndpoint(this.getEndpoint(value));\n    });\n    this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Refreshes the cell meta information for the all endpoints after the `updateSettings` method call which in some\n   * cases (call with `columns` option) can reset the cell metas to the initial state.\n   */\n  refreshCellMetas() {\n    this.endpoints.forEach(endpoint => {\n      const destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n      if (destinationVisualRow !== null) {\n        const cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n    });\n  }\n\n  /**\n   * Calculate and refresh a single endpoint.\n   *\n   * @param {object} endpoint Contains the endpoint information.\n   */\n  refreshEndpoint(endpoint) {\n    this.currentEndpoint = endpoint;\n    this.plugin.calculate(endpoint);\n    this.setEndpointValue(endpoint);\n    this.currentEndpoint = null;\n  }\n\n  /**\n   * Reset the endpoint value.\n   *\n   * @param {object} endpoint Contains the endpoint information.\n   * @param {boolean} [useOffset=true] Use the cell offset value.\n   */\n  resetEndpointValue(endpoint) {\n    let useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const alterRowOffset = endpoint.alterRowOffset || 0;\n    const alterColOffset = endpoint.alterColumnOffset || 0;\n    this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n  }\n\n  /**\n   * Set the endpoint value.\n   *\n   * @param {object} endpoint Contains the endpoint information.\n   * @param {string} [source] Source of the call information.\n   * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\n   */\n  setEndpointValue(endpoint, source) {\n    let render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n    if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n      this.throwOutOfBoundsWarning();\n      return;\n    }\n    const destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n    if (destinationVisualRow !== null) {\n      const cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n      if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n    }\n    if ((endpoint.roundFloat === true || Number.isInteger(endpoint.roundFloat)) && !isNaN(endpoint.result)) {\n      const roundFloatValue = endpoint.roundFloat;\n      let decimalPlacesCount = 0;\n\n      // `toFixed` method accepts only values between 0 and 100\n      if (Number.isInteger(roundFloatValue)) {\n        decimalPlacesCount = Math.min(Math.max(0, roundFloatValue), 100);\n      }\n      endpoint.result = endpoint.result.toFixed(decimalPlacesCount);\n    }\n    if (render) {\n      this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n    } else {\n      this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n    }\n    endpoint.alterRowOffset = undefined;\n    endpoint.alterColumnOffset = undefined;\n  }\n\n  /**\n   * Throw an error for the calculation range being out of boundaries.\n   *\n   * @private\n   */\n  throwOutOfBoundsWarning() {\n    warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n  }\n}\nexport default Endpoints;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}