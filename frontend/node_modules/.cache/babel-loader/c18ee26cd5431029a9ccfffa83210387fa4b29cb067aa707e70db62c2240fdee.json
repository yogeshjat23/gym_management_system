{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\nclass DataManager {\n  constructor(nestedRowsPlugin, hotInstance) {\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n    _defineProperty(this, \"data\", null);\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n    _defineProperty(this, \"parentReference\", new WeakMap());\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cache\", {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    });\n    this.hot = hotInstance;\n    this.plugin = nestedRowsPlugin;\n  }\n\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  setData(data) {\n    this.data = data;\n  }\n\n  /**\n   * Get the data cached in the manager.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getData() {\n    return this.data;\n  }\n\n  /**\n   * Load the \"raw\" source data, without NestedRows' modifications.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getRawSourceData() {\n    let rawSourceData = null;\n    this.plugin.disableCoreAPIModifiers();\n    rawSourceData = this.hot.getSourceData();\n    this.plugin.enableCoreAPIModifiers();\n    return rawSourceData;\n  }\n\n  /**\n   * Update the Data Manager with new data and refresh cache.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  updateWithData(data) {\n    this.setData(data);\n    this.rewriteCache();\n  }\n\n  /**\n   * Rewrite the nested structure cache.\n   *\n   * @private\n   */\n  rewriteCache() {\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n    rangeEach(0, this.data.length - 1, i => {\n      this.cacheNode(this.data[i], 0, null);\n    });\n  }\n\n  /**\n   * Cache a data node.\n   *\n   * @private\n   * @param {object} node Node to cache.\n   * @param {number} level Level of the node.\n   * @param {object} parent Parent of the node.\n   */\n  cacheNode(node, level, parent) {\n    if (!this.cache.levels[level]) {\n      this.cache.levels[level] = [];\n      this.cache.levelCount += 1;\n    }\n    this.cache.levels[level].push(node);\n    this.cache.rows.push(node);\n    this.cache.nodeInfo.set(node, {\n      parent,\n      row: this.cache.rows.length - 1,\n      level\n    });\n    if (this.hasChildren(node)) {\n      arrayEach(node.__children, elem => {\n        this.cacheNode(elem, level + 1, node);\n      });\n    }\n  }\n\n  /**\n   * Get the date for the provided visual row number.\n   *\n   * @param {number} row Row index.\n   * @returns {object}\n   */\n  getDataObject(row) {\n    return row === null || row === undefined ? null : this.cache.rows[row];\n  }\n\n  /**\n   * Read the row tree in search for a specific row index or row object.\n   *\n   * @private\n   * @param {object} parent The initial parent object.\n   * @param {number} readCount Number of read nodes.\n   * @param {number} neededIndex The row index we search for.\n   * @param {object} neededObject The row object we search for.\n   * @returns {number|object}\n   */\n  readTreeNodes(parent, readCount, neededIndex, neededObject) {\n    let rootLevel = false;\n    let readNodesCount = readCount;\n    if (isNaN(readNodesCount) && readNodesCount.end) {\n      return readNodesCount;\n    }\n    let parentObj = parent;\n    if (!parentObj) {\n      parentObj = {\n        __children: this.data\n      };\n      rootLevel = true;\n      readNodesCount -= 1;\n    }\n    if (neededIndex !== null && neededIndex !== undefined && readNodesCount === neededIndex) {\n      return {\n        result: parentObj,\n        end: true\n      };\n    }\n    if (neededObject !== null && neededObject !== undefined && parentObj === neededObject) {\n      return {\n        result: readNodesCount,\n        end: true\n      };\n    }\n    readNodesCount += 1;\n    if (parentObj.__children) {\n      arrayEach(parentObj.__children, val => {\n        this.parentReference.set(val, rootLevel ? null : parentObj);\n        readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n        if (isNaN(readNodesCount) && readNodesCount.end) {\n          return false;\n        }\n      });\n    }\n    return readNodesCount;\n  }\n\n  /**\n   * Mock a parent node.\n   *\n   * @private\n   * @returns {*}\n   */\n  mockParent() {\n    const fakeParent = this.mockNode();\n    fakeParent.__children = this.data;\n    return fakeParent;\n  }\n\n  /**\n   * Mock a data node.\n   *\n   * @private\n   * @returns {{}}\n   */\n  mockNode() {\n    const fakeNode = {};\n    objectEach(this.data[0], (val, key) => {\n      fakeNode[key] = null;\n    });\n    return fakeNode;\n  }\n\n  /**\n   * Get the row index for the provided row object.\n   *\n   * @param {object} rowObj The row object.\n   * @returns {number} Row index.\n   */\n  getRowIndex(rowObj) {\n    return rowObj === null || rowObj === undefined ? null : this.cache.nodeInfo.get(rowObj).row;\n  }\n\n  /**\n   * Get the index of the provided row index/row object within its parent.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {number}\n   */\n  getRowIndexWithinParent(row) {\n    let rowObj = null;\n    if (isNaN(row)) {\n      rowObj = row;\n    } else {\n      rowObj = this.getDataObject(row);\n    }\n    const parent = this.getRowParent(row);\n    if (parent === null || parent === undefined) {\n      return this.data.indexOf(rowObj);\n    }\n    return parent.__children.indexOf(rowObj);\n  }\n\n  /**\n   * Count all rows (including all parents and children).\n   *\n   * @returns {number}\n   */\n  countAllRows() {\n    const rootNodeMock = {\n      __children: this.data\n    };\n    return this.countChildren(rootNodeMock);\n  }\n\n  /**\n   * Count children of the provided parent.\n   *\n   * @param {object|number} parent Parent node.\n   * @returns {number} Children count.\n   */\n  countChildren(parent) {\n    let rowCount = 0;\n    let parentNode = parent;\n    if (!isNaN(parentNode)) {\n      parentNode = this.getDataObject(parentNode);\n    }\n    if (!parentNode || !parentNode.__children) {\n      return 0;\n    }\n    arrayEach(parentNode.__children, elem => {\n      rowCount += 1;\n      if (elem.__children) {\n        rowCount += this.countChildren(elem);\n      }\n    });\n    return rowCount;\n  }\n\n  /**\n   * Get the parent of the row at the provided index.\n   *\n   * @param {number|object} row Physical row index.\n   * @returns {object}\n   */\n  getRowParent(row) {\n    let rowObject;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return this.getRowObjectParent(rowObject);\n  }\n\n  /**\n   * Get the parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowObject The row object (tree node).\n   * @returns {object|null}\n   */\n  getRowObjectParent(rowObject) {\n    if (!rowObject || typeof rowObject !== 'object') {\n      return null;\n    }\n    return this.cache.nodeInfo.get(rowObject).parent;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @param {number} row Row index.\n   * @returns {number|null} Row level or null, when row doesn't exist.\n   */\n  getRowLevel(row) {\n    let rowObject = null;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return rowObject ? this.getRowObjectLevel(rowObject) : null;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @private\n   * @param {object} rowObject Row object.\n   * @returns {number} Row level.\n   */\n  getRowObjectLevel(rowObject) {\n    return rowObject === null || rowObject === undefined ? null : this.cache.nodeInfo.get(rowObject).level;\n  }\n\n  /**\n   * Check if the provided row/row element has children.\n   *\n   * @param {number|object} row Row number or row element.\n   * @returns {boolean}\n   */\n  hasChildren(row) {\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return !!(rowObj.__children && rowObj.__children.length);\n  }\n\n  /**\n   * Returns `true` if the row at the provided index has a parent.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n   */\n  isChild(index) {\n    return this.getRowParent(index) !== null;\n  }\n\n  /**\n   * Get child at a provided index from the parent element.\n   *\n   * @param {object} parent The parent row object.\n   * @param {number} index Index of the child element to be retrieved.\n   * @returns {object|null} The child element or `null` if the child doesn't exist.\n   */\n  getChild(parent, index) {\n    var _parent$__children;\n    return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n  }\n\n  /**\n   * Return `true` of the row at the provided index is located at the topmost level.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n   */\n  isRowHighestLevel(index) {\n    return !this.isChild(index);\n  }\n\n  /**\n   * Return `true` if the provided row index / row object represents a parent in the nested structure.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n   */\n  isParent(row) {\n    var _rowObj$__children;\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n  }\n\n  /**\n   * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n   *\n   * @param {object} parent The parent row object.\n   * @param {object} [element] The element to add as a child.\n   */\n  addChild(parent, element) {\n    let childElement = element;\n    this.hot.runHooks('beforeAddChild', parent, childElement);\n    let parentIndex = null;\n    if (parent) {\n      parentIndex = this.getRowIndex(parent);\n    }\n    this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n    let functionalParent = parent;\n    if (!parent) {\n      functionalParent = this.mockParent();\n    }\n    if (!functionalParent.__children) {\n      functionalParent.__children = [];\n    }\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    functionalParent.__children.push(childElement);\n    this.rewriteCache();\n    const newRowIndex = this.getRowIndex(childElement);\n    this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n    this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n    this.hot.runHooks('afterAddChild', parent, childElement);\n  }\n\n  /**\n   * Add a child node to the provided parent at a specified index.\n   *\n   * @param {object} parent Parent node.\n   * @param {number} index Index to insert the child element at.\n   * @param {object} [element] Element (node) to insert.\n   */\n  addChildAtIndex(parent, index, element) {\n    let childElement = element;\n    let flattenedIndex;\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    this.hot.runHooks('beforeAddChild', parent, childElement, index);\n    if (parent) {\n      const parentIndex = this.getRowIndex(parent);\n      const finalChildIndex = parentIndex + index + 1;\n      this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n      parent.__children.splice(index, null, childElement);\n      this.rewriteCache();\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n      this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n      this.plugin.enableCoreAPIModifiers();\n      this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n      flattenedIndex = finalChildIndex;\n    } else {\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.alter('insert_row_above', index, 1, 'NestedRows.addChildAtIndex');\n      this.plugin.enableCoreAPIModifiers();\n      flattenedIndex = this.getRowIndex(this.data[index]);\n    }\n\n    // Workaround for refreshing cache losing the reference to the mocked row.\n    childElement = this.getDataObject(flattenedIndex);\n    this.hot.runHooks('afterAddChild', parent, childElement, index);\n  }\n\n  /**\n   * Add a sibling element at the specified index.\n   *\n   * @param {number} index New element sibling's index.\n   * @param {('above'|'below')} where Direction in which the sibling is to be created.\n   */\n  addSibling(index) {\n    let where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n    const translatedIndex = this.translateTrimmedRow(index);\n    const parent = this.getRowParent(translatedIndex);\n    const indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n    switch (where) {\n      case 'below':\n        this.addChildAtIndex(parent, indexWithinParent + 1, null);\n        break;\n      case 'above':\n        this.addChildAtIndex(parent, indexWithinParent, null);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Detach the provided element from its parent and add it right after it.\n   *\n   * @param {object|Array} elements Row object or an array of selected coordinates.\n   * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n   */\n  detachFromParent(elements) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let element = null;\n    const rowObjects = [];\n    if (Array.isArray(elements)) {\n      rangeEach(elements[0], elements[2], i => {\n        const translatedIndex = this.translateTrimmedRow(i);\n        rowObjects.push(this.getDataObject(translatedIndex));\n      });\n      rangeEach(0, rowObjects.length - 2, i => {\n        this.detachFromParent(rowObjects[i], false);\n      });\n      element = rowObjects[rowObjects.length - 1];\n    } else {\n      element = elements;\n    }\n    const childRowIndex = this.getRowIndex(element);\n    const childCount = this.countChildren(element);\n    const indexWithinParent = this.getRowIndexWithinParent(element);\n    const parent = this.getRowParent(element);\n    const grandparent = this.getRowParent(parent);\n    const grandparentRowIndex = this.getRowIndex(grandparent);\n    let movedElementRowIndex = null;\n    this.hot.runHooks('beforeDetachChild', parent, element);\n    if (indexWithinParent !== null && indexWithinParent !== undefined) {\n      const removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n      this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      parent.__children.splice(indexWithinParent, 1);\n      this.rewriteCache();\n      this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      if (grandparent) {\n        movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n        const lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n        const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n        this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n        grandparent.__children.push(element);\n      } else {\n        movedElementRowIndex = this.hot.countRows() + 1;\n        this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n        this.data.push(element);\n      }\n    }\n    this.rewriteCache();\n    this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n    this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n    if (forceRender) {\n      this.hot.render();\n    }\n  }\n\n  /**\n   * Filter the data by the `logicRows` array.\n   *\n   * @private\n   * @param {number} index Index of the first row to remove.\n   * @param {number} amount Number of elements to remove.\n   * @param {Array} logicRows Array of indexes to remove.\n   */\n  filterData(index, amount, logicRows) {\n    // TODO: why are the first 2 arguments not used?\n\n    const elementsToRemove = [];\n    arrayEach(logicRows, elem => {\n      elementsToRemove.push(this.getDataObject(elem));\n    });\n    arrayEach(elementsToRemove, elem => {\n      const indexWithinParent = this.getRowIndexWithinParent(elem);\n      const tempParent = this.getRowParent(elem);\n      if (tempParent === null) {\n        this.data.splice(indexWithinParent, 1);\n      } else {\n        tempParent.__children.splice(indexWithinParent, 1);\n      }\n    });\n    this.rewriteCache();\n  }\n\n  /**\n   * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n   * default script.\n   *\n   * @private\n   * @param {number} index Physical index of the element at the splice beginning.\n   * @param {number} amount Number of elements to be removed.\n   * @param {object[]} elements Array of row objects to add.\n   */\n  spliceData(index, amount, elements) {\n    const previousElement = this.getDataObject(index - 1);\n    let newRowParent = null;\n    let indexWithinParent = index;\n    if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n      newRowParent = previousElement;\n      indexWithinParent = 0;\n    } else if (index < this.countAllRows()) {\n      newRowParent = this.getRowParent(index);\n      indexWithinParent = this.getRowIndexWithinParent(index);\n    }\n    if (newRowParent) {\n      if (elements) {\n        newRowParent.__children.splice(indexWithinParent, amount, ...elements);\n      } else {\n        newRowParent.__children.splice(indexWithinParent, amount);\n      }\n    } else if (elements) {\n      this.data.splice(indexWithinParent, amount, ...elements);\n    } else {\n      this.data.splice(indexWithinParent, amount);\n    }\n    this.rewriteCache();\n  }\n\n  /**\n   * Update the `__children` key of the upmost parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowElement Row object.\n   */\n  syncRowWithRawSource(rowElement) {\n    let upmostParent = rowElement;\n    let tempParent = null;\n    do {\n      tempParent = this.getRowParent(tempParent);\n      if (tempParent !== null) {\n        upmostParent = tempParent;\n      }\n    } while (tempParent !== null);\n    this.plugin.disableCoreAPIModifiers();\n    this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n    this.plugin.enableCoreAPIModifiers();\n  }\n\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Move a single row.\n   *\n   * @param {number} fromIndex Index of the row to be moved.\n   * @param {number} toIndex Index of the destination.\n   * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n   * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n  moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n    const moveToLastRow = toIndex === this.hot.countRows();\n    const fromParent = this.getRowParent(fromIndex);\n    const indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n    const elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n    const movingUp = fromIndex > toIndex;\n    let toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getRowParent(toIndex - 1);\n    }\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getDataObject(toIndex - 1);\n    }\n    if (!toParent) {\n      toParent = this.getDataObject(toIndex);\n      toParent.__children = [];\n    } else if (!toParent.__children) {\n      toParent.__children = [];\n    }\n    const indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n    const sameParent = fromParent === toParent;\n    toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n    fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);\n\n    // Sync the changes in the cached data with the actual data stored in HOT.\n    this.syncRowWithRawSource(fromParent);\n    if (!sameParent) {\n      this.syncRowWithRawSource(toParent);\n    }\n  }\n\n  /**\n   * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  translateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.translateTrimmedRow(row);\n    }\n    return row;\n  }\n\n  /**\n   * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  untranslateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n    }\n    return row;\n  }\n}\nexport default DataManager;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","rangeEach","objectEach","arrayEach","DataManager","constructor","nestedRowsPlugin","hotInstance","WeakMap","levels","levelCount","rows","nodeInfo","hot","plugin","setData","data","getData","getRawSourceData","rawSourceData","disableCoreAPIModifiers","getSourceData","enableCoreAPIModifiers","updateWithData","rewriteCache","cache","length","cacheNode","node","level","parent","push","set","row","hasChildren","__children","elem","getDataObject","undefined","readTreeNodes","readCount","neededIndex","neededObject","rootLevel","readNodesCount","isNaN","end","parentObj","result","val","parentReference","mockParent","fakeParent","mockNode","fakeNode","key","getRowIndex","rowObj","get","getRowIndexWithinParent","getRowParent","indexOf","countAllRows","rootNodeMock","countChildren","rowCount","parentNode","rowObject","getRowObjectParent","getRowLevel","getRowObjectLevel","isChild","index","getChild","_parent$__children","isRowHighestLevel","isParent","_rowObj$__children","addChild","element","childElement","runHooks","parentIndex","functionalParent","newRowIndex","rowIndexMapper","insertIndexes","addChildAtIndex","flattenedIndex","finalChildIndex","splice","setSourceDataAtCell","alter","addSibling","where","arguments","translatedIndex","translateTrimmedRow","indexWithinParent","detachFromParent","elements","forceRender","rowObjects","Array","isArray","childRowIndex","childCount","grandparent","grandparentRowIndex","movedElementRowIndex","removedRowIndexes","from","keys","pluginName","lastGrandparentChild","lastGrandparentChildIndex","countRows","render","filterData","amount","logicRows","elementsToRemove","tempParent","spliceData","previousElement","newRowParent","syncRowWithRawSource","rowElement","upmostParent","moveRow","fromIndex","toIndex","moveToCollapsed","moveToLastChild","moveToLastRow","fromParent","indexInFromParent","elemToMove","slice","movingUp","toParent","indexInTargetParent","sameParent","collapsingUI","untranslateTrimmedRow"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\nclass DataManager {\n  constructor(nestedRowsPlugin, hotInstance) {\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n    _defineProperty(this, \"data\", null);\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n    _defineProperty(this, \"parentReference\", new WeakMap());\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cache\", {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    });\n    this.hot = hotInstance;\n    this.plugin = nestedRowsPlugin;\n  }\n\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  setData(data) {\n    this.data = data;\n  }\n\n  /**\n   * Get the data cached in the manager.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getData() {\n    return this.data;\n  }\n\n  /**\n   * Load the \"raw\" source data, without NestedRows' modifications.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getRawSourceData() {\n    let rawSourceData = null;\n    this.plugin.disableCoreAPIModifiers();\n    rawSourceData = this.hot.getSourceData();\n    this.plugin.enableCoreAPIModifiers();\n    return rawSourceData;\n  }\n\n  /**\n   * Update the Data Manager with new data and refresh cache.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  updateWithData(data) {\n    this.setData(data);\n    this.rewriteCache();\n  }\n\n  /**\n   * Rewrite the nested structure cache.\n   *\n   * @private\n   */\n  rewriteCache() {\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n    rangeEach(0, this.data.length - 1, i => {\n      this.cacheNode(this.data[i], 0, null);\n    });\n  }\n\n  /**\n   * Cache a data node.\n   *\n   * @private\n   * @param {object} node Node to cache.\n   * @param {number} level Level of the node.\n   * @param {object} parent Parent of the node.\n   */\n  cacheNode(node, level, parent) {\n    if (!this.cache.levels[level]) {\n      this.cache.levels[level] = [];\n      this.cache.levelCount += 1;\n    }\n    this.cache.levels[level].push(node);\n    this.cache.rows.push(node);\n    this.cache.nodeInfo.set(node, {\n      parent,\n      row: this.cache.rows.length - 1,\n      level\n    });\n    if (this.hasChildren(node)) {\n      arrayEach(node.__children, elem => {\n        this.cacheNode(elem, level + 1, node);\n      });\n    }\n  }\n\n  /**\n   * Get the date for the provided visual row number.\n   *\n   * @param {number} row Row index.\n   * @returns {object}\n   */\n  getDataObject(row) {\n    return row === null || row === undefined ? null : this.cache.rows[row];\n  }\n\n  /**\n   * Read the row tree in search for a specific row index or row object.\n   *\n   * @private\n   * @param {object} parent The initial parent object.\n   * @param {number} readCount Number of read nodes.\n   * @param {number} neededIndex The row index we search for.\n   * @param {object} neededObject The row object we search for.\n   * @returns {number|object}\n   */\n  readTreeNodes(parent, readCount, neededIndex, neededObject) {\n    let rootLevel = false;\n    let readNodesCount = readCount;\n    if (isNaN(readNodesCount) && readNodesCount.end) {\n      return readNodesCount;\n    }\n    let parentObj = parent;\n    if (!parentObj) {\n      parentObj = {\n        __children: this.data\n      };\n      rootLevel = true;\n      readNodesCount -= 1;\n    }\n    if (neededIndex !== null && neededIndex !== undefined && readNodesCount === neededIndex) {\n      return {\n        result: parentObj,\n        end: true\n      };\n    }\n    if (neededObject !== null && neededObject !== undefined && parentObj === neededObject) {\n      return {\n        result: readNodesCount,\n        end: true\n      };\n    }\n    readNodesCount += 1;\n    if (parentObj.__children) {\n      arrayEach(parentObj.__children, val => {\n        this.parentReference.set(val, rootLevel ? null : parentObj);\n        readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n        if (isNaN(readNodesCount) && readNodesCount.end) {\n          return false;\n        }\n      });\n    }\n    return readNodesCount;\n  }\n\n  /**\n   * Mock a parent node.\n   *\n   * @private\n   * @returns {*}\n   */\n  mockParent() {\n    const fakeParent = this.mockNode();\n    fakeParent.__children = this.data;\n    return fakeParent;\n  }\n\n  /**\n   * Mock a data node.\n   *\n   * @private\n   * @returns {{}}\n   */\n  mockNode() {\n    const fakeNode = {};\n    objectEach(this.data[0], (val, key) => {\n      fakeNode[key] = null;\n    });\n    return fakeNode;\n  }\n\n  /**\n   * Get the row index for the provided row object.\n   *\n   * @param {object} rowObj The row object.\n   * @returns {number} Row index.\n   */\n  getRowIndex(rowObj) {\n    return rowObj === null || rowObj === undefined ? null : this.cache.nodeInfo.get(rowObj).row;\n  }\n\n  /**\n   * Get the index of the provided row index/row object within its parent.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {number}\n   */\n  getRowIndexWithinParent(row) {\n    let rowObj = null;\n    if (isNaN(row)) {\n      rowObj = row;\n    } else {\n      rowObj = this.getDataObject(row);\n    }\n    const parent = this.getRowParent(row);\n    if (parent === null || parent === undefined) {\n      return this.data.indexOf(rowObj);\n    }\n    return parent.__children.indexOf(rowObj);\n  }\n\n  /**\n   * Count all rows (including all parents and children).\n   *\n   * @returns {number}\n   */\n  countAllRows() {\n    const rootNodeMock = {\n      __children: this.data\n    };\n    return this.countChildren(rootNodeMock);\n  }\n\n  /**\n   * Count children of the provided parent.\n   *\n   * @param {object|number} parent Parent node.\n   * @returns {number} Children count.\n   */\n  countChildren(parent) {\n    let rowCount = 0;\n    let parentNode = parent;\n    if (!isNaN(parentNode)) {\n      parentNode = this.getDataObject(parentNode);\n    }\n    if (!parentNode || !parentNode.__children) {\n      return 0;\n    }\n    arrayEach(parentNode.__children, elem => {\n      rowCount += 1;\n      if (elem.__children) {\n        rowCount += this.countChildren(elem);\n      }\n    });\n    return rowCount;\n  }\n\n  /**\n   * Get the parent of the row at the provided index.\n   *\n   * @param {number|object} row Physical row index.\n   * @returns {object}\n   */\n  getRowParent(row) {\n    let rowObject;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return this.getRowObjectParent(rowObject);\n  }\n\n  /**\n   * Get the parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowObject The row object (tree node).\n   * @returns {object|null}\n   */\n  getRowObjectParent(rowObject) {\n    if (!rowObject || typeof rowObject !== 'object') {\n      return null;\n    }\n    return this.cache.nodeInfo.get(rowObject).parent;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @param {number} row Row index.\n   * @returns {number|null} Row level or null, when row doesn't exist.\n   */\n  getRowLevel(row) {\n    let rowObject = null;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return rowObject ? this.getRowObjectLevel(rowObject) : null;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @private\n   * @param {object} rowObject Row object.\n   * @returns {number} Row level.\n   */\n  getRowObjectLevel(rowObject) {\n    return rowObject === null || rowObject === undefined ? null : this.cache.nodeInfo.get(rowObject).level;\n  }\n\n  /**\n   * Check if the provided row/row element has children.\n   *\n   * @param {number|object} row Row number or row element.\n   * @returns {boolean}\n   */\n  hasChildren(row) {\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return !!(rowObj.__children && rowObj.__children.length);\n  }\n\n  /**\n   * Returns `true` if the row at the provided index has a parent.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n   */\n  isChild(index) {\n    return this.getRowParent(index) !== null;\n  }\n\n  /**\n   * Get child at a provided index from the parent element.\n   *\n   * @param {object} parent The parent row object.\n   * @param {number} index Index of the child element to be retrieved.\n   * @returns {object|null} The child element or `null` if the child doesn't exist.\n   */\n  getChild(parent, index) {\n    var _parent$__children;\n    return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n  }\n\n  /**\n   * Return `true` of the row at the provided index is located at the topmost level.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n   */\n  isRowHighestLevel(index) {\n    return !this.isChild(index);\n  }\n\n  /**\n   * Return `true` if the provided row index / row object represents a parent in the nested structure.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n   */\n  isParent(row) {\n    var _rowObj$__children;\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n  }\n\n  /**\n   * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n   *\n   * @param {object} parent The parent row object.\n   * @param {object} [element] The element to add as a child.\n   */\n  addChild(parent, element) {\n    let childElement = element;\n    this.hot.runHooks('beforeAddChild', parent, childElement);\n    let parentIndex = null;\n    if (parent) {\n      parentIndex = this.getRowIndex(parent);\n    }\n    this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n    let functionalParent = parent;\n    if (!parent) {\n      functionalParent = this.mockParent();\n    }\n    if (!functionalParent.__children) {\n      functionalParent.__children = [];\n    }\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    functionalParent.__children.push(childElement);\n    this.rewriteCache();\n    const newRowIndex = this.getRowIndex(childElement);\n    this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n    this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n    this.hot.runHooks('afterAddChild', parent, childElement);\n  }\n\n  /**\n   * Add a child node to the provided parent at a specified index.\n   *\n   * @param {object} parent Parent node.\n   * @param {number} index Index to insert the child element at.\n   * @param {object} [element] Element (node) to insert.\n   */\n  addChildAtIndex(parent, index, element) {\n    let childElement = element;\n    let flattenedIndex;\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    this.hot.runHooks('beforeAddChild', parent, childElement, index);\n    if (parent) {\n      const parentIndex = this.getRowIndex(parent);\n      const finalChildIndex = parentIndex + index + 1;\n      this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n      parent.__children.splice(index, null, childElement);\n      this.rewriteCache();\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n      this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n      this.plugin.enableCoreAPIModifiers();\n      this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n      flattenedIndex = finalChildIndex;\n    } else {\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.alter('insert_row_above', index, 1, 'NestedRows.addChildAtIndex');\n      this.plugin.enableCoreAPIModifiers();\n      flattenedIndex = this.getRowIndex(this.data[index]);\n    }\n\n    // Workaround for refreshing cache losing the reference to the mocked row.\n    childElement = this.getDataObject(flattenedIndex);\n    this.hot.runHooks('afterAddChild', parent, childElement, index);\n  }\n\n  /**\n   * Add a sibling element at the specified index.\n   *\n   * @param {number} index New element sibling's index.\n   * @param {('above'|'below')} where Direction in which the sibling is to be created.\n   */\n  addSibling(index) {\n    let where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n    const translatedIndex = this.translateTrimmedRow(index);\n    const parent = this.getRowParent(translatedIndex);\n    const indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n    switch (where) {\n      case 'below':\n        this.addChildAtIndex(parent, indexWithinParent + 1, null);\n        break;\n      case 'above':\n        this.addChildAtIndex(parent, indexWithinParent, null);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Detach the provided element from its parent and add it right after it.\n   *\n   * @param {object|Array} elements Row object or an array of selected coordinates.\n   * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n   */\n  detachFromParent(elements) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let element = null;\n    const rowObjects = [];\n    if (Array.isArray(elements)) {\n      rangeEach(elements[0], elements[2], i => {\n        const translatedIndex = this.translateTrimmedRow(i);\n        rowObjects.push(this.getDataObject(translatedIndex));\n      });\n      rangeEach(0, rowObjects.length - 2, i => {\n        this.detachFromParent(rowObjects[i], false);\n      });\n      element = rowObjects[rowObjects.length - 1];\n    } else {\n      element = elements;\n    }\n    const childRowIndex = this.getRowIndex(element);\n    const childCount = this.countChildren(element);\n    const indexWithinParent = this.getRowIndexWithinParent(element);\n    const parent = this.getRowParent(element);\n    const grandparent = this.getRowParent(parent);\n    const grandparentRowIndex = this.getRowIndex(grandparent);\n    let movedElementRowIndex = null;\n    this.hot.runHooks('beforeDetachChild', parent, element);\n    if (indexWithinParent !== null && indexWithinParent !== undefined) {\n      const removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n      this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      parent.__children.splice(indexWithinParent, 1);\n      this.rewriteCache();\n      this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      if (grandparent) {\n        movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n        const lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n        const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n        this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n        grandparent.__children.push(element);\n      } else {\n        movedElementRowIndex = this.hot.countRows() + 1;\n        this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n        this.data.push(element);\n      }\n    }\n    this.rewriteCache();\n    this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n    this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n    if (forceRender) {\n      this.hot.render();\n    }\n  }\n\n  /**\n   * Filter the data by the `logicRows` array.\n   *\n   * @private\n   * @param {number} index Index of the first row to remove.\n   * @param {number} amount Number of elements to remove.\n   * @param {Array} logicRows Array of indexes to remove.\n   */\n  filterData(index, amount, logicRows) {\n    // TODO: why are the first 2 arguments not used?\n\n    const elementsToRemove = [];\n    arrayEach(logicRows, elem => {\n      elementsToRemove.push(this.getDataObject(elem));\n    });\n    arrayEach(elementsToRemove, elem => {\n      const indexWithinParent = this.getRowIndexWithinParent(elem);\n      const tempParent = this.getRowParent(elem);\n      if (tempParent === null) {\n        this.data.splice(indexWithinParent, 1);\n      } else {\n        tempParent.__children.splice(indexWithinParent, 1);\n      }\n    });\n    this.rewriteCache();\n  }\n\n  /**\n   * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n   * default script.\n   *\n   * @private\n   * @param {number} index Physical index of the element at the splice beginning.\n   * @param {number} amount Number of elements to be removed.\n   * @param {object[]} elements Array of row objects to add.\n   */\n  spliceData(index, amount, elements) {\n    const previousElement = this.getDataObject(index - 1);\n    let newRowParent = null;\n    let indexWithinParent = index;\n    if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n      newRowParent = previousElement;\n      indexWithinParent = 0;\n    } else if (index < this.countAllRows()) {\n      newRowParent = this.getRowParent(index);\n      indexWithinParent = this.getRowIndexWithinParent(index);\n    }\n    if (newRowParent) {\n      if (elements) {\n        newRowParent.__children.splice(indexWithinParent, amount, ...elements);\n      } else {\n        newRowParent.__children.splice(indexWithinParent, amount);\n      }\n    } else if (elements) {\n      this.data.splice(indexWithinParent, amount, ...elements);\n    } else {\n      this.data.splice(indexWithinParent, amount);\n    }\n    this.rewriteCache();\n  }\n\n  /**\n   * Update the `__children` key of the upmost parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowElement Row object.\n   */\n  syncRowWithRawSource(rowElement) {\n    let upmostParent = rowElement;\n    let tempParent = null;\n    do {\n      tempParent = this.getRowParent(tempParent);\n      if (tempParent !== null) {\n        upmostParent = tempParent;\n      }\n    } while (tempParent !== null);\n    this.plugin.disableCoreAPIModifiers();\n    this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n    this.plugin.enableCoreAPIModifiers();\n  }\n\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Move a single row.\n   *\n   * @param {number} fromIndex Index of the row to be moved.\n   * @param {number} toIndex Index of the destination.\n   * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n   * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n  moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n    const moveToLastRow = toIndex === this.hot.countRows();\n    const fromParent = this.getRowParent(fromIndex);\n    const indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n    const elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n    const movingUp = fromIndex > toIndex;\n    let toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getRowParent(toIndex - 1);\n    }\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getDataObject(toIndex - 1);\n    }\n    if (!toParent) {\n      toParent = this.getDataObject(toIndex);\n      toParent.__children = [];\n    } else if (!toParent.__children) {\n      toParent.__children = [];\n    }\n    const indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n    const sameParent = fromParent === toParent;\n    toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n    fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);\n\n    // Sync the changes in the cached data with the actual data stored in HOT.\n    this.syncRowWithRawSource(fromParent);\n    if (!sameParent) {\n      this.syncRowWithRawSource(toParent);\n    }\n  }\n\n  /**\n   * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  translateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.translateTrimmedRow(row);\n    }\n    return row;\n  }\n\n  /**\n   * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  untranslateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n    }\n    return row;\n  }\n}\nexport default DataManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}