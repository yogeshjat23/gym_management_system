{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { hasOwnProperty, deepClone } from \"../../helpers/object.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { arrayEach, arrayReduce, arrayMap } from \"../../helpers/array.mjs\";\nimport * as C from \"../../i18n/constants.mjs\";\nimport { top as menuItemTop, bottom as menuItemBottom, left as menuItemLeft, right as menuItemRight, noBorders as menuItemNoBorders } from \"./contextMenuItem/index.mjs\";\nimport { createId, createDefaultCustomBorder, createSingleEmptyBorder, createEmptyBorders, extendDefaultBorder, hasLeftRightTypeOptions, hasStartEndTypeOptions, toInlinePropName, normalizeBorder, denormalizeBorder } from \"./utils.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory } from \"../../selection/index.mjs\";\nexport const PLUGIN_KEY = 'customBorders';\nexport const PLUGIN_PRIORITY = 90;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin CustomBorders\n * @class CustomBorders\n *\n * @description\n * This plugin enables an option to apply custom borders through the context menu (configurable with context menu key\n * `borders`).\n *\n * To initialize Handsontable with predefined custom borders, provide cell coordinates and border styles in a form\n * of an array.\n *\n * See [`customBorders` configuration option](@/api/options.md#customBorders) or go to\n * [Custom cell borders demo](@/guides/cell-features/formatting-cells/formatting-cells.md#custom-cell-borders) for more examples.\n *\n * @example\n * ```js\n * customBorders: [\n *   {\n *    range: {\n *      from: {\n *        row: 1,\n *        col: 1\n *      },\n *      to: {\n *        row: 3,\n *        col: 4\n *      },\n *    },\n *    start: {},\n *    end: {},\n *    top: {},\n *    bottom: {},\n *   },\n * ],\n *\n * // or\n * customBorders: [\n *   { row: 2,\n *     col: 2,\n *     start: {\n *       width: 2,\n *       color: 'red',\n *     },\n *     end: {\n *       width: 1,\n *       color: 'green',\n *     },\n *     top: '',\n *     bottom: '',\n *   }\n * ],\n * ```\n */\nvar _CustomBorders_brand = /*#__PURE__*/new WeakSet();\nexport class CustomBorders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Add border options to context menu.\n     *\n     * @param {object} defaultOptions Context menu items.\n     */\n    _classPrivateMethodInitSpec(this, _CustomBorders_brand);\n    /**\n     * Saved borders.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"savedBorders\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _assertClassBrand(_CustomBorders_brand, this, _onAfterContextMenuDefaultOptions).call(this, options));\n    this.addHook('init', () => _assertClassBrand(_CustomBorders_brand, this, _onAfterInit).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hideBorders();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`customBorders`](@/api/options.md#customborders)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.changeBorderSettings();\n    super.updatePlugin();\n  }\n\n  /**\n   * Set custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});\n   *\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * //  Selecting a cell range.\n   * hot.selectCell(0, 0, 2, 2);\n   * // Returning selected cells' range with the getSelectedRange method.\n   * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.\n   */\n  setBorders(selectionRanges, borderObject) {\n    let borderKeys = ['top', 'bottom', 'start', 'end'];\n    let normBorder = null;\n    if (borderObject) {\n      this.checkSettingsCohesion([borderObject]);\n      borderKeys = Object.keys(borderObject);\n      normBorder = normalizeBorder(borderObject);\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(borderKeys, borderKey => {\n          this.prepareBorderFromCustomAdded(row, col, normBorder, toInlinePropName(borderKey));\n        });\n      });\n    });\n\n    /*\n    The line below triggers a re-render of Handsontable. This will be a \"fastDraw\"\n    render, because that is the default for the TableView class.\n     The re-render is needed for borders on cells that did not have a border before.\n    The way this call works is that it calls Table.refreshSelections, which calls\n    Selection.getBorder, which creates a new instance of Border.\n     Seems wise to keep this single-direction flow of creating new Borders\n    */\n    this.hot.view.render();\n  }\n\n  /**\n   * Get custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.getBorders(hot.getSelectedRange());\n   * // Using without param - return all customBorders.\n   * customBordersPlugin.getBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @returns {object[]} Returns array of border objects.\n   */\n  getBorders(selectionRanges) {\n    if (!Array.isArray(selectionRanges)) {\n      return this.savedBorders;\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    const selectedBorders = [];\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(this.savedBorders, border => {\n          if (border.row === row && border.col === col) {\n            selectedBorders.push(denormalizeBorder(border));\n          }\n        });\n      });\n    });\n    return selectedBorders;\n  }\n\n  /**\n   * Clear custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.clearBorders(hot.getSelectedRange());\n   * // Using without param - clear all customBorders.\n   * customBordersPlugin.clearBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   */\n  clearBorders(selectionRanges) {\n    if (selectionRanges) {\n      this.setBorders(selectionRanges);\n    } else {\n      arrayEach(this.savedBorders, border => {\n        this.clearBordersFromSelectionSettings(border.id);\n        this.clearNullCellRange();\n        this.hot.removeCellMeta(border.row, border.col, 'borders');\n      });\n      this.savedBorders.length = 0;\n    }\n  }\n\n  /**\n   * Insert WalkontableSelection instance into Walkontable settings.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  insertBorderIntoSettings(border, place) {\n    const hasSavedBorders = this.checkSavedBorders(border);\n    if (!hasSavedBorders) {\n      this.savedBorders.push(border);\n    }\n    const visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));\n    const hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);\n    if (!hasCustomSelections) {\n      this.hot.selection.highlight.addCustomSelection({\n        border,\n        visualCellRange\n      });\n    }\n  }\n\n  /**\n   * Prepare borders from setting (single cell).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {\n    const nrOfRows = this.hot.countRows();\n    const nrOfColumns = this.hot.countCols();\n    if (row >= nrOfRows || column >= nrOfColumns) {\n      return;\n    }\n    let border = createEmptyBorders(row, column);\n    if (borderDescriptor) {\n      border = extendDefaultBorder(border, borderDescriptor);\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          Object.assign(customSelection.settings, borderDescriptor);\n          border.id = customSelection.settings.id;\n          border.top = customSelection.settings.top;\n          border.bottom = customSelection.settings.bottom;\n          border.start = customSelection.settings.start;\n          border.end = customSelection.settings.end;\n          return false; // breaks forAll\n        }\n      });\n    }\n    this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(border));\n    this.insertBorderIntoSettings(border, place);\n  }\n\n  /**\n   * Prepare borders from setting (object).\n   *\n   * @private\n   * @param {object} range {CellRange} The CellRange object.\n   * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.\n   */\n  prepareBorderFromCustomAddedRange(range, customBorder) {\n    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);\n    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);\n    rangeEach(range.from.row, lastRowIndex, rowIndex => {\n      rangeEach(range.from.col, lastColumnIndex, colIndex => {\n        const border = createEmptyBorders(rowIndex, colIndex);\n        let add = 0;\n        if (rowIndex === range.from.row) {\n          if (hasOwnProperty(customBorder, 'top')) {\n            add += 1;\n            border.top = customBorder.top;\n          }\n        }\n\n        // Please keep in mind that `range.to.row` may be beyond the table boundaries. The border won't be rendered.\n        if (rowIndex === range.to.row) {\n          if (hasOwnProperty(customBorder, 'bottom')) {\n            add += 1;\n            border.bottom = customBorder.bottom;\n          }\n        }\n        if (colIndex === range.from.col) {\n          if (hasOwnProperty(customBorder, 'start')) {\n            add += 1;\n            border.start = customBorder.start;\n          }\n        }\n\n        // Please keep in mind that `range.to.col` may be beyond the table boundaries. The border won't be rendered.\n        if (colIndex === range.to.col) {\n          if (hasOwnProperty(customBorder, 'end')) {\n            add += 1;\n            border.end = customBorder.end;\n          }\n        }\n        if (add > 0) {\n          this.hot.setCellMeta(rowIndex, colIndex, 'borders', denormalizeBorder(border));\n          this.insertBorderIntoSettings(border);\n        } else {\n          // TODO sometimes it enters here. Why?\n        }\n      });\n    });\n  }\n\n  /**\n   * Remove border (triggered from context menu).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   */\n  removeAllBorders(row, column) {\n    const borderId = createId(row, column);\n    this.spliceBorder(borderId);\n    this.clearBordersFromSelectionSettings(borderId);\n    this.clearNullCellRange();\n    this.hot.removeCellMeta(row, column, 'borders');\n  }\n\n  /**\n   * Set borders for each cell re. To border position.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  setBorder(row, column, place, remove) {\n    let bordersMeta = this.hot.getCellMeta(row, column).borders;\n    if (!bordersMeta || bordersMeta.border === undefined) {\n      bordersMeta = createEmptyBorders(row, column);\n    } else {\n      bordersMeta = normalizeBorder(bordersMeta);\n    }\n    if (remove) {\n      bordersMeta[place] = createSingleEmptyBorder();\n      const hideCount = this.countHide(bordersMeta);\n      if (hideCount === 4) {\n        this.removeAllBorders(row, column);\n      } else {\n        const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n        if (!customSelectionsChecker) {\n          this.insertBorderIntoSettings(bordersMeta);\n        }\n        this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n      }\n    } else {\n      bordersMeta[place] = createDefaultCustomBorder();\n      const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n      if (!customSelectionsChecker) {\n        this.insertBorderIntoSettings(bordersMeta);\n      }\n      this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n    }\n  }\n\n  /**\n   * Prepare borders based on cell and border position.\n   *\n   * @private\n   * @param {CellRange[]} selected An array of CellRange objects.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  prepareBorder(selected, place, remove) {\n    arrayEach(selected, _ref => {\n      let {\n        start,\n        end\n      } = _ref;\n      if (start.row === end.row && start.col === end.col) {\n        if (place === 'noBorders') {\n          this.removeAllBorders(start.row, start.col);\n        } else {\n          this.setBorder(start.row, start.col, place, remove);\n        }\n      } else {\n        switch (place) {\n          case 'noBorders':\n            rangeEach(start.col, end.col, colIndex => {\n              rangeEach(start.row, end.row, rowIndex => {\n                this.removeAllBorders(rowIndex, colIndex);\n              });\n            });\n            break;\n          case 'top':\n            rangeEach(start.col, end.col, topCol => {\n              this.setBorder(start.row, topCol, place, remove);\n            });\n            break;\n          case 'bottom':\n            rangeEach(start.col, end.col, bottomCol => {\n              this.setBorder(end.row, bottomCol, place, remove);\n            });\n            break;\n          case 'start':\n            rangeEach(start.row, end.row, rowStart => {\n              this.setBorder(rowStart, start.col, place, remove);\n            });\n            break;\n          case 'end':\n            rangeEach(start.row, end.row, rowEnd => {\n              this.setBorder(rowEnd, end.col, place, remove);\n            });\n            break;\n          default:\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Create borders from settings.\n   *\n   * @private\n   * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   */\n  createCustomBorders(customBorders) {\n    arrayEach(customBorders, customBorder => {\n      const normCustomBorder = normalizeBorder(customBorder);\n      if (customBorder.range) {\n        this.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);\n      } else {\n        this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);\n      }\n    });\n  }\n\n  /**\n   * Count hide property in border object.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @returns {number}\n   */\n  countHide(border) {\n    const {\n      top,\n      bottom,\n      start,\n      end\n    } = border;\n    const values = [top, bottom, start, end];\n    return arrayReduce(values, (accumulator, value) => {\n      let result = accumulator;\n      if (value && value.hide) {\n        result += 1;\n      }\n      return result;\n    }, 0);\n  }\n\n  /**\n   * Clear borders settings from custom selections.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  clearBordersFromSelectionSettings(borderId) {\n    const index = arrayMap(this.hot.selection.highlight.customSelections, customSelection => customSelection.settings.id).indexOf(borderId);\n    if (index > -1) {\n      this.hot.selection.highlight.customSelections[index].clear();\n    }\n  }\n\n  /**\n   * Clear cellRange with null value.\n   *\n   * @private\n   */\n  clearNullCellRange() {\n    arrayEach(this.hot.selection.highlight.customSelections, (customSelection, index) => {\n      if (customSelection.cellRange === null) {\n        this.hot.selection.highlight.customSelections[index].destroy();\n        this.hot.selection.highlight.customSelections.splice(index, 1);\n        return false; // breaks forAll\n      }\n    });\n  }\n\n  /**\n   * Hide custom borders.\n   *\n   * @private\n   */\n  hideBorders() {\n    arrayEach(this.savedBorders, border => {\n      this.clearBordersFromSelectionSettings(border.id);\n      this.clearNullCellRange();\n    });\n  }\n\n  /**\n   * Splice border from savedBorders.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  spliceBorder(borderId) {\n    const index = arrayMap(this.savedBorders, border => border.id).indexOf(borderId);\n    if (index > -1) {\n      this.savedBorders.splice(index, 1);\n    }\n  }\n\n  /**\n   * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   *\n   * @returns {boolean}\n   */\n  checkSavedBorders(border) {\n    let check = false;\n    const hideCount = this.countHide(border);\n    if (hideCount === 4) {\n      this.spliceBorder(border.id);\n      check = true;\n    } else {\n      arrayEach(this.savedBorders, (savedBorder, index) => {\n        if (border.id === savedBorder.id) {\n          this.savedBorders[index] = border;\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   *\n   * @returns {boolean}\n   */\n  checkCustomSelectionsFromContextMenu(border, place, remove) {\n    let check = false;\n    arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n      if (border.id === customSelection.settings.id) {\n        const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n        arrayEach(borders, borderObject => {\n          borderObject.toggleHiddenClass(place, remove); // TODO this also bad?\n        });\n        check = true;\n        return false; // breaks forAll\n      }\n    });\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true reset cellRange.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {CellRange} cellRange The selection range to check.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   * @returns {boolean}\n   */\n  checkCustomSelections(border, cellRange, place) {\n    const hideCount = this.countHide(border);\n    let check = false;\n    if (hideCount === 4) {\n      this.removeAllBorders(border.row, border.col);\n      check = true;\n    } else {\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          customSelection.visualCellRange = cellRange;\n          customSelection.commit();\n          if (place) {\n            const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n            arrayEach(borders, borderObject => {\n              borderObject.changeBorderStyle(place, border);\n            });\n          }\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n    return check;\n  }\n\n  /**\n   * Change borders from settings.\n   *\n   * @private\n   */\n  changeBorderSettings() {\n    const customBorders = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(customBorders)) {\n      const bordersClone = deepClone(customBorders);\n      this.checkSettingsCohesion(bordersClone);\n      if (!bordersClone.length) {\n        this.savedBorders = bordersClone;\n      }\n      this.createCustomBorders(bordersClone);\n    } else if (customBorders !== undefined) {\n      this.createCustomBorders(this.savedBorders);\n    }\n  }\n\n  /**\n   * Checks the settings cohesion. The properties such like \"left\"/\"right\" are supported only\n   * in the LTR mode and the \"left\"/\"right\" options can not be used together with \"start\"/\"end\" properties.\n   *\n   * @private\n   * @param {object[]} customBorders The user defined custom border objects array.\n   */\n  checkSettingsCohesion(customBorders) {\n    const hasLeftOrRight = hasLeftRightTypeOptions(customBorders);\n    const hasStartOrEnd = hasStartEndTypeOptions(customBorders);\n    if (hasLeftOrRight && hasStartOrEnd) {\n      throw new Error('The \"left\"/\"right\" and \"start\"/\"end\" options should not be used together. ' + 'Please use only the option \"start\"/\"end\".');\n    }\n    if (this.hot.isRtl() && hasLeftOrRight) {\n      throw new Error('The \"left\"/\"right\" properties are not supported for RTL. Please use option \"start\"/\"end\".');\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onAfterContextMenuDefaultOptions(defaultOptions) {\n  if (!this.hot.getSettings()[PLUGIN_KEY]) {\n    return;\n  }\n  defaultOptions.items.push({\n    name: '---------'\n  }, {\n    key: 'borders',\n    name() {\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_BORDERS);\n    },\n    disabled() {\n      const range = this.getSelectedRangeLast();\n      if (!range) {\n        return true;\n      }\n      if (range.isSingleHeader()) {\n        return true;\n      }\n      return this.selection.isSelectedByCorner();\n    },\n    submenu: {\n      items: [menuItemTop(this), menuItemRight(this), menuItemBottom(this), menuItemLeft(this), menuItemNoBorders(this)]\n    }\n  });\n}\n/**\n * `afterInit` hook callback.\n */\nfunction _onAfterInit() {\n  this.changeBorderSettings();\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","t","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_assertClassBrand","n","arguments","length","BasePlugin","hasOwnProperty","deepClone","rangeEach","arrayEach","arrayReduce","arrayMap","C","top","menuItemTop","bottom","menuItemBottom","left","menuItemLeft","right","menuItemRight","noBorders","menuItemNoBorders","createId","createDefaultCustomBorder","createSingleEmptyBorder","createEmptyBorders","extendDefaultBorder","hasLeftRightTypeOptions","hasStartEndTypeOptions","toInlinePropName","normalizeBorder","denormalizeBorder","detectSelectionType","normalizeSelectionFactory","PLUGIN_KEY","PLUGIN_PRIORITY","_CustomBorders_brand","WeakSet","CustomBorders","constructor","isEnabled","hot","getSettings","enablePlugin","enabled","addHook","options","_onAfterContextMenuDefaultOptions","_onAfterInit","disablePlugin","hideBorders","updatePlugin","changeBorderSettings","setBorders","selectionRanges","borderObject","borderKeys","normBorder","checkSettingsCohesion","keys","selectionType","selectionSchemaNormalizer","createCellCoords","_createCellCoords","bind","createCellRange","_createCellRange","selection","forAll","row","col","borderKey","prepareBorderFromCustomAdded","view","render","getBorders","Array","isArray","savedBorders","selectedBorders","border","push","clearBorders","clearBordersFromSelectionSettings","id","clearNullCellRange","removeCellMeta","insertBorderIntoSettings","place","hasSavedBorders","checkSavedBorders","visualCellRange","hasCustomSelections","checkCustomSelections","highlight","addCustomSelection","column","borderDescriptor","nrOfRows","countRows","nrOfColumns","countCols","customSelections","customSelection","settings","assign","start","end","setCellMeta","prepareBorderFromCustomAddedRange","range","customBorder","lastRowIndex","Math","min","to","lastColumnIndex","from","rowIndex","colIndex","removeAllBorders","borderId","spliceBorder","setBorder","remove","bordersMeta","getCellMeta","borders","undefined","hideCount","countHide","customSelectionsChecker","checkCustomSelectionsFromContextMenu","prepareBorder","selected","_ref","topCol","bottomCol","rowStart","rowEnd","createCustomBorders","customBorders","normCustomBorder","values","accumulator","result","hide","index","indexOf","clear","cellRange","destroy","splice","check","savedBorder","_wt","selectionManager","getBorderInstances","toggleHiddenClass","commit","changeBorderStyle","bordersClone","hasLeftOrRight","hasStartOrEnd","Error","isRtl","defaultOptions","items","name","key","getTranslatedPhrase","CONTEXTMENU_ITEMS_BORDERS","disabled","getSelectedRangeLast","isSingleHeader","isSelectedByCorner","submenu"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/customBorders/customBorders.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { hasOwnProperty, deepClone } from \"../../helpers/object.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { arrayEach, arrayReduce, arrayMap } from \"../../helpers/array.mjs\";\nimport * as C from \"../../i18n/constants.mjs\";\nimport { top as menuItemTop, bottom as menuItemBottom, left as menuItemLeft, right as menuItemRight, noBorders as menuItemNoBorders } from \"./contextMenuItem/index.mjs\";\nimport { createId, createDefaultCustomBorder, createSingleEmptyBorder, createEmptyBorders, extendDefaultBorder, hasLeftRightTypeOptions, hasStartEndTypeOptions, toInlinePropName, normalizeBorder, denormalizeBorder } from \"./utils.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory } from \"../../selection/index.mjs\";\nexport const PLUGIN_KEY = 'customBorders';\nexport const PLUGIN_PRIORITY = 90;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin CustomBorders\n * @class CustomBorders\n *\n * @description\n * This plugin enables an option to apply custom borders through the context menu (configurable with context menu key\n * `borders`).\n *\n * To initialize Handsontable with predefined custom borders, provide cell coordinates and border styles in a form\n * of an array.\n *\n * See [`customBorders` configuration option](@/api/options.md#customBorders) or go to\n * [Custom cell borders demo](@/guides/cell-features/formatting-cells/formatting-cells.md#custom-cell-borders) for more examples.\n *\n * @example\n * ```js\n * customBorders: [\n *   {\n *    range: {\n *      from: {\n *        row: 1,\n *        col: 1\n *      },\n *      to: {\n *        row: 3,\n *        col: 4\n *      },\n *    },\n *    start: {},\n *    end: {},\n *    top: {},\n *    bottom: {},\n *   },\n * ],\n *\n * // or\n * customBorders: [\n *   { row: 2,\n *     col: 2,\n *     start: {\n *       width: 2,\n *       color: 'red',\n *     },\n *     end: {\n *       width: 1,\n *       color: 'green',\n *     },\n *     top: '',\n *     bottom: '',\n *   }\n * ],\n * ```\n */\nvar _CustomBorders_brand = /*#__PURE__*/new WeakSet();\nexport class CustomBorders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Add border options to context menu.\n     *\n     * @param {object} defaultOptions Context menu items.\n     */\n    _classPrivateMethodInitSpec(this, _CustomBorders_brand);\n    /**\n     * Saved borders.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"savedBorders\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _assertClassBrand(_CustomBorders_brand, this, _onAfterContextMenuDefaultOptions).call(this, options));\n    this.addHook('init', () => _assertClassBrand(_CustomBorders_brand, this, _onAfterInit).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hideBorders();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`customBorders`](@/api/options.md#customborders)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.changeBorderSettings();\n    super.updatePlugin();\n  }\n\n  /**\n   * Set custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});\n   *\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * //  Selecting a cell range.\n   * hot.selectCell(0, 0, 2, 2);\n   * // Returning selected cells' range with the getSelectedRange method.\n   * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.\n   */\n  setBorders(selectionRanges, borderObject) {\n    let borderKeys = ['top', 'bottom', 'start', 'end'];\n    let normBorder = null;\n    if (borderObject) {\n      this.checkSettingsCohesion([borderObject]);\n      borderKeys = Object.keys(borderObject);\n      normBorder = normalizeBorder(borderObject);\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(borderKeys, borderKey => {\n          this.prepareBorderFromCustomAdded(row, col, normBorder, toInlinePropName(borderKey));\n        });\n      });\n    });\n\n    /*\n    The line below triggers a re-render of Handsontable. This will be a \"fastDraw\"\n    render, because that is the default for the TableView class.\n     The re-render is needed for borders on cells that did not have a border before.\n    The way this call works is that it calls Table.refreshSelections, which calls\n    Selection.getBorder, which creates a new instance of Border.\n     Seems wise to keep this single-direction flow of creating new Borders\n    */\n    this.hot.view.render();\n  }\n\n  /**\n   * Get custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.getBorders(hot.getSelectedRange());\n   * // Using without param - return all customBorders.\n   * customBordersPlugin.getBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @returns {object[]} Returns array of border objects.\n   */\n  getBorders(selectionRanges) {\n    if (!Array.isArray(selectionRanges)) {\n      return this.savedBorders;\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    const selectedBorders = [];\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(this.savedBorders, border => {\n          if (border.row === row && border.col === col) {\n            selectedBorders.push(denormalizeBorder(border));\n          }\n        });\n      });\n    });\n    return selectedBorders;\n  }\n\n  /**\n   * Clear custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.clearBorders(hot.getSelectedRange());\n   * // Using without param - clear all customBorders.\n   * customBordersPlugin.clearBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   */\n  clearBorders(selectionRanges) {\n    if (selectionRanges) {\n      this.setBorders(selectionRanges);\n    } else {\n      arrayEach(this.savedBorders, border => {\n        this.clearBordersFromSelectionSettings(border.id);\n        this.clearNullCellRange();\n        this.hot.removeCellMeta(border.row, border.col, 'borders');\n      });\n      this.savedBorders.length = 0;\n    }\n  }\n\n  /**\n   * Insert WalkontableSelection instance into Walkontable settings.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  insertBorderIntoSettings(border, place) {\n    const hasSavedBorders = this.checkSavedBorders(border);\n    if (!hasSavedBorders) {\n      this.savedBorders.push(border);\n    }\n    const visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));\n    const hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);\n    if (!hasCustomSelections) {\n      this.hot.selection.highlight.addCustomSelection({\n        border,\n        visualCellRange\n      });\n    }\n  }\n\n  /**\n   * Prepare borders from setting (single cell).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {\n    const nrOfRows = this.hot.countRows();\n    const nrOfColumns = this.hot.countCols();\n    if (row >= nrOfRows || column >= nrOfColumns) {\n      return;\n    }\n    let border = createEmptyBorders(row, column);\n    if (borderDescriptor) {\n      border = extendDefaultBorder(border, borderDescriptor);\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          Object.assign(customSelection.settings, borderDescriptor);\n          border.id = customSelection.settings.id;\n          border.top = customSelection.settings.top;\n          border.bottom = customSelection.settings.bottom;\n          border.start = customSelection.settings.start;\n          border.end = customSelection.settings.end;\n          return false; // breaks forAll\n        }\n      });\n    }\n    this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(border));\n    this.insertBorderIntoSettings(border, place);\n  }\n\n  /**\n   * Prepare borders from setting (object).\n   *\n   * @private\n   * @param {object} range {CellRange} The CellRange object.\n   * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.\n   */\n  prepareBorderFromCustomAddedRange(range, customBorder) {\n    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);\n    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);\n    rangeEach(range.from.row, lastRowIndex, rowIndex => {\n      rangeEach(range.from.col, lastColumnIndex, colIndex => {\n        const border = createEmptyBorders(rowIndex, colIndex);\n        let add = 0;\n        if (rowIndex === range.from.row) {\n          if (hasOwnProperty(customBorder, 'top')) {\n            add += 1;\n            border.top = customBorder.top;\n          }\n        }\n\n        // Please keep in mind that `range.to.row` may be beyond the table boundaries. The border won't be rendered.\n        if (rowIndex === range.to.row) {\n          if (hasOwnProperty(customBorder, 'bottom')) {\n            add += 1;\n            border.bottom = customBorder.bottom;\n          }\n        }\n        if (colIndex === range.from.col) {\n          if (hasOwnProperty(customBorder, 'start')) {\n            add += 1;\n            border.start = customBorder.start;\n          }\n        }\n\n        // Please keep in mind that `range.to.col` may be beyond the table boundaries. The border won't be rendered.\n        if (colIndex === range.to.col) {\n          if (hasOwnProperty(customBorder, 'end')) {\n            add += 1;\n            border.end = customBorder.end;\n          }\n        }\n        if (add > 0) {\n          this.hot.setCellMeta(rowIndex, colIndex, 'borders', denormalizeBorder(border));\n          this.insertBorderIntoSettings(border);\n        } else {\n          // TODO sometimes it enters here. Why?\n        }\n      });\n    });\n  }\n\n  /**\n   * Remove border (triggered from context menu).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   */\n  removeAllBorders(row, column) {\n    const borderId = createId(row, column);\n    this.spliceBorder(borderId);\n    this.clearBordersFromSelectionSettings(borderId);\n    this.clearNullCellRange();\n    this.hot.removeCellMeta(row, column, 'borders');\n  }\n\n  /**\n   * Set borders for each cell re. To border position.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  setBorder(row, column, place, remove) {\n    let bordersMeta = this.hot.getCellMeta(row, column).borders;\n    if (!bordersMeta || bordersMeta.border === undefined) {\n      bordersMeta = createEmptyBorders(row, column);\n    } else {\n      bordersMeta = normalizeBorder(bordersMeta);\n    }\n    if (remove) {\n      bordersMeta[place] = createSingleEmptyBorder();\n      const hideCount = this.countHide(bordersMeta);\n      if (hideCount === 4) {\n        this.removeAllBorders(row, column);\n      } else {\n        const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n        if (!customSelectionsChecker) {\n          this.insertBorderIntoSettings(bordersMeta);\n        }\n        this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n      }\n    } else {\n      bordersMeta[place] = createDefaultCustomBorder();\n      const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n      if (!customSelectionsChecker) {\n        this.insertBorderIntoSettings(bordersMeta);\n      }\n      this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n    }\n  }\n\n  /**\n   * Prepare borders based on cell and border position.\n   *\n   * @private\n   * @param {CellRange[]} selected An array of CellRange objects.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  prepareBorder(selected, place, remove) {\n    arrayEach(selected, _ref => {\n      let {\n        start,\n        end\n      } = _ref;\n      if (start.row === end.row && start.col === end.col) {\n        if (place === 'noBorders') {\n          this.removeAllBorders(start.row, start.col);\n        } else {\n          this.setBorder(start.row, start.col, place, remove);\n        }\n      } else {\n        switch (place) {\n          case 'noBorders':\n            rangeEach(start.col, end.col, colIndex => {\n              rangeEach(start.row, end.row, rowIndex => {\n                this.removeAllBorders(rowIndex, colIndex);\n              });\n            });\n            break;\n          case 'top':\n            rangeEach(start.col, end.col, topCol => {\n              this.setBorder(start.row, topCol, place, remove);\n            });\n            break;\n          case 'bottom':\n            rangeEach(start.col, end.col, bottomCol => {\n              this.setBorder(end.row, bottomCol, place, remove);\n            });\n            break;\n          case 'start':\n            rangeEach(start.row, end.row, rowStart => {\n              this.setBorder(rowStart, start.col, place, remove);\n            });\n            break;\n          case 'end':\n            rangeEach(start.row, end.row, rowEnd => {\n              this.setBorder(rowEnd, end.col, place, remove);\n            });\n            break;\n          default:\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Create borders from settings.\n   *\n   * @private\n   * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   */\n  createCustomBorders(customBorders) {\n    arrayEach(customBorders, customBorder => {\n      const normCustomBorder = normalizeBorder(customBorder);\n      if (customBorder.range) {\n        this.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);\n      } else {\n        this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);\n      }\n    });\n  }\n\n  /**\n   * Count hide property in border object.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @returns {number}\n   */\n  countHide(border) {\n    const {\n      top,\n      bottom,\n      start,\n      end\n    } = border;\n    const values = [top, bottom, start, end];\n    return arrayReduce(values, (accumulator, value) => {\n      let result = accumulator;\n      if (value && value.hide) {\n        result += 1;\n      }\n      return result;\n    }, 0);\n  }\n\n  /**\n   * Clear borders settings from custom selections.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  clearBordersFromSelectionSettings(borderId) {\n    const index = arrayMap(this.hot.selection.highlight.customSelections, customSelection => customSelection.settings.id).indexOf(borderId);\n    if (index > -1) {\n      this.hot.selection.highlight.customSelections[index].clear();\n    }\n  }\n\n  /**\n   * Clear cellRange with null value.\n   *\n   * @private\n   */\n  clearNullCellRange() {\n    arrayEach(this.hot.selection.highlight.customSelections, (customSelection, index) => {\n      if (customSelection.cellRange === null) {\n        this.hot.selection.highlight.customSelections[index].destroy();\n        this.hot.selection.highlight.customSelections.splice(index, 1);\n        return false; // breaks forAll\n      }\n    });\n  }\n\n  /**\n   * Hide custom borders.\n   *\n   * @private\n   */\n  hideBorders() {\n    arrayEach(this.savedBorders, border => {\n      this.clearBordersFromSelectionSettings(border.id);\n      this.clearNullCellRange();\n    });\n  }\n\n  /**\n   * Splice border from savedBorders.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  spliceBorder(borderId) {\n    const index = arrayMap(this.savedBorders, border => border.id).indexOf(borderId);\n    if (index > -1) {\n      this.savedBorders.splice(index, 1);\n    }\n  }\n\n  /**\n   * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   *\n   * @returns {boolean}\n   */\n  checkSavedBorders(border) {\n    let check = false;\n    const hideCount = this.countHide(border);\n    if (hideCount === 4) {\n      this.spliceBorder(border.id);\n      check = true;\n    } else {\n      arrayEach(this.savedBorders, (savedBorder, index) => {\n        if (border.id === savedBorder.id) {\n          this.savedBorders[index] = border;\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   *\n   * @returns {boolean}\n   */\n  checkCustomSelectionsFromContextMenu(border, place, remove) {\n    let check = false;\n    arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n      if (border.id === customSelection.settings.id) {\n        const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n        arrayEach(borders, borderObject => {\n          borderObject.toggleHiddenClass(place, remove); // TODO this also bad?\n        });\n        check = true;\n        return false; // breaks forAll\n      }\n    });\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true reset cellRange.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {CellRange} cellRange The selection range to check.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   * @returns {boolean}\n   */\n  checkCustomSelections(border, cellRange, place) {\n    const hideCount = this.countHide(border);\n    let check = false;\n    if (hideCount === 4) {\n      this.removeAllBorders(border.row, border.col);\n      check = true;\n    } else {\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          customSelection.visualCellRange = cellRange;\n          customSelection.commit();\n          if (place) {\n            const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n            arrayEach(borders, borderObject => {\n              borderObject.changeBorderStyle(place, border);\n            });\n          }\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n    return check;\n  }\n\n  /**\n   * Change borders from settings.\n   *\n   * @private\n   */\n  changeBorderSettings() {\n    const customBorders = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(customBorders)) {\n      const bordersClone = deepClone(customBorders);\n      this.checkSettingsCohesion(bordersClone);\n      if (!bordersClone.length) {\n        this.savedBorders = bordersClone;\n      }\n      this.createCustomBorders(bordersClone);\n    } else if (customBorders !== undefined) {\n      this.createCustomBorders(this.savedBorders);\n    }\n  }\n\n  /**\n   * Checks the settings cohesion. The properties such like \"left\"/\"right\" are supported only\n   * in the LTR mode and the \"left\"/\"right\" options can not be used together with \"start\"/\"end\" properties.\n   *\n   * @private\n   * @param {object[]} customBorders The user defined custom border objects array.\n   */\n  checkSettingsCohesion(customBorders) {\n    const hasLeftOrRight = hasLeftRightTypeOptions(customBorders);\n    const hasStartOrEnd = hasStartEndTypeOptions(customBorders);\n    if (hasLeftOrRight && hasStartOrEnd) {\n      throw new Error('The \"left\"/\"right\" and \"start\"/\"end\" options should not be used together. ' + 'Please use only the option \"start\"/\"end\".');\n    }\n    if (this.hot.isRtl() && hasLeftOrRight) {\n      throw new Error('The \"left\"/\"right\" properties are not supported for RTL. Please use option \"start\"/\"end\".');\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onAfterContextMenuDefaultOptions(defaultOptions) {\n  if (!this.hot.getSettings()[PLUGIN_KEY]) {\n    return;\n  }\n  defaultOptions.items.push({\n    name: '---------'\n  }, {\n    key: 'borders',\n    name() {\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_BORDERS);\n    },\n    disabled() {\n      const range = this.getSelectedRangeLast();\n      if (!range) {\n        return true;\n      }\n      if (range.isSingleHeader()) {\n        return true;\n      }\n      return this.selection.isSelectedByCorner();\n    },\n    submenu: {\n      items: [menuItemTop(this), menuItemRight(this), menuItemBottom(this), menuItemLeft(this), menuItemNoBorders(this)]\n    }\n  });\n}\n/**\n * `afterInit` hook callback.\n */\nfunction _onAfterInit() {\n  this.changeBorderSettings();\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}