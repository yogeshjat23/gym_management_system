{"ast":null,"code":"import { createUniqueMap } from \"../utils/dataStructures/uniqueMap.mjs\";\nimport { stopImmediatePropagation } from \"../helpers/dom/event.mjs\";\nimport { createContext, isContextObject } from \"./context.mjs\";\nimport { useRecorder } from \"./recorder.mjs\";\nimport { toSingleLine } from \"../helpers/templateLiteralTag.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The `ShortcutManager` API lets you store and manage [keyboard shortcut contexts](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#keyboard-shortcut-contexts) ([`ShortcutContext`](@/api/shortcutContext.md)).\n *\n * Each `ShortcutManager` object:\n * - Stores and manages its own set of keyboard shortcut contexts.\n * - Listens to the [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) events and runs actions for them.\n *\n * @alias ShortcutManager\n * @class ShortcutManager\n * @param {object} options The manager's options\n * @param {EventTarget} options.ownerWindow A starting `window` element\n * @param {Function} options.handleEvent A condition on which `event` is handled.\n * @param {Function} options.beforeKeyDown A hook fired before the `keydown` event is handled. You can use it to [block a keyboard shortcut's actions](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#block-a-keyboard-shortcut-s-actions).\n * @param {Function} options.afterKeyDown A hook fired after the `keydown` event is handled\n */\nexport const createShortcutManager = _ref => {\n  let {\n    ownerWindow,\n    handleEvent,\n    beforeKeyDown,\n    afterKeyDown\n  } = _ref;\n  /**\n   * A unique map that stores keyboard shortcut contexts.\n   *\n   * @type {UniqueMap}\n   */\n  const CONTEXTS = createUniqueMap({\n    errorIdExists: keys => `The \"${keys}\" context name is already registered.`\n  });\n  /**\n   * The name of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @type {string}\n   */\n  let activeContextName = 'grid';\n\n  /**\n   * Create a new [`ShortcutContext`](@/api/shortcutContext.md) object.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the new shortcut context\n   * @returns {object}\n   */\n  const addContext = contextName => {\n    const context = createContext(contextName);\n    CONTEXTS.addItem(contextName, context);\n    return context;\n  };\n\n  /**\n   * Get the ID of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @returns {string}\n   */\n  const getActiveContextName = () => {\n    return activeContextName;\n  };\n\n  /**\n   * Get a keyboard shortcut context by its name.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   * @returns {object|undefined} A [`ShortcutContext`](@/api/shortcutContext.md) object that stores registered shortcuts\n   */\n  const getContext = contextName => {\n    return CONTEXTS.getItem(contextName);\n  };\n\n  /**\n   * Start listening to keyboard shortcuts within a given [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   */\n  const setActiveContextName = contextName => {\n    if (!CONTEXTS.hasItem(contextName)) {\n      throw new Error(toSingleLine`You've tried to activate the \"${contextName}\" shortcut context\\x20\n        that does not exist. Before activation, register the context using the \"addContext\" method.`);\n    }\n    activeContextName = contextName;\n  };\n\n  /**\n   * This variable relates to the `captureCtrl` shortcut option,\n   * which allows for capturing the state of the Control/Meta modifier key.\n   * Some of the default keyboard shortcuts related to cell selection need this feature for working properly.\n   *\n   * @type {boolean}\n   */\n  let isCtrlKeySilenced = false;\n\n  /**\n   * A callback function for listening events from the recorder.\n   *\n   * @param {KeyboardEvent} event The keyboard event.\n   * @param {string[]} keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers.\n   * @param {object | string} context The context object or name.\n   * @returns {boolean}\n   */\n  const recorderCallback = function (event, keys) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getActiveContextName();\n    const activeContext = isContextObject(context) ? context : getContext(context);\n    let isExecutionCancelled = false;\n    if (!activeContext.hasShortcut(keys)) {\n      return isExecutionCancelled;\n    }\n\n    // Processing just actions being in stack at the moment of shortcut pressing (without respecting additions/removals performed dynamically).\n    const shortcuts = activeContext.getShortcuts(keys);\n    for (let index = 0; index < shortcuts.length; index++) {\n      const {\n        callback,\n        runOnlyIf,\n        preventDefault,\n        stopPropagation,\n        captureCtrl,\n        forwardToContext\n      } = shortcuts[index];\n      if (runOnlyIf(event) === true) {\n        isCtrlKeySilenced = captureCtrl;\n        isExecutionCancelled = callback(event, keys) === false;\n        isCtrlKeySilenced = false;\n        if (preventDefault) {\n          event.preventDefault();\n        }\n        if (stopPropagation) {\n          stopImmediatePropagation(event);\n          event.stopPropagation();\n        }\n        if (isExecutionCancelled) {\n          break;\n        }\n        if (forwardToContext) {\n          recorderCallback(event, keys, forwardToContext);\n        }\n      }\n    }\n    return isExecutionCancelled;\n  };\n\n  /**\n   * Internal key recorder.\n   *\n   * @private\n   */\n  const keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, recorderCallback);\n  keyRecorder.mount();\n  return {\n    addContext,\n    getActiveContextName,\n    getContext,\n    setActiveContextName,\n    /**\n     * Returns whether `control` or `meta` keys are pressed.\n     *\n     * @memberof ShortcutManager#\n     * @type {Function}\n     * @returns {boolean}\n     */\n    isCtrlPressed: () => !isCtrlKeySilenced && (keyRecorder.isPressed('control') || keyRecorder.isPressed('meta')),\n    /**\n     * Release every previously pressed key.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    releasePressedKeys: () => keyRecorder.releasePressedKeys(),\n    /**\n     * Destroy a context manager instance.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    destroy: () => keyRecorder.unmount()\n  };\n};","map":{"version":3,"names":["createUniqueMap","stopImmediatePropagation","createContext","isContextObject","useRecorder","toSingleLine","createShortcutManager","_ref","ownerWindow","handleEvent","beforeKeyDown","afterKeyDown","CONTEXTS","errorIdExists","keys","activeContextName","addContext","contextName","context","addItem","getActiveContextName","getContext","getItem","setActiveContextName","hasItem","Error","isCtrlKeySilenced","recorderCallback","event","arguments","length","undefined","activeContext","isExecutionCancelled","hasShortcut","shortcuts","getShortcuts","index","callback","runOnlyIf","preventDefault","stopPropagation","captureCtrl","forwardToContext","keyRecorder","mount","isCtrlPressed","isPressed","releasePressedKeys","destroy","unmount"],"sources":["D:/gym-project/frontend/node_modules/handsontable/shortcuts/manager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport { createUniqueMap } from \"../utils/dataStructures/uniqueMap.mjs\";\nimport { stopImmediatePropagation } from \"../helpers/dom/event.mjs\";\nimport { createContext, isContextObject } from \"./context.mjs\";\nimport { useRecorder } from \"./recorder.mjs\";\nimport { toSingleLine } from \"../helpers/templateLiteralTag.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The `ShortcutManager` API lets you store and manage [keyboard shortcut contexts](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#keyboard-shortcut-contexts) ([`ShortcutContext`](@/api/shortcutContext.md)).\n *\n * Each `ShortcutManager` object:\n * - Stores and manages its own set of keyboard shortcut contexts.\n * - Listens to the [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) events and runs actions for them.\n *\n * @alias ShortcutManager\n * @class ShortcutManager\n * @param {object} options The manager's options\n * @param {EventTarget} options.ownerWindow A starting `window` element\n * @param {Function} options.handleEvent A condition on which `event` is handled.\n * @param {Function} options.beforeKeyDown A hook fired before the `keydown` event is handled. You can use it to [block a keyboard shortcut's actions](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#block-a-keyboard-shortcut-s-actions).\n * @param {Function} options.afterKeyDown A hook fired after the `keydown` event is handled\n */\nexport const createShortcutManager = _ref => {\n  let {\n    ownerWindow,\n    handleEvent,\n    beforeKeyDown,\n    afterKeyDown\n  } = _ref;\n  /**\n   * A unique map that stores keyboard shortcut contexts.\n   *\n   * @type {UniqueMap}\n   */\n  const CONTEXTS = createUniqueMap({\n    errorIdExists: keys => `The \"${keys}\" context name is already registered.`\n  });\n  /**\n   * The name of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @type {string}\n   */\n  let activeContextName = 'grid';\n\n  /**\n   * Create a new [`ShortcutContext`](@/api/shortcutContext.md) object.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the new shortcut context\n   * @returns {object}\n   */\n  const addContext = contextName => {\n    const context = createContext(contextName);\n    CONTEXTS.addItem(contextName, context);\n    return context;\n  };\n\n  /**\n   * Get the ID of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @returns {string}\n   */\n  const getActiveContextName = () => {\n    return activeContextName;\n  };\n\n  /**\n   * Get a keyboard shortcut context by its name.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   * @returns {object|undefined} A [`ShortcutContext`](@/api/shortcutContext.md) object that stores registered shortcuts\n   */\n  const getContext = contextName => {\n    return CONTEXTS.getItem(contextName);\n  };\n\n  /**\n   * Start listening to keyboard shortcuts within a given [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   */\n  const setActiveContextName = contextName => {\n    if (!CONTEXTS.hasItem(contextName)) {\n      throw new Error(toSingleLine`You've tried to activate the \"${contextName}\" shortcut context\\x20\n        that does not exist. Before activation, register the context using the \"addContext\" method.`);\n    }\n    activeContextName = contextName;\n  };\n\n  /**\n   * This variable relates to the `captureCtrl` shortcut option,\n   * which allows for capturing the state of the Control/Meta modifier key.\n   * Some of the default keyboard shortcuts related to cell selection need this feature for working properly.\n   *\n   * @type {boolean}\n   */\n  let isCtrlKeySilenced = false;\n\n  /**\n   * A callback function for listening events from the recorder.\n   *\n   * @param {KeyboardEvent} event The keyboard event.\n   * @param {string[]} keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers.\n   * @param {object | string} context The context object or name.\n   * @returns {boolean}\n   */\n  const recorderCallback = function (event, keys) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getActiveContextName();\n    const activeContext = isContextObject(context) ? context : getContext(context);\n    let isExecutionCancelled = false;\n    if (!activeContext.hasShortcut(keys)) {\n      return isExecutionCancelled;\n    }\n\n    // Processing just actions being in stack at the moment of shortcut pressing (without respecting additions/removals performed dynamically).\n    const shortcuts = activeContext.getShortcuts(keys);\n    for (let index = 0; index < shortcuts.length; index++) {\n      const {\n        callback,\n        runOnlyIf,\n        preventDefault,\n        stopPropagation,\n        captureCtrl,\n        forwardToContext\n      } = shortcuts[index];\n      if (runOnlyIf(event) === true) {\n        isCtrlKeySilenced = captureCtrl;\n        isExecutionCancelled = callback(event, keys) === false;\n        isCtrlKeySilenced = false;\n        if (preventDefault) {\n          event.preventDefault();\n        }\n        if (stopPropagation) {\n          stopImmediatePropagation(event);\n          event.stopPropagation();\n        }\n        if (isExecutionCancelled) {\n          break;\n        }\n        if (forwardToContext) {\n          recorderCallback(event, keys, forwardToContext);\n        }\n      }\n    }\n    return isExecutionCancelled;\n  };\n\n  /**\n   * Internal key recorder.\n   *\n   * @private\n   */\n  const keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, recorderCallback);\n  keyRecorder.mount();\n  return {\n    addContext,\n    getActiveContextName,\n    getContext,\n    setActiveContextName,\n    /**\n     * Returns whether `control` or `meta` keys are pressed.\n     *\n     * @memberof ShortcutManager#\n     * @type {Function}\n     * @returns {boolean}\n     */\n    isCtrlPressed: () => !isCtrlKeySilenced && (keyRecorder.isPressed('control') || keyRecorder.isPressed('meta')),\n    /**\n     * Release every previously pressed key.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    releasePressedKeys: () => keyRecorder.releasePressedKeys(),\n    /**\n     * Destroy a context manager instance.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    destroy: () => keyRecorder.unmount()\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}