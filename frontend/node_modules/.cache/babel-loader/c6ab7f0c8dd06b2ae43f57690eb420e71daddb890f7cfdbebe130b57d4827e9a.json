{"ast":null,"code":"import { arrayEach, arrayMap } from \"../../../helpers/array.mjs\";\nimport * as C from \"../../../i18n/constants.mjs\";\n/**\n * @param {HiddenColumns} hiddenColumnsPlugin The plugin instance.\n * @returns {object}\n */\nexport default function showColumnItem(hiddenColumnsPlugin) {\n  const columns = [];\n  return {\n    key: 'hidden_columns_show',\n    name() {\n      const pluralForm = columns.length > 1 ? 1 : 0;\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);\n    },\n    callback() {\n      var _this$columnIndexMapp, _this$columnIndexMapp2;\n      if (columns.length === 0) {\n        return;\n      }\n      let startVisualColumn = columns[0];\n      let endVisualColumn = columns[columns.length - 1];\n\n      // Add to the selection one more visual column on the left.\n      startVisualColumn = (_this$columnIndexMapp = this.columnIndexMapper.getNearestNotHiddenIndex(startVisualColumn - 1, -1)) !== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;\n      // Add to the selection one more visual column on the right.\n      endVisualColumn = (_this$columnIndexMapp2 = this.columnIndexMapper.getNearestNotHiddenIndex(endVisualColumn + 1, 1)) !== null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : this.countCols() - 1;\n      hiddenColumnsPlugin.showColumns(columns);\n\n      // We render columns at first. It was needed for getting fixed columns.\n      // Please take a look at #6864 for broader description.\n      this.render();\n      this.view.adjustElementsSize();\n      const allColumnsSelected = endVisualColumn - startVisualColumn + 1 === this.countCols();\n\n      // When all headers needs to be selected then do nothing. The header selection is\n      // automatically handled by corner click.\n      if (!allColumnsSelected) {\n        this.selectColumns(startVisualColumn, endVisualColumn);\n      }\n    },\n    disabled: false,\n    hidden() {\n      const hiddenPhysicalColumns = arrayMap(hiddenColumnsPlugin.getHiddenColumns(), visualColumnIndex => {\n        return this.toPhysicalColumn(visualColumnIndex);\n      });\n      if (!(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {\n        return true;\n      }\n      columns.length = 0;\n      const selectedRangeLast = this.getSelectedRangeLast();\n      const visualStartColumn = selectedRangeLast.getTopStartCorner().col;\n      const visualEndColumn = selectedRangeLast.getBottomEndCorner().col;\n      const columnIndexMapper = this.columnIndexMapper;\n      const renderableStartColumn = columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);\n      const renderableEndColumn = columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);\n      const notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();\n      const physicalColumnIndexes = [];\n      if (visualStartColumn !== visualEndColumn) {\n        const visualColumnsInRange = visualEndColumn - visualStartColumn + 1;\n        const renderedColumnsInRange = renderableEndColumn - renderableStartColumn + 1;\n\n        // Collect not trimmed columns if there are some hidden columns in the selection range.\n        if (visualColumnsInRange > renderedColumnsInRange) {\n          const physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, visualEndColumn + 1);\n          physicalColumnIndexes.push(...physicalIndexesInRange.filter(physicalIndex => hiddenPhysicalColumns.includes(physicalIndex)));\n        }\n\n        // Handled column is the first rendered index and there are some visual indexes before it.\n      } else if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) {\n        // not trimmed indexes -> array of mappings from visual (native array's index) to physical indexes (value).\n        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, visualStartColumn)); // physical indexes\n\n        // When all columns are hidden and the context menu is triggered using top-left corner.\n      } else if (renderableStartColumn === null) {\n        // Show all hidden columns.\n        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, this.countCols()));\n      } else {\n        const lastVisualIndex = this.countCols() - 1;\n        const lastRenderableIndex = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));\n\n        // Handled column is the last rendered index and there are some visual indexes after it.\n        if (renderableEndColumn === lastRenderableIndex && lastVisualIndex > visualEndColumn) {\n          physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(visualEndColumn + 1));\n        }\n      }\n      arrayEach(physicalColumnIndexes, physicalColumnIndex => {\n        columns.push(this.toVisualColumn(physicalColumnIndex));\n      });\n      return columns.length === 0;\n    }\n  };\n}","map":{"version":3,"names":["arrayEach","arrayMap","C","showColumnItem","hiddenColumnsPlugin","columns","key","name","pluralForm","length","getTranslatedPhrase","CONTEXTMENU_ITEMS_SHOW_COLUMN","callback","_this$columnIndexMapp","_this$columnIndexMapp2","startVisualColumn","endVisualColumn","columnIndexMapper","getNearestNotHiddenIndex","countCols","showColumns","render","view","adjustElementsSize","allColumnsSelected","selectColumns","disabled","hidden","hiddenPhysicalColumns","getHiddenColumns","visualColumnIndex","toPhysicalColumn","selection","isSelectedByColumnHeader","isSelectedByCorner","selectedRangeLast","getSelectedRangeLast","visualStartColumn","getTopStartCorner","col","visualEndColumn","getBottomEndCorner","renderableStartColumn","getRenderableFromVisualIndex","renderableEndColumn","notTrimmedColumnIndexes","getNotTrimmedIndexes","physicalColumnIndexes","visualColumnsInRange","renderedColumnsInRange","physicalIndexesInRange","slice","push","filter","physicalIndex","includes","lastVisualIndex","lastRenderableIndex","physicalColumnIndex","toVisualColumn"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/showColumn.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport { arrayEach, arrayMap } from \"../../../helpers/array.mjs\";\nimport * as C from \"../../../i18n/constants.mjs\";\n/**\n * @param {HiddenColumns} hiddenColumnsPlugin The plugin instance.\n * @returns {object}\n */\nexport default function showColumnItem(hiddenColumnsPlugin) {\n  const columns = [];\n  return {\n    key: 'hidden_columns_show',\n    name() {\n      const pluralForm = columns.length > 1 ? 1 : 0;\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);\n    },\n    callback() {\n      var _this$columnIndexMapp, _this$columnIndexMapp2;\n      if (columns.length === 0) {\n        return;\n      }\n      let startVisualColumn = columns[0];\n      let endVisualColumn = columns[columns.length - 1];\n\n      // Add to the selection one more visual column on the left.\n      startVisualColumn = (_this$columnIndexMapp = this.columnIndexMapper.getNearestNotHiddenIndex(startVisualColumn - 1, -1)) !== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;\n      // Add to the selection one more visual column on the right.\n      endVisualColumn = (_this$columnIndexMapp2 = this.columnIndexMapper.getNearestNotHiddenIndex(endVisualColumn + 1, 1)) !== null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : this.countCols() - 1;\n      hiddenColumnsPlugin.showColumns(columns);\n\n      // We render columns at first. It was needed for getting fixed columns.\n      // Please take a look at #6864 for broader description.\n      this.render();\n      this.view.adjustElementsSize();\n      const allColumnsSelected = endVisualColumn - startVisualColumn + 1 === this.countCols();\n\n      // When all headers needs to be selected then do nothing. The header selection is\n      // automatically handled by corner click.\n      if (!allColumnsSelected) {\n        this.selectColumns(startVisualColumn, endVisualColumn);\n      }\n    },\n    disabled: false,\n    hidden() {\n      const hiddenPhysicalColumns = arrayMap(hiddenColumnsPlugin.getHiddenColumns(), visualColumnIndex => {\n        return this.toPhysicalColumn(visualColumnIndex);\n      });\n      if (!(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {\n        return true;\n      }\n      columns.length = 0;\n      const selectedRangeLast = this.getSelectedRangeLast();\n      const visualStartColumn = selectedRangeLast.getTopStartCorner().col;\n      const visualEndColumn = selectedRangeLast.getBottomEndCorner().col;\n      const columnIndexMapper = this.columnIndexMapper;\n      const renderableStartColumn = columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);\n      const renderableEndColumn = columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);\n      const notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();\n      const physicalColumnIndexes = [];\n      if (visualStartColumn !== visualEndColumn) {\n        const visualColumnsInRange = visualEndColumn - visualStartColumn + 1;\n        const renderedColumnsInRange = renderableEndColumn - renderableStartColumn + 1;\n\n        // Collect not trimmed columns if there are some hidden columns in the selection range.\n        if (visualColumnsInRange > renderedColumnsInRange) {\n          const physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, visualEndColumn + 1);\n          physicalColumnIndexes.push(...physicalIndexesInRange.filter(physicalIndex => hiddenPhysicalColumns.includes(physicalIndex)));\n        }\n\n        // Handled column is the first rendered index and there are some visual indexes before it.\n      } else if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) {\n        // not trimmed indexes -> array of mappings from visual (native array's index) to physical indexes (value).\n        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, visualStartColumn)); // physical indexes\n\n        // When all columns are hidden and the context menu is triggered using top-left corner.\n      } else if (renderableStartColumn === null) {\n        // Show all hidden columns.\n        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, this.countCols()));\n      } else {\n        const lastVisualIndex = this.countCols() - 1;\n        const lastRenderableIndex = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));\n\n        // Handled column is the last rendered index and there are some visual indexes after it.\n        if (renderableEndColumn === lastRenderableIndex && lastVisualIndex > visualEndColumn) {\n          physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(visualEndColumn + 1));\n        }\n      }\n      arrayEach(physicalColumnIndexes, physicalColumnIndex => {\n        columns.push(this.toVisualColumn(physicalColumnIndex));\n      });\n      return columns.length === 0;\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}