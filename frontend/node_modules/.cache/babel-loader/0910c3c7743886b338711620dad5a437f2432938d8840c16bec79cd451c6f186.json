{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stringify, parse } from \"../../3rdparty/SheetClip/index.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { sanitize } from \"../../helpers/string.mjs\";\nimport { removeContentEditableFromElementAndDeselect, runWithSelectedContendEditableElement, makeElementContentEditableAndSelectItsContent } from \"../../helpers/dom/element.mjs\";\nimport { isSafari } from \"../../helpers/browser.mjs\";\nimport copyItem from \"./contextMenuItem/copy.mjs\";\nimport copyColumnHeadersOnlyItem from \"./contextMenuItem/copyColumnHeadersOnly.mjs\";\nimport copyWithColumnGroupHeadersItem from \"./contextMenuItem/copyWithColumnGroupHeaders.mjs\";\nimport copyWithColumnHeadersItem from \"./contextMenuItem/copyWithColumnHeaders.mjs\";\nimport cutItem from \"./contextMenuItem/cut.mjs\";\nimport PasteEvent from \"./pasteEvent.mjs\";\nimport { CopyableRangesFactory, normalizeRanges } from \"./copyableRanges.mjs\";\nimport { _dataToHTML, htmlToGridSettings } from \"../../utils/parseTable.mjs\";\nHooks.getSingleton().register('afterCopyLimit');\nHooks.getSingleton().register('modifyCopyableRange');\nHooks.getSingleton().register('beforeCut');\nHooks.getSingleton().register('afterCut');\nHooks.getSingleton().register('beforePaste');\nHooks.getSingleton().register('afterPaste');\nHooks.getSingleton().register('beforeCopy');\nHooks.getSingleton().register('afterCopy');\nexport const PLUGIN_KEY = 'copyPaste';\nexport const PLUGIN_PRIORITY = 80;\nconst SETTING_KEYS = ['fragmentSelection'];\nconst META_HEAD = ['<meta name=\"generator\" content=\"Handsontable\"/>', '<style type=\"text/css\">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join('');\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n * Copy, cut, and paste data by using the `CopyPaste` plugin.\n *\n * Control the `CopyPaste` plugin programmatically through its [API methods](#methods).\n *\n * The user can access the copy-paste features through:\n * - The [context menu](@/guides/cell-features/clipboard/clipboard.md#context-menu).\n * - The [keyboard shortcuts](@/guides/cell-features/clipboard/clipboard.md#related-keyboard-shortcuts).\n * - The browser's menu bar.\n *\n * Read more:\n * - [Guides: Clipboard](@/guides/cell-features/clipboard/clipboard.md)\n * - [Configuration options: `copyPaste`](@/api/options.md#copypaste)\n *\n * @example\n * ```js\n * // enable the plugin with the default configuration\n * copyPaste: true,\n *\n * // or, enable the plugin with a custom configuration\n * copyPaste: {\n *   columnsLimit: 25,\n *   rowsLimit: 50,\n *   pasteMode: 'shift_down',\n *   copyColumnHeaders: true,\n *   copyColumnGroupHeaders: true,\n *   copyColumnHeadersOnly: true,\n *   uiContainer: document.body,\n * },\n * ```\n * @class CopyPaste\n * @plugin CopyPaste\n */\nvar _enableCopyColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnGroupHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnHeadersOnly = /*#__PURE__*/new WeakMap();\nvar _copyMode = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCopy = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCut = /*#__PURE__*/new WeakMap();\nvar _copyableRangesFactory = /*#__PURE__*/new WeakMap();\nvar _preventViewportScrollOnPaste = /*#__PURE__*/new WeakMap();\nvar _CopyPaste_brand = /*#__PURE__*/new WeakSet();\nexport class CopyPaste extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Ensure that the `copy`/`cut` events get triggered properly in Safari.\n     *\n     * @param {string} eventName Name of the event to get triggered.\n     */\n    _classPrivateMethodInitSpec(this, _CopyPaste_brand);\n    /**\n     * The maximum number of columns than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"columnsLimit\", Infinity);\n    /**\n     * The maximum number of rows than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"rowsLimit\", Infinity);\n    /**\n     * When pasting:\n     * - `'overwrite'` - overwrite the currently-selected cells\n     * - `'shift_down'` - move currently-selected cells down\n     * - `'shift_right'` - move currently-selected cells to the right\n     *\n     * @type {string}\n     * @default 'overwrite'\n     */\n    _defineProperty(this, \"pasteMode\", 'overwrite');\n    /**\n     * The UI container for the secondary focusable element.\n     *\n     * @type {HTMLElement}\n     */\n    _defineProperty(this, \"uiContainer\", this.hot.rootDocument.body);\n    /**\n     * Shows the \"Copy with headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeaders, false);\n    /**\n     * Shows the \"Copy with group headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_group headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnGroupHeaders, false);\n    /**\n     * Shows the \"Copy headers only\" item in the context menu and extends the context menu with the\n     * `'copy_column_headers_only'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeadersOnly, false);\n    /**\n     * Defines the data range to copy. Possible values:\n     *  * `'cells-only'` Copy selected cells only;\n     *  * `'column-headers-only'` Copy column headers only;\n     *  * `'with-column-group-headers'` Copy cells with all column headers;\n     *  * `'with-column-headers'` Copy cells with column headers;\n     *\n     * @type {'cells-only' | 'column-headers-only' | 'with-column-group-headers' | 'with-column-headers'}\n     */\n    _classPrivateFieldInitSpec(this, _copyMode, 'cells-only');\n    /**\n     * Flag that is used to prevent copying when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCopy, false);\n    /**\n     * Flag that is used to prevent cutting when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCut, false);\n    /**\n     * Class that helps generate copyable ranges based on the current selection for different copy mode\n     * types.\n     *\n     * @type {CopyableRangesFactory}\n     */\n    _classPrivateFieldInitSpec(this, _copyableRangesFactory, new CopyableRangesFactory({\n      countRows: () => this.hot.countRows(),\n      countColumns: () => this.hot.countCols(),\n      rowsLimit: () => this.rowsLimit,\n      columnsLimit: () => this.columnsLimit,\n      countColumnHeaders: () => this.hot.view.getColumnHeadersCount()\n    }));\n    /**\n     * Flag that indicates if the viewport scroll should be prevented after pasting the data.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventViewportScrollOnPaste, false);\n    /**\n     * Ranges of the cells coordinates, which should be used to copy/cut/paste actions.\n     *\n     * @private\n     * @type {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>}\n     */\n    _defineProperty(this, \"copyableRanges\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the [`CopyPaste`](#copypaste) plugin is enabled.\n   *\n   * This method gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) hook.\n   * If it returns `true`, the [`enablePlugin()`](#enableplugin) method gets called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      [PLUGIN_KEY]: settings\n    } = this.hot.getSettings();\n    if (typeof settings === 'object') {\n      var _settings$pasteMode, _settings$uiContainer;\n      this.pasteMode = (_settings$pasteMode = settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? _settings$pasteMode : this.pasteMode;\n      this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;\n      this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;\n      _classPrivateFieldSet(_enableCopyColumnHeaders, this, !!settings.copyColumnHeaders);\n      _classPrivateFieldSet(_enableCopyColumnGroupHeaders, this, !!settings.copyColumnGroupHeaders);\n      _classPrivateFieldSet(_enableCopyColumnHeadersOnly, this, !!settings.copyColumnHeadersOnly);\n      this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && _settings$uiContainer !== void 0 ? _settings$uiContainer : this.uiContainer;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _assertClassBrand(_CopyPaste_brand, this, _onAfterContextMenuDefaultOptions).call(this, options));\n    this.addHook('afterSelection', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_CopyPaste_brand, _this, _onAfterSelection).call(_this, ...args);\n    });\n    this.addHook('afterSelectionEnd', () => _assertClassBrand(_CopyPaste_brand, this, _onAfterSelectionEnd).call(this));\n    this.eventManager.addEventListener(this.hot.rootDocument, 'copy', function () {\n      return _this.onCopy(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'cut', function () {\n      return _this.onCut(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'paste', function () {\n      return _this.onPaste(...arguments);\n    });\n\n    // Without this workaround Safari (tested on Safari@16.5.2) does allow copying/cutting from the browser menu.\n    if (isSafari()) {\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseenter', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return _assertClassBrand(_CopyPaste_brand, _this, _onSafariMouseEnter).call(_this, ...args);\n      });\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseleave', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return _assertClassBrand(_CopyPaste_brand, _this, _onSafariMouseLeave).call(_this, ...args);\n      });\n      this.addHook('afterSelection', () => _assertClassBrand(_CopyPaste_brand, this, _onSafariAfterSelection).call(this));\n    }\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the state of the [`CopyPaste`](#copypaste) plugin.\n   *\n   * Gets called when [`updateSettings()`](@/api/core.md#updatesettings)\n   * is invoked with any of the following configuration options:\n   *  - [`copyPaste`](@/api/options.md#copypaste)\n   *  - [`fragmentSelection`](@/api/options.md#fragmentselection)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n  }\n\n  /**\n   * Copies the contents of the selected cells (and/or their related column headers) to the system clipboard.\n   *\n   * Takes an optional parameter (`copyMode`) that defines the scope of copying:\n   *\n   * | `copyMode` value              | Description                                                     |\n   * | ----------------------------- | --------------------------------------------------------------- |\n   * | `'cells-only'` (default)      | Copy the selected cells                                         |\n   * | `'with-column-headers'`       | - Copy the selected cells<br>- Copy the nearest column headers  |\n   * | `'with-column-group-headers'` | - Copy the selected cells<br>- Copy all related columns headers |\n   * | `'column-headers-only'`       | Copy the nearest column headers (without copying cells)         |\n   *\n   * @param {string} [copyMode='cells-only'] Copy mode.\n   */\n  copy() {\n    let copyMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cells-only';\n    _classPrivateFieldSet(_copyMode, this, copyMode);\n    _classPrivateFieldSet(_isTriggeredByCopy, this, true);\n    _assertClassBrand(_CopyPaste_brand, this, _ensureClipboardEventsGetTriggered).call(this, 'copy');\n  }\n\n  /**\n   * Copies the contents of the selected cells.\n   */\n  copyCellsOnly() {\n    this.copy('cells-only');\n  }\n  /**\n   * Copies the contents of column headers that are nearest to the selected cells.\n   */\n  copyColumnHeadersOnly() {\n    this.copy('column-headers-only');\n  }\n  /**\n   * Copies the contents of the selected cells and all their related column headers.\n   */\n  copyWithAllColumnHeaders() {\n    this.copy('with-column-group-headers');\n  }\n  /**\n   * Copies the contents of the selected cells and their nearest column headers.\n   */\n  copyWithColumnHeaders() {\n    this.copy('with-column-headers');\n  }\n\n  /**\n   * Cuts the contents of the selected cells to the system clipboard.\n   */\n  cut() {\n    _classPrivateFieldSet(_isTriggeredByCut, this, true);\n    _assertClassBrand(_CopyPaste_brand, this, _ensureClipboardEventsGetTriggered).call(this, 'cut');\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into a single string.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.\n   * @returns {string} A string that will be copied to the clipboard.\n   */\n  getRangedCopyableData(ranges) {\n    return stringify(this.getRangedData(ranges));\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into an array of arrays.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   * @returns {Array[]} An array of arrays that will be copied to the clipboard.\n   */\n  getRangedData(ranges) {\n    const data = [];\n    const {\n      rows,\n      columns\n    } = normalizeRanges(ranges);\n\n    // concatenate all rows and columns data defined in ranges into one copyable string\n    arrayEach(rows, row => {\n      const rowSet = [];\n      arrayEach(columns, column => {\n        if (row < 0) {\n          // `row` as the second argument acts here as the `headerLevel` argument\n          rowSet.push(this.hot.getColHeader(column, row));\n        } else {\n          rowSet.push(this.hot.getCopyableData(row, column));\n        }\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Simulates the paste action.\n   *\n   * For security reasons, modern browsers don't allow reading from the system clipboard.\n   *\n   * @param {string} pastableText The value to paste, as a raw string.\n   * @param {string} [pastableHtml=''] The value to paste, as HTML.\n   */\n  paste() {\n    let pastableText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let pastableHtml = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pastableText;\n    if (!pastableText && !pastableHtml) {\n      return;\n    }\n    const pasteData = new PasteEvent();\n    if (pastableText) {\n      pasteData.clipboardData.setData('text/plain', pastableText);\n    }\n    if (pastableHtml) {\n      pasteData.clipboardData.setData('text/html', pastableHtml);\n    }\n    this.onPaste(pasteData);\n  }\n\n  /**\n   * Prepares copyable text from the cells selection in the invisible textarea.\n   */\n  setCopyableText() {\n    const selectionRange = this.hot.getSelectedRangeLast();\n    if (!selectionRange) {\n      return;\n    }\n    if (selectionRange.isSingleHeader()) {\n      this.copyableRanges = [];\n      return;\n    }\n    _classPrivateFieldGet(_copyableRangesFactory, this).setSelectedRange(selectionRange);\n    const groupedRanges = new Map([['headers', null], ['cells', null]]);\n    if (_classPrivateFieldGet(_copyMode, this) === 'column-headers-only') {\n      groupedRanges.set('headers', _classPrivateFieldGet(_copyableRangesFactory, this).getMostBottomColumnHeadersRange());\n    } else {\n      if (_classPrivateFieldGet(_copyMode, this) === 'with-column-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(_copyableRangesFactory, this).getMostBottomColumnHeadersRange());\n      } else if (_classPrivateFieldGet(_copyMode, this) === 'with-column-group-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(_copyableRangesFactory, this).getAllColumnHeadersRange());\n      }\n      groupedRanges.set('cells', _classPrivateFieldGet(_copyableRangesFactory, this).getCellsRange());\n    }\n    this.copyableRanges = Array.from(groupedRanges.values()).filter(range => range !== null).map(_ref => {\n      let {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = _ref;\n      return {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      };\n    });\n    this.copyableRanges = this.hot.runHooks('modifyCopyableRange', this.copyableRanges);\n    const cellsRange = groupedRanges.get('cells');\n    if (cellsRange !== null && cellsRange.isRangeTrimmed) {\n      const {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = cellsRange;\n      this.hot.runHooks('afterCopyLimit', endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);\n    }\n  }\n\n  /**\n   * Verifies if editor exists and is open.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    var _this$hot$getActiveEd;\n    return (_this$hot$getActiveEd = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd === void 0 ? void 0 : _this$hot$getActiveEd.isOpened();\n  }\n  /**\n   * Prepares new values to populate them into datasource.\n   *\n   * @private\n   * @param {Array} inputArray An array of the data to populate.\n   * @param {Array} [selection] The selection which indicates from what position the data will be populated.\n   * @returns {Array} Range coordinates after populate data.\n   */\n  populateValues(inputArray) {\n    let selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.hot.getSelectedRangeLast();\n    if (!inputArray.length) {\n      return;\n    }\n    const populatedRowsLength = inputArray.length;\n    const populatedColumnsLength = inputArray[0].length;\n    const newRows = [];\n    const {\n      row: startRow,\n      col: startColumn\n    } = selection.getTopStartCorner();\n    const {\n      row: endRowFromSelection,\n      col: endColumnFromSelection\n    } = selection.getBottomEndCorner();\n    let visualRowForPopulatedData = startRow;\n    let visualColumnForPopulatedData = startColumn;\n    let lastVisualRow = startRow;\n    let lastVisualColumn = startColumn;\n\n    // We try to populate just all copied data or repeat copied data within a selection. Please keep in mind that we\n    // don't know whether populated data is bigger than selection on start as there are some cells for which values\n    // should be not inserted (it's known right after getting cell meta).\n    while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {\n      const {\n        skipRowOnPaste,\n        visualRow\n      } = this.hot.getCellMeta(visualRowForPopulatedData, startColumn);\n      visualRowForPopulatedData = visualRow + 1;\n      if (skipRowOnPaste === true) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      lastVisualRow = visualRow;\n      visualColumnForPopulatedData = startColumn;\n      const newRow = [];\n      const insertedRow = newRows.length % populatedRowsLength;\n      while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {\n        const {\n          skipColumnOnPaste,\n          visualCol\n        } = this.hot.getCellMeta(startRow, visualColumnForPopulatedData);\n        visualColumnForPopulatedData = visualCol + 1;\n        if (skipColumnOnPaste === true) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        lastVisualColumn = visualCol;\n        const insertedColumn = newRow.length % populatedColumnsLength;\n        newRow.push(inputArray[insertedRow][insertedColumn]);\n      }\n      newRows.push(newRow);\n    }\n    _classPrivateFieldSet(_preventViewportScrollOnPaste, this, true);\n    this.hot.populateFromArray(startRow, startColumn, newRows, undefined, undefined, 'CopyPaste.paste', this.pasteMode);\n    return [startRow, startColumn, lastVisualRow, lastVisualColumn];\n  }\n\n  /**\n   * Add the `contenteditable` attribute to the highlighted cell and select its content.\n   */\n\n  /**\n   * `copy` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCopy(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(_isTriggeredByCopy, this) || this.isEditorOpened()) {\n      return;\n    }\n    if (!this.hot.getSettings().outsideClickDeselects && event.target !== this.hot.rootDocument.body) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(_isTriggeredByCopy, this, false);\n    const data = this.getRangedData(this.copyableRanges);\n    const copiedHeadersCount = _assertClassBrand(_CopyPaste_brand, this, _countCopiedHeaders).call(this, this.copyableRanges);\n    const allowCopying = !!this.hot.runHooks('beforeCopy', data, this.copyableRanges, copiedHeadersCount);\n    if (allowCopying) {\n      const textPlain = stringify(data);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(data, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.runHooks('afterCopy', data, this.copyableRanges, copiedHeadersCount);\n    }\n    _classPrivateFieldSet(_copyMode, this, 'cells-only');\n    event.preventDefault();\n  }\n\n  /**\n   * `cut` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCut(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(_isTriggeredByCut, this) || this.isEditorOpened()) {\n      return;\n    }\n    if (!this.hot.getSettings().outsideClickDeselects && event.target !== this.hot.rootDocument.body) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(_isTriggeredByCut, this, false);\n    const rangedData = this.getRangedData(this.copyableRanges);\n    const allowCuttingOut = !!this.hot.runHooks('beforeCut', rangedData, this.copyableRanges);\n    if (allowCuttingOut) {\n      const textPlain = stringify(rangedData);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(rangedData, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.emptySelectedCells('CopyPaste.cut');\n      this.hot.runHooks('afterCut', rangedData, this.copyableRanges);\n    }\n    event.preventDefault();\n  }\n\n  /**\n   * `paste` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.\n   * @private\n   */\n  onPaste(event) {\n    if (!this.hot.isListening() || this.isEditorOpened() || !this.hot.getSelected()) {\n      return;\n    }\n    if (!this.hot.getSettings().outsideClickDeselects && event.target !== this.hot.rootDocument.body) {\n      return;\n    }\n    event.preventDefault();\n    let pastedData;\n    if (event && typeof event.clipboardData !== 'undefined') {\n      const textHTML = sanitize(event.clipboardData.getData('text/html'), {\n        ADD_TAGS: ['meta'],\n        ADD_ATTR: ['content'],\n        FORCE_BODY: true\n      });\n      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {\n        const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);\n        pastedData = parsedConfig.data;\n      } else {\n        pastedData = event.clipboardData.getData('text/plain');\n      }\n    } else if (typeof ClipboardEvent === 'undefined' && typeof this.hot.rootWindow.clipboardData !== 'undefined') {\n      pastedData = this.hot.rootWindow.clipboardData.getData('Text');\n    }\n    if (typeof pastedData === 'string') {\n      pastedData = parse(pastedData);\n    }\n    if (pastedData === void 0 || pastedData && pastedData.length === 0) {\n      return;\n    }\n    if (this.hot.runHooks('beforePaste', pastedData, this.copyableRanges) === false) {\n      return;\n    }\n    const [startRow, startColumn, endRow, endColumn] = this.populateValues(pastedData);\n    this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));\n    this.hot.runHooks('afterPaste', pastedData, this.copyableRanges);\n  }\n\n  /**\n   * Add copy and cut options to the Context Menu.\n   *\n   * @param {object} options Contains default added options of the Context Menu.\n   */\n\n  /**\n   * Destroys the `CopyPaste` plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _ensureClipboardEventsGetTriggered(eventName) {\n  // Without this workaround Safari (tested on Safari@16.5.2) does not trigger the 'copy' event.\n  if (isSafari()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        runWithSelectedContendEditableElement(currentlySelectedCell, () => {\n          this.hot.rootDocument.execCommand(eventName);\n        });\n      }\n    }\n  } else {\n    this.hot.rootDocument.execCommand(eventName);\n  }\n}\n/**\n * Counts how many column headers will be copied based on the passed range.\n *\n * @private\n * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n * @returns {{ columnHeadersCount: number }} Returns an object with keys that holds\n *                                           information with the number of copied headers.\n */\nfunction _countCopiedHeaders(ranges) {\n  const {\n    rows\n  } = normalizeRanges(ranges);\n  let columnHeadersCount = 0;\n  for (let row = 0; row < rows.length; row++) {\n    if (rows[row] >= 0) {\n      break;\n    }\n    columnHeadersCount += 1;\n  }\n  return {\n    columnHeadersCount\n  };\n}\nfunction _addContentEditableToHighlightedCell() {\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        makeElementContentEditableAndSelectItsContent(currentlySelectedCell);\n      }\n    }\n  }\n}\n/**\n * Remove the `contenteditable` attribute from the highlighted cell and deselect its content.\n */\nfunction _removeContentEditableFromHighlightedCell() {\n  // If the instance is not listening, the workaround is not needed.\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell !== null && currentlySelectedCell !== void 0 && currentlySelectedCell.hasAttribute('contenteditable')) {\n        removeContentEditableFromElementAndDeselect(currentlySelectedCell);\n      }\n    }\n  }\n}\nfunction _onAfterContextMenuDefaultOptions(options) {\n  options.items.push({\n    name: '---------'\n  }, copyItem(this));\n  if (_classPrivateFieldGet(_enableCopyColumnHeaders, this)) {\n    options.items.push(copyWithColumnHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(_enableCopyColumnGroupHeaders, this)) {\n    options.items.push(copyWithColumnGroupHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(_enableCopyColumnHeadersOnly, this)) {\n    options.items.push(copyColumnHeadersOnlyItem(this));\n  }\n  options.items.push(cutItem(this));\n}\n/**\n * Disables the viewport scroll after pasting the data.\n *\n * @param {number} fromRow Selection start row visual index.\n * @param {number} fromColumn Selection start column visual index.\n * @param {number} toRow Selection end row visual index.\n * @param {number} toColumn Selection end column visual index.\n * @param {object} preventScrolling Object with `value` property. If `true`, the viewport scroll will be prevented.\n */\nfunction _onAfterSelection(fromRow, fromColumn, toRow, toColumn, preventScrolling) {\n  if (_classPrivateFieldGet(_preventViewportScrollOnPaste, this)) {\n    preventScrolling.value = true;\n  }\n  _classPrivateFieldSet(_preventViewportScrollOnPaste, this, false);\n}\n/**\n * Force focus on focusableElement after end of the selection.\n */\nfunction _onAfterSelectionEnd() {\n  if (this.isEditorOpened()) {\n    return;\n  }\n  if (this.hot.getSettings().fragmentSelection) {\n    return;\n  }\n  this.setCopyableText();\n}\n/**\n * `document.body` `mouseenter` callback used to work around a Safari's problem with copying/cutting from the\n * browser's menu.\n */\nfunction _onSafariMouseEnter() {\n  _assertClassBrand(_CopyPaste_brand, this, _removeContentEditableFromHighlightedCell).call(this);\n}\n/**\n * `document.body` `mouseleave` callback used to work around a Safari's problem with copying/cutting from the\n * browser's menu.\n */\nfunction _onSafariMouseLeave() {\n  _assertClassBrand(_CopyPaste_brand, this, _addContentEditableToHighlightedCell).call(this);\n}\n/**\n * `afterSelection` hook callback triggered only on Safari.\n */\nfunction _onSafariAfterSelection() {\n  _assertClassBrand(_CopyPaste_brand, this, _removeContentEditableFromHighlightedCell).call(this);\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","n","arguments","length","BasePlugin","Hooks","stringify","parse","arrayEach","sanitize","removeContentEditableFromElementAndDeselect","runWithSelectedContendEditableElement","makeElementContentEditableAndSelectItsContent","isSafari","copyItem","copyColumnHeadersOnlyItem","copyWithColumnGroupHeadersItem","copyWithColumnHeadersItem","cutItem","PasteEvent","CopyableRangesFactory","normalizeRanges","_dataToHTML","htmlToGridSettings","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","SETTING_KEYS","META_HEAD","join","_enableCopyColumnHeaders","WeakMap","_enableCopyColumnGroupHeaders","_enableCopyColumnHeadersOnly","_copyMode","_isTriggeredByCopy","_isTriggeredByCut","_copyableRangesFactory","_preventViewportScrollOnPaste","_CopyPaste_brand","WeakSet","CopyPaste","constructor","Infinity","hot","rootDocument","body","countRows","countColumns","countCols","rowsLimit","columnsLimit","countColumnHeaders","view","getColumnHeadersCount","isEnabled","getSettings","enablePlugin","_this","enabled","settings","_settings$pasteMode","_settings$uiContainer","pasteMode","isNaN","copyColumnHeaders","copyColumnGroupHeaders","copyColumnHeadersOnly","uiContainer","addHook","options","_onAfterContextMenuDefaultOptions","_len","args","Array","_key","_onAfterSelection","_onAfterSelectionEnd","eventManager","addEventListener","onCopy","onCut","onPaste","_len2","_key2","_onSafariMouseEnter","_len3","_key3","_onSafariMouseLeave","_onSafariAfterSelection","updatePlugin","disablePlugin","copy","copyMode","undefined","_ensureClipboardEventsGetTriggered","copyCellsOnly","copyWithAllColumnHeaders","copyWithColumnHeaders","cut","getRangedCopyableData","ranges","getRangedData","data","rows","columns","row","rowSet","column","push","getColHeader","getCopyableData","paste","pastableText","pastableHtml","pasteData","clipboardData","setData","setCopyableText","selectionRange","getSelectedRangeLast","isSingleHeader","copyableRanges","setSelectedRange","groupedRanges","Map","getMostBottomColumnHeadersRange","getAllColumnHeadersRange","getCellsRange","from","values","filter","range","map","_ref","startRow","startCol","endRow","endCol","runHooks","cellsRange","isRangeTrimmed","isEditorOpened","_this$hot$getActiveEd","getActiveEditor","isOpened","populateValues","inputArray","selection","populatedRowsLength","populatedColumnsLength","newRows","col","startColumn","getTopStartCorner","endRowFromSelection","endColumnFromSelection","getBottomEndCorner","visualRowForPopulatedData","visualColumnForPopulatedData","lastVisualRow","lastVisualColumn","skipRowOnPaste","visualRow","getCellMeta","newRow","insertedRow","skipColumnOnPaste","visualCol","insertedColumn","populateFromArray","event","isListening","outsideClickDeselects","target","copiedHeadersCount","_countCopiedHeaders","allowCopying","textPlain","textHTML","ClipboardEvent","rootWindow","preventDefault","rangedData","allowCuttingOut","emptySelectedCells","getSelected","pastedData","getData","ADD_TAGS","ADD_ATTR","FORCE_BODY","test","parsedConfig","endColumn","selectCell","Math","min","destroy","eventName","lastSelectedRange","highlightRow","highlightColumn","highlight","currentlySelectedCell","getCell","execCommand","columnHeadersCount","_addContentEditableToHighlightedCell","_removeContentEditableFromHighlightedCell","hasAttribute","items","name","fromRow","fromColumn","toRow","toColumn","preventScrolling","fragmentSelection"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/copyPaste/copyPaste.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stringify, parse } from \"../../3rdparty/SheetClip/index.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { sanitize } from \"../../helpers/string.mjs\";\nimport { removeContentEditableFromElementAndDeselect, runWithSelectedContendEditableElement, makeElementContentEditableAndSelectItsContent } from \"../../helpers/dom/element.mjs\";\nimport { isSafari } from \"../../helpers/browser.mjs\";\nimport copyItem from \"./contextMenuItem/copy.mjs\";\nimport copyColumnHeadersOnlyItem from \"./contextMenuItem/copyColumnHeadersOnly.mjs\";\nimport copyWithColumnGroupHeadersItem from \"./contextMenuItem/copyWithColumnGroupHeaders.mjs\";\nimport copyWithColumnHeadersItem from \"./contextMenuItem/copyWithColumnHeaders.mjs\";\nimport cutItem from \"./contextMenuItem/cut.mjs\";\nimport PasteEvent from \"./pasteEvent.mjs\";\nimport { CopyableRangesFactory, normalizeRanges } from \"./copyableRanges.mjs\";\nimport { _dataToHTML, htmlToGridSettings } from \"../../utils/parseTable.mjs\";\nHooks.getSingleton().register('afterCopyLimit');\nHooks.getSingleton().register('modifyCopyableRange');\nHooks.getSingleton().register('beforeCut');\nHooks.getSingleton().register('afterCut');\nHooks.getSingleton().register('beforePaste');\nHooks.getSingleton().register('afterPaste');\nHooks.getSingleton().register('beforeCopy');\nHooks.getSingleton().register('afterCopy');\nexport const PLUGIN_KEY = 'copyPaste';\nexport const PLUGIN_PRIORITY = 80;\nconst SETTING_KEYS = ['fragmentSelection'];\nconst META_HEAD = ['<meta name=\"generator\" content=\"Handsontable\"/>', '<style type=\"text/css\">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join('');\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n * Copy, cut, and paste data by using the `CopyPaste` plugin.\n *\n * Control the `CopyPaste` plugin programmatically through its [API methods](#methods).\n *\n * The user can access the copy-paste features through:\n * - The [context menu](@/guides/cell-features/clipboard/clipboard.md#context-menu).\n * - The [keyboard shortcuts](@/guides/cell-features/clipboard/clipboard.md#related-keyboard-shortcuts).\n * - The browser's menu bar.\n *\n * Read more:\n * - [Guides: Clipboard](@/guides/cell-features/clipboard/clipboard.md)\n * - [Configuration options: `copyPaste`](@/api/options.md#copypaste)\n *\n * @example\n * ```js\n * // enable the plugin with the default configuration\n * copyPaste: true,\n *\n * // or, enable the plugin with a custom configuration\n * copyPaste: {\n *   columnsLimit: 25,\n *   rowsLimit: 50,\n *   pasteMode: 'shift_down',\n *   copyColumnHeaders: true,\n *   copyColumnGroupHeaders: true,\n *   copyColumnHeadersOnly: true,\n *   uiContainer: document.body,\n * },\n * ```\n * @class CopyPaste\n * @plugin CopyPaste\n */\nvar _enableCopyColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnGroupHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnHeadersOnly = /*#__PURE__*/new WeakMap();\nvar _copyMode = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCopy = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCut = /*#__PURE__*/new WeakMap();\nvar _copyableRangesFactory = /*#__PURE__*/new WeakMap();\nvar _preventViewportScrollOnPaste = /*#__PURE__*/new WeakMap();\nvar _CopyPaste_brand = /*#__PURE__*/new WeakSet();\nexport class CopyPaste extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Ensure that the `copy`/`cut` events get triggered properly in Safari.\n     *\n     * @param {string} eventName Name of the event to get triggered.\n     */\n    _classPrivateMethodInitSpec(this, _CopyPaste_brand);\n    /**\n     * The maximum number of columns than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"columnsLimit\", Infinity);\n    /**\n     * The maximum number of rows than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"rowsLimit\", Infinity);\n    /**\n     * When pasting:\n     * - `'overwrite'` - overwrite the currently-selected cells\n     * - `'shift_down'` - move currently-selected cells down\n     * - `'shift_right'` - move currently-selected cells to the right\n     *\n     * @type {string}\n     * @default 'overwrite'\n     */\n    _defineProperty(this, \"pasteMode\", 'overwrite');\n    /**\n     * The UI container for the secondary focusable element.\n     *\n     * @type {HTMLElement}\n     */\n    _defineProperty(this, \"uiContainer\", this.hot.rootDocument.body);\n    /**\n     * Shows the \"Copy with headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeaders, false);\n    /**\n     * Shows the \"Copy with group headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_group headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnGroupHeaders, false);\n    /**\n     * Shows the \"Copy headers only\" item in the context menu and extends the context menu with the\n     * `'copy_column_headers_only'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeadersOnly, false);\n    /**\n     * Defines the data range to copy. Possible values:\n     *  * `'cells-only'` Copy selected cells only;\n     *  * `'column-headers-only'` Copy column headers only;\n     *  * `'with-column-group-headers'` Copy cells with all column headers;\n     *  * `'with-column-headers'` Copy cells with column headers;\n     *\n     * @type {'cells-only' | 'column-headers-only' | 'with-column-group-headers' | 'with-column-headers'}\n     */\n    _classPrivateFieldInitSpec(this, _copyMode, 'cells-only');\n    /**\n     * Flag that is used to prevent copying when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCopy, false);\n    /**\n     * Flag that is used to prevent cutting when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCut, false);\n    /**\n     * Class that helps generate copyable ranges based on the current selection for different copy mode\n     * types.\n     *\n     * @type {CopyableRangesFactory}\n     */\n    _classPrivateFieldInitSpec(this, _copyableRangesFactory, new CopyableRangesFactory({\n      countRows: () => this.hot.countRows(),\n      countColumns: () => this.hot.countCols(),\n      rowsLimit: () => this.rowsLimit,\n      columnsLimit: () => this.columnsLimit,\n      countColumnHeaders: () => this.hot.view.getColumnHeadersCount()\n    }));\n    /**\n     * Flag that indicates if the viewport scroll should be prevented after pasting the data.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventViewportScrollOnPaste, false);\n    /**\n     * Ranges of the cells coordinates, which should be used to copy/cut/paste actions.\n     *\n     * @private\n     * @type {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>}\n     */\n    _defineProperty(this, \"copyableRanges\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the [`CopyPaste`](#copypaste) plugin is enabled.\n   *\n   * This method gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) hook.\n   * If it returns `true`, the [`enablePlugin()`](#enableplugin) method gets called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      [PLUGIN_KEY]: settings\n    } = this.hot.getSettings();\n    if (typeof settings === 'object') {\n      var _settings$pasteMode, _settings$uiContainer;\n      this.pasteMode = (_settings$pasteMode = settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? _settings$pasteMode : this.pasteMode;\n      this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;\n      this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;\n      _classPrivateFieldSet(_enableCopyColumnHeaders, this, !!settings.copyColumnHeaders);\n      _classPrivateFieldSet(_enableCopyColumnGroupHeaders, this, !!settings.copyColumnGroupHeaders);\n      _classPrivateFieldSet(_enableCopyColumnHeadersOnly, this, !!settings.copyColumnHeadersOnly);\n      this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && _settings$uiContainer !== void 0 ? _settings$uiContainer : this.uiContainer;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _assertClassBrand(_CopyPaste_brand, this, _onAfterContextMenuDefaultOptions).call(this, options));\n    this.addHook('afterSelection', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_CopyPaste_brand, _this, _onAfterSelection).call(_this, ...args);\n    });\n    this.addHook('afterSelectionEnd', () => _assertClassBrand(_CopyPaste_brand, this, _onAfterSelectionEnd).call(this));\n    this.eventManager.addEventListener(this.hot.rootDocument, 'copy', function () {\n      return _this.onCopy(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'cut', function () {\n      return _this.onCut(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'paste', function () {\n      return _this.onPaste(...arguments);\n    });\n\n    // Without this workaround Safari (tested on Safari@16.5.2) does allow copying/cutting from the browser menu.\n    if (isSafari()) {\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseenter', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return _assertClassBrand(_CopyPaste_brand, _this, _onSafariMouseEnter).call(_this, ...args);\n      });\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseleave', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return _assertClassBrand(_CopyPaste_brand, _this, _onSafariMouseLeave).call(_this, ...args);\n      });\n      this.addHook('afterSelection', () => _assertClassBrand(_CopyPaste_brand, this, _onSafariAfterSelection).call(this));\n    }\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the state of the [`CopyPaste`](#copypaste) plugin.\n   *\n   * Gets called when [`updateSettings()`](@/api/core.md#updatesettings)\n   * is invoked with any of the following configuration options:\n   *  - [`copyPaste`](@/api/options.md#copypaste)\n   *  - [`fragmentSelection`](@/api/options.md#fragmentselection)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n  }\n\n  /**\n   * Copies the contents of the selected cells (and/or their related column headers) to the system clipboard.\n   *\n   * Takes an optional parameter (`copyMode`) that defines the scope of copying:\n   *\n   * | `copyMode` value              | Description                                                     |\n   * | ----------------------------- | --------------------------------------------------------------- |\n   * | `'cells-only'` (default)      | Copy the selected cells                                         |\n   * | `'with-column-headers'`       | - Copy the selected cells<br>- Copy the nearest column headers  |\n   * | `'with-column-group-headers'` | - Copy the selected cells<br>- Copy all related columns headers |\n   * | `'column-headers-only'`       | Copy the nearest column headers (without copying cells)         |\n   *\n   * @param {string} [copyMode='cells-only'] Copy mode.\n   */\n  copy() {\n    let copyMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cells-only';\n    _classPrivateFieldSet(_copyMode, this, copyMode);\n    _classPrivateFieldSet(_isTriggeredByCopy, this, true);\n    _assertClassBrand(_CopyPaste_brand, this, _ensureClipboardEventsGetTriggered).call(this, 'copy');\n  }\n\n  /**\n   * Copies the contents of the selected cells.\n   */\n  copyCellsOnly() {\n    this.copy('cells-only');\n  }\n  /**\n   * Copies the contents of column headers that are nearest to the selected cells.\n   */\n  copyColumnHeadersOnly() {\n    this.copy('column-headers-only');\n  }\n  /**\n   * Copies the contents of the selected cells and all their related column headers.\n   */\n  copyWithAllColumnHeaders() {\n    this.copy('with-column-group-headers');\n  }\n  /**\n   * Copies the contents of the selected cells and their nearest column headers.\n   */\n  copyWithColumnHeaders() {\n    this.copy('with-column-headers');\n  }\n\n  /**\n   * Cuts the contents of the selected cells to the system clipboard.\n   */\n  cut() {\n    _classPrivateFieldSet(_isTriggeredByCut, this, true);\n    _assertClassBrand(_CopyPaste_brand, this, _ensureClipboardEventsGetTriggered).call(this, 'cut');\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into a single string.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.\n   * @returns {string} A string that will be copied to the clipboard.\n   */\n  getRangedCopyableData(ranges) {\n    return stringify(this.getRangedData(ranges));\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into an array of arrays.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   * @returns {Array[]} An array of arrays that will be copied to the clipboard.\n   */\n  getRangedData(ranges) {\n    const data = [];\n    const {\n      rows,\n      columns\n    } = normalizeRanges(ranges);\n\n    // concatenate all rows and columns data defined in ranges into one copyable string\n    arrayEach(rows, row => {\n      const rowSet = [];\n      arrayEach(columns, column => {\n        if (row < 0) {\n          // `row` as the second argument acts here as the `headerLevel` argument\n          rowSet.push(this.hot.getColHeader(column, row));\n        } else {\n          rowSet.push(this.hot.getCopyableData(row, column));\n        }\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Simulates the paste action.\n   *\n   * For security reasons, modern browsers don't allow reading from the system clipboard.\n   *\n   * @param {string} pastableText The value to paste, as a raw string.\n   * @param {string} [pastableHtml=''] The value to paste, as HTML.\n   */\n  paste() {\n    let pastableText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let pastableHtml = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pastableText;\n    if (!pastableText && !pastableHtml) {\n      return;\n    }\n    const pasteData = new PasteEvent();\n    if (pastableText) {\n      pasteData.clipboardData.setData('text/plain', pastableText);\n    }\n    if (pastableHtml) {\n      pasteData.clipboardData.setData('text/html', pastableHtml);\n    }\n    this.onPaste(pasteData);\n  }\n\n  /**\n   * Prepares copyable text from the cells selection in the invisible textarea.\n   */\n  setCopyableText() {\n    const selectionRange = this.hot.getSelectedRangeLast();\n    if (!selectionRange) {\n      return;\n    }\n    if (selectionRange.isSingleHeader()) {\n      this.copyableRanges = [];\n      return;\n    }\n    _classPrivateFieldGet(_copyableRangesFactory, this).setSelectedRange(selectionRange);\n    const groupedRanges = new Map([['headers', null], ['cells', null]]);\n    if (_classPrivateFieldGet(_copyMode, this) === 'column-headers-only') {\n      groupedRanges.set('headers', _classPrivateFieldGet(_copyableRangesFactory, this).getMostBottomColumnHeadersRange());\n    } else {\n      if (_classPrivateFieldGet(_copyMode, this) === 'with-column-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(_copyableRangesFactory, this).getMostBottomColumnHeadersRange());\n      } else if (_classPrivateFieldGet(_copyMode, this) === 'with-column-group-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(_copyableRangesFactory, this).getAllColumnHeadersRange());\n      }\n      groupedRanges.set('cells', _classPrivateFieldGet(_copyableRangesFactory, this).getCellsRange());\n    }\n    this.copyableRanges = Array.from(groupedRanges.values()).filter(range => range !== null).map(_ref => {\n      let {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = _ref;\n      return {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      };\n    });\n    this.copyableRanges = this.hot.runHooks('modifyCopyableRange', this.copyableRanges);\n    const cellsRange = groupedRanges.get('cells');\n    if (cellsRange !== null && cellsRange.isRangeTrimmed) {\n      const {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = cellsRange;\n      this.hot.runHooks('afterCopyLimit', endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);\n    }\n  }\n\n  /**\n   * Verifies if editor exists and is open.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    var _this$hot$getActiveEd;\n    return (_this$hot$getActiveEd = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd === void 0 ? void 0 : _this$hot$getActiveEd.isOpened();\n  }\n  /**\n   * Prepares new values to populate them into datasource.\n   *\n   * @private\n   * @param {Array} inputArray An array of the data to populate.\n   * @param {Array} [selection] The selection which indicates from what position the data will be populated.\n   * @returns {Array} Range coordinates after populate data.\n   */\n  populateValues(inputArray) {\n    let selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.hot.getSelectedRangeLast();\n    if (!inputArray.length) {\n      return;\n    }\n    const populatedRowsLength = inputArray.length;\n    const populatedColumnsLength = inputArray[0].length;\n    const newRows = [];\n    const {\n      row: startRow,\n      col: startColumn\n    } = selection.getTopStartCorner();\n    const {\n      row: endRowFromSelection,\n      col: endColumnFromSelection\n    } = selection.getBottomEndCorner();\n    let visualRowForPopulatedData = startRow;\n    let visualColumnForPopulatedData = startColumn;\n    let lastVisualRow = startRow;\n    let lastVisualColumn = startColumn;\n\n    // We try to populate just all copied data or repeat copied data within a selection. Please keep in mind that we\n    // don't know whether populated data is bigger than selection on start as there are some cells for which values\n    // should be not inserted (it's known right after getting cell meta).\n    while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {\n      const {\n        skipRowOnPaste,\n        visualRow\n      } = this.hot.getCellMeta(visualRowForPopulatedData, startColumn);\n      visualRowForPopulatedData = visualRow + 1;\n      if (skipRowOnPaste === true) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      lastVisualRow = visualRow;\n      visualColumnForPopulatedData = startColumn;\n      const newRow = [];\n      const insertedRow = newRows.length % populatedRowsLength;\n      while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {\n        const {\n          skipColumnOnPaste,\n          visualCol\n        } = this.hot.getCellMeta(startRow, visualColumnForPopulatedData);\n        visualColumnForPopulatedData = visualCol + 1;\n        if (skipColumnOnPaste === true) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        lastVisualColumn = visualCol;\n        const insertedColumn = newRow.length % populatedColumnsLength;\n        newRow.push(inputArray[insertedRow][insertedColumn]);\n      }\n      newRows.push(newRow);\n    }\n    _classPrivateFieldSet(_preventViewportScrollOnPaste, this, true);\n    this.hot.populateFromArray(startRow, startColumn, newRows, undefined, undefined, 'CopyPaste.paste', this.pasteMode);\n    return [startRow, startColumn, lastVisualRow, lastVisualColumn];\n  }\n\n  /**\n   * Add the `contenteditable` attribute to the highlighted cell and select its content.\n   */\n\n  /**\n   * `copy` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCopy(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(_isTriggeredByCopy, this) || this.isEditorOpened()) {\n      return;\n    }\n    if (!this.hot.getSettings().outsideClickDeselects && event.target !== this.hot.rootDocument.body) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(_isTriggeredByCopy, this, false);\n    const data = this.getRangedData(this.copyableRanges);\n    const copiedHeadersCount = _assertClassBrand(_CopyPaste_brand, this, _countCopiedHeaders).call(this, this.copyableRanges);\n    const allowCopying = !!this.hot.runHooks('beforeCopy', data, this.copyableRanges, copiedHeadersCount);\n    if (allowCopying) {\n      const textPlain = stringify(data);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(data, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.runHooks('afterCopy', data, this.copyableRanges, copiedHeadersCount);\n    }\n    _classPrivateFieldSet(_copyMode, this, 'cells-only');\n    event.preventDefault();\n  }\n\n  /**\n   * `cut` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCut(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(_isTriggeredByCut, this) || this.isEditorOpened()) {\n      return;\n    }\n    if (!this.hot.getSettings().outsideClickDeselects && event.target !== this.hot.rootDocument.body) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(_isTriggeredByCut, this, false);\n    const rangedData = this.getRangedData(this.copyableRanges);\n    const allowCuttingOut = !!this.hot.runHooks('beforeCut', rangedData, this.copyableRanges);\n    if (allowCuttingOut) {\n      const textPlain = stringify(rangedData);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(rangedData, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.emptySelectedCells('CopyPaste.cut');\n      this.hot.runHooks('afterCut', rangedData, this.copyableRanges);\n    }\n    event.preventDefault();\n  }\n\n  /**\n   * `paste` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.\n   * @private\n   */\n  onPaste(event) {\n    if (!this.hot.isListening() || this.isEditorOpened() || !this.hot.getSelected()) {\n      return;\n    }\n    if (!this.hot.getSettings().outsideClickDeselects && event.target !== this.hot.rootDocument.body) {\n      return;\n    }\n    event.preventDefault();\n    let pastedData;\n    if (event && typeof event.clipboardData !== 'undefined') {\n      const textHTML = sanitize(event.clipboardData.getData('text/html'), {\n        ADD_TAGS: ['meta'],\n        ADD_ATTR: ['content'],\n        FORCE_BODY: true\n      });\n      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {\n        const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);\n        pastedData = parsedConfig.data;\n      } else {\n        pastedData = event.clipboardData.getData('text/plain');\n      }\n    } else if (typeof ClipboardEvent === 'undefined' && typeof this.hot.rootWindow.clipboardData !== 'undefined') {\n      pastedData = this.hot.rootWindow.clipboardData.getData('Text');\n    }\n    if (typeof pastedData === 'string') {\n      pastedData = parse(pastedData);\n    }\n    if (pastedData === void 0 || pastedData && pastedData.length === 0) {\n      return;\n    }\n    if (this.hot.runHooks('beforePaste', pastedData, this.copyableRanges) === false) {\n      return;\n    }\n    const [startRow, startColumn, endRow, endColumn] = this.populateValues(pastedData);\n    this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));\n    this.hot.runHooks('afterPaste', pastedData, this.copyableRanges);\n  }\n\n  /**\n   * Add copy and cut options to the Context Menu.\n   *\n   * @param {object} options Contains default added options of the Context Menu.\n   */\n\n  /**\n   * Destroys the `CopyPaste` plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _ensureClipboardEventsGetTriggered(eventName) {\n  // Without this workaround Safari (tested on Safari@16.5.2) does not trigger the 'copy' event.\n  if (isSafari()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        runWithSelectedContendEditableElement(currentlySelectedCell, () => {\n          this.hot.rootDocument.execCommand(eventName);\n        });\n      }\n    }\n  } else {\n    this.hot.rootDocument.execCommand(eventName);\n  }\n}\n/**\n * Counts how many column headers will be copied based on the passed range.\n *\n * @private\n * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n * @returns {{ columnHeadersCount: number }} Returns an object with keys that holds\n *                                           information with the number of copied headers.\n */\nfunction _countCopiedHeaders(ranges) {\n  const {\n    rows\n  } = normalizeRanges(ranges);\n  let columnHeadersCount = 0;\n  for (let row = 0; row < rows.length; row++) {\n    if (rows[row] >= 0) {\n      break;\n    }\n    columnHeadersCount += 1;\n  }\n  return {\n    columnHeadersCount\n  };\n}\nfunction _addContentEditableToHighlightedCell() {\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        makeElementContentEditableAndSelectItsContent(currentlySelectedCell);\n      }\n    }\n  }\n}\n/**\n * Remove the `contenteditable` attribute from the highlighted cell and deselect its content.\n */\nfunction _removeContentEditableFromHighlightedCell() {\n  // If the instance is not listening, the workaround is not needed.\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell !== null && currentlySelectedCell !== void 0 && currentlySelectedCell.hasAttribute('contenteditable')) {\n        removeContentEditableFromElementAndDeselect(currentlySelectedCell);\n      }\n    }\n  }\n}\nfunction _onAfterContextMenuDefaultOptions(options) {\n  options.items.push({\n    name: '---------'\n  }, copyItem(this));\n  if (_classPrivateFieldGet(_enableCopyColumnHeaders, this)) {\n    options.items.push(copyWithColumnHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(_enableCopyColumnGroupHeaders, this)) {\n    options.items.push(copyWithColumnGroupHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(_enableCopyColumnHeadersOnly, this)) {\n    options.items.push(copyColumnHeadersOnlyItem(this));\n  }\n  options.items.push(cutItem(this));\n}\n/**\n * Disables the viewport scroll after pasting the data.\n *\n * @param {number} fromRow Selection start row visual index.\n * @param {number} fromColumn Selection start column visual index.\n * @param {number} toRow Selection end row visual index.\n * @param {number} toColumn Selection end column visual index.\n * @param {object} preventScrolling Object with `value` property. If `true`, the viewport scroll will be prevented.\n */\nfunction _onAfterSelection(fromRow, fromColumn, toRow, toColumn, preventScrolling) {\n  if (_classPrivateFieldGet(_preventViewportScrollOnPaste, this)) {\n    preventScrolling.value = true;\n  }\n  _classPrivateFieldSet(_preventViewportScrollOnPaste, this, false);\n}\n/**\n * Force focus on focusableElement after end of the selection.\n */\nfunction _onAfterSelectionEnd() {\n  if (this.isEditorOpened()) {\n    return;\n  }\n  if (this.hot.getSettings().fragmentSelection) {\n    return;\n  }\n  this.setCopyableText();\n}\n/**\n * `document.body` `mouseenter` callback used to work around a Safari's problem with copying/cutting from the\n * browser's menu.\n */\nfunction _onSafariMouseEnter() {\n  _assertClassBrand(_CopyPaste_brand, this, _removeContentEditableFromHighlightedCell).call(this);\n}\n/**\n * `document.body` `mouseleave` callback used to work around a Safari's problem with copying/cutting from the\n * browser's menu.\n */\nfunction _onSafariMouseLeave() {\n  _assertClassBrand(_CopyPaste_brand, this, _addContentEditableToHighlightedCell).call(this);\n}\n/**\n * `afterSelection` hook callback triggered only on Safari.\n */\nfunction _onSafariAfterSelection() {\n  _assertClassBrand(_CopyPaste_brand, this, _removeContentEditableFromHighlightedCell).call(this);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}