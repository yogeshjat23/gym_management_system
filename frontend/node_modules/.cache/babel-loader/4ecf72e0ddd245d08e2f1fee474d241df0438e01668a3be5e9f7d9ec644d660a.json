{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { Selection } from \"./../../3rdparty/walkontable/src/index.mjs\";\nclass VisualSelection extends Selection {\n  constructor(settings, visualCellRange) {\n    super(settings, null);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n    _defineProperty(this, \"visualCellRange\", null);\n    this.visualCellRange = visualCellRange || null;\n    this.commit();\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n  add(coords) {\n    if (this.visualCellRange === null) {\n      this.visualCellRange = this.settings.createCellRange(coords);\n    } else {\n      this.visualCellRange.expand(coords);\n    }\n    return this;\n  }\n\n  /**\n   * Clears visual and renderable selection.\n   *\n   * @returns {VisualSelection}\n   */\n  clear() {\n    this.visualCellRange = null;\n    return super.clear();\n  }\n\n  /**\n   * Trims the passed cell range object by removing all coordinates that points to the hidden rows\n   * or columns. The result is a new cell range object that points only to the visible indexes or `null`.\n   *\n   * @private\n   * @param {CellRange} cellRange Cells range object to be trimmed.\n   * @returns {CellRange} Visual non-hidden cells range coordinates.\n   */\n  trimToVisibleCellsRangeOnly(_ref) {\n    let {\n      from,\n      to\n    } = _ref;\n    let visibleFromCoords = this.getNearestNotHiddenCoords(from, 1);\n    let visibleToCoords = this.getNearestNotHiddenCoords(to, -1);\n    if (visibleFromCoords === null || visibleToCoords === null) {\n      return null;\n    }\n    if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {\n      visibleFromCoords = from;\n      visibleToCoords = to;\n    }\n    return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);\n  }\n\n  /**\n   * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible\n   * rows and/or columns the `null` value is returned.\n   *\n   * @private\n   * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.\n   * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                                  rows and from left to right for columns. For -1, it is the other way around.\n   * @param {1|-1} columnSearchDirection The same as above but for rows.\n   * @returns {CellCoords|null} Visual cell coordinates.\n   */\n  getNearestNotHiddenCoords(coords, rowSearchDirection) {\n    let columnSearchDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rowSearchDirection;\n    const nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper, coords.row, rowSearchDirection);\n\n    // There are no more visual rows in the range.\n    if (nextVisibleRow === null) {\n      return null;\n    }\n    const nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper, coords.col, columnSearchDirection);\n\n    // There are no more visual columns in the range.\n    if (nextVisibleColumn === null) {\n      return null;\n    }\n    return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);\n  }\n\n  /**\n   * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} visualIndex The index as starting point for finding the nearest visible index.\n   * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                               rows and from left to right for columns. For -1, it is the other way around.\n   * @returns {number|null} Visual row/column index.\n   */\n  getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {\n    if (visualIndex < 0) {\n      return visualIndex;\n    }\n    return indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);\n  }\n\n  /**\n   * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n   * at the end of process of adding visual selection coordinates.\n   *\n   * @returns {VisualSelection}\n   */\n  commit() {\n    // There is no information about visual ranges, thus no selection may be displayed.\n    if (this.visualCellRange === null) {\n      return this;\n    }\n    const trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);\n\n    // There is no visual start point (and also visual end point) in the range.\n    if (trimmedCellRange === null) {\n      this.cellRange = null;\n    } else {\n      this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);\n    }\n    return this;\n  }\n\n  /**\n   * Some selection may be a part of broader cell range. This function sync coordinates of current selection\n   * and the broader cell range when needed (current selection can't be presented visually).\n   *\n   * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n   * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n   *\n   * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n   *\n   * @returns {VisualSelection}\n   */\n  syncWith(broaderCellRange) {\n    const coordsFrom = broaderCellRange.from.clone().normalize();\n    const rowDirection = broaderCellRange.getVerticalDirection() === 'N-S' ? 1 : -1;\n    const columnDirection = broaderCellRange.getHorizontalDirection() === 'W-E' ? 1 : -1;\n    const renderableHighlight = this.settings.visualToRenderableCoords(this.visualCellRange.highlight);\n    let cellCoordsVisual = null;\n    if (renderableHighlight === null || renderableHighlight.col === null || renderableHighlight.row === null) {\n      cellCoordsVisual = this.getNearestNotHiddenCoords(coordsFrom, rowDirection, columnDirection);\n    }\n    if (cellCoordsVisual !== null && broaderCellRange.overlaps(cellCoordsVisual)) {\n      const currentHighlight = broaderCellRange.highlight.clone();\n      if (currentHighlight.row >= 0) {\n        currentHighlight.row = cellCoordsVisual.row;\n      }\n      if (currentHighlight.col >= 0) {\n        currentHighlight.col = cellCoordsVisual.col;\n      }\n\n      // We can't show selection visually now, but we found first visible range in the broader cell range.\n      if (this.cellRange === null) {\n        const cellCoordsRenderable = this.settings.visualToRenderableCoords(currentHighlight);\n        this.cellRange = this.settings.createCellRange(cellCoordsRenderable);\n      }\n\n      // TODO\n      // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n      // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n      broaderCellRange.setHighlight(currentHighlight);\n    }\n\n    // TODO\n    // Sync the highlight coords from the visual selection layer with logical coords.\n    if (this.settings.selectionType === 'focus' && renderableHighlight !== null && cellCoordsVisual === null) {\n      broaderCellRange.setHighlight(this.visualCellRange.highlight);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n   * The method overwrites the original method to support header selection for hidden cells.\n   * To make the header selection working, the CellCoords and CellRange have to support not\n   * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getCorners() {\n    const {\n      from,\n      to\n    } = this.cellRange;\n    return [Math.min(from.row, to.row), Math.min(from.col, to.col), Math.max(from.row, to.row), Math.max(from.col, to.col)];\n  }\n\n  /**\n   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection\n   * coordinates (visual indexes).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getVisualCorners() {\n    const topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());\n    const bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());\n    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];\n  }\n\n  /**\n   * Creates a new CellRange object based on visual coordinates which before object creation are\n   * translated to renderable indexes.\n   *\n   * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n   *                                      points to the beginning of the selection.\n   * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n   *                                    points to the end of the selection.\n   * @returns {CellRange|null}\n   */\n  createRenderableCellRange(visualFromCoords, visualToCoords) {\n    const renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n    const renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n    if (renderableFromCoords.row === null || renderableFromCoords.col === null || renderableToCoords.row === null || renderableToCoords.col === null) {\n      return null;\n    }\n    return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n  }\n}\nexport default VisualSelection;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","Selection","VisualSelection","constructor","settings","visualCellRange","commit","add","coords","createCellRange","expand","clear","trimToVisibleCellsRangeOnly","_ref","from","to","visibleFromCoords","getNearestNotHiddenCoords","visibleToCoords","row","col","rowSearchDirection","columnSearchDirection","arguments","length","undefined","nextVisibleRow","getNearestNotHiddenIndex","rowIndexMapper","nextVisibleColumn","columnIndexMapper","createCellCoords","indexMapper","visualIndex","searchDirection","trimmedCellRange","cellRange","createRenderableCellRange","syncWith","broaderCellRange","coordsFrom","clone","normalize","rowDirection","getVerticalDirection","columnDirection","getHorizontalDirection","renderableHighlight","visualToRenderableCoords","highlight","cellCoordsVisual","overlaps","currentHighlight","cellCoordsRenderable","setHighlight","selectionType","getCorners","Math","min","max","getVisualCorners","topStart","renderableToVisualCoords","getTopStartCorner","bottomEnd","getBottomEndCorner","visualFromCoords","visualToCoords","renderableFromCoords","renderableToCoords"],"sources":["D:/gym-project/frontend/node_modules/handsontable/selection/highlight/visualSelection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { Selection } from \"./../../3rdparty/walkontable/src/index.mjs\";\nclass VisualSelection extends Selection {\n  constructor(settings, visualCellRange) {\n    super(settings, null);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n    _defineProperty(this, \"visualCellRange\", null);\n    this.visualCellRange = visualCellRange || null;\n    this.commit();\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n  add(coords) {\n    if (this.visualCellRange === null) {\n      this.visualCellRange = this.settings.createCellRange(coords);\n    } else {\n      this.visualCellRange.expand(coords);\n    }\n    return this;\n  }\n\n  /**\n   * Clears visual and renderable selection.\n   *\n   * @returns {VisualSelection}\n   */\n  clear() {\n    this.visualCellRange = null;\n    return super.clear();\n  }\n\n  /**\n   * Trims the passed cell range object by removing all coordinates that points to the hidden rows\n   * or columns. The result is a new cell range object that points only to the visible indexes or `null`.\n   *\n   * @private\n   * @param {CellRange} cellRange Cells range object to be trimmed.\n   * @returns {CellRange} Visual non-hidden cells range coordinates.\n   */\n  trimToVisibleCellsRangeOnly(_ref) {\n    let {\n      from,\n      to\n    } = _ref;\n    let visibleFromCoords = this.getNearestNotHiddenCoords(from, 1);\n    let visibleToCoords = this.getNearestNotHiddenCoords(to, -1);\n    if (visibleFromCoords === null || visibleToCoords === null) {\n      return null;\n    }\n    if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {\n      visibleFromCoords = from;\n      visibleToCoords = to;\n    }\n    return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);\n  }\n\n  /**\n   * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible\n   * rows and/or columns the `null` value is returned.\n   *\n   * @private\n   * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.\n   * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                                  rows and from left to right for columns. For -1, it is the other way around.\n   * @param {1|-1} columnSearchDirection The same as above but for rows.\n   * @returns {CellCoords|null} Visual cell coordinates.\n   */\n  getNearestNotHiddenCoords(coords, rowSearchDirection) {\n    let columnSearchDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rowSearchDirection;\n    const nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper, coords.row, rowSearchDirection);\n\n    // There are no more visual rows in the range.\n    if (nextVisibleRow === null) {\n      return null;\n    }\n    const nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper, coords.col, columnSearchDirection);\n\n    // There are no more visual columns in the range.\n    if (nextVisibleColumn === null) {\n      return null;\n    }\n    return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);\n  }\n\n  /**\n   * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} visualIndex The index as starting point for finding the nearest visible index.\n   * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                               rows and from left to right for columns. For -1, it is the other way around.\n   * @returns {number|null} Visual row/column index.\n   */\n  getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {\n    if (visualIndex < 0) {\n      return visualIndex;\n    }\n    return indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);\n  }\n\n  /**\n   * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n   * at the end of process of adding visual selection coordinates.\n   *\n   * @returns {VisualSelection}\n   */\n  commit() {\n    // There is no information about visual ranges, thus no selection may be displayed.\n    if (this.visualCellRange === null) {\n      return this;\n    }\n    const trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);\n\n    // There is no visual start point (and also visual end point) in the range.\n    if (trimmedCellRange === null) {\n      this.cellRange = null;\n    } else {\n      this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);\n    }\n    return this;\n  }\n\n  /**\n   * Some selection may be a part of broader cell range. This function sync coordinates of current selection\n   * and the broader cell range when needed (current selection can't be presented visually).\n   *\n   * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n   * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n   *\n   * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n   *\n   * @returns {VisualSelection}\n   */\n  syncWith(broaderCellRange) {\n    const coordsFrom = broaderCellRange.from.clone().normalize();\n    const rowDirection = broaderCellRange.getVerticalDirection() === 'N-S' ? 1 : -1;\n    const columnDirection = broaderCellRange.getHorizontalDirection() === 'W-E' ? 1 : -1;\n    const renderableHighlight = this.settings.visualToRenderableCoords(this.visualCellRange.highlight);\n    let cellCoordsVisual = null;\n    if (renderableHighlight === null || renderableHighlight.col === null || renderableHighlight.row === null) {\n      cellCoordsVisual = this.getNearestNotHiddenCoords(coordsFrom, rowDirection, columnDirection);\n    }\n    if (cellCoordsVisual !== null && broaderCellRange.overlaps(cellCoordsVisual)) {\n      const currentHighlight = broaderCellRange.highlight.clone();\n      if (currentHighlight.row >= 0) {\n        currentHighlight.row = cellCoordsVisual.row;\n      }\n      if (currentHighlight.col >= 0) {\n        currentHighlight.col = cellCoordsVisual.col;\n      }\n\n      // We can't show selection visually now, but we found first visible range in the broader cell range.\n      if (this.cellRange === null) {\n        const cellCoordsRenderable = this.settings.visualToRenderableCoords(currentHighlight);\n        this.cellRange = this.settings.createCellRange(cellCoordsRenderable);\n      }\n\n      // TODO\n      // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n      // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n      broaderCellRange.setHighlight(currentHighlight);\n    }\n\n    // TODO\n    // Sync the highlight coords from the visual selection layer with logical coords.\n    if (this.settings.selectionType === 'focus' && renderableHighlight !== null && cellCoordsVisual === null) {\n      broaderCellRange.setHighlight(this.visualCellRange.highlight);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n   * The method overwrites the original method to support header selection for hidden cells.\n   * To make the header selection working, the CellCoords and CellRange have to support not\n   * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getCorners() {\n    const {\n      from,\n      to\n    } = this.cellRange;\n    return [Math.min(from.row, to.row), Math.min(from.col, to.col), Math.max(from.row, to.row), Math.max(from.col, to.col)];\n  }\n\n  /**\n   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection\n   * coordinates (visual indexes).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getVisualCorners() {\n    const topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());\n    const bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());\n    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];\n  }\n\n  /**\n   * Creates a new CellRange object based on visual coordinates which before object creation are\n   * translated to renderable indexes.\n   *\n   * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n   *                                      points to the beginning of the selection.\n   * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n   *                                    points to the end of the selection.\n   * @returns {CellRange|null}\n   */\n  createRenderableCellRange(visualFromCoords, visualToCoords) {\n    const renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n    const renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n    if (renderableFromCoords.row === null || renderableFromCoords.col === null || renderableToCoords.row === null || renderableToCoords.col === null) {\n      return null;\n    }\n    return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n  }\n}\nexport default VisualSelection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}