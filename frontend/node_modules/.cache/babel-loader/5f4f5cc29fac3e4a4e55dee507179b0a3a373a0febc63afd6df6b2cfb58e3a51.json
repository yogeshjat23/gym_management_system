{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\nimport { addClass, removeClass, offset, hasClass, outerWidth } from \"../../helpers/dom/element.mjs\";\nimport { offsetRelativeTo } from \"../../helpers/dom/event.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport BacklightUI from \"./ui/backlight.mjs\";\nimport GuidelineUI from \"./ui/guideline.mjs\";\nHooks.getSingleton().register('beforeColumnMove');\nHooks.getSingleton().register('afterColumnMove');\nexport const PLUGIN_KEY = 'manualColumnMove';\nexport const PLUGIN_PRIORITY = 120;\nconst CSS_PLUGIN = 'ht__manualColumnMove';\nconst CSS_SHOW_UI = 'show-ui';\nconst CSS_ON_MOVING = 'on-moving--columns';\nconst CSS_AFTER_SELECTION = 'after-selection--columns';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualColumnMove\n * @class ManualColumnMove\n *\n * @description\n * This plugin allows to change columns order. To make columns order persistent the {@link Options#persistentState}\n * plugin should be enabled.\n *\n * API:\n * - `moveColumn` - move single column to the new position.\n * - `moveColumns` - move many columns (as an array of indexes) to the new position.\n * - `dragColumn` - drag single column to the new position.\n * - `dragColumns` - drag many columns (as an array of indexes) to the new position.\n *\n * [Documentation](@/guides/columns/column-moving/column-moving.md) explain differences between drag and move actions.\n * Please keep in mind that if you want apply visual changes,\n * you have to call manually the `render` method on the instance of Handsontable.\n *\n * The plugin creates additional components to make moving possibly using user interface:\n * - backlight - highlight of selected columns.\n * - guideline - line which shows where columns has been moved.\n *\n * @class ManualColumnMove\n * @plugin ManualColumnMove\n */\nvar _backlight = /*#__PURE__*/new WeakMap();\nvar _guideline = /*#__PURE__*/new WeakMap();\nvar _columnsToMove = /*#__PURE__*/new WeakMap();\nvar _countCols = /*#__PURE__*/new WeakMap();\nvar _pressed = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _cachedDropIndex = /*#__PURE__*/new WeakMap();\nvar _hoveredColumn = /*#__PURE__*/new WeakMap();\nvar _rootElementOffset = /*#__PURE__*/new WeakMap();\nvar _hasRowHeaders = /*#__PURE__*/new WeakMap();\nvar _fixedColumnsStart = /*#__PURE__*/new WeakMap();\nvar _ManualColumnMove_brand = /*#__PURE__*/new WeakSet();\nexport class ManualColumnMove extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Change the behavior of selection / dragging.\n     *\n     * @param {MouseEvent} event `mousedown` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _ManualColumnMove_brand);\n    /**\n     * Backlight UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _backlight, new BacklightUI(this.hot));\n    /**\n     * Guideline UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _guideline, new GuidelineUI(this.hot));\n    /**\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _columnsToMove, []);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _countCols, 0);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _pressed, false);\n    /**\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _target, {});\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _cachedDropIndex, void 0);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _hoveredColumn, void 0);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _rootElementOffset, void 0);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hasRowHeaders, void 0);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _fixedColumnsStart, void 0);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualColumnMove#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_ManualColumnMove_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_ManualColumnMove_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('afterScrollVertically', () => _assertClassBrand(_ManualColumnMove_brand, this, _onAfterScrollVertically).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_ManualColumnMove_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.buildPluginUI();\n    this.registerEvents();\n\n    // TODO: move adding plugin classname to BasePlugin.\n    addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualColumnMove`](@/api/options.md#manualcolumnmove)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    this.unregisterEvents();\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.disablePlugin();\n  }\n\n  /**\n   * Moves a single column.\n   *\n   * @param {number} column Visual column index to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  moveColumn(column, finalIndex) {\n    return this.moveColumns([column], finalIndex);\n  }\n\n  /**\n   * Moves a multiple columns.\n   *\n   * @param {Array} columns Array of visual column indexes to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  moveColumns(columns, finalIndex) {\n    const dropIndex = _classPrivateFieldGet(_cachedDropIndex, this);\n    const movePossible = this.isMovePossible(columns, finalIndex);\n    const beforeMoveHook = this.hot.runHooks('beforeColumnMove', columns, finalIndex, dropIndex, movePossible);\n    _classPrivateFieldSet(_cachedDropIndex, this, undefined);\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if (movePossible) {\n      this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);\n    }\n    const movePerformed = movePossible && this.isColumnOrderChanged(columns, finalIndex);\n    this.hot.runHooks('afterColumnMove', columns, finalIndex, dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n\n  /**\n   * Drag a single column to drop index position.\n   *\n   * @param {number} column Visual column index to be dragged.\n   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  dragColumn(column, dropIndex) {\n    return this.dragColumns([column], dropIndex);\n  }\n\n  /**\n   * Drag multiple columns to drop index position.\n   *\n   * @param {Array} columns Array of visual column indexes to be dragged.\n   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  dragColumns(columns, dropIndex) {\n    const finalIndex = this.countFinalIndex(columns, dropIndex);\n    _classPrivateFieldSet(_cachedDropIndex, this, dropIndex);\n    return this.moveColumns(columns, finalIndex);\n  }\n\n  /**\n   * Indicates if it's possible to move columns to the desired position. Some of the actions aren't\n   * possible, i.e. You can’t move more than one element to the last position.\n   *\n   * @param {Array} movedColumns Array of visual column indexes to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedColumns, finalIndex) {\n    const length = this.hot.columnIndexMapper.getNotTrimmedIndexesLength();\n\n    // An attempt to transfer more columns to start destination than is possible (only when moving from the top to the bottom).\n    const tooHighDestinationIndex = movedColumns.length + finalIndex > length;\n    const tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedColumnIndex = movedColumns.some(movedColumn => movedColumn < 0);\n    const tooHighMovedColumnIndex = movedColumns.some(movedColumn => movedColumn >= length);\n    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Indicates if order of columns was changed.\n   *\n   * @private\n   * @param {Array} movedColumns Array of visual column indexes to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @returns {boolean}\n   */\n  isColumnOrderChanged(movedColumns, finalIndex) {\n    return movedColumns.some((column, nrOfMovedElement) => column - nrOfMovedElement !== finalIndex);\n  }\n\n  /**\n   * Count the final column index from the drop index.\n   *\n   * @private\n   * @param {Array} movedColumns Array of visual column indexes to be moved.\n   * @param {number} dropIndex Visual column index, being a drop index for the moved columns.\n   * @returns {number} Visual column index, being a start index for the moved columns.\n   */\n  countFinalIndex(movedColumns, dropIndex) {\n    const numberOfColumnsLowerThanDropIndex = arrayReduce(movedColumns, (numberOfColumns, currentColumnIndex) => {\n      if (currentColumnIndex < dropIndex) {\n        numberOfColumns += 1;\n      }\n      return numberOfColumns;\n    }, 0);\n    return dropIndex - numberOfColumnsLowerThanDropIndex;\n  }\n\n  /**\n   * Gets the sum of the widths of columns in the provided range.\n   *\n   * @private\n   * @param {number} fromColumn Visual column index.\n   * @param {number} toColumn Visual column index.\n   * @returns {number}\n   */\n  getColumnsWidth(fromColumn, toColumn) {\n    const columnMapper = this.hot.columnIndexMapper;\n    let columnsWidth = 0;\n    for (let visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; visualColumnIndex += 1) {\n      // We can't use just `getColWidth` (even without indexes translation) as it doesn't return proper values\n      // when column is stretched.\n      const renderableIndex = columnMapper.getRenderableFromVisualIndex(visualColumnIndex);\n      if (visualColumnIndex < 0) {\n        columnsWidth += this.hot.view._wt.wtViewport.getRowHeaderWidth() || 0;\n      } else if (renderableIndex !== null) {\n        columnsWidth += this.hot.view._wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;\n      }\n    }\n    return columnsWidth;\n  }\n\n  /**\n   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.\n   *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(pluginSettings)) {\n      this.moveColumns(pluginSettings, 0);\n    } else if (pluginSettings !== undefined) {\n      const persistentState = this.persistentStateLoad();\n      if (persistentState.length) {\n        this.moveColumns(persistentState, 0);\n      }\n    }\n  }\n\n  /**\n   * Checks if the provided column is in the fixedColumnsTop section.\n   *\n   * @private\n   * @param {number} column Visual column index to check.\n   * @returns {boolean}\n   */\n  isFixedColumnsStart(column) {\n    return column < this.hot.getSettings().fixedColumnsStart;\n  }\n\n  /**\n   * Saves the manual column positions to the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    this.hot.runHooks('persistentStateSave', 'manualColumnMove', this.hot.columnIndexMapper.getIndexesSequence()); // The `PersistentState` plugin should be refactored.\n  }\n\n  /**\n   * Loads the manual column positions from the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   */\n  persistentStateLoad() {\n    const storedState = {};\n    this.hot.runHooks('persistentStateLoad', 'manualColumnMove', storedState);\n    return storedState.value ? storedState.value : [];\n  }\n\n  /**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * @private\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array}\n   */\n  prepareColumnsToMoving(start, end) {\n    const selectedColumns = [];\n    rangeEach(start, end, i => {\n      selectedColumns.push(i);\n    });\n    return selectedColumns;\n  }\n\n  /**\n   * Update the UI visual position.\n   *\n   * @private\n   */\n  refreshPositions() {\n    const firstVisible = this.hot.view.getFirstFullyVisibleColumn();\n    if (this.isFixedColumnsStart(_classPrivateFieldGet(_hoveredColumn, this)) && firstVisible > 0) {\n      this.hot.scrollViewportTo({\n        col: this.hot.columnIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1)\n      });\n    }\n    const wtTable = this.hot.view._wt.wtTable;\n    const scrollableElement = this.hot.view._wt.wtOverlays.scrollableElement;\n    const scrollStart = typeof scrollableElement.scrollX === 'number' ? scrollableElement.scrollX : scrollableElement.scrollLeft;\n    let tdOffsetStart = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, _classPrivateFieldGet(_hoveredColumn, this) - 1);\n    const hiderWidth = wtTable.hider.offsetWidth;\n    const tbodyOffsetLeft = wtTable.TBODY.offsetLeft;\n    const backlightElemMarginStart = _classPrivateFieldGet(_backlight, this).getOffset().start;\n    const backlightElemWidth = _classPrivateFieldGet(_backlight, this).getSize().width;\n    let rowHeaderWidth = 0;\n    let mouseOffsetStart = 0;\n    if (this.hot.isRtl()) {\n      const rootWindow = this.hot.rootWindow;\n      const containerWidth = outerWidth(this.hot.rootElement);\n      const gridMostRightPos = rootWindow.innerWidth - _classPrivateFieldGet(_rootElementOffset, this) - containerWidth;\n      mouseOffsetStart = rootWindow.innerWidth - _classPrivateFieldGet(_target, this).eventPageX - gridMostRightPos - (scrollableElement.scrollX === undefined ? scrollStart : 0);\n    } else {\n      mouseOffsetStart = _classPrivateFieldGet(_target, this).eventPageX - (_classPrivateFieldGet(_rootElementOffset, this) - (scrollableElement.scrollX === undefined ? scrollStart : 0));\n    }\n    if (_classPrivateFieldGet(_hasRowHeaders, this)) {\n      rowHeaderWidth = this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;\n    }\n    if (this.isFixedColumnsStart(_classPrivateFieldGet(_hoveredColumn, this))) {\n      tdOffsetStart += scrollStart;\n    }\n    tdOffsetStart += rowHeaderWidth;\n    if (_classPrivateFieldGet(_hoveredColumn, this) < 0) {\n      // if hover on rowHeader\n      if (_classPrivateFieldGet(_fixedColumnsStart, this) > 0) {\n        _classPrivateFieldGet(_target, this).col = 0;\n      } else {\n        _classPrivateFieldGet(_target, this).col = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n      }\n    } else if (_classPrivateFieldGet(_target, this).TD.offsetWidth / 2 + tdOffsetStart <= mouseOffsetStart) {\n      const newCoordsCol = _classPrivateFieldGet(_hoveredColumn, this) >= _classPrivateFieldGet(_countCols, this) ? _classPrivateFieldGet(_countCols, this) - 1 : _classPrivateFieldGet(_hoveredColumn, this);\n\n      // if hover on right part of TD\n      _classPrivateFieldGet(_target, this).col = newCoordsCol + 1;\n      // unfortunately first column is bigger than rest\n      tdOffsetStart += _classPrivateFieldGet(_target, this).TD.offsetWidth;\n    } else {\n      // elsewhere on table\n      _classPrivateFieldGet(_target, this).col = _classPrivateFieldGet(_hoveredColumn, this);\n    }\n    let backlightStart = mouseOffsetStart;\n    let guidelineStart = tdOffsetStart;\n    if (mouseOffsetStart + backlightElemWidth + backlightElemMarginStart >= hiderWidth) {\n      // prevent display backlight on the right side of the table\n      backlightStart = hiderWidth - backlightElemWidth - backlightElemMarginStart;\n    } else if (mouseOffsetStart + backlightElemMarginStart < tbodyOffsetLeft + rowHeaderWidth) {\n      // prevent display backlight on the left side of the table\n      backlightStart = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginStart);\n    }\n    if (tdOffsetStart >= hiderWidth - 1) {\n      // prevent display guideline outside the table\n      guidelineStart = hiderWidth - 1;\n    } else if (guidelineStart === 0) {\n      // guideline has got `margin-left: -1px` as default\n      guidelineStart = 1;\n    } else if (scrollableElement.scrollX !== undefined && _classPrivateFieldGet(_hoveredColumn, this) < _classPrivateFieldGet(_fixedColumnsStart, this)) {\n      guidelineStart -= _classPrivateFieldGet(_rootElementOffset, this) <= scrollableElement.scrollX ? _classPrivateFieldGet(_rootElementOffset, this) : 0;\n    }\n    _classPrivateFieldGet(_backlight, this).setPosition(null, backlightStart);\n    _classPrivateFieldGet(_guideline, this).setPosition(null, guidelineStart);\n  }\n\n  /**\n   * Binds the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _assertClassBrand(_ManualColumnMove_brand, this, _onMouseMove).call(this, event));\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _assertClassBrand(_ManualColumnMove_brand, this, _onMouseUp).call(this));\n  }\n\n  /**\n   * Unbinds the events used by the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    this.eventManager.clear();\n  }\n  /**\n   * Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    _classPrivateFieldGet(_backlight, this).build();\n    _classPrivateFieldGet(_guideline, this).build();\n  }\n\n  /**\n   * Callback for the `afterLoadData` hook.\n   *\n   * @private\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.destroy();\n  }\n}\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const wtTable = this.hot.view._wt.wtTable;\n  const isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();\n  const selection = this.hot.getSelectedRangeLast();\n  // This block action shouldn't be handled below.\n  const isSortingElement = hasClass(event.target, 'sortAction');\n  if (!selection || !isHeaderSelection || _classPrivateFieldGet(_pressed, this) || event.button !== 0 || isSortingElement) {\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_columnsToMove, this).length = 0;\n    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);\n    return;\n  }\n  const guidelineIsNotReady = _classPrivateFieldGet(_guideline, this).isBuilt() && !_classPrivateFieldGet(_guideline, this).isAppended();\n  const backlightIsNotReady = _classPrivateFieldGet(_backlight, this).isBuilt() && !_classPrivateFieldGet(_backlight, this).isAppended();\n  if (guidelineIsNotReady && backlightIsNotReady) {\n    _classPrivateFieldGet(_guideline, this).appendTo(wtTable.hider);\n    _classPrivateFieldGet(_backlight, this).appendTo(wtTable.hider);\n  }\n  const {\n    from,\n    to\n  } = selection;\n  const start = Math.min(from.col, to.col);\n  const end = Math.max(from.col, to.col);\n  if (coords.row < 0 && coords.col >= start && coords.col <= end) {\n    controller.column = true;\n    _classPrivateFieldSet(_pressed, this, true);\n    const eventOffsetX = TD.firstChild ? offsetRelativeTo(event, TD.firstChild).x : event.offsetX;\n    _classPrivateFieldGet(_target, this).eventPageX = event.pageX;\n    _classPrivateFieldSet(_hoveredColumn, this, coords.col);\n    _classPrivateFieldGet(_target, this).TD = TD;\n    _classPrivateFieldGet(_target, this).col = coords.col;\n    _classPrivateFieldSet(_columnsToMove, this, this.prepareColumnsToMoving(start, end));\n    _classPrivateFieldSet(_hasRowHeaders, this, !!this.hot.getSettings().rowHeaders);\n    _classPrivateFieldSet(_countCols, this, this.hot.countCols());\n    _classPrivateFieldSet(_fixedColumnsStart, this, this.hot.getSettings().fixedColumnsStart);\n    _classPrivateFieldSet(_rootElementOffset, this, offset(this.hot.rootElement).left);\n    const countColumnsFrom = _classPrivateFieldGet(_hasRowHeaders, this) ? -1 : 0;\n    const topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;\n    const fixedColumnsStart = coords.col < _classPrivateFieldGet(_fixedColumnsStart, this);\n    const horizontalScrollPosition = this.hot.view._wt.wtOverlays.inlineStartOverlay.getOverlayOffset();\n    const offsetX = Math.abs(eventOffsetX - (this.hot.isRtl() ? TD.offsetWidth : 0));\n    const inlineOffset = this.getColumnsWidth(start, coords.col - 1) + offsetX;\n    const inlinePos = this.getColumnsWidth(countColumnsFrom, start - 1) + (fixedColumnsStart ? horizontalScrollPosition : 0) + inlineOffset;\n    _classPrivateFieldGet(_backlight, this).setPosition(topPos, inlinePos);\n    _classPrivateFieldGet(_backlight, this).setSize(this.getColumnsWidth(start, end), wtTable.hider.offsetHeight - topPos);\n    _classPrivateFieldGet(_backlight, this).setOffset(null, -inlineOffset);\n    addClass(this.hot.rootElement, CSS_ON_MOVING);\n  } else {\n    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_columnsToMove, this).length = 0;\n  }\n}\n/**\n * 'mouseMove' event callback. Fired when pointer move on document.documentElement.\n *\n * @param {MouseEvent} event `mousemove` event properties.\n */\nfunction _onMouseMove(event) {\n  if (!_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  _classPrivateFieldGet(_target, this).eventPageX = event.pageX;\n  this.refreshPositions();\n}\n/**\n * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.\n *\n * @param {MouseEvent} event `mouseover` event properties.\n * @param {CellCoords} coords Visual cell coordinates where was fired event.\n * @param {HTMLElement} TD Cell represented as HTMLElement.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  if (!selectedRange || !_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  if (_classPrivateFieldGet(_columnsToMove, this).indexOf(coords.col) > -1) {\n    removeClass(this.hot.rootElement, CSS_SHOW_UI);\n  } else {\n    addClass(this.hot.rootElement, CSS_SHOW_UI);\n  }\n  controller.row = true;\n  controller.column = true;\n  controller.cell = true;\n  _classPrivateFieldSet(_hoveredColumn, this, coords.col);\n  _classPrivateFieldGet(_target, this).TD = TD;\n}\n/**\n * `onMouseUp` hook callback.\n */\nfunction _onMouseUp() {\n  const target = _classPrivateFieldGet(_target, this).col;\n  const columnsLen = _classPrivateFieldGet(_columnsToMove, this).length;\n  _classPrivateFieldSet(_hoveredColumn, this, undefined);\n  _classPrivateFieldSet(_pressed, this, false);\n  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);\n  if (this.hot.selection.isSelectedByColumnHeader()) {\n    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n  }\n  if (columnsLen < 1 || target === undefined) {\n    return;\n  }\n  const firstMovedVisualColumn = _classPrivateFieldGet(_columnsToMove, this)[0];\n  const firstMovedPhysicalColumn = this.hot.toPhysicalColumn(firstMovedVisualColumn);\n  const movePerformed = this.dragColumns(_classPrivateFieldGet(_columnsToMove, this), target);\n  _classPrivateFieldGet(_columnsToMove, this).length = 0;\n  if (movePerformed === true) {\n    this.persistentStateSave();\n    this.hot.render();\n    this.hot.view.adjustElementsSize();\n    const selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);\n    const selectionEnd = selectionStart + columnsLen - 1;\n    this.hot.selectColumns(selectionStart, selectionEnd);\n  }\n}\n/**\n * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.\n */\nfunction _onAfterScrollVertically() {\n  const wtTable = this.hot.view._wt.wtTable;\n  const headerHeight = wtTable.getColumnHeaderHeight(0) + 1;\n  const scrollTop = wtTable.holder.scrollTop;\n  const posTop = headerHeight + scrollTop;\n  _classPrivateFieldGet(_backlight, this).setPosition(posTop);\n  _classPrivateFieldGet(_backlight, this).setSize(null, wtTable.hider.offsetHeight - posTop);\n}\nfunction _onAfterLoadData() {\n  this.moveBySettingsOrLoad();\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","t","set","has","TypeError","_classPrivateFieldSet","s","r","_assertClassBrand","_classPrivateFieldGet","get","n","arguments","length","BasePlugin","Hooks","arrayReduce","addClass","removeClass","offset","hasClass","outerWidth","offsetRelativeTo","rangeEach","BacklightUI","GuidelineUI","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","CSS_PLUGIN","CSS_SHOW_UI","CSS_ON_MOVING","CSS_AFTER_SELECTION","_backlight","WeakMap","_guideline","_columnsToMove","_countCols","_pressed","_target","_cachedDropIndex","_hoveredColumn","_rootElementOffset","_hasRowHeaders","_fixedColumnsStart","_ManualColumnMove_brand","WeakSet","ManualColumnMove","constructor","hot","isEnabled","getSettings","enablePlugin","_this","enabled","addHook","_len","args","Array","_key","_onBeforeOnCellMouseDown","call","_len2","_key2","_onBeforeOnCellMouseOver","_onAfterScrollVertically","_len3","_key3","_onAfterLoadData","buildPluginUI","registerEvents","rootElement","updatePlugin","disablePlugin","moveBySettingsOrLoad","unregisterEvents","destroy","moveColumn","column","finalIndex","moveColumns","columns","dropIndex","movePossible","isMovePossible","beforeMoveHook","runHooks","undefined","columnIndexMapper","moveIndexes","movePerformed","isColumnOrderChanged","dragColumn","dragColumns","countFinalIndex","movedColumns","getNotTrimmedIndexesLength","tooHighDestinationIndex","tooLowDestinationIndex","tooLowMovedColumnIndex","some","movedColumn","tooHighMovedColumnIndex","nrOfMovedElement","numberOfColumnsLowerThanDropIndex","numberOfColumns","currentColumnIndex","getColumnsWidth","fromColumn","toColumn","columnMapper","columnsWidth","visualColumnIndex","renderableIndex","getRenderableFromVisualIndex","view","_wt","wtViewport","getRowHeaderWidth","wtTable","getStretchedColumnWidth","pluginSettings","isArray","persistentState","persistentStateLoad","isFixedColumnsStart","fixedColumnsStart","persistentStateSave","getIndexesSequence","storedState","value","prepareColumnsToMoving","start","end","selectedColumns","i","push","refreshPositions","firstVisible","getFirstFullyVisibleColumn","scrollViewportTo","col","getNearestNotHiddenIndex","scrollableElement","wtOverlays","scrollStart","scrollX","scrollLeft","tdOffsetStart","THEAD","offsetLeft","hiderWidth","hider","offsetWidth","tbodyOffsetLeft","TBODY","backlightElemMarginStart","getOffset","backlightElemWidth","getSize","width","rowHeaderWidth","mouseOffsetStart","isRtl","rootWindow","containerWidth","gridMostRightPos","innerWidth","eventPageX","inlineStartOverlay","clone","getColumnHeader","TD","newCoordsCol","backlightStart","guidelineStart","Math","abs","setPosition","documentElement","rootDocument","eventManager","addEventListener","event","_onMouseMove","_onMouseUp","clear","build","coords","controller","isHeaderSelection","selection","isSelectedByColumnHeader","getSelectedRangeLast","isSortingElement","target","button","guidelineIsNotReady","isBuilt","isAppended","backlightIsNotReady","appendTo","from","to","min","max","row","eventOffsetX","firstChild","x","offsetX","pageX","rowHeaders","countCols","left","countColumnsFrom","topPos","holder","scrollTop","getColumnHeaderHeight","horizontalScrollPosition","getOverlayOffset","inlineOffset","inlinePos","setSize","offsetHeight","setOffset","selectedRange","indexOf","cell","columnsLen","firstMovedVisualColumn","firstMovedPhysicalColumn","toPhysicalColumn","render","adjustElementsSize","selectionStart","toVisualColumn","selectionEnd","selectColumns","headerHeight","posTop"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/manualColumnMove/manualColumnMove.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\nimport { addClass, removeClass, offset, hasClass, outerWidth } from \"../../helpers/dom/element.mjs\";\nimport { offsetRelativeTo } from \"../../helpers/dom/event.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport BacklightUI from \"./ui/backlight.mjs\";\nimport GuidelineUI from \"./ui/guideline.mjs\";\nHooks.getSingleton().register('beforeColumnMove');\nHooks.getSingleton().register('afterColumnMove');\nexport const PLUGIN_KEY = 'manualColumnMove';\nexport const PLUGIN_PRIORITY = 120;\nconst CSS_PLUGIN = 'ht__manualColumnMove';\nconst CSS_SHOW_UI = 'show-ui';\nconst CSS_ON_MOVING = 'on-moving--columns';\nconst CSS_AFTER_SELECTION = 'after-selection--columns';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualColumnMove\n * @class ManualColumnMove\n *\n * @description\n * This plugin allows to change columns order. To make columns order persistent the {@link Options#persistentState}\n * plugin should be enabled.\n *\n * API:\n * - `moveColumn` - move single column to the new position.\n * - `moveColumns` - move many columns (as an array of indexes) to the new position.\n * - `dragColumn` - drag single column to the new position.\n * - `dragColumns` - drag many columns (as an array of indexes) to the new position.\n *\n * [Documentation](@/guides/columns/column-moving/column-moving.md) explain differences between drag and move actions.\n * Please keep in mind that if you want apply visual changes,\n * you have to call manually the `render` method on the instance of Handsontable.\n *\n * The plugin creates additional components to make moving possibly using user interface:\n * - backlight - highlight of selected columns.\n * - guideline - line which shows where columns has been moved.\n *\n * @class ManualColumnMove\n * @plugin ManualColumnMove\n */\nvar _backlight = /*#__PURE__*/new WeakMap();\nvar _guideline = /*#__PURE__*/new WeakMap();\nvar _columnsToMove = /*#__PURE__*/new WeakMap();\nvar _countCols = /*#__PURE__*/new WeakMap();\nvar _pressed = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _cachedDropIndex = /*#__PURE__*/new WeakMap();\nvar _hoveredColumn = /*#__PURE__*/new WeakMap();\nvar _rootElementOffset = /*#__PURE__*/new WeakMap();\nvar _hasRowHeaders = /*#__PURE__*/new WeakMap();\nvar _fixedColumnsStart = /*#__PURE__*/new WeakMap();\nvar _ManualColumnMove_brand = /*#__PURE__*/new WeakSet();\nexport class ManualColumnMove extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Change the behavior of selection / dragging.\n     *\n     * @param {MouseEvent} event `mousedown` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _ManualColumnMove_brand);\n    /**\n     * Backlight UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _backlight, new BacklightUI(this.hot));\n    /**\n     * Guideline UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _guideline, new GuidelineUI(this.hot));\n    /**\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _columnsToMove, []);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _countCols, 0);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _pressed, false);\n    /**\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _target, {});\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _cachedDropIndex, void 0);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _hoveredColumn, void 0);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _rootElementOffset, void 0);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hasRowHeaders, void 0);\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _fixedColumnsStart, void 0);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualColumnMove#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_ManualColumnMove_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_ManualColumnMove_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('afterScrollVertically', () => _assertClassBrand(_ManualColumnMove_brand, this, _onAfterScrollVertically).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_ManualColumnMove_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.buildPluginUI();\n    this.registerEvents();\n\n    // TODO: move adding plugin classname to BasePlugin.\n    addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualColumnMove`](@/api/options.md#manualcolumnmove)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    this.unregisterEvents();\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.disablePlugin();\n  }\n\n  /**\n   * Moves a single column.\n   *\n   * @param {number} column Visual column index to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  moveColumn(column, finalIndex) {\n    return this.moveColumns([column], finalIndex);\n  }\n\n  /**\n   * Moves a multiple columns.\n   *\n   * @param {Array} columns Array of visual column indexes to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  moveColumns(columns, finalIndex) {\n    const dropIndex = _classPrivateFieldGet(_cachedDropIndex, this);\n    const movePossible = this.isMovePossible(columns, finalIndex);\n    const beforeMoveHook = this.hot.runHooks('beforeColumnMove', columns, finalIndex, dropIndex, movePossible);\n    _classPrivateFieldSet(_cachedDropIndex, this, undefined);\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if (movePossible) {\n      this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);\n    }\n    const movePerformed = movePossible && this.isColumnOrderChanged(columns, finalIndex);\n    this.hot.runHooks('afterColumnMove', columns, finalIndex, dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n\n  /**\n   * Drag a single column to drop index position.\n   *\n   * @param {number} column Visual column index to be dragged.\n   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  dragColumn(column, dropIndex) {\n    return this.dragColumns([column], dropIndex);\n  }\n\n  /**\n   * Drag multiple columns to drop index position.\n   *\n   * @param {Array} columns Array of visual column indexes to be dragged.\n   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  dragColumns(columns, dropIndex) {\n    const finalIndex = this.countFinalIndex(columns, dropIndex);\n    _classPrivateFieldSet(_cachedDropIndex, this, dropIndex);\n    return this.moveColumns(columns, finalIndex);\n  }\n\n  /**\n   * Indicates if it's possible to move columns to the desired position. Some of the actions aren't\n   * possible, i.e. You can’t move more than one element to the last position.\n   *\n   * @param {Array} movedColumns Array of visual column indexes to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedColumns, finalIndex) {\n    const length = this.hot.columnIndexMapper.getNotTrimmedIndexesLength();\n\n    // An attempt to transfer more columns to start destination than is possible (only when moving from the top to the bottom).\n    const tooHighDestinationIndex = movedColumns.length + finalIndex > length;\n    const tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedColumnIndex = movedColumns.some(movedColumn => movedColumn < 0);\n    const tooHighMovedColumnIndex = movedColumns.some(movedColumn => movedColumn >= length);\n    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Indicates if order of columns was changed.\n   *\n   * @private\n   * @param {Array} movedColumns Array of visual column indexes to be moved.\n   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).\n   * @returns {boolean}\n   */\n  isColumnOrderChanged(movedColumns, finalIndex) {\n    return movedColumns.some((column, nrOfMovedElement) => column - nrOfMovedElement !== finalIndex);\n  }\n\n  /**\n   * Count the final column index from the drop index.\n   *\n   * @private\n   * @param {Array} movedColumns Array of visual column indexes to be moved.\n   * @param {number} dropIndex Visual column index, being a drop index for the moved columns.\n   * @returns {number} Visual column index, being a start index for the moved columns.\n   */\n  countFinalIndex(movedColumns, dropIndex) {\n    const numberOfColumnsLowerThanDropIndex = arrayReduce(movedColumns, (numberOfColumns, currentColumnIndex) => {\n      if (currentColumnIndex < dropIndex) {\n        numberOfColumns += 1;\n      }\n      return numberOfColumns;\n    }, 0);\n    return dropIndex - numberOfColumnsLowerThanDropIndex;\n  }\n\n  /**\n   * Gets the sum of the widths of columns in the provided range.\n   *\n   * @private\n   * @param {number} fromColumn Visual column index.\n   * @param {number} toColumn Visual column index.\n   * @returns {number}\n   */\n  getColumnsWidth(fromColumn, toColumn) {\n    const columnMapper = this.hot.columnIndexMapper;\n    let columnsWidth = 0;\n    for (let visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; visualColumnIndex += 1) {\n      // We can't use just `getColWidth` (even without indexes translation) as it doesn't return proper values\n      // when column is stretched.\n      const renderableIndex = columnMapper.getRenderableFromVisualIndex(visualColumnIndex);\n      if (visualColumnIndex < 0) {\n        columnsWidth += this.hot.view._wt.wtViewport.getRowHeaderWidth() || 0;\n      } else if (renderableIndex !== null) {\n        columnsWidth += this.hot.view._wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;\n      }\n    }\n    return columnsWidth;\n  }\n\n  /**\n   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.\n   *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(pluginSettings)) {\n      this.moveColumns(pluginSettings, 0);\n    } else if (pluginSettings !== undefined) {\n      const persistentState = this.persistentStateLoad();\n      if (persistentState.length) {\n        this.moveColumns(persistentState, 0);\n      }\n    }\n  }\n\n  /**\n   * Checks if the provided column is in the fixedColumnsTop section.\n   *\n   * @private\n   * @param {number} column Visual column index to check.\n   * @returns {boolean}\n   */\n  isFixedColumnsStart(column) {\n    return column < this.hot.getSettings().fixedColumnsStart;\n  }\n\n  /**\n   * Saves the manual column positions to the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    this.hot.runHooks('persistentStateSave', 'manualColumnMove', this.hot.columnIndexMapper.getIndexesSequence()); // The `PersistentState` plugin should be refactored.\n  }\n\n  /**\n   * Loads the manual column positions from the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   */\n  persistentStateLoad() {\n    const storedState = {};\n    this.hot.runHooks('persistentStateLoad', 'manualColumnMove', storedState);\n    return storedState.value ? storedState.value : [];\n  }\n\n  /**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * @private\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array}\n   */\n  prepareColumnsToMoving(start, end) {\n    const selectedColumns = [];\n    rangeEach(start, end, i => {\n      selectedColumns.push(i);\n    });\n    return selectedColumns;\n  }\n\n  /**\n   * Update the UI visual position.\n   *\n   * @private\n   */\n  refreshPositions() {\n    const firstVisible = this.hot.view.getFirstFullyVisibleColumn();\n    if (this.isFixedColumnsStart(_classPrivateFieldGet(_hoveredColumn, this)) && firstVisible > 0) {\n      this.hot.scrollViewportTo({\n        col: this.hot.columnIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1)\n      });\n    }\n    const wtTable = this.hot.view._wt.wtTable;\n    const scrollableElement = this.hot.view._wt.wtOverlays.scrollableElement;\n    const scrollStart = typeof scrollableElement.scrollX === 'number' ? scrollableElement.scrollX : scrollableElement.scrollLeft;\n    let tdOffsetStart = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, _classPrivateFieldGet(_hoveredColumn, this) - 1);\n    const hiderWidth = wtTable.hider.offsetWidth;\n    const tbodyOffsetLeft = wtTable.TBODY.offsetLeft;\n    const backlightElemMarginStart = _classPrivateFieldGet(_backlight, this).getOffset().start;\n    const backlightElemWidth = _classPrivateFieldGet(_backlight, this).getSize().width;\n    let rowHeaderWidth = 0;\n    let mouseOffsetStart = 0;\n    if (this.hot.isRtl()) {\n      const rootWindow = this.hot.rootWindow;\n      const containerWidth = outerWidth(this.hot.rootElement);\n      const gridMostRightPos = rootWindow.innerWidth - _classPrivateFieldGet(_rootElementOffset, this) - containerWidth;\n      mouseOffsetStart = rootWindow.innerWidth - _classPrivateFieldGet(_target, this).eventPageX - gridMostRightPos - (scrollableElement.scrollX === undefined ? scrollStart : 0);\n    } else {\n      mouseOffsetStart = _classPrivateFieldGet(_target, this).eventPageX - (_classPrivateFieldGet(_rootElementOffset, this) - (scrollableElement.scrollX === undefined ? scrollStart : 0));\n    }\n    if (_classPrivateFieldGet(_hasRowHeaders, this)) {\n      rowHeaderWidth = this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;\n    }\n    if (this.isFixedColumnsStart(_classPrivateFieldGet(_hoveredColumn, this))) {\n      tdOffsetStart += scrollStart;\n    }\n    tdOffsetStart += rowHeaderWidth;\n    if (_classPrivateFieldGet(_hoveredColumn, this) < 0) {\n      // if hover on rowHeader\n      if (_classPrivateFieldGet(_fixedColumnsStart, this) > 0) {\n        _classPrivateFieldGet(_target, this).col = 0;\n      } else {\n        _classPrivateFieldGet(_target, this).col = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n      }\n    } else if (_classPrivateFieldGet(_target, this).TD.offsetWidth / 2 + tdOffsetStart <= mouseOffsetStart) {\n      const newCoordsCol = _classPrivateFieldGet(_hoveredColumn, this) >= _classPrivateFieldGet(_countCols, this) ? _classPrivateFieldGet(_countCols, this) - 1 : _classPrivateFieldGet(_hoveredColumn, this);\n\n      // if hover on right part of TD\n      _classPrivateFieldGet(_target, this).col = newCoordsCol + 1;\n      // unfortunately first column is bigger than rest\n      tdOffsetStart += _classPrivateFieldGet(_target, this).TD.offsetWidth;\n    } else {\n      // elsewhere on table\n      _classPrivateFieldGet(_target, this).col = _classPrivateFieldGet(_hoveredColumn, this);\n    }\n    let backlightStart = mouseOffsetStart;\n    let guidelineStart = tdOffsetStart;\n    if (mouseOffsetStart + backlightElemWidth + backlightElemMarginStart >= hiderWidth) {\n      // prevent display backlight on the right side of the table\n      backlightStart = hiderWidth - backlightElemWidth - backlightElemMarginStart;\n    } else if (mouseOffsetStart + backlightElemMarginStart < tbodyOffsetLeft + rowHeaderWidth) {\n      // prevent display backlight on the left side of the table\n      backlightStart = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginStart);\n    }\n    if (tdOffsetStart >= hiderWidth - 1) {\n      // prevent display guideline outside the table\n      guidelineStart = hiderWidth - 1;\n    } else if (guidelineStart === 0) {\n      // guideline has got `margin-left: -1px` as default\n      guidelineStart = 1;\n    } else if (scrollableElement.scrollX !== undefined && _classPrivateFieldGet(_hoveredColumn, this) < _classPrivateFieldGet(_fixedColumnsStart, this)) {\n      guidelineStart -= _classPrivateFieldGet(_rootElementOffset, this) <= scrollableElement.scrollX ? _classPrivateFieldGet(_rootElementOffset, this) : 0;\n    }\n    _classPrivateFieldGet(_backlight, this).setPosition(null, backlightStart);\n    _classPrivateFieldGet(_guideline, this).setPosition(null, guidelineStart);\n  }\n\n  /**\n   * Binds the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _assertClassBrand(_ManualColumnMove_brand, this, _onMouseMove).call(this, event));\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _assertClassBrand(_ManualColumnMove_brand, this, _onMouseUp).call(this));\n  }\n\n  /**\n   * Unbinds the events used by the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    this.eventManager.clear();\n  }\n  /**\n   * Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    _classPrivateFieldGet(_backlight, this).build();\n    _classPrivateFieldGet(_guideline, this).build();\n  }\n\n  /**\n   * Callback for the `afterLoadData` hook.\n   *\n   * @private\n   */\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(_backlight, this).destroy();\n    _classPrivateFieldGet(_guideline, this).destroy();\n    super.destroy();\n  }\n}\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const wtTable = this.hot.view._wt.wtTable;\n  const isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();\n  const selection = this.hot.getSelectedRangeLast();\n  // This block action shouldn't be handled below.\n  const isSortingElement = hasClass(event.target, 'sortAction');\n  if (!selection || !isHeaderSelection || _classPrivateFieldGet(_pressed, this) || event.button !== 0 || isSortingElement) {\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_columnsToMove, this).length = 0;\n    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);\n    return;\n  }\n  const guidelineIsNotReady = _classPrivateFieldGet(_guideline, this).isBuilt() && !_classPrivateFieldGet(_guideline, this).isAppended();\n  const backlightIsNotReady = _classPrivateFieldGet(_backlight, this).isBuilt() && !_classPrivateFieldGet(_backlight, this).isAppended();\n  if (guidelineIsNotReady && backlightIsNotReady) {\n    _classPrivateFieldGet(_guideline, this).appendTo(wtTable.hider);\n    _classPrivateFieldGet(_backlight, this).appendTo(wtTable.hider);\n  }\n  const {\n    from,\n    to\n  } = selection;\n  const start = Math.min(from.col, to.col);\n  const end = Math.max(from.col, to.col);\n  if (coords.row < 0 && coords.col >= start && coords.col <= end) {\n    controller.column = true;\n    _classPrivateFieldSet(_pressed, this, true);\n    const eventOffsetX = TD.firstChild ? offsetRelativeTo(event, TD.firstChild).x : event.offsetX;\n    _classPrivateFieldGet(_target, this).eventPageX = event.pageX;\n    _classPrivateFieldSet(_hoveredColumn, this, coords.col);\n    _classPrivateFieldGet(_target, this).TD = TD;\n    _classPrivateFieldGet(_target, this).col = coords.col;\n    _classPrivateFieldSet(_columnsToMove, this, this.prepareColumnsToMoving(start, end));\n    _classPrivateFieldSet(_hasRowHeaders, this, !!this.hot.getSettings().rowHeaders);\n    _classPrivateFieldSet(_countCols, this, this.hot.countCols());\n    _classPrivateFieldSet(_fixedColumnsStart, this, this.hot.getSettings().fixedColumnsStart);\n    _classPrivateFieldSet(_rootElementOffset, this, offset(this.hot.rootElement).left);\n    const countColumnsFrom = _classPrivateFieldGet(_hasRowHeaders, this) ? -1 : 0;\n    const topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;\n    const fixedColumnsStart = coords.col < _classPrivateFieldGet(_fixedColumnsStart, this);\n    const horizontalScrollPosition = this.hot.view._wt.wtOverlays.inlineStartOverlay.getOverlayOffset();\n    const offsetX = Math.abs(eventOffsetX - (this.hot.isRtl() ? TD.offsetWidth : 0));\n    const inlineOffset = this.getColumnsWidth(start, coords.col - 1) + offsetX;\n    const inlinePos = this.getColumnsWidth(countColumnsFrom, start - 1) + (fixedColumnsStart ? horizontalScrollPosition : 0) + inlineOffset;\n    _classPrivateFieldGet(_backlight, this).setPosition(topPos, inlinePos);\n    _classPrivateFieldGet(_backlight, this).setSize(this.getColumnsWidth(start, end), wtTable.hider.offsetHeight - topPos);\n    _classPrivateFieldGet(_backlight, this).setOffset(null, -inlineOffset);\n    addClass(this.hot.rootElement, CSS_ON_MOVING);\n  } else {\n    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    _classPrivateFieldSet(_pressed, this, false);\n    _classPrivateFieldGet(_columnsToMove, this).length = 0;\n  }\n}\n/**\n * 'mouseMove' event callback. Fired when pointer move on document.documentElement.\n *\n * @param {MouseEvent} event `mousemove` event properties.\n */\nfunction _onMouseMove(event) {\n  if (!_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  _classPrivateFieldGet(_target, this).eventPageX = event.pageX;\n  this.refreshPositions();\n}\n/**\n * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.\n *\n * @param {MouseEvent} event `mouseover` event properties.\n * @param {CellCoords} coords Visual cell coordinates where was fired event.\n * @param {HTMLElement} TD Cell represented as HTMLElement.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  if (!selectedRange || !_classPrivateFieldGet(_pressed, this)) {\n    return;\n  }\n  if (_classPrivateFieldGet(_columnsToMove, this).indexOf(coords.col) > -1) {\n    removeClass(this.hot.rootElement, CSS_SHOW_UI);\n  } else {\n    addClass(this.hot.rootElement, CSS_SHOW_UI);\n  }\n  controller.row = true;\n  controller.column = true;\n  controller.cell = true;\n  _classPrivateFieldSet(_hoveredColumn, this, coords.col);\n  _classPrivateFieldGet(_target, this).TD = TD;\n}\n/**\n * `onMouseUp` hook callback.\n */\nfunction _onMouseUp() {\n  const target = _classPrivateFieldGet(_target, this).col;\n  const columnsLen = _classPrivateFieldGet(_columnsToMove, this).length;\n  _classPrivateFieldSet(_hoveredColumn, this, undefined);\n  _classPrivateFieldSet(_pressed, this, false);\n  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);\n  if (this.hot.selection.isSelectedByColumnHeader()) {\n    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n  }\n  if (columnsLen < 1 || target === undefined) {\n    return;\n  }\n  const firstMovedVisualColumn = _classPrivateFieldGet(_columnsToMove, this)[0];\n  const firstMovedPhysicalColumn = this.hot.toPhysicalColumn(firstMovedVisualColumn);\n  const movePerformed = this.dragColumns(_classPrivateFieldGet(_columnsToMove, this), target);\n  _classPrivateFieldGet(_columnsToMove, this).length = 0;\n  if (movePerformed === true) {\n    this.persistentStateSave();\n    this.hot.render();\n    this.hot.view.adjustElementsSize();\n    const selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);\n    const selectionEnd = selectionStart + columnsLen - 1;\n    this.hot.selectColumns(selectionStart, selectionEnd);\n  }\n}\n/**\n * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.\n */\nfunction _onAfterScrollVertically() {\n  const wtTable = this.hot.view._wt.wtTable;\n  const headerHeight = wtTable.getColumnHeaderHeight(0) + 1;\n  const scrollTop = wtTable.holder.scrollTop;\n  const posTop = headerHeight + scrollTop;\n  _classPrivateFieldGet(_backlight, this).setPosition(posTop);\n  _classPrivateFieldGet(_backlight, this).setSize(null, wtTable.hider.offsetHeight - posTop);\n}\nfunction _onAfterLoadData() {\n  this.moveBySettingsOrLoad();\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}