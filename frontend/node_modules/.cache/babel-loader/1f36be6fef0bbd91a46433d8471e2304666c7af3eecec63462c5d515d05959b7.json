{"ast":null,"code":"import { hasOwnProperty, isObject } from \"../../helpers/object.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\n/**\n * Create separated id for borders for each cell.\n *\n * @param {number} row Visual row index.\n * @param {number} col Visual column index.\n * @returns {string}\n */\nexport function createId(row, col) {\n  return `border_row${row}col${col}`;\n}\n\n/**\n * Create default single border for each position (top/right/bottom/left).\n *\n * @returns {object} `{{width: number, color: string}}`.\n */\nexport function createDefaultCustomBorder() {\n  return {\n    width: 1,\n    color: '#000'\n  };\n}\n\n/**\n * Create default object for empty border.\n *\n * @returns {object} `{{hide: boolean}}`.\n */\nexport function createSingleEmptyBorder() {\n  return {\n    hide: true\n  };\n}\n\n/**\n * Create default Handsontable border object.\n *\n * @returns {object} `{{width: number, color: string, cornerVisible: boolean}}`.\n */\nexport function createDefaultHtBorder() {\n  return {\n    width: 1,\n    color: '#000',\n    cornerVisible: false\n  };\n}\n\n/**\n * Normalizes the border object to be compatible with the Border API from the Walkontable.\n * The function translates the \"left\"/\"right\" properties to \"start\"/\"end\" prop names.\n *\n * @param {object} border The configuration object of the border.\n * @returns {object}\n */\nexport function normalizeBorder(border) {\n  if (isDefined(border.start) || isDefined(border.left)) {\n    var _border$start;\n    border.start = (_border$start = border.start) !== null && _border$start !== void 0 ? _border$start : border.left;\n  }\n  if (isDefined(border.end) || isDefined(border.right)) {\n    var _border$end;\n    border.end = (_border$end = border.end) !== null && _border$end !== void 0 ? _border$end : border.right;\n  }\n  delete border.left;\n  delete border.right;\n  return border;\n}\n\n/**\n * Denormalizes the border object to be backward compatible with the previous version of the CustomBorders\n * plugin API. The function extends the border configuration object for the backward compatible \"left\"/\"right\"\n * properties.\n *\n * @param {object} border The configuration object of the border.\n * @returns {object}\n */\nexport function denormalizeBorder(border) {\n  if (isDefined(border.start)) {\n    border.left = border.start;\n  }\n  if (isDefined(border.end)) {\n    border.right = border.end;\n  }\n  return border;\n}\n\n/**\n * Prepare empty border for each cell with all custom borders hidden.\n *\n * @param {number} row Visual row index.\n * @param {number} col Visual column index.\n * @returns {{id: string, border: any, row: number, col: number, top: {hide: boolean}, bottom: {hide: boolean}, start: {hide: boolean}, end: {hide: boolean}}} Returns border configuration containing visual indexes.\n */\nexport function createEmptyBorders(row, col) {\n  return {\n    id: createId(row, col),\n    border: createDefaultHtBorder(),\n    row,\n    col,\n    top: createSingleEmptyBorder(),\n    bottom: createSingleEmptyBorder(),\n    start: createSingleEmptyBorder(),\n    end: createSingleEmptyBorder()\n  };\n}\n\n/**\n * @param {object} defaultBorder The default border object.\n * @param {object} customBorder The border object with custom settings.\n * @returns {object}\n */\nexport function extendDefaultBorder(defaultBorder, customBorder) {\n  if (hasOwnProperty(customBorder, 'border') && customBorder.border) {\n    defaultBorder.border = customBorder.border;\n  }\n  if (hasOwnProperty(customBorder, 'top') && isDefined(customBorder.top)) {\n    if (customBorder.top) {\n      if (!isObject(customBorder.top)) {\n        customBorder.top = createDefaultCustomBorder();\n      }\n      defaultBorder.top = customBorder.top;\n    } else {\n      customBorder.top = createSingleEmptyBorder();\n      defaultBorder.top = customBorder.top;\n    }\n  }\n  if (hasOwnProperty(customBorder, 'bottom') && isDefined(customBorder.bottom)) {\n    if (customBorder.bottom) {\n      if (!isObject(customBorder.bottom)) {\n        customBorder.bottom = createDefaultCustomBorder();\n      }\n      defaultBorder.bottom = customBorder.bottom;\n    } else {\n      customBorder.bottom = createSingleEmptyBorder();\n      defaultBorder.bottom = customBorder.bottom;\n    }\n  }\n  if (hasOwnProperty(customBorder, 'start') && isDefined(customBorder.start)) {\n    if (customBorder.start) {\n      if (!isObject(customBorder.start)) {\n        customBorder.start = createDefaultCustomBorder();\n      }\n      defaultBorder.start = customBorder.start;\n    } else {\n      customBorder.start = createSingleEmptyBorder();\n      defaultBorder.start = customBorder.start;\n    }\n  }\n  if (hasOwnProperty(customBorder, 'end') && isDefined(customBorder.end)) {\n    if (customBorder.end) {\n      if (!isObject(customBorder.end)) {\n        customBorder.end = createDefaultCustomBorder();\n      }\n      defaultBorder.end = customBorder.end;\n    } else {\n      customBorder.end = createSingleEmptyBorder();\n      defaultBorder.end = customBorder.end;\n    }\n  }\n  return defaultBorder;\n}\n\n/**\n * Check if selection has border.\n *\n * @param {Core} hot The Handsontable instance.\n * @param {string} [direction] If set ('left' or 'top') then only the specified border side will be checked.\n * @returns {boolean}\n */\nexport function checkSelectionBorders(hot, direction) {\n  let atLeastOneHasBorder = false;\n  arrayEach(hot.getSelectedRange(), range => {\n    range.forAll((r, c) => {\n      if (r < 0 || c < 0) {\n        return;\n      }\n      const metaBorders = hot.getCellMeta(r, c).borders;\n      if (metaBorders) {\n        if (direction) {\n          if (!hasOwnProperty(metaBorders[direction], 'hide') || metaBorders[direction].hide === false) {\n            atLeastOneHasBorder = true;\n            return false; // breaks forAll\n          }\n        } else {\n          atLeastOneHasBorder = true;\n          return false; // breaks forAll\n        }\n      }\n    });\n  });\n  return atLeastOneHasBorder;\n}\n\n/**\n * Mark label in contextMenu as selected.\n *\n * @param {string} label The label text.\n * @returns {string}\n */\nexport function markSelected(label) {\n  return `<span class=\"selected\">${String.fromCharCode(10003)}</span>${label}`; // workaround for https://github.com/handsontable/handsontable/issues/1946\n}\n\n/**\n * Checks if in the borders config there are defined \"left\" or \"right\" border properties.\n *\n * @param {object[]} borders The custom border plugin's options.\n * @returns {boolean}\n */\nexport function hasLeftRightTypeOptions(borders) {\n  return borders.some(border => isDefined(border.left) || isDefined(border.right));\n}\n\n/**\n * Checks if in the borders config there are defined \"start\" or \"end\" border properties.\n *\n * @param {object[]} borders The custom border plugin's options.\n * @returns {boolean}\n */\nexport function hasStartEndTypeOptions(borders) {\n  return borders.some(border => isDefined(border.start) || isDefined(border.end));\n}\nconst physicalToInlinePropNames = new Map([['left', 'start'], ['right', 'end']]);\n\n/**\n * Translates the physical horizontal direction to logical ones. If not known property name is\n * passed it will be returned without modification.\n *\n * @param {string} propName The physical direction property name (\"left\" or \"right\").\n * @returns {string}\n */\nexport function toInlinePropName(propName) {\n  var _physicalToInlineProp;\n  return (_physicalToInlineProp = physicalToInlinePropNames.get(propName)) !== null && _physicalToInlineProp !== void 0 ? _physicalToInlineProp : propName;\n}","map":{"version":3,"names":["hasOwnProperty","isObject","isDefined","arrayEach","createId","row","col","createDefaultCustomBorder","width","color","createSingleEmptyBorder","hide","createDefaultHtBorder","cornerVisible","normalizeBorder","border","start","left","_border$start","end","right","_border$end","denormalizeBorder","createEmptyBorders","id","top","bottom","extendDefaultBorder","defaultBorder","customBorder","checkSelectionBorders","hot","direction","atLeastOneHasBorder","getSelectedRange","range","forAll","r","c","metaBorders","getCellMeta","borders","markSelected","label","String","fromCharCode","hasLeftRightTypeOptions","some","hasStartEndTypeOptions","physicalToInlinePropNames","Map","toInlinePropName","propName","_physicalToInlineProp","get"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/customBorders/utils.mjs"],"sourcesContent":["import { hasOwnProperty, isObject } from \"../../helpers/object.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\n/**\n * Create separated id for borders for each cell.\n *\n * @param {number} row Visual row index.\n * @param {number} col Visual column index.\n * @returns {string}\n */\nexport function createId(row, col) {\n  return `border_row${row}col${col}`;\n}\n\n/**\n * Create default single border for each position (top/right/bottom/left).\n *\n * @returns {object} `{{width: number, color: string}}`.\n */\nexport function createDefaultCustomBorder() {\n  return {\n    width: 1,\n    color: '#000'\n  };\n}\n\n/**\n * Create default object for empty border.\n *\n * @returns {object} `{{hide: boolean}}`.\n */\nexport function createSingleEmptyBorder() {\n  return {\n    hide: true\n  };\n}\n\n/**\n * Create default Handsontable border object.\n *\n * @returns {object} `{{width: number, color: string, cornerVisible: boolean}}`.\n */\nexport function createDefaultHtBorder() {\n  return {\n    width: 1,\n    color: '#000',\n    cornerVisible: false\n  };\n}\n\n/**\n * Normalizes the border object to be compatible with the Border API from the Walkontable.\n * The function translates the \"left\"/\"right\" properties to \"start\"/\"end\" prop names.\n *\n * @param {object} border The configuration object of the border.\n * @returns {object}\n */\nexport function normalizeBorder(border) {\n  if (isDefined(border.start) || isDefined(border.left)) {\n    var _border$start;\n    border.start = (_border$start = border.start) !== null && _border$start !== void 0 ? _border$start : border.left;\n  }\n  if (isDefined(border.end) || isDefined(border.right)) {\n    var _border$end;\n    border.end = (_border$end = border.end) !== null && _border$end !== void 0 ? _border$end : border.right;\n  }\n  delete border.left;\n  delete border.right;\n  return border;\n}\n\n/**\n * Denormalizes the border object to be backward compatible with the previous version of the CustomBorders\n * plugin API. The function extends the border configuration object for the backward compatible \"left\"/\"right\"\n * properties.\n *\n * @param {object} border The configuration object of the border.\n * @returns {object}\n */\nexport function denormalizeBorder(border) {\n  if (isDefined(border.start)) {\n    border.left = border.start;\n  }\n  if (isDefined(border.end)) {\n    border.right = border.end;\n  }\n  return border;\n}\n\n/**\n * Prepare empty border for each cell with all custom borders hidden.\n *\n * @param {number} row Visual row index.\n * @param {number} col Visual column index.\n * @returns {{id: string, border: any, row: number, col: number, top: {hide: boolean}, bottom: {hide: boolean}, start: {hide: boolean}, end: {hide: boolean}}} Returns border configuration containing visual indexes.\n */\nexport function createEmptyBorders(row, col) {\n  return {\n    id: createId(row, col),\n    border: createDefaultHtBorder(),\n    row,\n    col,\n    top: createSingleEmptyBorder(),\n    bottom: createSingleEmptyBorder(),\n    start: createSingleEmptyBorder(),\n    end: createSingleEmptyBorder()\n  };\n}\n\n/**\n * @param {object} defaultBorder The default border object.\n * @param {object} customBorder The border object with custom settings.\n * @returns {object}\n */\nexport function extendDefaultBorder(defaultBorder, customBorder) {\n  if (hasOwnProperty(customBorder, 'border') && customBorder.border) {\n    defaultBorder.border = customBorder.border;\n  }\n  if (hasOwnProperty(customBorder, 'top') && isDefined(customBorder.top)) {\n    if (customBorder.top) {\n      if (!isObject(customBorder.top)) {\n        customBorder.top = createDefaultCustomBorder();\n      }\n      defaultBorder.top = customBorder.top;\n    } else {\n      customBorder.top = createSingleEmptyBorder();\n      defaultBorder.top = customBorder.top;\n    }\n  }\n  if (hasOwnProperty(customBorder, 'bottom') && isDefined(customBorder.bottom)) {\n    if (customBorder.bottom) {\n      if (!isObject(customBorder.bottom)) {\n        customBorder.bottom = createDefaultCustomBorder();\n      }\n      defaultBorder.bottom = customBorder.bottom;\n    } else {\n      customBorder.bottom = createSingleEmptyBorder();\n      defaultBorder.bottom = customBorder.bottom;\n    }\n  }\n  if (hasOwnProperty(customBorder, 'start') && isDefined(customBorder.start)) {\n    if (customBorder.start) {\n      if (!isObject(customBorder.start)) {\n        customBorder.start = createDefaultCustomBorder();\n      }\n      defaultBorder.start = customBorder.start;\n    } else {\n      customBorder.start = createSingleEmptyBorder();\n      defaultBorder.start = customBorder.start;\n    }\n  }\n  if (hasOwnProperty(customBorder, 'end') && isDefined(customBorder.end)) {\n    if (customBorder.end) {\n      if (!isObject(customBorder.end)) {\n        customBorder.end = createDefaultCustomBorder();\n      }\n      defaultBorder.end = customBorder.end;\n    } else {\n      customBorder.end = createSingleEmptyBorder();\n      defaultBorder.end = customBorder.end;\n    }\n  }\n  return defaultBorder;\n}\n\n/**\n * Check if selection has border.\n *\n * @param {Core} hot The Handsontable instance.\n * @param {string} [direction] If set ('left' or 'top') then only the specified border side will be checked.\n * @returns {boolean}\n */\nexport function checkSelectionBorders(hot, direction) {\n  let atLeastOneHasBorder = false;\n  arrayEach(hot.getSelectedRange(), range => {\n    range.forAll((r, c) => {\n      if (r < 0 || c < 0) {\n        return;\n      }\n      const metaBorders = hot.getCellMeta(r, c).borders;\n      if (metaBorders) {\n        if (direction) {\n          if (!hasOwnProperty(metaBorders[direction], 'hide') || metaBorders[direction].hide === false) {\n            atLeastOneHasBorder = true;\n            return false; // breaks forAll\n          }\n        } else {\n          atLeastOneHasBorder = true;\n          return false; // breaks forAll\n        }\n      }\n    });\n  });\n  return atLeastOneHasBorder;\n}\n\n/**\n * Mark label in contextMenu as selected.\n *\n * @param {string} label The label text.\n * @returns {string}\n */\nexport function markSelected(label) {\n  return `<span class=\"selected\">${String.fromCharCode(10003)}</span>${label}`; // workaround for https://github.com/handsontable/handsontable/issues/1946\n}\n\n/**\n * Checks if in the borders config there are defined \"left\" or \"right\" border properties.\n *\n * @param {object[]} borders The custom border plugin's options.\n * @returns {boolean}\n */\nexport function hasLeftRightTypeOptions(borders) {\n  return borders.some(border => isDefined(border.left) || isDefined(border.right));\n}\n\n/**\n * Checks if in the borders config there are defined \"start\" or \"end\" border properties.\n *\n * @param {object[]} borders The custom border plugin's options.\n * @returns {boolean}\n */\nexport function hasStartEndTypeOptions(borders) {\n  return borders.some(border => isDefined(border.start) || isDefined(border.end));\n}\nconst physicalToInlinePropNames = new Map([['left', 'start'], ['right', 'end']]);\n\n/**\n * Translates the physical horizontal direction to logical ones. If not known property name is\n * passed it will be returned without modification.\n *\n * @param {string} propName The physical direction property name (\"left\" or \"right\").\n * @returns {string}\n */\nexport function toInlinePropName(propName) {\n  var _physicalToInlineProp;\n  return (_physicalToInlineProp = physicalToInlinePropNames.get(propName)) !== null && _physicalToInlineProp !== void 0 ? _physicalToInlineProp : propName;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}