{"ast":null,"code":"function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\nexport default class RowMoveController {\n  constructor(plugin) {\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n    _defineProperty(this, \"dataManager\", void 0);\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n    _defineProperty(this, \"collapsingUI\", void 0);\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n    this.dataManager = plugin.dataManager;\n    this.collapsingUI = plugin.collapsingUI;\n  }\n\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n    const improperUsage = this.displayAPICompatibilityWarning({\n      rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    });\n    if (improperUsage) {\n      return false;\n    }\n    this.movedToCollapsed = false;\n    const dropToLastRow = dropIndex === this.hot.countRows();\n    const physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n    let allowMove = true;\n    const physicalStartIndexes = rows.map(rowIndex => {\n      // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n      if (!allowMove) {\n        return false;\n      }\n      const physicalRowIndex = this.dataManager.translateTrimmedRow(rowIndex);\n      allowMove = this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n      return physicalRowIndex;\n    });\n    const willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n    if (!allowMove || !willDataChange) {\n      return false;\n    }\n    const baseParent = this.getBaseParent(physicalStartIndexes);\n    const targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n    const sameParent = baseParent === targetParent;\n    this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);\n\n    // Stash the current state of collapsed rows\n    this.collapsingUI.collapsedRowsStash.stash();\n    this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n    this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n    this.dataManager.rewriteCache();\n    this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n    this.collapsingUI.collapsedRowsStash.applyStash(false);\n\n    // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));\n\n    // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n    this.hot.render();\n    this.selectCells(rows, dropIndex);\n    return false;\n  }\n\n  /**\n   * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n   *\n   * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n   * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n   */\n  displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n    const {\n      rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    } = beforeMoveRowHookArgs;\n    let shouldTerminate = false;\n    if (isUndefined(dropIndex)) {\n      warn(toSingleLine`Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\x20\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.`);\n\n      // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n      shouldTerminate = true;\n    }\n    return shouldTerminate;\n  }\n\n  /**\n   * Check if the moving action should be allowed.\n   *\n   * @param {number} physicalRowIndex Physical start row index.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @returns {boolean} `true` if it should continue with the moving action.\n   */\n  shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n    /*\n       We can't move rows when any of them is:\n       - a parent\n       - a top-level element\n       - is being moved to the top level\n       - is being moved to the position of any of the moved rows (not changing position)\n    */\n\n    return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n  }\n\n  /**\n   * Get the base row parent.\n   *\n   * @param {number} physicalStartIndexes Physical start row index.\n   * @returns {object|null} The base row parent.\n   */\n  getBaseParent(physicalStartIndexes) {\n    return this.dataManager.getRowParent(physicalStartIndexes[0]);\n  }\n\n  /**\n   * Get the target row parent.\n   *\n   * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n   * @param {number} physicalDropIndex Physical drop row index.\n   * @returns {object|null} The target row parent.\n   */\n  getTargetParent(dropToLastRow, physicalDropIndex) {\n    let targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);\n\n    // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n    // parent's children instead\n    if (targetParent === null || targetParent === undefined) {\n      targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n    }\n    return targetParent;\n  }\n\n  /**\n   * Shift the cached collapsible rows position according to the move action.\n   *\n   * @param {number[]} physicalStartIndexes Physical start row indexes.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n   */\n  shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n    if (!sameParent) {\n      if (Math.max(...physicalStartIndexes) <= physicalDropIndex) {\n        this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n      } else {\n        this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n      }\n    }\n  }\n\n  /**\n   * Move the rows at the provided coordinates.\n   *\n   * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @param {object} targetParent Parent of the destination row.\n   */\n  moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n    const moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n    this.hot.batchRender(() => {\n      physicalStartIndexes.forEach(physicalStartIndex => {\n        this.dataManager.moveRow(physicalStartIndex, physicalDropIndex, this.movedToCollapsed, moveToLastChild);\n      });\n    });\n  }\n\n  /**\n   * Move the cell meta for multiple rows.\n   *\n   * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n   * @param {number} targetIndex Index of the destination of the move.\n   */\n  moveCellsMeta(baseIndexes, targetIndex) {\n    const rowsOfMeta = [];\n    const movingDown = Math.max(...baseIndexes) < targetIndex;\n    baseIndexes.forEach(baseIndex => {\n      rowsOfMeta.push(this.hot.getCellMetaAtRow(baseIndex));\n    });\n    this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n    this.hot.spliceCellsMeta(targetIndex - (movingDown ? rowsOfMeta.length : 0), 0, ...rowsOfMeta);\n  }\n\n  /**\n   * Select cells after the move.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   */\n  selectCells(rows, dropIndex) {\n    const rowsLen = rows.length;\n    let startRow = 0;\n    let endRow = 0;\n    let selection = null;\n    let lastColIndex = null;\n    if (this.movedToCollapsed) {\n      let physicalDropIndex = null;\n      if (rows[rowsLen - 1] < dropIndex) {\n        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n      } else {\n        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n      }\n      const parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n      const parentIndex = this.dataManager.getRowIndex(parentObject);\n      startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n      endRow = startRow;\n    } else if (rows[rowsLen - 1] < dropIndex) {\n      endRow = dropIndex - 1;\n      startRow = endRow - rowsLen + 1;\n    } else {\n      startRow = dropIndex;\n      endRow = startRow + rowsLen - 1;\n    }\n    selection = this.hot.selection;\n    lastColIndex = this.hot.countCols() - 1;\n    selection.setRangeStart(this.hot._createCellCoords(startRow, 0));\n    selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);\n  }\n\n  // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n}","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","isUndefined","warn","toSingleLine","RowMoveController","constructor","plugin","hot","dataManager","collapsingUI","onBeforeRowMove","rows","finalIndex","dropIndex","movePossible","improperUsage","displayAPICompatibilityWarning","movedToCollapsed","dropToLastRow","countRows","physicalDropIndex","countSourceRows","translateTrimmedRow","allowMove","physicalStartIndexes","map","rowIndex","physicalRowIndex","shouldAllowMoving","willDataChange","indexOf","baseParent","getBaseParent","targetParent","getTargetParent","sameParent","areChildrenCollapsed","collapsedRowsStash","stash","shiftCollapsibleParentsLocations","moveRows","rewriteCache","moveCellsMeta","applyStash","runHooks","isRowOrderChanged","render","selectCells","beforeMoveRowHookArgs","shouldTerminate","isParent","isRowHighestLevel","getRowParent","undefined","Math","max","shiftStash","length","moveToLastChild","getRowIndex","countChildren","batchRender","forEach","physicalStartIndex","moveRow","baseIndexes","targetIndex","rowsOfMeta","movingDown","baseIndex","push","getCellMetaAtRow","spliceCellsMeta","rowsLen","startRow","endRow","selection","lastColIndex","parentObject","parentIndex","untranslateTrimmedRow","countCols","setRangeStart","_createCellCoords","setRangeEnd","movedRows","some","row","nrOfMovedElement"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\nexport default class RowMoveController {\n  constructor(plugin) {\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n    _defineProperty(this, \"dataManager\", void 0);\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n    _defineProperty(this, \"collapsingUI\", void 0);\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n    this.dataManager = plugin.dataManager;\n    this.collapsingUI = plugin.collapsingUI;\n  }\n\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n    const improperUsage = this.displayAPICompatibilityWarning({\n      rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    });\n    if (improperUsage) {\n      return false;\n    }\n    this.movedToCollapsed = false;\n    const dropToLastRow = dropIndex === this.hot.countRows();\n    const physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n    let allowMove = true;\n    const physicalStartIndexes = rows.map(rowIndex => {\n      // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n      if (!allowMove) {\n        return false;\n      }\n      const physicalRowIndex = this.dataManager.translateTrimmedRow(rowIndex);\n      allowMove = this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n      return physicalRowIndex;\n    });\n    const willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n    if (!allowMove || !willDataChange) {\n      return false;\n    }\n    const baseParent = this.getBaseParent(physicalStartIndexes);\n    const targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n    const sameParent = baseParent === targetParent;\n    this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);\n\n    // Stash the current state of collapsed rows\n    this.collapsingUI.collapsedRowsStash.stash();\n    this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n    this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n    this.dataManager.rewriteCache();\n    this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n    this.collapsingUI.collapsedRowsStash.applyStash(false);\n\n    // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));\n\n    // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n    this.hot.render();\n    this.selectCells(rows, dropIndex);\n    return false;\n  }\n\n  /**\n   * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n   *\n   * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n   * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n   */\n  displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n    const {\n      rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    } = beforeMoveRowHookArgs;\n    let shouldTerminate = false;\n    if (isUndefined(dropIndex)) {\n      warn(toSingleLine`Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\x20\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.`);\n\n      // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n      shouldTerminate = true;\n    }\n    return shouldTerminate;\n  }\n\n  /**\n   * Check if the moving action should be allowed.\n   *\n   * @param {number} physicalRowIndex Physical start row index.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @returns {boolean} `true` if it should continue with the moving action.\n   */\n  shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n    /*\n       We can't move rows when any of them is:\n       - a parent\n       - a top-level element\n       - is being moved to the top level\n       - is being moved to the position of any of the moved rows (not changing position)\n    */\n\n    return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n  }\n\n  /**\n   * Get the base row parent.\n   *\n   * @param {number} physicalStartIndexes Physical start row index.\n   * @returns {object|null} The base row parent.\n   */\n  getBaseParent(physicalStartIndexes) {\n    return this.dataManager.getRowParent(physicalStartIndexes[0]);\n  }\n\n  /**\n   * Get the target row parent.\n   *\n   * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n   * @param {number} physicalDropIndex Physical drop row index.\n   * @returns {object|null} The target row parent.\n   */\n  getTargetParent(dropToLastRow, physicalDropIndex) {\n    let targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);\n\n    // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n    // parent's children instead\n    if (targetParent === null || targetParent === undefined) {\n      targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n    }\n    return targetParent;\n  }\n\n  /**\n   * Shift the cached collapsible rows position according to the move action.\n   *\n   * @param {number[]} physicalStartIndexes Physical start row indexes.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n   */\n  shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n    if (!sameParent) {\n      if (Math.max(...physicalStartIndexes) <= physicalDropIndex) {\n        this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n      } else {\n        this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n      }\n    }\n  }\n\n  /**\n   * Move the rows at the provided coordinates.\n   *\n   * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @param {object} targetParent Parent of the destination row.\n   */\n  moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n    const moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n    this.hot.batchRender(() => {\n      physicalStartIndexes.forEach(physicalStartIndex => {\n        this.dataManager.moveRow(physicalStartIndex, physicalDropIndex, this.movedToCollapsed, moveToLastChild);\n      });\n    });\n  }\n\n  /**\n   * Move the cell meta for multiple rows.\n   *\n   * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n   * @param {number} targetIndex Index of the destination of the move.\n   */\n  moveCellsMeta(baseIndexes, targetIndex) {\n    const rowsOfMeta = [];\n    const movingDown = Math.max(...baseIndexes) < targetIndex;\n    baseIndexes.forEach(baseIndex => {\n      rowsOfMeta.push(this.hot.getCellMetaAtRow(baseIndex));\n    });\n    this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n    this.hot.spliceCellsMeta(targetIndex - (movingDown ? rowsOfMeta.length : 0), 0, ...rowsOfMeta);\n  }\n\n  /**\n   * Select cells after the move.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   */\n  selectCells(rows, dropIndex) {\n    const rowsLen = rows.length;\n    let startRow = 0;\n    let endRow = 0;\n    let selection = null;\n    let lastColIndex = null;\n    if (this.movedToCollapsed) {\n      let physicalDropIndex = null;\n      if (rows[rowsLen - 1] < dropIndex) {\n        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n      } else {\n        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n      }\n      const parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n      const parentIndex = this.dataManager.getRowIndex(parentObject);\n      startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n      endRow = startRow;\n    } else if (rows[rowsLen - 1] < dropIndex) {\n      endRow = dropIndex - 1;\n      startRow = endRow - rowsLen + 1;\n    } else {\n      startRow = dropIndex;\n      endRow = startRow + rowsLen - 1;\n    }\n    selection = this.hot.selection;\n    lastColIndex = this.hot.countCols() - 1;\n    selection.setRangeStart(this.hot._createCellCoords(startRow, 0));\n    selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);\n  }\n\n  // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}