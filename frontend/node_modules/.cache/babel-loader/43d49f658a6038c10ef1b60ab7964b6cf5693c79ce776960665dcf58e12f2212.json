{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport TreeNode from \"../../../utils/dataStructures/tree.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @private\n * @class HeadersTree\n *\n * The header tree class keeps nested header settings in the tree\n * structure for easier node manipulation (e.q collapse or expand column).\n * That trees represent the current state of the nested headers. From the\n * trees, the matrix is generated for nested header renderers.\n *\n * The second role of the module is validation. While building the tree,\n * there is check whether the configuration contains overlapping\n * headers. If true, then the exception is thrown.\n *\n * The tree is static; it means that its column indexing never changes\n * even when a collapsing header is performed. The structure is based\n * on visual column indexes.\n *\n * For example, for that header configuration:\n *   +----+----+----+----+----+\n *   │ A1                │ A2 │\n *   +----+----+----+----+----+\n *   │ B1           │ B2 │ B3 │\n *   +----+----+----+----+----+\n *   │ C1      │ C2 │ C3 │ C4 │\n *   +----+----+----+----+----+\n *\n * The tree structures look like:\n *                (0)                      (4)           // a visual column index\n *                 │                        │\n *        .------(A1)------.              (A2)--.\n *   .--(B1)--.           (B2)--.              (B3)--.\n *  (C1)     (C2)              (C3)                 (C4)\n *\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _rootNodes = /*#__PURE__*/new WeakMap();\nvar _rootsIndex = /*#__PURE__*/new WeakMap();\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nexport default class HeadersTree {\n  constructor(sourceSettings) {\n    /**\n     * The collection of nested headers settings structured into trees. The root trees are stored\n     * under the visual column index.\n     *\n     * @private\n     * @type {Map<number, TreeNode>}\n     */\n    _classPrivateFieldInitSpec(this, _rootNodes, new Map());\n    /**\n     * A map that translates the visual column indexes that intersect the range\n     * defined by the header colspan width to the root index.\n     *\n     * @private\n     * @type {Map<number, number>}\n     */\n    _classPrivateFieldInitSpec(this, _rootsIndex, new Map());\n    /**\n     * The instance of the SourceSettings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, null);\n    _classPrivateFieldSet(_sourceSettings, this, sourceSettings);\n  }\n\n  /**\n   * Gets an array of the all root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  getRoots() {\n    return Array.from(_classPrivateFieldGet(_rootNodes, this).values());\n  }\n\n  /**\n   * Gets a root node by specified visual column index.\n   *\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getRootByColumn(columnIndex) {\n    let node;\n    if (_classPrivateFieldGet(_rootsIndex, this).has(columnIndex)) {\n      node = _classPrivateFieldGet(_rootNodes, this).get(_classPrivateFieldGet(_rootsIndex, this).get(columnIndex));\n    }\n    return node;\n  }\n\n  /**\n   * Gets a tree node by its position in the grid settings.\n   *\n   * @param {number} headerLevel Header level index (there is support only for positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getNode(headerLevel, columnIndex) {\n    const rootNode = this.getRootByColumn(columnIndex);\n    if (!rootNode) {\n      return;\n    }\n\n    // Normalize the visual column index to a 0-based system for a specific \"box\" defined\n    // by root node colspan width.\n    const normColumnIndex = columnIndex - _classPrivateFieldGet(_rootsIndex, this).get(columnIndex);\n    let columnCursor = 0;\n    let treeNode;\n\n    // Collect all parent nodes that depend on the collapsed node.\n    rootNode.walkDown(node => {\n      const {\n        data: {\n          origColspan,\n          headerLevel: nodeHeaderLevel\n        }\n      } = node;\n      if (headerLevel === nodeHeaderLevel) {\n        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {\n          treeNode = node;\n          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;\n          return false; // Cancel tree traversing.\n        }\n        columnCursor += origColspan;\n      }\n    });\n    return treeNode;\n  }\n\n  /**\n   * Builds (or rebuilds if called again) root nodes indexes.\n   */\n  rebuildTreeIndex() {\n    let columnIndex = 0;\n    _classPrivateFieldGet(_rootsIndex, this).clear();\n    arrayEach(_classPrivateFieldGet(_rootNodes, this), _ref => {\n      let [, {\n        data: {\n          colspan\n        }\n      }] = _ref;\n      // Map tree range (colspan range/width) into visual column index of the root node.\n      for (let i = columnIndex; i < columnIndex + colspan; i++) {\n        _classPrivateFieldGet(_rootsIndex, this).set(i, columnIndex);\n      }\n      columnIndex += colspan;\n    });\n  }\n\n  /**\n   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built\n   * from the previous call.\n   */\n  buildTree() {\n    this.clear();\n    const columnsCount = _classPrivateFieldGet(_sourceSettings, this).getColumnsCount();\n    let columnIndex = 0;\n    while (columnIndex < columnsCount) {\n      const columnSettings = _classPrivateFieldGet(_sourceSettings, this).getHeaderSettings(0, columnIndex);\n      const rootNode = new TreeNode();\n      _classPrivateFieldGet(_rootNodes, this).set(columnIndex, rootNode);\n      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n      columnIndex += columnSettings.origColspan;\n    }\n    this.rebuildTreeIndex();\n  }\n\n  /**\n   * Builds leaves for specified tree node.\n   *\n   * @param {TreeNode} parentNode A node to which the leaves applies.\n   * @param {number} columnIndex A visual column index.\n   * @param {number} headerLevel Currently processed header level.\n   * @param {number} [extractionLength=1] Determines column extraction length for node children.\n   */\n  buildLeaves(parentNode, columnIndex, headerLevel) {\n    let extractionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const columnsSettings = _classPrivateFieldGet(_sourceSettings, this).getHeadersSettings(headerLevel, columnIndex, extractionLength);\n    headerLevel += 1;\n    arrayEach(columnsSettings, columnSettings => {\n      const nodeData = {\n        ...columnSettings,\n        /**\n         * The header level (tree node depth level).\n         *\n         * @type {number}\n         */\n        headerLevel: headerLevel - 1,\n        /**\n         * A visual column index.\n         *\n         * @type {number}\n         */\n        columnIndex\n      };\n      let node;\n      if (headerLevel === 1) {\n        // fill the root node\n        parentNode.data = nodeData;\n        node = parentNode;\n      } else {\n        node = new TreeNode(nodeData);\n        parentNode.addChild(node);\n      }\n      if (headerLevel < _classPrivateFieldGet(_sourceSettings, this).getLayersCount()) {\n        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);\n      }\n      columnIndex += columnSettings.origColspan;\n    });\n  }\n\n  /**\n   * Clears the tree to the initial state.\n   */\n  clear() {\n    _classPrivateFieldGet(_rootNodes, this).clear();\n    _classPrivateFieldGet(_rootsIndex, this).clear();\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","arrayEach","TreeNode","_rootNodes","WeakMap","_rootsIndex","_sourceSettings","HeadersTree","constructor","sourceSettings","Map","getRoots","Array","from","values","getRootByColumn","columnIndex","node","getNode","headerLevel","rootNode","normColumnIndex","columnCursor","treeNode","walkDown","data","origColspan","nodeHeaderLevel","isRoot","rebuildTreeIndex","clear","_ref","colspan","i","buildTree","columnsCount","getColumnsCount","columnSettings","getHeaderSettings","buildLeaves","parentNode","extractionLength","undefined","columnsSettings","getHeadersSettings","nodeData","addChild","getLayersCount"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedHeaders/stateManager/headersTree.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport TreeNode from \"../../../utils/dataStructures/tree.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @private\n * @class HeadersTree\n *\n * The header tree class keeps nested header settings in the tree\n * structure for easier node manipulation (e.q collapse or expand column).\n * That trees represent the current state of the nested headers. From the\n * trees, the matrix is generated for nested header renderers.\n *\n * The second role of the module is validation. While building the tree,\n * there is check whether the configuration contains overlapping\n * headers. If true, then the exception is thrown.\n *\n * The tree is static; it means that its column indexing never changes\n * even when a collapsing header is performed. The structure is based\n * on visual column indexes.\n *\n * For example, for that header configuration:\n *   +----+----+----+----+----+\n *   │ A1                │ A2 │\n *   +----+----+----+----+----+\n *   │ B1           │ B2 │ B3 │\n *   +----+----+----+----+----+\n *   │ C1      │ C2 │ C3 │ C4 │\n *   +----+----+----+----+----+\n *\n * The tree structures look like:\n *                (0)                      (4)           // a visual column index\n *                 │                        │\n *        .------(A1)------.              (A2)--.\n *   .--(B1)--.           (B2)--.              (B3)--.\n *  (C1)     (C2)              (C3)                 (C4)\n *\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _rootNodes = /*#__PURE__*/new WeakMap();\nvar _rootsIndex = /*#__PURE__*/new WeakMap();\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nexport default class HeadersTree {\n  constructor(sourceSettings) {\n    /**\n     * The collection of nested headers settings structured into trees. The root trees are stored\n     * under the visual column index.\n     *\n     * @private\n     * @type {Map<number, TreeNode>}\n     */\n    _classPrivateFieldInitSpec(this, _rootNodes, new Map());\n    /**\n     * A map that translates the visual column indexes that intersect the range\n     * defined by the header colspan width to the root index.\n     *\n     * @private\n     * @type {Map<number, number>}\n     */\n    _classPrivateFieldInitSpec(this, _rootsIndex, new Map());\n    /**\n     * The instance of the SourceSettings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, null);\n    _classPrivateFieldSet(_sourceSettings, this, sourceSettings);\n  }\n\n  /**\n   * Gets an array of the all root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  getRoots() {\n    return Array.from(_classPrivateFieldGet(_rootNodes, this).values());\n  }\n\n  /**\n   * Gets a root node by specified visual column index.\n   *\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getRootByColumn(columnIndex) {\n    let node;\n    if (_classPrivateFieldGet(_rootsIndex, this).has(columnIndex)) {\n      node = _classPrivateFieldGet(_rootNodes, this).get(_classPrivateFieldGet(_rootsIndex, this).get(columnIndex));\n    }\n    return node;\n  }\n\n  /**\n   * Gets a tree node by its position in the grid settings.\n   *\n   * @param {number} headerLevel Header level index (there is support only for positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getNode(headerLevel, columnIndex) {\n    const rootNode = this.getRootByColumn(columnIndex);\n    if (!rootNode) {\n      return;\n    }\n\n    // Normalize the visual column index to a 0-based system for a specific \"box\" defined\n    // by root node colspan width.\n    const normColumnIndex = columnIndex - _classPrivateFieldGet(_rootsIndex, this).get(columnIndex);\n    let columnCursor = 0;\n    let treeNode;\n\n    // Collect all parent nodes that depend on the collapsed node.\n    rootNode.walkDown(node => {\n      const {\n        data: {\n          origColspan,\n          headerLevel: nodeHeaderLevel\n        }\n      } = node;\n      if (headerLevel === nodeHeaderLevel) {\n        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {\n          treeNode = node;\n          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;\n          return false; // Cancel tree traversing.\n        }\n        columnCursor += origColspan;\n      }\n    });\n    return treeNode;\n  }\n\n  /**\n   * Builds (or rebuilds if called again) root nodes indexes.\n   */\n  rebuildTreeIndex() {\n    let columnIndex = 0;\n    _classPrivateFieldGet(_rootsIndex, this).clear();\n    arrayEach(_classPrivateFieldGet(_rootNodes, this), _ref => {\n      let [, {\n        data: {\n          colspan\n        }\n      }] = _ref;\n      // Map tree range (colspan range/width) into visual column index of the root node.\n      for (let i = columnIndex; i < columnIndex + colspan; i++) {\n        _classPrivateFieldGet(_rootsIndex, this).set(i, columnIndex);\n      }\n      columnIndex += colspan;\n    });\n  }\n\n  /**\n   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built\n   * from the previous call.\n   */\n  buildTree() {\n    this.clear();\n    const columnsCount = _classPrivateFieldGet(_sourceSettings, this).getColumnsCount();\n    let columnIndex = 0;\n    while (columnIndex < columnsCount) {\n      const columnSettings = _classPrivateFieldGet(_sourceSettings, this).getHeaderSettings(0, columnIndex);\n      const rootNode = new TreeNode();\n      _classPrivateFieldGet(_rootNodes, this).set(columnIndex, rootNode);\n      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n      columnIndex += columnSettings.origColspan;\n    }\n    this.rebuildTreeIndex();\n  }\n\n  /**\n   * Builds leaves for specified tree node.\n   *\n   * @param {TreeNode} parentNode A node to which the leaves applies.\n   * @param {number} columnIndex A visual column index.\n   * @param {number} headerLevel Currently processed header level.\n   * @param {number} [extractionLength=1] Determines column extraction length for node children.\n   */\n  buildLeaves(parentNode, columnIndex, headerLevel) {\n    let extractionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const columnsSettings = _classPrivateFieldGet(_sourceSettings, this).getHeadersSettings(headerLevel, columnIndex, extractionLength);\n    headerLevel += 1;\n    arrayEach(columnsSettings, columnSettings => {\n      const nodeData = {\n        ...columnSettings,\n        /**\n         * The header level (tree node depth level).\n         *\n         * @type {number}\n         */\n        headerLevel: headerLevel - 1,\n        /**\n         * A visual column index.\n         *\n         * @type {number}\n         */\n        columnIndex\n      };\n      let node;\n      if (headerLevel === 1) {\n        // fill the root node\n        parentNode.data = nodeData;\n        node = parentNode;\n      } else {\n        node = new TreeNode(nodeData);\n        parentNode.addChild(node);\n      }\n      if (headerLevel < _classPrivateFieldGet(_sourceSettings, this).getLayersCount()) {\n        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);\n      }\n      columnIndex += columnSettings.origColspan;\n    });\n  }\n\n  /**\n   * Clears the tree to the initial state.\n   */\n  clear() {\n    _classPrivateFieldGet(_rootNodes, this).clear();\n    _classPrivateFieldGet(_rootsIndex, this).clear();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}