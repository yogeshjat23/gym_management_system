{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport AxisSyncer from \"./axisSyncer.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for syncing actions done on indexes for HOT to actions performed\n * on HF's.\n *\n */\nvar _rowIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _columnIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _postponeAction = /*#__PURE__*/new WeakMap();\nvar _isPerformingUndo = /*#__PURE__*/new WeakMap();\nvar _isPerformingRedo = /*#__PURE__*/new WeakMap();\nvar _engine = /*#__PURE__*/new WeakMap();\nvar _sheetId = /*#__PURE__*/new WeakMap();\nclass IndexSyncer {\n  constructor(rowIndexMapper, columnIndexMapper, postponeAction) {\n    /**\n     * Indexes synchronizer for the axis of the rows.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _rowIndexSyncer, void 0);\n    /**\n     * Indexes synchronizer for the axis of the columns.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _columnIndexSyncer, void 0);\n    /**\n     * Method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n     *\n     * @private\n     * @type {Function}\n     */\n    _classPrivateFieldInitSpec(this, _postponeAction, void 0);\n    /**\n     * Flag informing whether undo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingUndo, false);\n    /**\n     * Flag informing whether redo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingRedo, false);\n    /**\n     * The HF's engine instance which will be synced.\n     *\n     * @private\n     * @type {HyperFormula|null}\n     */\n    _classPrivateFieldInitSpec(this, _engine, null);\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @private\n     * @type {string|null}\n     */\n    _classPrivateFieldInitSpec(this, _sheetId, null);\n    _classPrivateFieldSet(_rowIndexSyncer, this, new AxisSyncer('row', rowIndexMapper, this));\n    _classPrivateFieldSet(_columnIndexSyncer, this, new AxisSyncer('column', columnIndexMapper, this));\n    _classPrivateFieldSet(_postponeAction, this, postponeAction);\n  }\n\n  /**\n   * Gets index synchronizer for a particular axis.\n   *\n   * @param {'row'|'column'} indexType Type of indexes.\n   * @returns {AxisSyncer}\n   */\n  getForAxis(indexType) {\n    if (indexType === 'row') {\n      return _classPrivateFieldGet(_rowIndexSyncer, this);\n    }\n    return _classPrivateFieldGet(_columnIndexSyncer, this);\n  }\n\n  /**\n   * Sets flag informing whether an undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformUndo(flagValue) {\n    _classPrivateFieldSet(_isPerformingUndo, this, flagValue);\n  }\n\n  /**\n   * Sets flag informing whether a redo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformRedo(flagValue) {\n    _classPrivateFieldSet(_isPerformingRedo, this, flagValue);\n  }\n\n  /**\n   * Gets information whether redo or undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isPerformingUndoRedo() {\n    return _classPrivateFieldGet(_isPerformingUndo, this) || _classPrivateFieldGet(_isPerformingRedo, this);\n  }\n\n  /**\n   * Gets HyperFormula's sheet id.\n   *\n   * @returns {string|null}\n   */\n  getSheetId() {\n    return _classPrivateFieldGet(_sheetId, this);\n  }\n\n  /**\n   * Gets engine instance that will be used for handled instance of Handsontable.\n   *\n   * @type {HyperFormula|null}\n   */\n  getEngine() {\n    return _classPrivateFieldGet(_engine, this);\n  }\n\n  /**\n   * Gets method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n   *\n   * @returns {Function}\n   */\n  getPostponeAction() {\n    return _classPrivateFieldGet(_postponeAction, this);\n  }\n\n  /**\n   * Setups a synchronization endpoint.\n   *\n   * @param {HyperFormula|null} engine The HF's engine instance which will be synced.\n   * @param {string|null} sheetId HyperFormula's sheet name.\n   */\n  setupSyncEndpoint(engine, sheetId) {\n    _classPrivateFieldSet(_engine, this, engine);\n    _classPrivateFieldSet(_sheetId, this, sheetId);\n    _classPrivateFieldGet(_rowIndexSyncer, this).init();\n    _classPrivateFieldGet(_columnIndexSyncer, this).init();\n  }\n}\nexport default IndexSyncer;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","AxisSyncer","_rowIndexSyncer","WeakMap","_columnIndexSyncer","_postponeAction","_isPerformingUndo","_isPerformingRedo","_engine","_sheetId","IndexSyncer","constructor","rowIndexMapper","columnIndexMapper","postponeAction","getForAxis","indexType","setPerformUndo","flagValue","setPerformRedo","isPerformingUndoRedo","getSheetId","getEngine","getPostponeAction","setupSyncEndpoint","engine","sheetId","init"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/formulas/indexSyncer/index.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport AxisSyncer from \"./axisSyncer.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for syncing actions done on indexes for HOT to actions performed\n * on HF's.\n *\n */\nvar _rowIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _columnIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _postponeAction = /*#__PURE__*/new WeakMap();\nvar _isPerformingUndo = /*#__PURE__*/new WeakMap();\nvar _isPerformingRedo = /*#__PURE__*/new WeakMap();\nvar _engine = /*#__PURE__*/new WeakMap();\nvar _sheetId = /*#__PURE__*/new WeakMap();\nclass IndexSyncer {\n  constructor(rowIndexMapper, columnIndexMapper, postponeAction) {\n    /**\n     * Indexes synchronizer for the axis of the rows.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _rowIndexSyncer, void 0);\n    /**\n     * Indexes synchronizer for the axis of the columns.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _columnIndexSyncer, void 0);\n    /**\n     * Method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n     *\n     * @private\n     * @type {Function}\n     */\n    _classPrivateFieldInitSpec(this, _postponeAction, void 0);\n    /**\n     * Flag informing whether undo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingUndo, false);\n    /**\n     * Flag informing whether redo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingRedo, false);\n    /**\n     * The HF's engine instance which will be synced.\n     *\n     * @private\n     * @type {HyperFormula|null}\n     */\n    _classPrivateFieldInitSpec(this, _engine, null);\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @private\n     * @type {string|null}\n     */\n    _classPrivateFieldInitSpec(this, _sheetId, null);\n    _classPrivateFieldSet(_rowIndexSyncer, this, new AxisSyncer('row', rowIndexMapper, this));\n    _classPrivateFieldSet(_columnIndexSyncer, this, new AxisSyncer('column', columnIndexMapper, this));\n    _classPrivateFieldSet(_postponeAction, this, postponeAction);\n  }\n\n  /**\n   * Gets index synchronizer for a particular axis.\n   *\n   * @param {'row'|'column'} indexType Type of indexes.\n   * @returns {AxisSyncer}\n   */\n  getForAxis(indexType) {\n    if (indexType === 'row') {\n      return _classPrivateFieldGet(_rowIndexSyncer, this);\n    }\n    return _classPrivateFieldGet(_columnIndexSyncer, this);\n  }\n\n  /**\n   * Sets flag informing whether an undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformUndo(flagValue) {\n    _classPrivateFieldSet(_isPerformingUndo, this, flagValue);\n  }\n\n  /**\n   * Sets flag informing whether a redo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformRedo(flagValue) {\n    _classPrivateFieldSet(_isPerformingRedo, this, flagValue);\n  }\n\n  /**\n   * Gets information whether redo or undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isPerformingUndoRedo() {\n    return _classPrivateFieldGet(_isPerformingUndo, this) || _classPrivateFieldGet(_isPerformingRedo, this);\n  }\n\n  /**\n   * Gets HyperFormula's sheet id.\n   *\n   * @returns {string|null}\n   */\n  getSheetId() {\n    return _classPrivateFieldGet(_sheetId, this);\n  }\n\n  /**\n   * Gets engine instance that will be used for handled instance of Handsontable.\n   *\n   * @type {HyperFormula|null}\n   */\n  getEngine() {\n    return _classPrivateFieldGet(_engine, this);\n  }\n\n  /**\n   * Gets method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n   *\n   * @returns {Function}\n   */\n  getPostponeAction() {\n    return _classPrivateFieldGet(_postponeAction, this);\n  }\n\n  /**\n   * Setups a synchronization endpoint.\n   *\n   * @param {HyperFormula|null} engine The HF's engine instance which will be synced.\n   * @param {string|null} sheetId HyperFormula's sheet name.\n   */\n  setupSyncEndpoint(engine, sheetId) {\n    _classPrivateFieldSet(_engine, this, engine);\n    _classPrivateFieldSet(_sheetId, this, sheetId);\n    _classPrivateFieldGet(_rowIndexSyncer, this).init();\n    _classPrivateFieldGet(_columnIndexSyncer, this).init();\n  }\n}\nexport default IndexSyncer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}