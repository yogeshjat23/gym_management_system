{"ast":null,"code":"function _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { extend, isObject } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { normalizeSettings } from \"./settingsNormalizer.mjs\";\n/**\n * List of properties which are configurable. That properties can be changed using public API.\n *\n * @type {string[]}\n */\nexport const HEADER_CONFIGURABLE_PROPS = ['label', 'collapsible'];\n\n/**\n * The class manages and normalizes settings passed by the developer\n * into the nested headers plugin. The SourceSettings class is a\n * source of truth for tree builder (HeaderTree) module.\n *\n * @private\n * @class SourceSettings\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nexport default class SourceSettings {\n  constructor() {\n    /**\n     * The normalized source data (normalized user-defined settings for nested headers).\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _data, []);\n    /**\n     * The total length of the nested header layers.\n     *\n     * @private\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _dataLength, 0);\n    /**\n     * Columns count limit value trims source settings to that value. If columns\n     * count limit intersects nested header, the header's colspan value is reduced\n     * to keep the whole structure stable (trimmed precisely where the limit is set).\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, Infinity);\n  }\n  /**\n   * Sets columns limit to the source settings will be trimmed. All headers which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldSet(_columnsLimit, this, columnsCount);\n  }\n\n  /**\n   * Sets a new nested header configuration.\n   *\n   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.\n   */\n  setData() {\n    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classPrivateFieldSet(_data, this, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet(_columnsLimit, this)));\n    _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_data, this).length);\n  }\n\n  /**\n   * Gets normalized source settings.\n   *\n   * @returns {Array[]}\n   */\n  getData() {\n    return _classPrivateFieldGet(_data, this);\n  }\n\n  /**\n   * Merges settings with current source settings.\n   *\n   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional\n   *                                      properties to merge with current source settings.\n   */\n  mergeWith(additionalSettings) {\n    arrayEach(additionalSettings, _ref => {\n      let {\n        row,\n        col,\n        ...rest\n      } = _ref;\n      const headerSettings = this.getHeaderSettings(row, col);\n      if (headerSettings !== null) {\n        extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n      }\n    });\n  }\n\n  /**\n   * Maps the current state with a callback. For each source settings the callback function\n   * is called. If the function returns value that value is merged with the source settings.\n   *\n   * @param {Function} callback A function that is called for every header settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  map(callback) {\n    arrayEach(_classPrivateFieldGet(_data, this), header => {\n      arrayEach(header, headerSettings => {\n        const propsToExtend = callback({\n          ...headerSettings\n        });\n        if (isObject(propsToExtend)) {\n          extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    });\n  }\n\n  /**\n   * Gets source column header settings for a specified header. The returned\n   * object contains information about the header label, its colspan length,\n   * or if it is hidden in the header renderers.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _headersSettings$colu;\n    if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n      return null;\n    }\n    const headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n    if (Array.isArray(headersSettings) === false || columnIndex >= headersSettings.length) {\n      return null;\n    }\n    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n  }\n\n  /**\n   * Gets source of column headers settings for specified headers. If the retrieved column\n   * settings overlap the range \"box\" determined by \"columnIndex\" and \"columnsLength\"\n   * the exception will be thrown.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index from which the settings will be extracted.\n   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.\n   * @returns {object}\n   */\n  getHeadersSettings(headerLevel, columnIndex) {\n    let columnsLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const headersSettingsChunks = [];\n    if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n      return headersSettingsChunks;\n    }\n    const headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n    let currentLength = 0;\n    for (let i = columnIndex; i < headersSettings.length; i++) {\n      const headerSettings = headersSettings[i];\n      if (headerSettings.isPlaceholder) {\n        throw new Error('The first column settings cannot overlap the other header layers');\n      }\n      currentLength += headerSettings.colspan;\n      headersSettingsChunks.push(headerSettings);\n      if (headerSettings.colspan > 1) {\n        i += headerSettings.colspan - 1;\n      }\n\n      // We met the current sum of the child colspans\n      if (currentLength === columnsLength) {\n        break;\n      }\n      // We exceeds the current sum of the child colspans, the last columns colspan overlaps the \"columnsLength\" length.\n      if (currentLength > columnsLength) {\n        throw new Error('The last column settings cannot overlap the other header layers');\n      }\n    }\n    return headersSettingsChunks;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_dataLength, this);\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(_dataLength, this) > 0 ? _classPrivateFieldGet(_data, this)[0].length : 0;\n  }\n\n  /**\n   * Clears the data.\n   */\n  clear() {\n    _classPrivateFieldSet(_data, this, []);\n    _classPrivateFieldSet(_dataLength, this, 0);\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","extend","isObject","arrayEach","normalizeSettings","HEADER_CONFIGURABLE_PROPS","_data","WeakMap","_dataLength","_columnsLimit","SourceSettings","constructor","Infinity","setColumnsLimit","columnsCount","setData","nestedHeadersSettings","undefined","getData","mergeWith","additionalSettings","_ref","row","col","rest","headerSettings","getHeaderSettings","map","callback","header","propsToExtend","headerLevel","columnIndex","_headersSettings$colu","headersSettings","Array","isArray","getHeadersSettings","columnsLength","headersSettingsChunks","currentLength","i","isPlaceholder","Error","colspan","push","getLayersCount","getColumnsCount","clear"],"sources":["D:/gym-project/frontend/node_modules/handsontable/plugins/nestedHeaders/stateManager/sourceSettings.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { extend, isObject } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { normalizeSettings } from \"./settingsNormalizer.mjs\";\n/**\n * List of properties which are configurable. That properties can be changed using public API.\n *\n * @type {string[]}\n */\nexport const HEADER_CONFIGURABLE_PROPS = ['label', 'collapsible'];\n\n/**\n * The class manages and normalizes settings passed by the developer\n * into the nested headers plugin. The SourceSettings class is a\n * source of truth for tree builder (HeaderTree) module.\n *\n * @private\n * @class SourceSettings\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nexport default class SourceSettings {\n  constructor() {\n    /**\n     * The normalized source data (normalized user-defined settings for nested headers).\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _data, []);\n    /**\n     * The total length of the nested header layers.\n     *\n     * @private\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _dataLength, 0);\n    /**\n     * Columns count limit value trims source settings to that value. If columns\n     * count limit intersects nested header, the header's colspan value is reduced\n     * to keep the whole structure stable (trimmed precisely where the limit is set).\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, Infinity);\n  }\n  /**\n   * Sets columns limit to the source settings will be trimmed. All headers which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldSet(_columnsLimit, this, columnsCount);\n  }\n\n  /**\n   * Sets a new nested header configuration.\n   *\n   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.\n   */\n  setData() {\n    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classPrivateFieldSet(_data, this, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet(_columnsLimit, this)));\n    _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_data, this).length);\n  }\n\n  /**\n   * Gets normalized source settings.\n   *\n   * @returns {Array[]}\n   */\n  getData() {\n    return _classPrivateFieldGet(_data, this);\n  }\n\n  /**\n   * Merges settings with current source settings.\n   *\n   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional\n   *                                      properties to merge with current source settings.\n   */\n  mergeWith(additionalSettings) {\n    arrayEach(additionalSettings, _ref => {\n      let {\n        row,\n        col,\n        ...rest\n      } = _ref;\n      const headerSettings = this.getHeaderSettings(row, col);\n      if (headerSettings !== null) {\n        extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n      }\n    });\n  }\n\n  /**\n   * Maps the current state with a callback. For each source settings the callback function\n   * is called. If the function returns value that value is merged with the source settings.\n   *\n   * @param {Function} callback A function that is called for every header settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  map(callback) {\n    arrayEach(_classPrivateFieldGet(_data, this), header => {\n      arrayEach(header, headerSettings => {\n        const propsToExtend = callback({\n          ...headerSettings\n        });\n        if (isObject(propsToExtend)) {\n          extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    });\n  }\n\n  /**\n   * Gets source column header settings for a specified header. The returned\n   * object contains information about the header label, its colspan length,\n   * or if it is hidden in the header renderers.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _headersSettings$colu;\n    if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n      return null;\n    }\n    const headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n    if (Array.isArray(headersSettings) === false || columnIndex >= headersSettings.length) {\n      return null;\n    }\n    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n  }\n\n  /**\n   * Gets source of column headers settings for specified headers. If the retrieved column\n   * settings overlap the range \"box\" determined by \"columnIndex\" and \"columnsLength\"\n   * the exception will be thrown.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index from which the settings will be extracted.\n   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.\n   * @returns {object}\n   */\n  getHeadersSettings(headerLevel, columnIndex) {\n    let columnsLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const headersSettingsChunks = [];\n    if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n      return headersSettingsChunks;\n    }\n    const headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n    let currentLength = 0;\n    for (let i = columnIndex; i < headersSettings.length; i++) {\n      const headerSettings = headersSettings[i];\n      if (headerSettings.isPlaceholder) {\n        throw new Error('The first column settings cannot overlap the other header layers');\n      }\n      currentLength += headerSettings.colspan;\n      headersSettingsChunks.push(headerSettings);\n      if (headerSettings.colspan > 1) {\n        i += headerSettings.colspan - 1;\n      }\n\n      // We met the current sum of the child colspans\n      if (currentLength === columnsLength) {\n        break;\n      }\n      // We exceeds the current sum of the child colspans, the last columns colspan overlaps the \"columnsLength\" length.\n      if (currentLength > columnsLength) {\n        throw new Error('The last column settings cannot overlap the other header layers');\n      }\n    }\n    return headersSettingsChunks;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_dataLength, this);\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(_dataLength, this) > 0 ? _classPrivateFieldGet(_data, this)[0].length : 0;\n  }\n\n  /**\n   * Clears the data.\n   */\n  clear() {\n    _classPrivateFieldSet(_data, this, []);\n    _classPrivateFieldSet(_dataLength, this, 0);\n  }\n}"],"mappings":"AAEA,SAASA,0BAA0BA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAAEC,0BAA0B,CAACH,CAAC,EAAEC,CAAC,CAAC,EAAEA,CAAC,CAACG,GAAG,CAACJ,CAAC,EAAEE,CAAC,CAAC;AAAE;AAC9F,SAASC,0BAA0BA,CAACH,CAAC,EAAEC,CAAC,EAAE;EAAE,IAAIA,CAAC,CAACI,GAAG,CAACL,CAAC,CAAC,EAAE,MAAM,IAAIM,SAAS,CAAC,gEAAgE,CAAC;AAAE;AACjJ,SAASC,qBAAqBA,CAACC,CAAC,EAAEN,CAAC,EAAE;EAAE,OAAOM,CAAC,CAACC,GAAG,CAACC,iBAAiB,CAACF,CAAC,EAAEN,CAAC,CAAC,CAAC;AAAE;AAC9E,SAASS,qBAAqBA,CAACH,CAAC,EAAEN,CAAC,EAAEU,CAAC,EAAE;EAAE,OAAOJ,CAAC,CAACJ,GAAG,CAACM,iBAAiB,CAACF,CAAC,EAAEN,CAAC,CAAC,EAAEU,CAAC,CAAC,EAAEA,CAAC;AAAE;AACvF,SAASF,iBAAiBA,CAACV,CAAC,EAAEC,CAAC,EAAEY,CAAC,EAAE;EAAE,IAAI,UAAU,IAAI,OAAOb,CAAC,GAAGA,CAAC,KAAKC,CAAC,GAAGD,CAAC,CAACK,GAAG,CAACJ,CAAC,CAAC,EAAE,OAAOa,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGd,CAAC,GAAGY,CAAC;EAAE,MAAM,IAAIP,SAAS,CAAC,+CAA+C,CAAC;AAAE;AAClM,SAASU,MAAM,EAAEC,QAAQ,QAAQ,6BAA6B;AAC9D,SAASC,SAAS,QAAQ,4BAA4B;AACtD,SAASC,iBAAiB,QAAQ,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,yBAAyB,GAAG,CAAC,OAAO,EAAE,aAAa,CAAC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,KAAK,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AACtC,IAAIC,WAAW,GAAG,aAAa,IAAID,OAAO,CAAC,CAAC;AAC5C,IAAIE,aAAa,GAAG,aAAa,IAAIF,OAAO,CAAC,CAAC;AAC9C,eAAe,MAAMG,cAAc,CAAC;EAClCC,WAAWA,CAAA,EAAG;IACZ;AACJ;AACA;AACA;AACA;AACA;IACI3B,0BAA0B,CAAC,IAAI,EAAEsB,KAAK,EAAE,EAAE,CAAC;IAC3C;AACJ;AACA;AACA;AACA;AACA;IACItB,0BAA0B,CAAC,IAAI,EAAEwB,WAAW,EAAE,CAAC,CAAC;IAChD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIxB,0BAA0B,CAAC,IAAI,EAAEyB,aAAa,EAAEG,QAAQ,CAAC;EAC3D;EACA;AACF;AACA;AACA;AACA;AACA;EACEC,eAAeA,CAACC,YAAY,EAAE;IAC5BlB,qBAAqB,CAACa,aAAa,EAAE,IAAI,EAAEK,YAAY,CAAC;EAC1D;;EAEA;AACF;AACA;AACA;AACA;EACEC,OAAOA,CAAA,EAAG;IACR,IAAIC,qBAAqB,GAAGjB,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKkB,SAAS,GAAGlB,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;IAClGH,qBAAqB,CAACU,KAAK,EAAE,IAAI,EAAEF,iBAAiB,CAACY,qBAAqB,EAAExB,qBAAqB,CAACiB,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC;IACxHb,qBAAqB,CAACY,WAAW,EAAE,IAAI,EAAEhB,qBAAqB,CAACc,KAAK,EAAE,IAAI,CAAC,CAACN,MAAM,CAAC;EACrF;;EAEA;AACF;AACA;AACA;AACA;EACEkB,OAAOA,CAAA,EAAG;IACR,OAAO1B,qBAAqB,CAACc,KAAK,EAAE,IAAI,CAAC;EAC3C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEa,SAASA,CAACC,kBAAkB,EAAE;IAC5BjB,SAAS,CAACiB,kBAAkB,EAAEC,IAAI,IAAI;MACpC,IAAI;QACFC,GAAG;QACHC,GAAG;QACH,GAAGC;MACL,CAAC,GAAGH,IAAI;MACR,MAAMI,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAACJ,GAAG,EAAEC,GAAG,CAAC;MACvD,IAAIE,cAAc,KAAK,IAAI,EAAE;QAC3BxB,MAAM,CAACwB,cAAc,EAAED,IAAI,EAAEnB,yBAAyB,CAAC;MACzD;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEsB,GAAGA,CAACC,QAAQ,EAAE;IACZzB,SAAS,CAACX,qBAAqB,CAACc,KAAK,EAAE,IAAI,CAAC,EAAEuB,MAAM,IAAI;MACtD1B,SAAS,CAAC0B,MAAM,EAAEJ,cAAc,IAAI;QAClC,MAAMK,aAAa,GAAGF,QAAQ,CAAC;UAC7B,GAAGH;QACL,CAAC,CAAC;QACF,IAAIvB,QAAQ,CAAC4B,aAAa,CAAC,EAAE;UAC3B7B,MAAM,CAACwB,cAAc,EAAEK,aAAa,EAAEzB,yBAAyB,CAAC;QAClE;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEqB,iBAAiBA,CAACK,WAAW,EAAEC,WAAW,EAAE;IAC1C,IAAIC,qBAAqB;IACzB,IAAIF,WAAW,IAAIvC,qBAAqB,CAACgB,WAAW,EAAE,IAAI,CAAC,IAAIuB,WAAW,GAAG,CAAC,EAAE;MAC9E,OAAO,IAAI;IACb;IACA,MAAMG,eAAe,GAAG1C,qBAAqB,CAACc,KAAK,EAAE,IAAI,CAAC,CAACyB,WAAW,CAAC;IACvE,IAAII,KAAK,CAACC,OAAO,CAACF,eAAe,CAAC,KAAK,KAAK,IAAIF,WAAW,IAAIE,eAAe,CAAClC,MAAM,EAAE;MACrF,OAAO,IAAI;IACb;IACA,OAAO,CAACiC,qBAAqB,GAAGC,eAAe,CAACF,WAAW,CAAC,MAAM,IAAI,IAAIC,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,IAAI;EAC3I;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,kBAAkBA,CAACN,WAAW,EAAEC,WAAW,EAAE;IAC3C,IAAIM,aAAa,GAAGvC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKkB,SAAS,GAAGlB,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;IACzF,MAAMwC,qBAAqB,GAAG,EAAE;IAChC,IAAIR,WAAW,IAAIvC,qBAAqB,CAACgB,WAAW,EAAE,IAAI,CAAC,IAAIuB,WAAW,GAAG,CAAC,EAAE;MAC9E,OAAOQ,qBAAqB;IAC9B;IACA,MAAML,eAAe,GAAG1C,qBAAqB,CAACc,KAAK,EAAE,IAAI,CAAC,CAACyB,WAAW,CAAC;IACvE,IAAIS,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIC,CAAC,GAAGT,WAAW,EAAES,CAAC,GAAGP,eAAe,CAAClC,MAAM,EAAEyC,CAAC,EAAE,EAAE;MACzD,MAAMhB,cAAc,GAAGS,eAAe,CAACO,CAAC,CAAC;MACzC,IAAIhB,cAAc,CAACiB,aAAa,EAAE;QAChC,MAAM,IAAIC,KAAK,CAAC,kEAAkE,CAAC;MACrF;MACAH,aAAa,IAAIf,cAAc,CAACmB,OAAO;MACvCL,qBAAqB,CAACM,IAAI,CAACpB,cAAc,CAAC;MAC1C,IAAIA,cAAc,CAACmB,OAAO,GAAG,CAAC,EAAE;QAC9BH,CAAC,IAAIhB,cAAc,CAACmB,OAAO,GAAG,CAAC;MACjC;;MAEA;MACA,IAAIJ,aAAa,KAAKF,aAAa,EAAE;QACnC;MACF;MACA;MACA,IAAIE,aAAa,GAAGF,aAAa,EAAE;QACjC,MAAM,IAAIK,KAAK,CAAC,iEAAiE,CAAC;MACpF;IACF;IACA,OAAOJ,qBAAqB;EAC9B;;EAEA;AACF;AACA;AACA;AACA;EACEO,cAAcA,CAAA,EAAG;IACf,OAAOtD,qBAAqB,CAACgB,WAAW,EAAE,IAAI,CAAC;EACjD;;EAEA;AACF;AACA;AACA;AACA;EACEuC,eAAeA,CAAA,EAAG;IAChB,OAAOvD,qBAAqB,CAACgB,WAAW,EAAE,IAAI,CAAC,GAAG,CAAC,GAAGhB,qBAAqB,CAACc,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAACN,MAAM,GAAG,CAAC;EACxG;;EAEA;AACF;AACA;EACEgD,KAAKA,CAAA,EAAG;IACNpD,qBAAqB,CAACU,KAAK,EAAE,IAAI,EAAE,EAAE,CAAC;IACtCV,qBAAqB,CAACY,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC;EAC7C;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}