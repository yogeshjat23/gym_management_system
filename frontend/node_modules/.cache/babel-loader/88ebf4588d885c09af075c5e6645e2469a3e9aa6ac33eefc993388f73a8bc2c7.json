{"ast":null,"code":"/**\n * Gets first position where to move element (respecting the fact that some element will be sooner or later\n * taken out of the dataset in order to move them).\n *\n * @param {Array<number>} movedIndexes Sequence of moved indexes for certain axis.\n * @param {number} finalIndex Final place where to move rows.\n * @param {number} numberOfIndexes Number of indexes in a dataset.\n * @returns {number} Index informing where to move the first element.\n */\nfunction getMoveLine(movedIndexes, finalIndex, numberOfIndexes) {\n  const notMovedElements = Array.from(Array(numberOfIndexes).keys()).filter(index => movedIndexes.includes(index) === false);\n  if (finalIndex === 0) {\n    var _notMovedElements$fin;\n    return (_notMovedElements$fin = notMovedElements[finalIndex]) !== null && _notMovedElements$fin !== void 0 ? _notMovedElements$fin : 0; // Moving before the first dataset's element.\n  }\n  return notMovedElements[finalIndex - 1] + 1; // Moving before another element.\n}\n\n/**\n * Gets initially calculated move positions.\n *\n * @param {Array<number>} movedIndexes Sequence of moved indexes for certain axis.\n * @param {number} moveLine Final place where to move rows.\n * @returns {Array<{from: number, to: number}>} Initially calculated move positions.\n */\nfunction getInitiallyCalculatedMoves(movedIndexes, moveLine) {\n  const moves = [];\n  movedIndexes.forEach(movedIndex => {\n    const move = {\n      from: movedIndex,\n      to: moveLine\n    };\n    moves.forEach(previouslyMovedIndex => {\n      const isMovingFromEndToStart = previouslyMovedIndex.from > previouslyMovedIndex.to;\n      const isMovingElementBefore = previouslyMovedIndex.to <= move.from;\n      const isMovingAfterElement = previouslyMovedIndex.from > move.from;\n      if (isMovingAfterElement && isMovingElementBefore && isMovingFromEndToStart) {\n        move.from += 1;\n      }\n    });\n\n    // Moved element from right to left (or bottom to top).\n    if (move.from >= moveLine) {\n      moveLine += 1;\n    }\n    moves.push(move);\n  });\n  return moves;\n}\n\n/**\n * Gets finally calculated move positions (after adjusting).\n *\n * @param {Array<{from: number, to: number}>} moves Initially calculated move positions.\n * @returns {Array<{from: number, to: number}>} Finally calculated move positions (after adjusting).\n */\nfunction adjustedCalculatedMoves(moves) {\n  moves.forEach((move, index) => {\n    const nextMoved = moves.slice(index + 1);\n    nextMoved.forEach(nextMovedIndex => {\n      const isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;\n      if (nextMovedIndex.from > move.from && isMovingFromStartToEnd) {\n        nextMovedIndex.from -= 1;\n      }\n    });\n  });\n  return moves;\n}\n\n/**\n * Get list of move positions.\n *\n * @param {Array<number>} movedIndexes Sequence of moved indexes for certain axis.\n * @param {number} finalIndex Final place where to move rows.\n * @param {number} numberOfIndexes Number of indexes in a dataset.\n * @returns {Array<{from: number, to: number}>}\n */\nexport function getMoves(movedIndexes, finalIndex, numberOfIndexes) {\n  const moves = getInitiallyCalculatedMoves(movedIndexes, getMoveLine(movedIndexes, finalIndex, numberOfIndexes));\n  return adjustedCalculatedMoves(moves);\n}","map":{"version":3,"names":["getMoveLine","movedIndexes","finalIndex","numberOfIndexes","notMovedElements","Array","from","keys","filter","index","includes","_notMovedElements$fin","getInitiallyCalculatedMoves","moveLine","moves","forEach","movedIndex","move","to","previouslyMovedIndex","isMovingFromEndToStart","isMovingElementBefore","isMovingAfterElement","push","adjustedCalculatedMoves","nextMoved","slice","nextMovedIndex","isMovingFromStartToEnd","getMoves"],"sources":["D:/gym-project/frontend/node_modules/handsontable/helpers/moves.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\n/**\n * Gets first position where to move element (respecting the fact that some element will be sooner or later\n * taken out of the dataset in order to move them).\n *\n * @param {Array<number>} movedIndexes Sequence of moved indexes for certain axis.\n * @param {number} finalIndex Final place where to move rows.\n * @param {number} numberOfIndexes Number of indexes in a dataset.\n * @returns {number} Index informing where to move the first element.\n */\nfunction getMoveLine(movedIndexes, finalIndex, numberOfIndexes) {\n  const notMovedElements = Array.from(Array(numberOfIndexes).keys()).filter(index => movedIndexes.includes(index) === false);\n  if (finalIndex === 0) {\n    var _notMovedElements$fin;\n    return (_notMovedElements$fin = notMovedElements[finalIndex]) !== null && _notMovedElements$fin !== void 0 ? _notMovedElements$fin : 0; // Moving before the first dataset's element.\n  }\n  return notMovedElements[finalIndex - 1] + 1; // Moving before another element.\n}\n\n/**\n * Gets initially calculated move positions.\n *\n * @param {Array<number>} movedIndexes Sequence of moved indexes for certain axis.\n * @param {number} moveLine Final place where to move rows.\n * @returns {Array<{from: number, to: number}>} Initially calculated move positions.\n */\nfunction getInitiallyCalculatedMoves(movedIndexes, moveLine) {\n  const moves = [];\n  movedIndexes.forEach(movedIndex => {\n    const move = {\n      from: movedIndex,\n      to: moveLine\n    };\n    moves.forEach(previouslyMovedIndex => {\n      const isMovingFromEndToStart = previouslyMovedIndex.from > previouslyMovedIndex.to;\n      const isMovingElementBefore = previouslyMovedIndex.to <= move.from;\n      const isMovingAfterElement = previouslyMovedIndex.from > move.from;\n      if (isMovingAfterElement && isMovingElementBefore && isMovingFromEndToStart) {\n        move.from += 1;\n      }\n    });\n\n    // Moved element from right to left (or bottom to top).\n    if (move.from >= moveLine) {\n      moveLine += 1;\n    }\n    moves.push(move);\n  });\n  return moves;\n}\n\n/**\n * Gets finally calculated move positions (after adjusting).\n *\n * @param {Array<{from: number, to: number}>} moves Initially calculated move positions.\n * @returns {Array<{from: number, to: number}>} Finally calculated move positions (after adjusting).\n */\nfunction adjustedCalculatedMoves(moves) {\n  moves.forEach((move, index) => {\n    const nextMoved = moves.slice(index + 1);\n    nextMoved.forEach(nextMovedIndex => {\n      const isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;\n      if (nextMovedIndex.from > move.from && isMovingFromStartToEnd) {\n        nextMovedIndex.from -= 1;\n      }\n    });\n  });\n  return moves;\n}\n\n/**\n * Get list of move positions.\n *\n * @param {Array<number>} movedIndexes Sequence of moved indexes for certain axis.\n * @param {number} finalIndex Final place where to move rows.\n * @param {number} numberOfIndexes Number of indexes in a dataset.\n * @returns {Array<{from: number, to: number}>}\n */\nexport function getMoves(movedIndexes, finalIndex, numberOfIndexes) {\n  const moves = getInitiallyCalculatedMoves(movedIndexes, getMoveLine(movedIndexes, finalIndex, numberOfIndexes));\n  return adjustedCalculatedMoves(moves);\n}"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAWA,CAACC,YAAY,EAAEC,UAAU,EAAEC,eAAe,EAAE;EAC9D,MAAMC,gBAAgB,GAAGC,KAAK,CAACC,IAAI,CAACD,KAAK,CAACF,eAAe,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAACC,KAAK,IAAIR,YAAY,CAACS,QAAQ,CAACD,KAAK,CAAC,KAAK,KAAK,CAAC;EAC1H,IAAIP,UAAU,KAAK,CAAC,EAAE;IACpB,IAAIS,qBAAqB;IACzB,OAAO,CAACA,qBAAqB,GAAGP,gBAAgB,CAACF,UAAU,CAAC,MAAM,IAAI,IAAIS,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC,CAAC,CAAC;EAC1I;EACA,OAAOP,gBAAgB,CAACF,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,2BAA2BA,CAACX,YAAY,EAAEY,QAAQ,EAAE;EAC3D,MAAMC,KAAK,GAAG,EAAE;EAChBb,YAAY,CAACc,OAAO,CAACC,UAAU,IAAI;IACjC,MAAMC,IAAI,GAAG;MACXX,IAAI,EAAEU,UAAU;MAChBE,EAAE,EAAEL;IACN,CAAC;IACDC,KAAK,CAACC,OAAO,CAACI,oBAAoB,IAAI;MACpC,MAAMC,sBAAsB,GAAGD,oBAAoB,CAACb,IAAI,GAAGa,oBAAoB,CAACD,EAAE;MAClF,MAAMG,qBAAqB,GAAGF,oBAAoB,CAACD,EAAE,IAAID,IAAI,CAACX,IAAI;MAClE,MAAMgB,oBAAoB,GAAGH,oBAAoB,CAACb,IAAI,GAAGW,IAAI,CAACX,IAAI;MAClE,IAAIgB,oBAAoB,IAAID,qBAAqB,IAAID,sBAAsB,EAAE;QAC3EH,IAAI,CAACX,IAAI,IAAI,CAAC;MAChB;IACF,CAAC,CAAC;;IAEF;IACA,IAAIW,IAAI,CAACX,IAAI,IAAIO,QAAQ,EAAE;MACzBA,QAAQ,IAAI,CAAC;IACf;IACAC,KAAK,CAACS,IAAI,CAACN,IAAI,CAAC;EAClB,CAAC,CAAC;EACF,OAAOH,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,uBAAuBA,CAACV,KAAK,EAAE;EACtCA,KAAK,CAACC,OAAO,CAAC,CAACE,IAAI,EAAER,KAAK,KAAK;IAC7B,MAAMgB,SAAS,GAAGX,KAAK,CAACY,KAAK,CAACjB,KAAK,GAAG,CAAC,CAAC;IACxCgB,SAAS,CAACV,OAAO,CAACY,cAAc,IAAI;MAClC,MAAMC,sBAAsB,GAAGD,cAAc,CAACrB,IAAI,GAAGqB,cAAc,CAACT,EAAE;MACtE,IAAIS,cAAc,CAACrB,IAAI,GAAGW,IAAI,CAACX,IAAI,IAAIsB,sBAAsB,EAAE;QAC7DD,cAAc,CAACrB,IAAI,IAAI,CAAC;MAC1B;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOQ,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,QAAQA,CAAC5B,YAAY,EAAEC,UAAU,EAAEC,eAAe,EAAE;EAClE,MAAMW,KAAK,GAAGF,2BAA2B,CAACX,YAAY,EAAED,WAAW,CAACC,YAAY,EAAEC,UAAU,EAAEC,eAAe,CAAC,CAAC;EAC/G,OAAOqB,uBAAuB,CAACV,KAAK,CAAC;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}