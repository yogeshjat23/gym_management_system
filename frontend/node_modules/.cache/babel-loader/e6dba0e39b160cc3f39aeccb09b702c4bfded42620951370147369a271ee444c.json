{"ast":null,"code":"function _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { isFunctionKey, isCtrlMetaKey } from \"./helpers/unicode.mjs\";\nimport { isImmediatePropagationStopped } from \"./helpers/dom/event.mjs\";\nimport { getEditorInstance } from \"./editors/registry.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nvar _EditorManager_brand = /*#__PURE__*/new WeakSet();\nclass EditorManager {\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   * @param {TableMeta} tableMeta The table meta instance.\n   * @param {Selection} selection The selection instance.\n   */\n  constructor(hotInstance, tableMeta, _selection) {\n    /**\n     * OnAfterDocumentKeyDown callback.\n     *\n     * @param {KeyboardEvent} event The keyboard event object.\n     */\n    _classPrivateMethodInitSpec(this, _EditorManager_brand);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to an instance's private GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"tableMeta\", void 0);\n    /**\n     * Instance of {@link Selection}.\n     *\n     * @private\n     * @type {Selection}\n     */\n    _defineProperty(this, \"selection\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Determines if EditorManager is destroyed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"destroyed\", false);\n    /**\n     * A reference to an instance of the activeEditor.\n     *\n     * @private\n     * @type {BaseEditor}\n     */\n    _defineProperty(this, \"activeEditor\", void 0);\n    /**\n     * Keeps a reference to the cell's properties object.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", void 0);\n    this.hot = hotInstance;\n    this.tableMeta = tableMeta;\n    this.selection = _selection;\n    this.eventManager = new EventManager(hotInstance);\n    this.hot.addHook('afterDocumentKeyDown', event => _assertClassBrand(_EditorManager_brand, this, _onAfterDocumentKeyDown).call(this, event));\n\n    // Open editor when text composition is started (IME editor)\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'compositionstart', event => {\n      if (!this.destroyed && this.hot.isListening()) {\n        this.openEditor('', event);\n      }\n    });\n    this.hot.view._wt.update('onCellDblClick', (event, coords, elem) => _assertClassBrand(_EditorManager_brand, this, _onCellDblClick).call(this, event, coords, elem));\n  }\n\n  /**\n   * Get active editor.\n   *\n   * @returns {BaseEditor}\n   */\n  getActiveEditor() {\n    return this.activeEditor;\n  }\n\n  /**\n   * Prepare text input to be displayed at given grid cell.\n   */\n  prepareEditor() {\n    var _this$hot$getSelected;\n    if (this.activeEditor && this.activeEditor.isWaiting()) {\n      this.closeEditor(false, false, dataSaved => {\n        if (dataSaved) {\n          this.prepareEditor();\n        }\n      });\n      return;\n    }\n    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;\n    if (!highlight || highlight.isHeader()) {\n      return;\n    }\n    const {\n      row,\n      col\n    } = highlight;\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', row, col);\n    let visualRowToCheck = row;\n    let visualColumnToCheck = col;\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n    }\n\n    // Getting values using the modified coordinates.\n    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const td = this.hot.getCell(row, col, true);\n\n    // Skip the preparation when the cell is not rendered in the DOM. The cell is scrolled out of\n    // the table's viewport.\n    if (td) {\n      const editorClass = this.hot.getCellEditor(this.cellProperties);\n      const prop = this.hot.colToProp(visualColumnToCheck);\n      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);\n      this.activeEditor = getEditorInstance(editorClass, this.hot);\n      // Using not modified coordinates, as we need to get the table element using selection coordinates.\n      // There is an extra translation in the editor for saving value.\n      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);\n    }\n  }\n\n  /**\n   * Check is editor is opened/showed.\n   *\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    return this.activeEditor && this.activeEditor.isOpened();\n  }\n\n  /**\n   * Open editor with initial value.\n   *\n   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.\n   * @param {Event} event The event object.\n   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor\n   *                                             when arrow keys are pressed.\n   */\n  openEditor(newInitialValue, event) {\n    let enableFullEditMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const selection = this.hot.getSelectedRangeLast();\n    let allowOpening = this.hot.runHooks('beforeBeginEditing', selection.highlight.row, selection.highlight.col, newInitialValue, event, enableFullEditMode);\n\n    // If the above hook does not return boolean apply default behavior which disallows opening\n    // an editor after double mouse click for non-contiguous selection (while pressing Ctrl/Cmd) and\n    // for multiple selected cells (while pressing SHIFT).\n    if (event instanceof MouseEvent && typeof allowOpening !== 'boolean') {\n      allowOpening = this.hot.selection.getLayerLevel() === 0 && selection.isSingle();\n    }\n    if (allowOpening === false) {\n      this.clearActiveEditor();\n      return;\n    }\n    if (!this.activeEditor) {\n      this.hot.scrollToFocusedCell();\n      this.prepareEditor();\n    }\n    if (this.activeEditor) {\n      if (enableFullEditMode) {\n        this.activeEditor.enableFullEditMode();\n      }\n      this.activeEditor.beginEditing(newInitialValue, event);\n    }\n  }\n\n  /**\n   * Close editor, finish editing cell.\n   *\n   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {\n    if (this.activeEditor) {\n      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);\n    } else if (callback) {\n      callback(false);\n    }\n  }\n\n  /**\n   * Close editor and save changes.\n   *\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   */\n  closeEditorAndSaveChanges(isCtrlPressed) {\n    this.closeEditor(false, isCtrlPressed);\n  }\n\n  /**\n   * Close editor and restore original value.\n   *\n   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.\n   */\n  closeEditorAndRestoreOriginalValue(isCtrlPressed) {\n    this.closeEditor(true, isCtrlPressed);\n  }\n\n  /**\n   * Clears reference to an instance of the active editor.\n   *\n   * @private\n   */\n  clearActiveEditor() {\n    this.activeEditor = undefined;\n  }\n\n  /**\n   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.\n   * Editable cell is when:\n   *   - the cell has defined an editor type;\n   *   - the cell is not marked as read-only;\n   *   - the cell is not hidden.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEditable() {\n    const selection = this.hot.getSelectedRangeLast();\n    if (!selection) {\n      return false;\n    }\n    const editorClass = this.hot.getCellEditor(this.cellProperties);\n    const {\n      row,\n      col\n    } = selection.highlight;\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));\n    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Controls selection's behavior after clicking `Enter`.\n   *\n   * @private\n   * @param {KeyboardEvent} event The keyboard event object.\n   */\n  moveSelectionAfterEnter(event) {\n    const enterMoves = {\n      ...(typeof this.tableMeta.enterMoves === 'function' ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves)\n    };\n    if (event.shiftKey) {\n      enterMoves.row = -enterMoves.row;\n      enterMoves.col = -enterMoves.col;\n    }\n    if (this.hot.selection.isMultiple()) {\n      this.selection.transformFocus(enterMoves.row, enterMoves.col);\n    } else {\n      this.selection.transformStart(enterMoves.row, enterMoves.col, true);\n    }\n  }\n  /**\n   * Destroy the instance.\n   */\n  destroy() {\n    this.destroyed = true;\n    this.eventManager.destroy();\n  }\n}\nfunction _onAfterDocumentKeyDown(event) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || isImmediatePropagationStopped(event)) {\n    return;\n  }\n  const {\n    keyCode\n  } = event;\n\n  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n  const isCtrlPressed = (event.ctrlKey || event.metaKey) && !event.altKey;\n  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {\n    if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {\n      this.openEditor('', event);\n    }\n  }\n}\n/**\n * OnCellDblClick callback.\n *\n * @param {MouseEvent} event The mouse event object.\n * @param {object} coords The cell coordinates.\n */\nfunction _onCellDblClick(event, coords) {\n  if (coords.isCell()) {\n    this.openEditor(null, event, true);\n  }\n}\nconst instances = new WeakMap();\n\n/**\n * @param {Core} hotInstance The Handsontable instance.\n * @param {TableMeta} tableMeta The table meta class instance.\n * @param {Selection} selection The selection instance.\n * @returns {EditorManager}\n */\nEditorManager.getInstance = function (hotInstance, tableMeta, selection) {\n  let editorManager = instances.get(hotInstance);\n  if (!editorManager) {\n    editorManager = new EditorManager(hotInstance, tableMeta, selection);\n    instances.set(hotInstance, editorManager);\n  }\n  return editorManager;\n};\nexport default EditorManager;","map":{"version":3,"names":["_classPrivateMethodInitSpec","e","a","_checkPrivateRedeclaration","add","t","has","TypeError","_defineProperty","r","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","String","Number","_assertClassBrand","n","arguments","length","isFunctionKey","isCtrlMetaKey","isImmediatePropagationStopped","getEditorInstance","EventManager","_EditorManager_brand","WeakSet","EditorManager","constructor","hotInstance","tableMeta","_selection","hot","selection","eventManager","addHook","event","_onAfterDocumentKeyDown","addEventListener","rootDocument","documentElement","destroyed","isListening","openEditor","view","_wt","update","coords","elem","_onCellDblClick","getActiveEditor","activeEditor","prepareEditor","_this$hot$getSelected","isWaiting","closeEditor","dataSaved","highlight","getSelectedRangeLast","isHeader","row","col","modifiedCellCoords","runHooks","visualRowToCheck","visualColumnToCheck","Array","isArray","cellProperties","getCellMeta","isCellEditable","clearActiveEditor","td","getCell","editorClass","getCellEditor","prop","colToProp","originalValue","getSourceDataAtCell","toPhysicalRow","prepare","isEditorOpened","isOpened","newInitialValue","enableFullEditMode","undefined","allowOpening","MouseEvent","getLayerLevel","isSingle","scrollToFocusedCell","beginEditing","restoreOriginalValue","isCtrlPressed","callback","finishEditing","closeEditorAndSaveChanges","closeEditorAndRestoreOriginalValue","rowIndexMapper","columnIndexMapper","isCellHidden","isHidden","toPhysicalColumn","readOnly","moveSelectionAfterEnter","enterMoves","shiftKey","isMultiple","transformFocus","transformStart","destroy","keyCode","ctrlKey","metaKey","altKey","isCell","instances","WeakMap","getInstance","editorManager","get","set"],"sources":["D:/gym-project/frontend/node_modules/handsontable/editorManager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { isFunctionKey, isCtrlMetaKey } from \"./helpers/unicode.mjs\";\nimport { isImmediatePropagationStopped } from \"./helpers/dom/event.mjs\";\nimport { getEditorInstance } from \"./editors/registry.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nvar _EditorManager_brand = /*#__PURE__*/new WeakSet();\nclass EditorManager {\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   * @param {TableMeta} tableMeta The table meta instance.\n   * @param {Selection} selection The selection instance.\n   */\n  constructor(hotInstance, tableMeta, _selection) {\n    /**\n     * OnAfterDocumentKeyDown callback.\n     *\n     * @param {KeyboardEvent} event The keyboard event object.\n     */\n    _classPrivateMethodInitSpec(this, _EditorManager_brand);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to an instance's private GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"tableMeta\", void 0);\n    /**\n     * Instance of {@link Selection}.\n     *\n     * @private\n     * @type {Selection}\n     */\n    _defineProperty(this, \"selection\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Determines if EditorManager is destroyed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"destroyed\", false);\n    /**\n     * A reference to an instance of the activeEditor.\n     *\n     * @private\n     * @type {BaseEditor}\n     */\n    _defineProperty(this, \"activeEditor\", void 0);\n    /**\n     * Keeps a reference to the cell's properties object.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", void 0);\n    this.hot = hotInstance;\n    this.tableMeta = tableMeta;\n    this.selection = _selection;\n    this.eventManager = new EventManager(hotInstance);\n    this.hot.addHook('afterDocumentKeyDown', event => _assertClassBrand(_EditorManager_brand, this, _onAfterDocumentKeyDown).call(this, event));\n\n    // Open editor when text composition is started (IME editor)\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'compositionstart', event => {\n      if (!this.destroyed && this.hot.isListening()) {\n        this.openEditor('', event);\n      }\n    });\n    this.hot.view._wt.update('onCellDblClick', (event, coords, elem) => _assertClassBrand(_EditorManager_brand, this, _onCellDblClick).call(this, event, coords, elem));\n  }\n\n  /**\n   * Get active editor.\n   *\n   * @returns {BaseEditor}\n   */\n  getActiveEditor() {\n    return this.activeEditor;\n  }\n\n  /**\n   * Prepare text input to be displayed at given grid cell.\n   */\n  prepareEditor() {\n    var _this$hot$getSelected;\n    if (this.activeEditor && this.activeEditor.isWaiting()) {\n      this.closeEditor(false, false, dataSaved => {\n        if (dataSaved) {\n          this.prepareEditor();\n        }\n      });\n      return;\n    }\n    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;\n    if (!highlight || highlight.isHeader()) {\n      return;\n    }\n    const {\n      row,\n      col\n    } = highlight;\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', row, col);\n    let visualRowToCheck = row;\n    let visualColumnToCheck = col;\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n    }\n\n    // Getting values using the modified coordinates.\n    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const td = this.hot.getCell(row, col, true);\n\n    // Skip the preparation when the cell is not rendered in the DOM. The cell is scrolled out of\n    // the table's viewport.\n    if (td) {\n      const editorClass = this.hot.getCellEditor(this.cellProperties);\n      const prop = this.hot.colToProp(visualColumnToCheck);\n      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);\n      this.activeEditor = getEditorInstance(editorClass, this.hot);\n      // Using not modified coordinates, as we need to get the table element using selection coordinates.\n      // There is an extra translation in the editor for saving value.\n      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);\n    }\n  }\n\n  /**\n   * Check is editor is opened/showed.\n   *\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    return this.activeEditor && this.activeEditor.isOpened();\n  }\n\n  /**\n   * Open editor with initial value.\n   *\n   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.\n   * @param {Event} event The event object.\n   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor\n   *                                             when arrow keys are pressed.\n   */\n  openEditor(newInitialValue, event) {\n    let enableFullEditMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const selection = this.hot.getSelectedRangeLast();\n    let allowOpening = this.hot.runHooks('beforeBeginEditing', selection.highlight.row, selection.highlight.col, newInitialValue, event, enableFullEditMode);\n\n    // If the above hook does not return boolean apply default behavior which disallows opening\n    // an editor after double mouse click for non-contiguous selection (while pressing Ctrl/Cmd) and\n    // for multiple selected cells (while pressing SHIFT).\n    if (event instanceof MouseEvent && typeof allowOpening !== 'boolean') {\n      allowOpening = this.hot.selection.getLayerLevel() === 0 && selection.isSingle();\n    }\n    if (allowOpening === false) {\n      this.clearActiveEditor();\n      return;\n    }\n    if (!this.activeEditor) {\n      this.hot.scrollToFocusedCell();\n      this.prepareEditor();\n    }\n    if (this.activeEditor) {\n      if (enableFullEditMode) {\n        this.activeEditor.enableFullEditMode();\n      }\n      this.activeEditor.beginEditing(newInitialValue, event);\n    }\n  }\n\n  /**\n   * Close editor, finish editing cell.\n   *\n   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {\n    if (this.activeEditor) {\n      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);\n    } else if (callback) {\n      callback(false);\n    }\n  }\n\n  /**\n   * Close editor and save changes.\n   *\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   */\n  closeEditorAndSaveChanges(isCtrlPressed) {\n    this.closeEditor(false, isCtrlPressed);\n  }\n\n  /**\n   * Close editor and restore original value.\n   *\n   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.\n   */\n  closeEditorAndRestoreOriginalValue(isCtrlPressed) {\n    this.closeEditor(true, isCtrlPressed);\n  }\n\n  /**\n   * Clears reference to an instance of the active editor.\n   *\n   * @private\n   */\n  clearActiveEditor() {\n    this.activeEditor = undefined;\n  }\n\n  /**\n   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.\n   * Editable cell is when:\n   *   - the cell has defined an editor type;\n   *   - the cell is not marked as read-only;\n   *   - the cell is not hidden.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEditable() {\n    const selection = this.hot.getSelectedRangeLast();\n    if (!selection) {\n      return false;\n    }\n    const editorClass = this.hot.getCellEditor(this.cellProperties);\n    const {\n      row,\n      col\n    } = selection.highlight;\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));\n    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Controls selection's behavior after clicking `Enter`.\n   *\n   * @private\n   * @param {KeyboardEvent} event The keyboard event object.\n   */\n  moveSelectionAfterEnter(event) {\n    const enterMoves = {\n      ...(typeof this.tableMeta.enterMoves === 'function' ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves)\n    };\n    if (event.shiftKey) {\n      enterMoves.row = -enterMoves.row;\n      enterMoves.col = -enterMoves.col;\n    }\n    if (this.hot.selection.isMultiple()) {\n      this.selection.transformFocus(enterMoves.row, enterMoves.col);\n    } else {\n      this.selection.transformStart(enterMoves.row, enterMoves.col, true);\n    }\n  }\n  /**\n   * Destroy the instance.\n   */\n  destroy() {\n    this.destroyed = true;\n    this.eventManager.destroy();\n  }\n}\nfunction _onAfterDocumentKeyDown(event) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || isImmediatePropagationStopped(event)) {\n    return;\n  }\n  const {\n    keyCode\n  } = event;\n\n  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n  const isCtrlPressed = (event.ctrlKey || event.metaKey) && !event.altKey;\n  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {\n    if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {\n      this.openEditor('', event);\n    }\n  }\n}\n/**\n * OnCellDblClick callback.\n *\n * @param {MouseEvent} event The mouse event object.\n * @param {object} coords The cell coordinates.\n */\nfunction _onCellDblClick(event, coords) {\n  if (coords.isCell()) {\n    this.openEditor(null, event, true);\n  }\n}\nconst instances = new WeakMap();\n\n/**\n * @param {Core} hotInstance The Handsontable instance.\n * @param {TableMeta} tableMeta The table meta class instance.\n * @param {Selection} selection The selection instance.\n * @returns {EditorManager}\n */\nEditorManager.getInstance = function (hotInstance, tableMeta, selection) {\n  let editorManager = instances.get(hotInstance);\n  if (!editorManager) {\n    editorManager = new EditorManager(hotInstance, tableMeta, selection);\n    instances.set(hotInstance, editorManager);\n  }\n  return editorManager;\n};\nexport default EditorManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}